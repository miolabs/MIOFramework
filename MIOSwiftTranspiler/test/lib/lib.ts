var SwiftIterator = /** @class */ (function () {
    function SwiftIterator(_currentToNext) {
        this._current = 0;
        this._currentToNext = _currentToNext;
    }
    SwiftIterator.prototype.next = function () { return this._currentToNext(this._current++); };
    return SwiftIterator;
}());
class _DefaultEnumImplementation {
    static $equal(a, b, $info){return (a && a.rawValue) == (b && b.rawValue)}
    static $notEqual(a, b, $info){return !this.$equal(a, b, $info)}
}
//{Self:SNA2, T: {Self:SNA1, T: String}}
function _clarifyGenerics(Class) {
    if(!Class.Self) return Class
    let result = Class.Self
    for(let genericKey in Class) {
        if(genericKey === 'Self') continue
        //let genericType = _clarifyGenerics(Class[genericKey])
        let genericType = Class[genericKey]
        for(let key in result) {
            let prop = Object.getOwnPropertyDescriptor(result, key)
            prop = (prop || {}).value
            if(!(prop instanceof Object) || prop.$genericType !== genericKey) continue
            let resultType = genericType
            if(prop.$subchain) {
                let subchain = prop.$subchain.split('.')
                for(let elem of subchain) {
                    resultType = resultType[elem]
                }
            }
            result = {...result, [key]: resultType}
        }
    }
    result = {...result, Self: result}
    return result
}
function _cloneStruct(obj) {
    if(!(obj instanceof Object) || obj instanceof String || obj instanceof Number || obj instanceof Bool || !obj.constructor.$struct) return obj
    var cloned = new obj.constructor()
    if(obj.cloneStructFill) {
        cloned.cloneStructFill(obj, {});
    }
    else {
        for(var prop in obj) {
            if(!obj.hasOwnProperty(prop)) continue
            cloned[prop] = _cloneStruct(obj[prop])
        }
    }
    return cloned
}
function _create(Class, signature, ...params) {
    if(params[params.length - 1]) params[params.length - 1].$setThis = $val => obj = $val
    let obj
    if(Class.$mixin) {
        if(!Class.prototype[signature]) throw "unsupported signature " + signature + " for " + Class.name
        obj = Class.prototype[signature].apply(new Class(), params)
        if(obj == null) throw "unsupported signature or null argument passed " + signature + " for " + Class.name
        obj.$info = params[params.length - 1]
        if(obj.init$vars) obj.init$vars()
    }
    else {
        obj = new Class()
        obj.$info = params[params.length - 1]
        if(obj.init$vars) obj.init$vars()
        if(!obj[signature]) throw "unsupported signature " + signature + " for " + Class.name
        obj[signature].apply(obj, params)
    }
    obj.$initialized = true
    if(obj.$failed) return Optional.none
    if(Class[signature + '$failable']) obj = _injectIntoOptional(obj)
    return obj
}
function _findStringSwitchCaseCasesString(cases, string, $info) { return cases.indexOf(string) }
function _injectIntoOptional(val) {
    return val == null ? Optional.none : Optional.some(val, {})
}
const PROTOCOL_DEFAULT_IMPLEMENTATION_PRIORITY = {
    "ClosedRange.makeIterator": "Collection$implementation",
    "Range.makeIterator": "Collection$implementation"
}
function _mixin(dest, source, shouldOverride) {
    var properties = Object.getOwnPropertyNames(source.prototype)
    for (let name of properties) {
        if (name == 'constructor') continue
        /*
        if(name === '' && dest.prototype.constructor.name === '') {
            console.log(name in dest.prototype, source.prototype.constructor.name)
            console.log(source.prototype[name])
        }
        */
        let proceed = !(name in dest.prototype)
        if(!proceed) {
            let prioritisedClass = PROTOCOL_DEFAULT_IMPLEMENTATION_PRIORITY[dest.prototype.constructor.name + '.' + name]
            if(prioritisedClass) proceed = source.prototype.constructor.name === prioritisedClass
            else proceed = shouldOverride
        }
        if(proceed) {
            Object.defineProperty(
                dest.prototype,
                name,
                Object.getOwnPropertyDescriptor(source.prototype, name)
            )
        }
    }

    _mixinStatic(dest, source, shouldOverride)
}
function _mixinStatic(dest, source, shouldOverride) {
    var staticProperties = Object.getOwnPropertyNames(source)
    const commonProperties = Object.getOwnPropertyNames(function(){})
    for (let name of staticProperties) {
        if (commonProperties.includes(name)) continue
        if (shouldOverride || !(name in dest)) {
            Object.defineProperty(
                dest,
                name,
                Object.getOwnPropertyDescriptor(source, name)
            )
        }
    }
}
function _optionalTry(expr) { try { return expr() } catch(e) { return Optional.none } }
//legacy for _.tmp = ...
var _ = {}
function /*Swift.(file).min(_:T,_:T)*/
/*Swift.(file).min(_:T,_:T)*/
min<T>(x, y, $info?) {
return ((_.arg0 = y).constructor.$lessThan(_.arg0, x) ? y : x)
}


function /*Swift.(file).min(_:T,_:T,_:T,_:[T])*/
/*Swift.(file).min(_:T,_:T,_:T,_:[T])*/
minMany<T>(x, y, z, rest, $info?) {
let minValue = min(min(x, y), z);
{
let $value$generator = _cloneStruct(rest.makeIterator( {}));
while(true) {
const $ifLet0, value_1;
if(!((($ifLet0 = $value$generator.next( {$setThis: $val => $value$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) break
if(!((_.arg0 = value_1).constructor.$lessThan(_.arg0, minValue))) continue
minValue = value_1;
}
};
return minValue
}


function /*Swift.(file).max(_:T,_:T)*/
/*Swift.(file).max(_:T,_:T)*/
max<T>(x, y, $info?) {
return ((_.arg0 = y).constructor.$greaterThanOrEqual(_.arg0, x) ? y : x)
}


function /*Swift.(file).max(_:T,_:T,_:T,_:[T])*/
/*Swift.(file).max(_:T,_:T,_:T,_:[T])*/
maxMany<T>(x, y, z, rest, $info?) {
let maxValue = max(max(x, y), z);
{
let $value$generator = _cloneStruct(rest.makeIterator( {}));
while(true) {
const $ifLet0, value_1;
if(!((($ifLet0 = $value$generator.next( {$setThis: $val => $value$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) break
if(!((_.arg0 = value_1).constructor.$greaterThanOrEqual(_.arg0, maxValue))) continue
maxValue = value_1;
}
};
return maxValue
}





























function /*Swift.(file).assert(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)*/
/*Swift.(file).assert(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)*/
assertFileLine(condition, message, file, line, $info?) {
if((Bool.$not(condition( {})))) {
}
}


function /*Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)*/
/*Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)*/
preconditionFileLine(condition, message, file, line, $info?) {
if((Bool.$not(condition( {})))) {
assertionFailureFileLine(() => message( {}), null, null);
}
}


function /*Swift.(file).assertionFailure(_:() -> String,file:StaticString,line:UInt)*/
/*Swift.(file).assertionFailure(_:() -> String,file:StaticString,line:UInt)*/
assertionFailureFileLine(message, file, line, $info?) {
throw message( {})
}


function /*Swift.(file).preconditionFailure(_:() -> String,file:StaticString,line:UInt)*/
/*Swift.(file).preconditionFailure(_:() -> String,file:StaticString,line:UInt)*/
preconditionFailureFileLine(message, file, line, $info?) {
throw 'unsupported method Swift.(file).preconditionFailure(_:() -> String,file:StaticString,line:UInt) in ' + this.constructor.name
}


function /*Swift.(file).fatalError(_:() -> String,file:StaticString,line:UInt)*/
/*Swift.(file).fatalError(_:() -> String,file:StaticString,line:UInt)*/
fatalErrorFileLine(message, file, line, $info?) {
throw 'unsupported method Swift.(file).fatalError(_:() -> String,file:StaticString,line:UInt) in ' + this.constructor.name
}





























































































































function /*Swift.(file).unsafeBitCast(_:T,to:U.Type)*/
/*Swift.(file).unsafeBitCast(_:T,to:U.Type)*/
unsafeBitCastTo<T, U>(x, type, $info?) {
throw 'unsupported method Swift.(file).unsafeBitCast(_:T,to:U.Type) in ' + this.constructor.name
}








function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}

















function /*Swift.(file).unsafeDowncast(_:AnyObject,to:T.Type)*/
/*Swift.(file).unsafeDowncast(_:AnyObject,to:T.Type)*/
unsafeDowncastTo<T>(x, type, $info?) {
throw 'unsupported method Swift.(file).unsafeDowncast(_:AnyObject,to:T.Type) in ' + this.constructor.name
}





























function /*Swift.(file).getSwiftClassInstanceExtents(_:AnyClass)*/
/*Swift.(file).getSwiftClassInstanceExtents(_:AnyClass)*/
getSwiftClassInstanceExtents(theClass, $info?) {
throw 'unsupported method Swift.(file).getSwiftClassInstanceExtents(_:AnyClass) in ' + this.constructor.name
}


function /*Swift.(file).getObjCClassInstanceExtents(_:AnyClass)*/
/*Swift.(file).getObjCClassInstanceExtents(_:AnyClass)*/
getObjCClassInstanceExtents(theClass, $info?) {
throw 'unsupported method Swift.(file).getObjCClassInstanceExtents(_:AnyClass) in ' + this.constructor.name
}


























































































































function /*Swift.(file).type(of:T)*/
/*Swift.(file).type(of:T)*/
typeOf<T, Metatype>(value, $info?) {
throw 'unsupported method Swift.(file).type(of:T) in ' + this.constructor.name
}


function /*Swift.(file).withoutActuallyEscaping(_:ClosureType,do:(ClosureType) throws -> ResultType)*/
/*Swift.(file).withoutActuallyEscaping(_:ClosureType,do:(ClosureType) throws -> ResultType)*/
withoutActuallyEscapingDo<ClosureType, ResultType>(closure, body, $info?) {
throw 'unsupported method Swift.(file).withoutActuallyEscaping(_:ClosureType,do:(ClosureType) throws -> ResultType) in ' + this.constructor.name
}





function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}





function /*Swift.(file).+=infix(_:_ContiguousArrayBuffer<Element>,_:C)*/
/*Swift.(file).+=infix(_:_ContiguousArrayBuffer<Element>,_:C)*/
$addAndAssign<Element, C>(lhs$inout, rhs, $info?) {
let lhs = lhs$inout.get()
const $result = (() => {
const oldCount = lhs.count;
const newCount = Int.$add(oldCount, numericCast(rhs.count, {T: Int, U: Int}));
const buf;
if((_fastPath(Int.$lessThanOrEqual(newCount, lhs.capacity)))) {
buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(UnsafeMutablePointer.$add(lhs.firstElementAddress, oldCount)), numericCast(rhs.count, {T: Int, U: Int}), {});
lhs.count = newCount;
}
else {
let newLHS = _create(_ContiguousArrayBuffer, 'init_uninitializedCountIntMinimumCapacityInt', newCount, _growArrayCapacity(lhs.capacity), {});
newLHS.firstElementAddress.moveInitializeFromCount(lhs.firstElementAddress, oldCount);
lhs.count = 0;
let $tuple = {0: newLHS, 1: lhs}
lhs = $tuple[0]
newLHS = $tuple[1];
buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(UnsafeMutablePointer.$add(lhs.firstElementAddress, oldCount)), numericCast(rhs.count, {T: Int, U: Int}), {});
};
let $tuple = buf.initializeFrom(rhs), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
preconditionFileLine(() => Optional.wrappedEqualsOptionalNilComparisonType(remainders.next( {$setThis: $val => remainders = $val}), _injectIntoOptional(null)), () => "rhs underreported its count", null, null);
preconditionFileLine(() => Int.$equal(writtenUpTo, buf.endIndex), () => "rhs overreported its count", null, null);})()
lhs$inout.set(lhs)
return $result
}















































function /*Swift.(file).dump(_:T,to:TargetStream,name:String?,indent:Int,maxDepth:Int,maxItems:Int)*/
/*Swift.(file).dump(_:T,to:TargetStream,name:String?,indent:Int,maxDepth:Int,maxItems:Int)*/
dumpToNameIndentMaxDepthMaxItems<T, TargetStream>(value, target$inout, _name, indent, maxDepth, maxItems, $info?) {
let target = target$inout.get()
const $result = (() => {
let maxItemCounter = maxItems;
let visitedItems = _create(Dictionary, 'init', {});
target._lock( {$setThis: $val => target = $val});
let $defer = () => {
target._unlock( {$setThis: $val => target = $val});
}
const $result = (() => {
try {;
_dump_unlockedToNameIndentMaxDepthMaxItemCounterVisitedItems(value, {get: () => target, set: $val => target = $val}, _name, indent, maxDepth, {get: () => maxItemCounter, set: $val => maxItemCounter = $val}, {get: () => visitedItems, set: $val => visitedItems = $val});
return value;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;})()
target$inout.set(target)
return $result
}


function /*Swift.(file).dump(_:T,name:String?,indent:Int,maxDepth:Int,maxItems:Int)*/
/*Swift.(file).dump(_:T,name:String?,indent:Int,maxDepth:Int,maxItems:Int)*/
dumpNameIndentMaxDepthMaxItems<T>(value, _name, indent, maxDepth, maxItems, $info?) {
let stdoutStream = _create(_Stdout, 'init', {});
return dumpToNameIndentMaxDepthMaxItems(value, {get: () => stdoutStream, set: $val => stdoutStream = $val}, _name, indent, maxDepth, maxItems)
}








function /*Swift.(file).===infix(_:AnyObject?,_:AnyObject?)*/
/*Swift.(file).===infix(_:AnyObject?,_:AnyObject?)*/
$identical(lhs, rhs, $info?) {
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const l = $match[0][0]
const r = $match[1][0]
return ObjectIdentifier.$equal(_create(ObjectIdentifier, 'initAnyObject', l, {}), _create(ObjectIdentifier, 'initAnyObject', r, {}));
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
}


function /*Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)*/
/*Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)*/
$notIdentical(lhs, rhs, $info?) {
return Bool.$not($identical(lhs, rhs))
}



































function /*Swift.(file).Hashable_isEqual_indirect(_:UnsafePointer<T>,_:UnsafePointer<T>)*/
/*Swift.(file).Hashable_isEqual_indirect(_:UnsafePointer<T>,_:UnsafePointer<T>)*/
Hashable_isEqual_indirect<T>(lhs, rhs, $info?) {
return (_.arg0 = lhs.pointee).constructor.$equal(_.arg0, rhs.pointee)
}


function /*Swift.(file).Hashable_hashValue_indirect(_:UnsafePointer<T>)*/
/*Swift.(file).Hashable_hashValue_indirect(_:UnsafePointer<T>)*/
Hashable_hashValue_indirect<T>(value, $info?) {
return value.pointee.hashValue
}


























function /*Swift.(file).readLine(strippingNewline:Bool)*/
/*Swift.(file).readLine(strippingNewline:Bool)*/
readLineStrippingNewline(strippingNewline, $info?) {
throw 'unsupported method Swift.(file).readLine(strippingNewline:Bool) in ' + this.constructor.name
}














function /*Swift.(file).abs(_:T)*/
/*Swift.(file).abs(_:T)*/
abs<T>(x, $info?) {
return (x.constructor.$lessThan(x, 0) ? x.constructor.$negate(x) : x)
}


function /*Swift.(file).numericCast(_:T)*/
/*Swift.(file).numericCast(_:T)*/
numericCast<T, U>(x, $info?) {
return _create($info.U, 'initT', x, {})
}






















































































function /*Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)*/
/*Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)*/
/*!!!DUPLICATE NAME*/
withExtendedLifetime<T, Result>(x, body, $info?) {
let $defer = () => {
_fixLifetime(x);
}
const $result = (() => {
try {;
return body(x);}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}


function /*Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)*/
/*Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)*/
/*!!!DUPLICATE NAME*/
withExtendedLifetime<T, Result>(x, body, $info?) {
let $defer = () => {
_fixLifetime(x);
}
const $result = (() => {
try {;
return body(x);}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}





function /*Swift.(file).withUnsafeMutablePointer(to:T,_:(UnsafeMutablePointer<T>) throws -> Result)*/
/*Swift.(file).withUnsafeMutablePointer(to:T,_:(UnsafeMutablePointer<T>) throws -> Result)*/
withUnsafeMutablePointerTo<T, Result>(value$inout, body, $info?) {
throw 'unsupported method Swift.(file).withUnsafeMutablePointer(to:T,_:(UnsafeMutablePointer<T>) throws -> Result) in ' + this.constructor.name
}


function /*Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)*/
/*Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)*/
withUnsafePointerTo<T, Result>(value$inout, body, $info?) {
throw 'unsupported method Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result) in ' + this.constructor.name
}


function /*Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)*/
/*Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)*/
withUnsafePointerTo<T, Result>(value$inout, body, $info?) {
throw 'unsupported method Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result) in ' + this.constructor.name
}





function /*Swift.(file).isKnownUniquelyReferenced(_:T?)*/
/*Swift.(file).isKnownUniquelyReferenced(_:T?)*/
/*!!!DUPLICATE NAME*/
isKnownUniquelyReferenced<T>(object$inout, $info?) {
let object = object$inout.get()
const $result = (() => {
return _isUnique({get: () => object, set: $val => object = $val});})()
object$inout.set(object)
return $result
}


function /*Swift.(file).isKnownUniquelyReferenced(_:T?)*/
/*Swift.(file).isKnownUniquelyReferenced(_:T?)*/
/*!!!DUPLICATE NAME*/
isKnownUniquelyReferenced<T>(object$inout, $info?) {
let object = object$inout.get()
const $result = (() => {
return _isUnique({get: () => object, set: $val => object = $val});})()
object$inout.set(object)
return $result
}
































function /*Swift.(file).swap(_:T,_:T)*/
/*Swift.(file).swap(_:T,_:T)*/
swap<T>(a$inout, b$inout, $info?) {
let a = a$inout.get()
let b = b$inout.get()
const $result = (() => {
let $tuple = {0: b, 1: a}
a = $tuple[0]
b = $tuple[1];})()
a$inout.set(a)
b$inout.set(b)
return $result
}


function /*Swift.(file).KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)*/
/*Swift.(file).KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)*/
KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(keyType, $info?) {
throw 'unsupported method Swift.(file).KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type) in ' + this.constructor.name
}


function /*Swift.(file).ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)*/
/*Swift.(file).ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)*/
ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(elementType, $info?) {
throw 'unsupported method Swift.(file).ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type) in ' + this.constructor.name
}





function /*Swift.(file).??infix(_:T?,_:() throws -> T)*/
/*Swift.(file).??infix(_:T?,_:() throws -> T)*/
$nilCoalescing<T>(optional, defaultValue, $info?) {
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue( {});
}
}


function /*Swift.(file).??infix(_:T?,_:() throws -> T?)*/
/*Swift.(file).??infix(_:T?,_:() throws -> T?)*/
nilCoalescingOptional<T>(optional, defaultValue, $info?) {
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return _injectIntoOptional(value);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue( {});
}
}






































function /*Swift.(file).~=infix(_:T,_:T)*/
/*Swift.(file).~=infix(_:T,_:T)*/
$patternMatch<T>(a, b, $info?) {
return (_.arg0 = a).constructor.$equal(_.arg0, b)
}


function /*Swift.(file).print(_:[Any],separator:String,terminator:String)*/
/*Swift.(file).print(_:[Any],separator:String,terminator:String)*/
printSeparatorTerminator(items, separator, terminator, $info?) {
console.log.apply(null, items)
}


function /*Swift.(file).debugPrint(_:[Any],separator:String,terminator:String)*/
/*Swift.(file).debugPrint(_:[Any],separator:String,terminator:String)*/
debugPrintSeparatorTerminator(items, separator, terminator, $info?) {
const $ifLet0, hook_1
if((($ifLet0 = _playgroundPrintHook)||true) && $ifLet0.rawValue == 'some' && ((hook_1 = $ifLet0[0])||true)) {
let output = _create(_TeeStream, 'initLeftRight', "", _create(_Stdout, 'init', {}), {});
_debugPrintSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val});
hook_1(output.left);
}
else {
let output = _create(_Stdout, 'init', {});
_debugPrintSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val});
}
}


function /*Swift.(file).print(_:[Any],separator:String,terminator:String,to:Target)*/
/*Swift.(file).print(_:[Any],separator:String,terminator:String,to:Target)*/
printSeparatorTerminatorTo<Target>(items, separator, terminator, output$inout, $info?) {
let output = output$inout.get()
const $result = (() => {
_printSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val});})()
output$inout.set(output)
return $result
}


function /*Swift.(file).debugPrint(_:[Any],separator:String,terminator:String,to:Target)*/
/*Swift.(file).debugPrint(_:[Any],separator:String,terminator:String,to:Target)*/
debugPrintSeparatorTerminatorTo<Target>(items, separator, terminator, output$inout, $info?) {
let output = output$inout.get()
const $result = (() => {
_debugPrintSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val});})()
output$inout.set(output)
return $result
}




















function /*Swift.(file).getChild(of:T,type:Any.Type,index:Int)*/
/*Swift.(file).getChild(of:T,type:Any.Type,index:Int)*/
getChildOfTypeIndex<T>(value, type, index, $info?) {
let nameC = _injectIntoOptional(null);
let freeFunc = _injectIntoOptional(null);
const value = _cloneStruct(_getChildOfTypeIndexOutNameOutFreeFunc(value, type, index, {get: () => nameC, set: $val => nameC = $val}, {get: () => freeFunc, set: $val => freeFunc = $val}));
const _name = nameC.flatMap((($0, $info?) => _create(String, 'initValidatingUTF8UnsafePointer', $0, {})));
_injectIntoOptional(((_.tmp0 = freeFunc).rawValue === 'some') ? (_.tmp0[0](nameC)) : null);
return {0: _name, 1: value}
}














function /*Swift.(file).repeatElement(_:T,count:Int)*/
/*Swift.(file).repeatElement(_:T,count:Int)*/
repeatElementCount<T>(_element, n, $info?) {
return _create(Repeated, 'init_repeatingCountInt', _element, n, {})
}



























































function /*Swift.(file).stride(from:T,to:T,by:T.Stride)*/
/*Swift.(file).stride(from:T,to:T,by:T.Stride)*/
strideFromToBy<T>(start, end, stride, $info?) {
return _create(StrideTo, 'init_startEndStride', start, end, stride, {})
}


function /*Swift.(file).stride(from:T,through:T,by:T.Stride)*/
/*Swift.(file).stride(from:T,through:T,by:T.Stride)*/
strideFromThroughBy<T>(start, end, stride, $info?) {
return _create(StrideThrough, 'init_startEndStride', start, end, stride, {})
}


function /*Swift.(file).unimplemented_utf8_32bit(_:String,file:StaticString,line:UInt)*/
/*Swift.(file).unimplemented_utf8_32bit(_:String,file:StaticString,line:UInt)*/
unimplemented_utf8_32bitFileLine(message, file, line, $info?) {
fatalErrorFileLine(() => "32-bit: Unimplemented for UTF-8 support", file, line)
}






































































































































function /*Swift.(file).fastFill(_:UnsafeBufferPointer<UInt8>,_:UnsafeMutableBufferPointer<UInt8>)*/
/*Swift.(file).fastFill(_:UnsafeBufferPointer<UInt8>,_:UnsafeMutableBufferPointer<UInt8>)*/
fastFill(sourceBuffer, outputBuffer, $info?) {
throw 'unsupported method Swift.(file).fastFill(_:UnsafeBufferPointer<UInt8>,_:UnsafeMutableBufferPointer<UInt8>) in ' + this.constructor.name
}


function /*Swift.(file).copyUTF16Segment(boundedBy:Range<Int>,into:UnsafeMutableBufferPointer<UInt16>,_:(Int) -> (Unicode.Scalar, Int))*/
/*Swift.(file).copyUTF16Segment(boundedBy:Range<Int>,into:UnsafeMutableBufferPointer<UInt16>,_:(Int) -> (Unicode.Scalar, Int))*/
copyUTF16SegmentBoundedByInto(range, outputBuffer, f, $info?) {
let readIndex = range.lowerBound;
let outputWriteIndex = 0;
const outputCount = outputBuffer.count;
while(true){
if(!((Int.$notEqual(readIndex, range.upperBound)))) break
const $tuple = f(readIndex), scalar = $tuple && $tuple[0], _length = $tuple && $tuple[1];
if((Bool.$logicalAND(scalar._hasNormalizationBoundaryBefore, () => Int.$notEqual(readIndex, range.lowerBound)))) {
break;
};
Int.$addAndAssign({get: () => readIndex, set: $val => readIndex = $val}, _length);
{
let $cu$generator = _cloneStruct(scalar.utf16.makeIterator( {}));
while(true) {
const $ifLet0, cu_1;
if(!((($ifLet0 = $cu$generator.next( {$setThis: $val => $cu$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
if((Int.$lessThan(outputWriteIndex, outputCount))) {
outputBuffer.subscript$set(cu_1, outputWriteIndex, {$setThis: $val => outputBuffer = _cloneStruct($val)});
Int.$addAndAssign({get: () => outputWriteIndex, set: $val => outputWriteIndex = $val}, 1);
}
else {
return _injectIntoOptional(null);
};
}
};
};
return _injectIntoOptional({0: Int.$subtract(readIndex, range.lowerBound), 1: outputWriteIndex})
}


function /*Swift.(file).transcodeValidUTF16ToUTF8(_:UnsafeBufferPointer<UInt16>,into:UnsafeMutableBufferPointer<UInt8>)*/
/*Swift.(file).transcodeValidUTF16ToUTF8(_:UnsafeBufferPointer<UInt16>,into:UnsafeMutableBufferPointer<UInt8>)*/
transcodeValidUTF16ToUTF8Into(sourceBuffer, outputBuffer, $info?) {
let readIndex = 0;
let writeIndex = 0;
const outputCount = outputBuffer.count;
const sourceCount = sourceBuffer.count;
while(true){
if(!((Int.$lessThan(readIndex, sourceCount)))) break
const $tuple = _decodeScalarStartingAt(sourceBuffer, readIndex), scalar = $tuple && $tuple[0], _length = $tuple && $tuple[1];
Int.$addAndAssign({get: () => readIndex, set: $val => readIndex = $val}, _length);
{
let $cu$generator = _cloneStruct(UTF8.encode(scalar)._unsafelyUnwrappedUnchecked.makeIterator( {}));
while(true) {
const $ifLet0, cu_1;
if(!((($ifLet0 = $cu$generator.next( {$setThis: $val => $cu$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
if((Int.$lessThan(writeIndex, outputCount))) {
outputBuffer.subscript$set(cu_1, writeIndex, {$setThis: $val => outputBuffer = _cloneStruct($val)});
Int.infix_38_43_61({get: () => writeIndex, set: $val => writeIndex = $val}, 1);
}
else {
return _injectIntoOptional(null);
};
}
};
};
return _injectIntoOptional(writeIndex)
}




















function /*Swift.(file).determineCodeUnitCapacity(_:Int)*/
/*Swift.(file).determineCodeUnitCapacity(_:Int)*/
determineCodeUnitCapacity(desiredCapacity, $info?) {
throw 'unsupported method Swift.(file).determineCodeUnitCapacity(_:Int) in ' + this.constructor.name
}


























function /*Swift.(file).validateUTF8(_:UnsafeBufferPointer<UInt8>)*/
/*Swift.(file).validateUTF8(_:UnsafeBufferPointer<UInt8>)*/
validateUTF8(buf, $info?) {
throw 'unsupported method Swift.(file).validateUTF8(_:UnsafeBufferPointer<UInt8>) in ' + this.constructor.name
}


function /*Swift.(file).repairUTF8(_:UnsafeBufferPointer<UInt8>,firstKnownBrokenRange:Range<Int>)*/
/*Swift.(file).repairUTF8(_:UnsafeBufferPointer<UInt8>,firstKnownBrokenRange:Range<Int>)*/
repairUTF8FirstKnownBrokenRange(input, firstKnownBrokenRange, $info?) {
let result = _create(_StringGuts, 'init', {});
const replacementCharacterCount = Unicode.Scalar._replacementCharacter.withUTF8CodeUnits((($0, $info?) => $0.count));
let brokenRange = _cloneStruct(firstKnownBrokenRange);
let remainingInput = _cloneStruct(input);
do {
const goodChunk = _cloneStruct(remainingInput.subscript$get(Int.prefix_46_46_60(brokenRange.startIndex)));
result.appendInPlaceIsASCII(_create(UnsafeBufferPointer, 'initRebasingSlice', goodChunk, {}), false, {$setThis: $val => result = $val});
Unicode.Scalar._replacementCharacter.withUTF8CodeUnits((($0, $info?) => result.appendInPlaceIsASCII($0, false, {$setThis: $val => result = $val})));
remainingInput = _create(UnsafeBufferPointer, 'initRebasingSlice', remainingInput.subscript$get(Int.$openEndedRange(brokenRange.endIndex)), {});
const $match = validateUTF8(remainingInput)
if((($match.rawValue == UTF8ValidationResult.success().rawValue))) {
result.appendInPlaceIsASCII(remainingInput, false, {$setThis: $val => result = $val});
return _create(String, 'init_StringGuts', result, {});
}
else if((($match.rawValue == UTF8ValidationResult.error().rawValue))) {
const newBrokenRange = $match[0]
brokenRange = _cloneStruct(newBrokenRange);
};
} while(Int.$greaterThan(remainingInput.count, 0));
return _create(String, 'init_StringGuts', result, {})
}





















































function /*Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:(OutputEncoding.CodeUnit) -> Void)*/
/*Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:(OutputEncoding.CodeUnit) -> Void)*/
transcodeFromToStoppingOnErrorInto<Input, InputEncoding, OutputEncoding>(input, inputEncoding, outputEncoding, stopOnError, processCodeUnit, $info?) {
throw 'unsupported method Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:(OutputEncoding.CodeUnit) -> Void) in ' + this.constructor.name
}


function /*Swift.(file).transcode(_:InputEncoding.Type,_:OutputEncoding.Type,_:Input,_:(OutputEncoding.CodeUnit) -> Void,stopOnError:Bool)*/
/*Swift.(file).transcode(_:InputEncoding.Type,_:OutputEncoding.Type,_:Input,_:(OutputEncoding.CodeUnit) -> Void,stopOnError:Bool)*/
transcodeStopOnError<Input, InputEncoding, OutputEncoding>(inputEncoding, outputEncoding, input, output, stopOnError, $info?) {
throw 'unsupported method Swift.(file).transcode(_:InputEncoding.Type,_:OutputEncoding.Type,_:Input,_:(OutputEncoding.CodeUnit) -> Void,stopOnError:Bool) in ' + this.constructor.name
}
































function /*Swift.(file).any(_:SIMDMask<Storage>)*/
/*Swift.(file).any(_:SIMDMask<Storage>)*/
any<Storage>(mask, $info?) {
return ((function(){throw '!unclarifiedGeneric:Storage.Scalar'})()).$lessThan(mask._storage.min( {}), 0)
}





function /*Swift.(file).pointwiseMin(_:T,_:T)*/
/*Swift.(file).pointwiseMin(_:T,_:T)*/
pointwiseMin<T>(a, b, $info?) {
let result = _create(((function(){throw '!unclarifiedGeneric:T'})()), 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(min(a.subscript$get(i_1), b.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}


function /*Swift.(file).pointwiseMax(_:T,_:T)*/
/*Swift.(file).pointwiseMax(_:T,_:T)*/
pointwiseMax<T>(a, b, $info?) {
let result = _create(((function(){throw '!unclarifiedGeneric:T'})()), 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(max(a.subscript$get(i_1), b.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}


function /*Swift.(file).pointwiseMin(_:T,_:T)*/
/*Swift.(file).pointwiseMin(_:T,_:T)*/
pointwiseMin<T>(a, b, $info?) {
let result = _create(((function(){throw '!unclarifiedGeneric:T'})()), 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(min(a.subscript$get(i_1), b.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}


function /*Swift.(file).pointwiseMax(_:T,_:T)*/
/*Swift.(file).pointwiseMax(_:T,_:T)*/
pointwiseMax<T>(a, b, $info?) {
let result = _create(((function(){throw '!unclarifiedGeneric:T'})()), 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(max(a.subscript$get(i_1), b.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}


function /*Swift.(file).sequence(first:T,next:(T) -> T?)*/
/*Swift.(file).sequence(first:T,next:(T) -> T?)*/
sequenceFirstNext<T>(first, next, $info?) {
return sequenceStateNext({0: _injectIntoOptional(first), 1: true}, ((state$inout, $info?) => { 
const $match = state
if(((true))) {
const value = $match[0]
state["1"] = false;
return value;
}
else if((($match[0].rawValue == 'some'))) {
const value = $match[0][0]
const nextValue = next(value);
state["0"] = nextValue;
return nextValue;
}
else if((($match[0].rawValue == Optional.none.rawValue))) {
return _injectIntoOptional(null);
}; }))
}


function /*Swift.(file).sequence(state:State,next:(inout State) -> T?)*/
/*Swift.(file).sequence(state:State,next:(inout State) -> T?)*/
sequenceStateNext<T, State>(state, next, $info?) {
return _create(UnfoldSequence, 'init_state_nextfunction_type', state, next, {})
}














function /*Swift.(file).withVaList(_:[CVarArg],_:(CVaListPointer) -> R)*/
/*Swift.(file).withVaList(_:[CVarArg],_:(CVaListPointer) -> R)*/
withVaList<R>(args, body, $info?) {
const builder = _create(__VaListBuilder, 'init', {});
{
let $a$generator = _cloneStruct(args.makeIterator( {}));
while(true) {
const $ifLet0, a_1;
if(!((($ifLet0 = $a$generator.next( {$setThis: $val => $a$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((a_1 = $ifLet0[0])||true))) break
builder.append(a_1);
}
};
return _withVaList(builder, body)
}





function /*Swift.(file).getVaList(_:[CVarArg])*/
/*Swift.(file).getVaList(_:[CVarArg])*/
getVaList(args, $info?) {
throw 'unsupported method Swift.(file).getVaList(_:[CVarArg]) in ' + this.constructor.name
}





function /*Swift.(file).zip(_:Sequence1,_:Sequence2)*/
/*Swift.(file).zip(_:Sequence1,_:Sequence2)*/
zip<Sequence1, Sequence2>(sequence1, sequence2, $info?) {
return _create(Zip2Sequence, 'init', sequence1, sequence2, {})
}


















































function /*Swift.(file).%infix(_:T,_:T)*/
/*Swift.(file).%infix(_:T,_:T)*/
$remainder<T>(lhs, rhs, $info?) {
return lhs % rhs
}


function /*Swift.(file).%=infix(_:T,_:T)*/
/*Swift.(file).%=infix(_:T,_:T)*/
$remainderAndAssign<T>(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}










































































function /*Swift.(file).withUnsafeMutableBytes(of:T,_:(UnsafeMutableRawBufferPointer) throws -> Result)*/
/*Swift.(file).withUnsafeMutableBytes(of:T,_:(UnsafeMutableRawBufferPointer) throws -> Result)*/
withUnsafeMutableBytesOf<T, Result>(value$inout, body, $info?) {
throw 'unsupported method Swift.(file).withUnsafeMutableBytes(of:T,_:(UnsafeMutableRawBufferPointer) throws -> Result) in ' + this.constructor.name
}


function /*Swift.(file).withUnsafeBytes(of:T,_:(UnsafeRawBufferPointer) throws -> Result)*/
/*Swift.(file).withUnsafeBytes(of:T,_:(UnsafeRawBufferPointer) throws -> Result)*/
withUnsafeBytesOf<T, Result>(value, body, $info?) {
throw 'unsupported method Swift.(file).withUnsafeBytes(of:T,_:(UnsafeRawBufferPointer) throws -> Result) in ' + this.constructor.name
}


function /*Swift.(file).withUnsafeBytes(of:T,_:(UnsafeRawBufferPointer) throws -> Result)*/
/*Swift.(file).withUnsafeBytes(of:T,_:(UnsafeRawBufferPointer) throws -> Result)*/
withUnsafeBytesOf<T, Result>(value, body, $info?) {
throw 'unsupported method Swift.(file).withUnsafeBytes(of:T,_:(UnsafeRawBufferPointer) throws -> Result) in ' + this.constructor.name
}





function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs < rhs
}


function /*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs <= rhs
}


function /*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs > rhs
}


function /*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs >= rhs
}


function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs < rhs
}


function /*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs <= rhs
}


function /*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs > rhs
}


function /*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs >= rhs
}


function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs < rhs
}


function /*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs <= rhs
}


function /*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs > rhs
}


function /*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs >= rhs
}


function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs < rhs
}


function /*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs <= rhs
}


function /*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs > rhs
}


function /*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs >= rhs
}


function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs < rhs
}


function /*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs <= rhs
}


function /*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs > rhs
}


function /*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs >= rhs
}


function /*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).==infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$equal<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs == rhs
}


function /*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).!=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$notEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs != rhs
}


function /*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs < rhs
}


function /*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).<=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$lessThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs <= rhs
}


function /*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThan<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs > rhs
}


function /*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*Swift.(file).>=infix(_:(A, B, C, D, E, F),_:(A, B, C, D, E, F))*/
/*!!!DUPLICATE NAME*/
$greaterThanOrEqual<A, B, C, D, E, F>(lhs, rhs, $info?) {
return lhs >= rhs
}


class _ArrayBody{
static readonly $struct = true





/*Swift.(file)._ArrayBody.init(count:Int,capacity:Int,elementTypeIsBridgedVerbatim:Bool)*/
/*Swift.(file)._ArrayBody.init(count:Int,capacity:Int,elementTypeIsBridgedVerbatim:Bool)*/
initCountIntCapacityIntElementTypeIsBridgedVerbatimBool(count, capacity, elementTypeIsBridgedVerbatim, $info?) {
throw 'unsupported method Swift.(file)._ArrayBody.init(count:Int,capacity:Int,elementTypeIsBridgedVerbatim:Bool) in ' + this.constructor.name
}
/*Swift.(file)._ArrayBody.init()*/
/*Swift.(file)._ArrayBody.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._ArrayBody.init() in ' + this.constructor.name
}

/*Swift.(file)._ArrayBody.count*/
count$get() {
throw 'unsupported variable Swift.(file)._ArrayBody.count in ' + this.constructor.name
}
get count() { return this.count$get() };






/*Swift.(file)._ArrayBody.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file)._ArrayBody.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._ArrayBody.elementTypeIsBridgedVerbatim*/
elementTypeIsBridgedVerbatim$get() {
throw 'unsupported variable Swift.(file)._ArrayBody.elementTypeIsBridgedVerbatim in ' + this.constructor.name
}
get elementTypeIsBridgedVerbatim() { return this.elementTypeIsBridgedVerbatim$get() };










init$vars() {let _this = this;

}
}


class _DependenceToken{
static readonly $struct = true
/*Swift.(file)._DependenceToken.init()*/
/*Swift.(file)._DependenceToken.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._DependenceToken.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


interface _ObjectiveCBridgeable<_ObjectiveCType>{





}
class _ObjectiveCBridgeable$implementation{
}


class _BridgeableMetatype implements _ObjectiveCBridgeable{
static readonly $struct = true

/*Swift.(file)._BridgeableMetatype.value*/
value$get() {
throw 'unsupported variable Swift.(file)._BridgeableMetatype.value in ' + this.constructor.name
}
get value() { return this.value$get() };





/*Swift.(file)._BridgeableMetatype.init(value:AnyObject.Type)*/
/*Swift.(file)._BridgeableMetatype.init(value:AnyObject.Type)*/
initValueAnyObject(value, $info?) {
throw 'unsupported method Swift.(file)._BridgeableMetatype.init(value:AnyObject.Type) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}
if(typeof _ObjectiveCBridgeable$implementation != 'undefined') _mixin(_BridgeableMetatype, _ObjectiveCBridgeable$implementation, false)


class _CocoaFastEnumerationStackBuf{
static readonly $struct = true

















































































/*Swift.(file)._CocoaFastEnumerationStackBuf.count*/
count$get() {
throw 'unsupported variable Swift.(file)._CocoaFastEnumerationStackBuf.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file)._CocoaFastEnumerationStackBuf.init()*/
/*Swift.(file)._CocoaFastEnumerationStackBuf.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._CocoaFastEnumerationStackBuf.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class _BridgeStorage<NativeClass>{
static readonly $struct = true



/*Swift.(file)._BridgeStorage.rawValue*/
rawValue$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };





/*Swift.(file)._BridgeStorage.init(native:_BridgeStorage<NativeClass>.Native,isFlagged:Bool)*/
/*Swift.(file)._BridgeStorage.init(native:_BridgeStorage<NativeClass>.Native,isFlagged:Bool)*/
initNative_BridgeStorageNativeIsFlaggedBool(_native, flag, $info?) {
throw 'unsupported method Swift.(file)._BridgeStorage.init(native:_BridgeStorage<NativeClass>.Native,isFlagged:Bool) in ' + this.constructor.name
}
/*Swift.(file)._BridgeStorage.init(objC:_BridgeStorage<NativeClass>.ObjC)*/
/*Swift.(file)._BridgeStorage.init(objC:_BridgeStorage<NativeClass>.ObjC)*/
initObjC_BridgeStorageObjC(objC, $info?) {
throw 'unsupported method Swift.(file)._BridgeStorage.init(objC:_BridgeStorage<NativeClass>.ObjC) in ' + this.constructor.name
}
/*Swift.(file)._BridgeStorage.init(native:_BridgeStorage<NativeClass>.Native)*/
/*Swift.(file)._BridgeStorage.init(native:_BridgeStorage<NativeClass>.Native)*/
initNative_BridgeStorageNative(_native, $info?) {
throw 'unsupported method Swift.(file)._BridgeStorage.init(native:_BridgeStorage<NativeClass>.Native) in ' + this.constructor.name
}
/*Swift.(file)._BridgeStorage.init(taggedPayload:UInt)*/
/*Swift.(file)._BridgeStorage.init(taggedPayload:UInt)*/
initTaggedPayloadUInt(taggedPayload, $info?) {
throw 'unsupported method Swift.(file)._BridgeStorage.init(taggedPayload:UInt) in ' + this.constructor.name
}
/*Swift.(file)._BridgeStorage.isUniquelyReferencedNative()*/
/*Swift.(file)._BridgeStorage.isUniquelyReferencedNative()*/
isUniquelyReferencedNative($info?) {
throw 'unsupported method Swift.(file)._BridgeStorage.isUniquelyReferencedNative() in ' + this.constructor.name
}

/*Swift.(file)._BridgeStorage.isNative*/
isNative$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.isNative in ' + this.constructor.name
}
get isNative() { return this.isNative$get() };




/*Swift.(file)._BridgeStorage.flagMask*/
static flagMask$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.flagMask in ' + this.constructor.name
}
static get flagMask() { return this.flagMask$get() };




/*Swift.(file)._BridgeStorage.isUnflaggedNative*/
isUnflaggedNative$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.isUnflaggedNative in ' + this.constructor.name
}
get isUnflaggedNative() { return this.isUnflaggedNative$get() };




/*Swift.(file)._BridgeStorage.isObjC*/
isObjC$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.isObjC in ' + this.constructor.name
}
get isObjC() { return this.isObjC$get() };




/*Swift.(file)._BridgeStorage.nativeInstance*/
nativeInstance$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.nativeInstance in ' + this.constructor.name
}
get nativeInstance() { return this.nativeInstance$get() };




/*Swift.(file)._BridgeStorage.unflaggedNativeInstance*/
unflaggedNativeInstance$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.unflaggedNativeInstance in ' + this.constructor.name
}
get unflaggedNativeInstance() { return this.unflaggedNativeInstance$get() };



/*Swift.(file)._BridgeStorage.isUniquelyReferencedUnflaggedNative()*/
/*Swift.(file)._BridgeStorage.isUniquelyReferencedUnflaggedNative()*/
isUniquelyReferencedUnflaggedNative($info?) {
throw 'unsupported method Swift.(file)._BridgeStorage.isUniquelyReferencedUnflaggedNative() in ' + this.constructor.name
}

/*Swift.(file)._BridgeStorage.objCInstance*/
objCInstance$get() {
throw 'unsupported variable Swift.(file)._BridgeStorage.objCInstance in ' + this.constructor.name
}
get objCInstance() { return this.objCInstance$get() };



init$vars() {let _this = this;

}
}


class _BridgingBufferHeader{
static readonly $struct = true
/*Swift.(file)._BridgingBufferHeader.init(_:Int)*/
/*Swift.(file)._BridgingBufferHeader.init(_:Int)*/
initInt(count, $info?) {
throw 'unsupported method Swift.(file)._BridgingBufferHeader.init(_:Int) in ' + this.constructor.name
}

/*Swift.(file)._BridgingBufferHeader.count*/
count$get() {
throw 'unsupported variable Swift.(file)._BridgingBufferHeader.count in ' + this.constructor.name
}
get count() { return this.count$get() };





init$vars() {let _this = this;

}
}


interface RawRepresentable<RawValue>{

/*Swift.(file).RawRepresentable.init(rawValue:Self.RawValue)*/
/*Swift.(file).RawRepresentable.init(rawValue:Self.RawValue)*/
initRawValue(rawValue, $info?)

/*Swift.(file).RawRepresentable.rawValue*/
rawValue;



}
class RawRepresentable$implementation{

/*Swift.(file).RawRepresentable.hashValue*/
hashValue$get() {
let _this = this;
return _this.rawValue.hashValue
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).RawRepresentable.hash(into:Hasher)*/
/*Swift.(file).RawRepresentable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}

/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
/*Swift.(file).RawRepresentable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
/*Swift.(file).RawRepresentable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).RawRepresentable.init(from:Decoder) in ' + this.constructor.name
}
}




























































interface CaseIterable<AllCases>{


/*Swift.(file).CaseIterable.allCases*/
static allCases;



}
class CaseIterable$implementation{
}


interface ExpressibleByNilLiteral{
/*Swift.(file).ExpressibleByNilLiteral.init(nilLiteral:())*/
/*Swift.(file).ExpressibleByNilLiteral.init(nilLiteral:())*/
initNilLiteraltuple_type(nilLiteral, $info?)
}
class ExpressibleByNilLiteral$implementation{
}


interface _ExpressibleByBuiltinIntegerLiteral{
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(value, $info?)
}
class _ExpressibleByBuiltinIntegerLiteral$implementation{
}


interface ExpressibleByIntegerLiteral<IntegerLiteralType>{

/*Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self.IntegerLiteralType)*/
/*Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self.IntegerLiteralType)*/
initIntegerLiteral(value, $info?)
}
class ExpressibleByIntegerLiteral$implementation{
/*Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)*/
/*Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)*/
/*!!!DUPLICATE NAME*/
initIntegerLiteral(value, $info?) {
return value
}
}




interface _ExpressibleByBuiltinFloatLiteral{
/*Swift.(file)._ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:_MaxBuiltinFloatType)*/
/*Swift.(file)._ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:_MaxBuiltinFloatType)*/
init_builtinFloatLiteral_MaxBuiltinFloatType(value, $info?)
}
class _ExpressibleByBuiltinFloatLiteral$implementation{
}


interface ExpressibleByFloatLiteral<FloatLiteralType>{

/*Swift.(file).ExpressibleByFloatLiteral.init(floatLiteral:Self.FloatLiteralType)*/
/*Swift.(file).ExpressibleByFloatLiteral.init(floatLiteral:Self.FloatLiteralType)*/
initFloatLiteral(value, $info?)
}
class ExpressibleByFloatLiteral$implementation{
}


interface _ExpressibleByBuiltinBooleanLiteral{
/*Swift.(file)._ExpressibleByBuiltinBooleanLiteral.init(_builtinBooleanLiteral:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinBooleanLiteral.init(_builtinBooleanLiteral:Int1)*/
init_builtinBooleanLiteralInt1(value, $info?)
}
class _ExpressibleByBuiltinBooleanLiteral$implementation{
}


interface ExpressibleByBooleanLiteral<BooleanLiteralType>{

/*Swift.(file).ExpressibleByBooleanLiteral.init(booleanLiteral:Self.BooleanLiteralType)*/
/*Swift.(file).ExpressibleByBooleanLiteral.init(booleanLiteral:Self.BooleanLiteralType)*/
initBooleanLiteral(value, $info?)
}
class ExpressibleByBooleanLiteral$implementation{
}


interface _ExpressibleByBuiltinUnicodeScalarLiteral{
/*Swift.(file)._ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:Int32)*/
/*Swift.(file)._ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:Int32)*/
init_builtinUnicodeScalarLiteralInt32(value, $info?)
}
class _ExpressibleByBuiltinUnicodeScalarLiteral$implementation{
}


interface ExpressibleByUnicodeScalarLiteral<UnicodeScalarLiteralType>{

/*Swift.(file).ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:Self.UnicodeScalarLiteralType)*/
/*Swift.(file).ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:Self.UnicodeScalarLiteralType)*/
initUnicodeScalarLiteral(value, $info?)
}
class ExpressibleByUnicodeScalarLiteral$implementation{
}


interface _ExpressibleByBuiltinExtendedGraphemeClusterLiteral extends _ExpressibleByBuiltinUnicodeScalarLiteral{
/*Swift.(file)._ExpressibleByBuiltinExtendedGraphemeClusterLiteral.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinExtendedGraphemeClusterLiteral.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_builtinExtendedGraphemeClusterLiteralRawPointerUtf8CodeUnitCountWordIsASCIIInt1(start, utf8CodeUnitCount, isASCII, $info?)
}
class _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation{
}
if(typeof _ExpressibleByBuiltinUnicodeScalarLiteral$implementation != 'undefined') _mixin(_ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation, _ExpressibleByBuiltinUnicodeScalarLiteral$implementation, false)


interface ExpressibleByExtendedGraphemeClusterLiteral<ExtendedGraphemeClusterLiteralType> extends ExpressibleByUnicodeScalarLiteral{

/*Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(extendedGraphemeClusterLiteral:Self.ExtendedGraphemeClusterLiteralType)*/
/*Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(extendedGraphemeClusterLiteral:Self.ExtendedGraphemeClusterLiteralType)*/
initExtendedGraphemeClusterLiteral(value, $info?)
}
class ExpressibleByExtendedGraphemeClusterLiteral$implementation{
/*Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(unicodeScalarLiteral:Self.ExtendedGraphemeClusterLiteralType)*/
/*Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(unicodeScalarLiteral:Self.ExtendedGraphemeClusterLiteralType)*/
initUnicodeScalarLiteral(value, $info?) {
let _this = this;
_this.initExtendedGraphemeClusterLiteral(value);
return
}
}
if(typeof ExpressibleByUnicodeScalarLiteral$implementation != 'undefined') _mixin(ExpressibleByExtendedGraphemeClusterLiteral$implementation, ExpressibleByUnicodeScalarLiteral$implementation, false)




interface _ExpressibleByBuiltinStringLiteral extends _ExpressibleByBuiltinExtendedGraphemeClusterLiteral{
/*Swift.(file)._ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_builtinStringLiteralRawPointerUtf8CodeUnitCountWordIsASCIIInt1(start, utf8CodeUnitCount, isASCII, $info?)
}
class _ExpressibleByBuiltinStringLiteral$implementation{
}
if(typeof _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(_ExpressibleByBuiltinStringLiteral$implementation, _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation, false)


interface ExpressibleByStringLiteral<StringLiteralType> extends ExpressibleByExtendedGraphemeClusterLiteral{

/*Swift.(file).ExpressibleByStringLiteral.init(stringLiteral:Self.StringLiteralType)*/
/*Swift.(file).ExpressibleByStringLiteral.init(stringLiteral:Self.StringLiteralType)*/
initStringLiteral(value, $info?)
}
class ExpressibleByStringLiteral$implementation{
/*Swift.(file).ExpressibleByStringLiteral.init(extendedGraphemeClusterLiteral:Self.StringLiteralType)*/
/*Swift.(file).ExpressibleByStringLiteral.init(extendedGraphemeClusterLiteral:Self.StringLiteralType)*/
initExtendedGraphemeClusterLiteral(value, $info?) {
let _this = this;
_this.initStringLiteral(value);
return
}
}
if(typeof ExpressibleByExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(ExpressibleByStringLiteral$implementation, ExpressibleByExtendedGraphemeClusterLiteral$implementation, false)




interface ExpressibleByArrayLiteral<ArrayLiteralElement>{

/*Swift.(file).ExpressibleByArrayLiteral.init(arrayLiteral:[Self.ArrayLiteralElement])*/
/*Swift.(file).ExpressibleByArrayLiteral.init(arrayLiteral:[Self.ArrayLiteralElement])*/
initArrayLiteralArray(_elements, $info?)
}
class ExpressibleByArrayLiteral$implementation{
}


interface ExpressibleByDictionaryLiteral<Key, Value>{


/*Swift.(file).ExpressibleByDictionaryLiteral.init(dictionaryLiteral:[(Self.Key, Self.Value)])*/
/*Swift.(file).ExpressibleByDictionaryLiteral.init(dictionaryLiteral:[(Self.Key, Self.Value)])*/
initDictionaryLiteralArray(_elements, $info?)
}
class ExpressibleByDictionaryLiteral$implementation{
}


interface ExpressibleByStringInterpolation<StringInterpolation> extends ExpressibleByStringLiteral{

/*Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:Self.StringInterpolation)*/
/*Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:Self.StringInterpolation)*/
initStringInterpolation(stringInterpolation, $info?)
}
class ExpressibleByStringInterpolation$implementation{
/*Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:DefaultStringInterpolation)*/
/*Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:DefaultStringInterpolation)*/
initStringInterpolationDefaultStringInterpolation(stringInterpolation, $info?) {
let _this = this;
_this.initStringLiteral(stringInterpolation.make( {}));
return
}
}
if(typeof ExpressibleByStringLiteral$implementation != 'undefined') _mixin(ExpressibleByStringInterpolation$implementation, ExpressibleByStringLiteral$implementation, false)




interface StringInterpolationProtocol<StringLiteralType>{

/*Swift.(file).StringInterpolationProtocol.init(literalCapacity:Int,interpolationCount:Int)*/
/*Swift.(file).StringInterpolationProtocol.init(literalCapacity:Int,interpolationCount:Int)*/
initLiteralCapacityIntInterpolationCountInt(literalCapacity, interpolationCount, $info?)
/*Swift.(file).StringInterpolationProtocol.appendLiteral(_:Self.StringLiteralType)*/
/*Swift.(file).StringInterpolationProtocol.appendLiteral(_:Self.StringLiteralType)*/
appendLiteral(literal, $info?)
}
class StringInterpolationProtocol$implementation{
}


interface _ExpressibleByColorLiteral{
/*Swift.(file)._ExpressibleByColorLiteral.init(_colorLiteralRed:Float,green:Float,blue:Float,alpha:Float)*/
/*Swift.(file)._ExpressibleByColorLiteral.init(_colorLiteralRed:Float,green:Float,blue:Float,alpha:Float)*/
init_colorLiteralRedFloatGreenFloatBlueFloatAlphaFloat(red, green, blue, alpha, $info?)
}
class _ExpressibleByColorLiteral$implementation{
}


interface _ExpressibleByImageLiteral{
/*Swift.(file)._ExpressibleByImageLiteral.init(imageLiteralResourceName:String)*/
/*Swift.(file)._ExpressibleByImageLiteral.init(imageLiteralResourceName:String)*/
initImageLiteralResourceNameString(path, $info?)
}
class _ExpressibleByImageLiteral$implementation{
}


interface _ExpressibleByFileReferenceLiteral{
/*Swift.(file)._ExpressibleByFileReferenceLiteral.init(fileReferenceLiteralResourceName:String)*/
/*Swift.(file)._ExpressibleByFileReferenceLiteral.init(fileReferenceLiteralResourceName:String)*/
initFileReferenceLiteralResourceNameString(path, $info?)
}
class _ExpressibleByFileReferenceLiteral$implementation{
}


interface _DestructorSafeContainer{
}


interface _HasContiguousBytes{
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?)



}
class _HasContiguousBytes$implementation{



}




class _UnsafePartiallyInitializedContiguousArrayBuffer<Element>{
static readonly $struct = true

/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.result*/
result$get() {
throw 'unsupported variable Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.result in ' + this.constructor.name
}
get result() { return this.result$get() };






/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.p*/
p$get() {
throw 'unsupported variable Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.p in ' + this.constructor.name
}
get p() { return this.p$get() };






/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity*/
remainingCapacity$get() {
throw 'unsupported variable Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.remainingCapacity in ' + this.constructor.name
}
get remainingCapacity() { return this.remainingCapacity$get() };





/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.init(initialCapacity:Int)*/
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.init(initialCapacity:Int)*/
initInitialCapacityInt(initialCapacity, $info?) {
throw 'unsupported method Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.init(initialCapacity:Int) in ' + this.constructor.name
}
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.add(_:Element)*/
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.add(_:Element)*/
add(_element, $info?) {
throw 'unsupported method Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.add(_:Element) in ' + this.constructor.name
}
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.addWithExistingCapacity(_:Element)*/
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.addWithExistingCapacity(_:Element)*/
addWithExistingCapacity(_element, $info?) {
throw 'unsupported method Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.addWithExistingCapacity(_:Element) in ' + this.constructor.name
}
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.finish()*/
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.finish()*/
finish($info?) {
throw 'unsupported method Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.finish() in ' + this.constructor.name
}
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.finishWithOriginalCount()*/
/*Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.finishWithOriginalCount()*/
finishWithOriginalCount($info?) {
throw 'unsupported method Swift.(file)._UnsafePartiallyInitializedContiguousArrayBuffer.finishWithOriginalCount() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class _DebuggerSupport{
static CollectionStatus = class{

static get notACollection() {return Object.assign(new _DebuggerSupport.CollectionStatus(), {rawValue: "notACollection", ...Array.from(arguments)})}

static get collectionOfElements() {return Object.assign(new _DebuggerSupport.CollectionStatus(), {rawValue: "collectionOfElements", ...Array.from(arguments)})}

static get collectionOfPairs() {return Object.assign(new _DebuggerSupport.CollectionStatus(), {rawValue: "collectionOfPairs", ...Array.from(arguments)})}

static get _element() {return Object.assign(new _DebuggerSupport.CollectionStatus(), {rawValue: "_element", ...Array.from(arguments)})}

static get pair() {return Object.assign(new _DebuggerSupport.CollectionStatus(), {rawValue: "pair", ...Array.from(arguments)})}

static get elementOfPair() {return Object.assign(new _DebuggerSupport.CollectionStatus(), {rawValue: "elementOfPair", ...Array.from(arguments)})}

/*Swift.(file)._DebuggerSupport.CollectionStatus.isCollection*/
isCollection$get() {
throw 'unsupported variable Swift.(file)._DebuggerSupport.CollectionStatus.isCollection in ' + this.constructor.name
}
get isCollection() { return this.isCollection$get() };



/*Swift.(file)._DebuggerSupport.CollectionStatus.getChildStatus(child:Mirror)*/
/*Swift.(file)._DebuggerSupport.CollectionStatus.getChildStatus(child:Mirror)*/
getChildStatusChild(child, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.CollectionStatus.getChildStatus(child:Mirror) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.CollectionStatus.==(_:_DebuggerSupport.CollectionStatus,_:_DebuggerSupport.CollectionStatus)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file)._DebuggerSupport.CollectionStatus.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file)._DebuggerSupport.CollectionStatus.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file)._DebuggerSupport.CollectionStatus.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.CollectionStatus.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
static /*Swift.(file)._DebuggerSupport.isClass(_:Any)*/
/*Swift.(file)._DebuggerSupport.isClass(_:Any)*/
isClass(value, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.isClass(_:Any) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.checkValue(_:Any,ifClass:(AnyObject) -> T,otherwise:() -> T)*/
/*Swift.(file)._DebuggerSupport.checkValue(_:Any,ifClass:(AnyObject) -> T,otherwise:() -> T)*/
checkValueIfClassOtherwise<T>(value, ifClass, otherwise, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.checkValue(_:Any,ifClass:(AnyObject) -> T,otherwise:() -> T) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.asObjectIdentifier(_:Any)*/
/*Swift.(file)._DebuggerSupport.asObjectIdentifier(_:Any)*/
asObjectIdentifier(value, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.asObjectIdentifier(_:Any) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.asObjectAddress(_:Any)*/
/*Swift.(file)._DebuggerSupport.asObjectAddress(_:Any)*/
asObjectAddress(value, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.asObjectAddress(_:Any) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.asStringRepresentation(value:Any?,mirror:Mirror,count:Int)*/
/*Swift.(file)._DebuggerSupport.asStringRepresentation(value:Any?,mirror:Mirror,count:Int)*/
asStringRepresentationValueMirrorCount(value, mirror, count, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.asStringRepresentation(value:Any?,mirror:Mirror,count:Int) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.ivarCount(mirror:Mirror)*/
/*Swift.(file)._DebuggerSupport.ivarCount(mirror:Mirror)*/
ivarCountMirror(mirror, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.ivarCount(mirror:Mirror) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.shouldExpand(mirror:Mirror,collectionStatus:_DebuggerSupport.CollectionStatus,isRoot:Bool)*/
/*Swift.(file)._DebuggerSupport.shouldExpand(mirror:Mirror,collectionStatus:_DebuggerSupport.CollectionStatus,isRoot:Bool)*/
shouldExpandMirrorCollectionStatusIsRoot(mirror, collectionStatus, isRoot, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.shouldExpand(mirror:Mirror,collectionStatus:_DebuggerSupport.CollectionStatus,isRoot:Bool) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.printForDebuggerImpl(value:Any?,mirror:Mirror,name:String?,indent:Int,maxDepth:Int,isRoot:Bool,parentCollectionStatus:_DebuggerSupport.CollectionStatus,refsAlreadySeen:Set<ObjectIdentifier>,maxItemCounter:Int,target:StreamType)*/
/*Swift.(file)._DebuggerSupport.printForDebuggerImpl(value:Any?,mirror:Mirror,name:String?,indent:Int,maxDepth:Int,isRoot:Bool,parentCollectionStatus:_DebuggerSupport.CollectionStatus,refsAlreadySeen:Set<ObjectIdentifier>,maxItemCounter:Int,target:StreamType)*/
printForDebuggerImplValueMirrorNameIndentMaxDepthIsRootParentCollectionStatusRefsAlreadySeenMaxItemCounterTarget<StreamType>(value, mirror, _name, indent, maxDepth, isRoot, parentCollectionStatus, refsAlreadySeen$inout, maxItemCounter$inout, target$inout, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.printForDebuggerImpl(value:Any?,mirror:Mirror,name:String?,indent:Int,maxDepth:Int,isRoot:Bool,parentCollectionStatus:_DebuggerSupport.CollectionStatus,refsAlreadySeen:Set<ObjectIdentifier>,maxItemCounter:Int,target:StreamType) in ' + this.constructor.name
}
static /*Swift.(file)._DebuggerSupport.stringForPrintObject(_:Any)*/
/*Swift.(file)._DebuggerSupport.stringForPrintObject(_:Any)*/
stringForPrintObject(value, $info?) {
throw 'unsupported method Swift.(file)._DebuggerSupport.stringForPrintObject(_:Any) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(_DebuggerSupport.CollectionStatus, _DefaultEnumImplementation, false)
_mixin(_DebuggerSupport, _DefaultEnumImplementation, false)


class _DictionaryBuilder<Key, Value>{
static readonly $struct = true








/*Swift.(file)._DictionaryBuilder.init(count:Int)*/
/*Swift.(file)._DictionaryBuilder.init(count:Int)*/
initCountInt(count, $info?) {
throw 'unsupported method Swift.(file)._DictionaryBuilder.init(count:Int) in ' + this.constructor.name
}
/*Swift.(file)._DictionaryBuilder.add(key:Key,value:Value)*/
/*Swift.(file)._DictionaryBuilder.add(key:Key,value:Value)*/
addKeyValue(newKey, value, $info?) {
throw 'unsupported method Swift.(file)._DictionaryBuilder.add(key:Key,value:Value) in ' + this.constructor.name
}
/*Swift.(file)._DictionaryBuilder.take()*/
/*Swift.(file)._DictionaryBuilder.take()*/
take($info?) {
throw 'unsupported method Swift.(file)._DictionaryBuilder.take() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


interface _DictionaryBuffer<Key, Value, Index>{




/*Swift.(file)._DictionaryBuffer.startIndex*/
startIndex;




/*Swift.(file)._DictionaryBuffer.endIndex*/
endIndex;



/*Swift.(file)._DictionaryBuffer.index(after:Self.Index)*/
/*Swift.(file)._DictionaryBuffer.index(after:Self.Index)*/
indexAfter(i, $info?)
/*Swift.(file)._DictionaryBuffer.index(forKey:Self.Key)*/
/*Swift.(file)._DictionaryBuffer.index(forKey:Self.Key)*/
indexForKey(key, $info?)

/*Swift.(file)._DictionaryBuffer.count*/
count;



/*Swift.(file)._DictionaryBuffer.contains(_:Self.Key)*/
/*Swift.(file)._DictionaryBuffer.contains(_:Self.Key)*/
contains(key, $info?)
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Key)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Key)*/
lookup(key, $info?)
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Index)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Index)*/
/*!!!DUPLICATE NAME*/
lookup(index, $info?)
/*Swift.(file)._DictionaryBuffer.key(at:Self.Index)*/
/*Swift.(file)._DictionaryBuffer.key(at:Self.Index)*/
keyAt(index, $info?)
/*Swift.(file)._DictionaryBuffer.value(at:Self.Index)*/
/*Swift.(file)._DictionaryBuffer.value(at:Self.Index)*/
valueAt(index, $info?)
}
class _DictionaryBuffer$implementation{
}


interface Equatable{
static /*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?)
}
class Equatable$implementation{
static /*Swift.(file).Equatable.!=infix(_:Self,_:Self)*/
/*Swift.(file).Equatable.!=infix(_:Self,_:Self)*/
$notEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$equal(_.arg0, rhs))
}
}




interface Error{










}
class Error$implementation{













}








class FloatingPointClassification{

static get signalingNaN() {return Object.assign(new FloatingPointClassification(), {rawValue: "signalingNaN", ...Array.from(arguments)})}

static get quietNaN() {return Object.assign(new FloatingPointClassification(), {rawValue: "quietNaN", ...Array.from(arguments)})}

static get negativeInfinity() {return Object.assign(new FloatingPointClassification(), {rawValue: "negativeInfinity", ...Array.from(arguments)})}

static get negativeNormal() {return Object.assign(new FloatingPointClassification(), {rawValue: "negativeNormal", ...Array.from(arguments)})}

static get negativeSubnormal() {return Object.assign(new FloatingPointClassification(), {rawValue: "negativeSubnormal", ...Array.from(arguments)})}

static get negativeZero() {return Object.assign(new FloatingPointClassification(), {rawValue: "negativeZero", ...Array.from(arguments)})}

static get positiveZero() {return Object.assign(new FloatingPointClassification(), {rawValue: "positiveZero", ...Array.from(arguments)})}

static get positiveSubnormal() {return Object.assign(new FloatingPointClassification(), {rawValue: "positiveSubnormal", ...Array.from(arguments)})}

static get positiveNormal() {return Object.assign(new FloatingPointClassification(), {rawValue: "positiveNormal", ...Array.from(arguments)})}

static get positiveInfinity() {return Object.assign(new FloatingPointClassification(), {rawValue: "positiveInfinity", ...Array.from(arguments)})}
static /*Swift.(file).FloatingPointClassification.==(_:FloatingPointClassification,_:FloatingPointClassification)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).FloatingPointClassification.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).FloatingPointClassification.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).FloatingPointClassification.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).FloatingPointClassification.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(FloatingPointClassification, _DefaultEnumImplementation, false)


class FloatingPointRoundingRule{

static get toNearestOrAwayFromZero() {return Object.assign(new FloatingPointRoundingRule(), {rawValue: "toNearestOrAwayFromZero", ...Array.from(arguments)})}

static get toNearestOrEven() {return Object.assign(new FloatingPointRoundingRule(), {rawValue: "toNearestOrEven", ...Array.from(arguments)})}

static get up() {return Object.assign(new FloatingPointRoundingRule(), {rawValue: "up", ...Array.from(arguments)})}

static get down() {return Object.assign(new FloatingPointRoundingRule(), {rawValue: "down", ...Array.from(arguments)})}

static get towardZero() {return Object.assign(new FloatingPointRoundingRule(), {rawValue: "towardZero", ...Array.from(arguments)})}

static get awayFromZero() {return Object.assign(new FloatingPointRoundingRule(), {rawValue: "awayFromZero", ...Array.from(arguments)})}
static /*Swift.(file).FloatingPointRoundingRule.==(_:FloatingPointRoundingRule,_:FloatingPointRoundingRule)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).FloatingPointRoundingRule.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).FloatingPointRoundingRule.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).FloatingPointRoundingRule.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).FloatingPointRoundingRule.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(FloatingPointRoundingRule, _DefaultEnumImplementation, false)


interface Hashable extends Equatable{

/*Swift.(file).Hashable.hashValue*/
hashValue;



/*Swift.(file).Hashable.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?)

}
class Hashable$implementation{

}
if(typeof Equatable$implementation != 'undefined') _mixin(Hashable$implementation, Equatable$implementation, false)




interface _HasCustomAnyHashableRepresentation{

}
class _HasCustomAnyHashableRepresentation$implementation{
}


interface _AnyHashableBox{














}
class _AnyHashableBox$implementation{



}




class _ConcreteHashableBox<Base> implements _AnyHashableBox{
static readonly $struct = true





/*Swift.(file)._ConcreteHashableBox.init(_:Base)*/
/*Swift.(file)._ConcreteHashableBox.init(_:Base)*/
init(base, $info?) {
throw 'unsupported method Swift.(file)._ConcreteHashableBox.init(_:Base) in ' + this.constructor.name
}











init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_ConcreteHashableBox, _AnyHashableBox$implementation, false)


class Hasher{
static readonly $struct = true





/*Swift.(file).Hasher.init()*/
/*Swift.(file).Hasher.init()*/
init($info?) {
let _this = this;
_this._core = _create(Hasher._Core, 'init', {});
return
}
/*Swift.(file).Hasher.init(_seed:Int)*/
/*Swift.(file).Hasher.init(_seed:Int)*/
init_seedInt(_seed, $info?) {
let _this = this;
_this._core = _create(Hasher._Core, 'initSeedInt', _seed, {});
return
}
/*Swift.(file).Hasher.init(_rawSeed:(UInt64, UInt64))*/
/*Swift.(file).Hasher.init(_rawSeed:(UInt64, UInt64))*/
init_rawSeedtuple_type(_rawSeed, $info?) {
let _this = this;
_this._core = _create(Hasher._Core, 'initStateHasher_State', _create(Hasher._State, 'initRawSeedtuple_type', _rawSeed, {}), {});
return
}






/*Swift.(file).Hasher.combine(_:H)*/
/*Swift.(file).Hasher.combine(_:H)*/
combine<H>(value, $info?) {
let _this = this;
value.hashInto({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}






/*Swift.(file).Hasher.combine(bytes:UnsafeRawBufferPointer)*/
/*Swift.(file).Hasher.combine(bytes:UnsafeRawBufferPointer)*/
combineBytes(bytes, $info?) {
let _this = this;
_this._core.combineBytes(bytes, {$setThis: $val => _this._core = $val})
}

/*Swift.(file).Hasher.finalize()*/
/*Swift.(file).Hasher.finalize()*/
finalize($info?) {
let _this = this;
let core = _cloneStruct(_this._core);
return _create(Int, 'initTruncatingIfNeeded', core.finalize( {$setThis: $val => core = $val}), {})
}




static _TailBuffer = class{
static readonly $struct = true

/*Swift.(file).Hasher._TailBuffer.value*/
value$get() {
throw 'unsupported variable Swift.(file).Hasher._TailBuffer.value in ' + this.constructor.name
}
get value() { return this.value$get() };





/*Swift.(file).Hasher._TailBuffer.init()*/
/*Swift.(file).Hasher._TailBuffer.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Hasher._TailBuffer.init() in ' + this.constructor.name
}
/*Swift.(file).Hasher._TailBuffer.init(tail:UInt64,byteCount:UInt64)*/
/*Swift.(file).Hasher._TailBuffer.init(tail:UInt64,byteCount:UInt64)*/
initTailUInt64ByteCountUInt64(tail, byteCount, $info?) {
throw 'unsupported method Swift.(file).Hasher._TailBuffer.init(tail:UInt64,byteCount:UInt64) in ' + this.constructor.name
}
/*Swift.(file).Hasher._TailBuffer.init(tail:UInt64,byteCount:Int)*/
/*Swift.(file).Hasher._TailBuffer.init(tail:UInt64,byteCount:Int)*/
initTailUInt64ByteCountInt(tail, byteCount, $info?) {
throw 'unsupported method Swift.(file).Hasher._TailBuffer.init(tail:UInt64,byteCount:Int) in ' + this.constructor.name
}

/*Swift.(file).Hasher._TailBuffer.tail*/
tail$get() {
throw 'unsupported variable Swift.(file).Hasher._TailBuffer.tail in ' + this.constructor.name
}
get tail() { return this.tail$get() };




/*Swift.(file).Hasher._TailBuffer.byteCount*/
byteCount$get() {
throw 'unsupported variable Swift.(file).Hasher._TailBuffer.byteCount in ' + this.constructor.name
}
get byteCount() { return this.byteCount$get() };



/*Swift.(file).Hasher._TailBuffer.append(_:UInt64)*/
/*Swift.(file).Hasher._TailBuffer.append(_:UInt64)*/
append(bytes, $info?) {
throw 'unsupported method Swift.(file).Hasher._TailBuffer.append(_:UInt64) in ' + this.constructor.name
}
/*Swift.(file).Hasher._TailBuffer.append(_:UInt64,count:UInt64)*/
/*Swift.(file).Hasher._TailBuffer.append(_:UInt64,count:UInt64)*/
appendCount(bytes, count, $info?) {
throw 'unsupported method Swift.(file).Hasher._TailBuffer.append(_:UInt64,count:UInt64) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
static _Core = class{
static readonly $struct = true










/*Swift.(file).Hasher._Core.init(state:Hasher._State)*/
/*Swift.(file).Hasher._Core.init(state:Hasher._State)*/
initStateHasher_State(state, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.init(state:Hasher._State) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.init()*/
/*Swift.(file).Hasher._Core.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Hasher._Core.init() in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.init(seed:Int)*/
/*Swift.(file).Hasher._Core.init(seed:Int)*/
initSeedInt(seed, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.init(seed:Int) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.combine(_:UInt)*/
/*Swift.(file).Hasher._Core.combine(_:UInt)*/
combine(value, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.combine(_:UInt) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.combine(_:UInt64)*/
/*Swift.(file).Hasher._Core.combine(_:UInt64)*/
/*!!!DUPLICATE NAME*/
combine(value, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.combine(_:UInt64) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.combine(_:UInt32)*/
/*Swift.(file).Hasher._Core.combine(_:UInt32)*/
/*!!!DUPLICATE NAME*/
combine(value, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.combine(_:UInt32) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.combine(_:UInt16)*/
/*Swift.(file).Hasher._Core.combine(_:UInt16)*/
/*!!!DUPLICATE NAME*/
combine(value, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.combine(_:UInt16) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.combine(_:UInt8)*/
/*Swift.(file).Hasher._Core.combine(_:UInt8)*/
/*!!!DUPLICATE NAME*/
combine(value, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.combine(_:UInt8) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.combine(bytes:UInt64,count:Int)*/
/*Swift.(file).Hasher._Core.combine(bytes:UInt64,count:Int)*/
combineBytesCount(bytes, count, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.combine(bytes:UInt64,count:Int) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.combine(bytes:UnsafeRawBufferPointer)*/
/*Swift.(file).Hasher._Core.combine(bytes:UnsafeRawBufferPointer)*/
combineBytes(bytes, $info?) {
throw 'unsupported method Swift.(file).Hasher._Core.combine(bytes:UnsafeRawBufferPointer) in ' + this.constructor.name
}
/*Swift.(file).Hasher._Core.finalize()*/
/*Swift.(file).Hasher._Core.finalize()*/
finalize($info?) {
throw 'unsupported method Swift.(file).Hasher._Core.finalize() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
static _State = class{
static readonly $struct = true

/*Swift.(file).Hasher._State.v0*/
v0$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v0 in ' + this.constructor.name
}
get v0() { return this.v0$get() };






/*Swift.(file).Hasher._State.v1*/
v1$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v1 in ' + this.constructor.name
}
get v1() { return this.v1$get() };






/*Swift.(file).Hasher._State.v2*/
v2$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v2 in ' + this.constructor.name
}
get v2() { return this.v2$get() };






/*Swift.(file).Hasher._State.v3*/
v3$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v3 in ' + this.constructor.name
}
get v3() { return this.v3$get() };






/*Swift.(file).Hasher._State.v4*/
v4$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v4 in ' + this.constructor.name
}
get v4() { return this.v4$get() };






/*Swift.(file).Hasher._State.v5*/
v5$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v5 in ' + this.constructor.name
}
get v5() { return this.v5$get() };






/*Swift.(file).Hasher._State.v6*/
v6$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v6 in ' + this.constructor.name
}
get v6() { return this.v6$get() };






/*Swift.(file).Hasher._State.v7*/
v7$get() {
throw 'unsupported variable Swift.(file).Hasher._State.v7 in ' + this.constructor.name
}
get v7() { return this.v7$get() };





/*Swift.(file).Hasher._State.init(rawSeed:(UInt64, UInt64))*/
/*Swift.(file).Hasher._State.init(rawSeed:(UInt64, UInt64))*/
initRawSeedtuple_type(rawSeed, $info?) {
throw 'unsupported method Swift.(file).Hasher._State.init(rawSeed:(UInt64, UInt64)) in ' + this.constructor.name
}



/*Swift.(file).Hasher._State.compress(_:UInt64)*/
/*Swift.(file).Hasher._State.compress(_:UInt64)*/
compress(m, $info?) {
let _this = this;
UInt64.$bitwiseXORAndAssign({get: () => _this.v3, set: $val => _this.v3 = $val}, m);
_this._round( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
UInt64.$bitwiseXORAndAssign({get: () => _this.v0, set: $val => _this.v0 = $val}, m)
}
/*Swift.(file).Hasher._State.finalize(tailAndByteCount:UInt64)*/
/*Swift.(file).Hasher._State.finalize(tailAndByteCount:UInt64)*/
finalizeTailAndByteCount(tailAndByteCount, $info?) {
let _this = this;
_this.compress(tailAndByteCount, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
UInt64.$bitwiseXORAndAssign({get: () => _this.v2, set: $val => _this.v2 = $val}, 0xff);
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, 3).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
_this._round( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return _this._extract( {})
}
/*Swift.(file).Hasher._State.init()*/
/*Swift.(file).Hasher._State.init()*/
init($info?) {
let _this = this;
_this.initRawSeedtuple_type(Hasher._executionSeed);
return
}
/*Swift.(file).Hasher._State.init(seed:Int)*/
/*Swift.(file).Hasher._State.init(seed:Int)*/
initSeedInt(seed, $info?) {
let _this = this;
const executionSeed = Hasher._executionSeed;
const seed = _create(UInt, 'initBitPatternInt', seed, {});
_this.initRawSeedtuple_type({0: UInt64.$bitwiseXOR(executionSeed["0"], _create(UInt64, 'initTruncatingIfNeeded', seed, {})), 1: executionSeed["1"]});
return
}
init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}




class _UnmanagedAnyObjectArray{
static readonly $struct = true

/*Swift.(file)._UnmanagedAnyObjectArray.value*/
value$get() {
throw 'unsupported variable Swift.(file)._UnmanagedAnyObjectArray.value in ' + this.constructor.name
}
get value() { return this.value$get() };





/*Swift.(file)._UnmanagedAnyObjectArray.init(_:UnsafeMutablePointer<AnyObject>)*/
/*Swift.(file)._UnmanagedAnyObjectArray.init(_:UnsafeMutablePointer<AnyObject>)*/
initUnsafeMutablePointer(up, $info?) {
throw 'unsupported method Swift.(file)._UnmanagedAnyObjectArray.init(_:UnsafeMutablePointer<AnyObject>) in ' + this.constructor.name
}
/*Swift.(file)._UnmanagedAnyObjectArray.init(_:UnsafeMutablePointer<AnyObject>?)*/
/*Swift.(file)._UnmanagedAnyObjectArray.init(_:UnsafeMutablePointer<AnyObject>?)*/
initOptional(up, $info?) {
throw 'unsupported method Swift.(file)._UnmanagedAnyObjectArray.init(_:UnsafeMutablePointer<AnyObject>?) in ' + this.constructor.name
}
static readonly initOptional$failable = true
/*Swift.(file)._UnmanagedAnyObjectArray.subscript(_:Int)*/
/*Swift.(file)._UnmanagedAnyObjectArray.subscript(_:Int)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._UnmanagedAnyObjectArray.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file)._UnmanagedAnyObjectArray.subscript(_:Int)*/
/*Swift.(file)._UnmanagedAnyObjectArray.subscript(_:Int)*/
subscript$set(newValue, i, $info?) {
throw 'unsupported method Swift.(file)._UnmanagedAnyObjectArray.subscript(_:Int) in ' + this.constructor.name
}



init$vars() {let _this = this;

}
}


interface _HashTableDelegate{
/*Swift.(file)._HashTableDelegate.hashValue(at:_HashTable.Bucket)*/
/*Swift.(file)._HashTableDelegate.hashValue(at:_HashTable.Bucket)*/
hashValueAt(bucket, $info?)
/*Swift.(file)._HashTableDelegate.moveEntry(from:_HashTable.Bucket,to:_HashTable.Bucket)*/
/*Swift.(file)._HashTableDelegate.moveEntry(from:_HashTable.Bucket,to:_HashTable.Bucket)*/
moveEntryFromTo(source, target, $info?)
}
class _HashTableDelegate$implementation{
}


interface AdditiveArithmetic extends Equatable{

/*Swift.(file).AdditiveArithmetic.zero*/
static zero;



static /*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?)
static /*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?)
static /*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?)
}
class AdditiveArithmetic$implementation{

/*Swift.(file).AdditiveArithmetic.zero*/
static zero$get() {
let _this = this;
return 0;
}
static get zero() { return this.zero$get()
}
static get zero() { return this.zero$get() };



static /*Swift.(file).AdditiveArithmetic.+prefix(_:Self)*/
/*Swift.(file).AdditiveArithmetic.+prefix(_:Self)*/
$positive(x, $info?) {
return +x
}
}
if(typeof Equatable$implementation != 'undefined') _mixin(AdditiveArithmetic$implementation, Equatable$implementation, false)






interface Numeric<Magnitude> extends AdditiveArithmetic, ExpressibleByIntegerLiteral{
/*Swift.(file).Numeric.init(exactly:T)*/
/*Swift.(file).Numeric.init(exactly:T)*/
initExactly<T>(source, $info?)


/*Swift.(file).Numeric.magnitude*/
magnitude;



static /*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?)
static /*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?)
}
class Numeric$implementation{
}
if(typeof AdditiveArithmetic$implementation != 'undefined') _mixin(Numeric$implementation, AdditiveArithmetic$implementation, false)
if(typeof ExpressibleByIntegerLiteral$implementation != 'undefined') _mixin(Numeric$implementation, ExpressibleByIntegerLiteral$implementation, false)


interface SignedNumeric extends Numeric{
static /*Swift.(file).SignedNumeric.-prefix(_:Self)*/
/*Swift.(file).SignedNumeric.-prefix(_:Self)*/
$negate(operand, $info?)
/*Swift.(file).SignedNumeric.negate()*/
/*Swift.(file).SignedNumeric.negate()*/
negate($info?)
}
class SignedNumeric$implementation{
static /*Swift.(file).SignedNumeric.-prefix(_:Self)*/
/*Swift.(file).SignedNumeric.-prefix(_:Self)*/
$negate(operand, $info?) {
return -operand
}
/*Swift.(file).SignedNumeric.negate()*/
/*Swift.(file).SignedNumeric.negate()*/
negate($info?) {
$info.$setThis(-this)
}
}
if(typeof Numeric$implementation != 'undefined') _mixin(SignedNumeric$implementation, Numeric$implementation, false)




class KeyPathKind{

static get readOnly() {return Object.assign(new KeyPathKind(), {rawValue: "readOnly", ...Array.from(arguments)})}

static get value() {return Object.assign(new KeyPathKind(), {rawValue: "value", ...Array.from(arguments)})}

static get reference() {return Object.assign(new KeyPathKind(), {rawValue: "reference", ...Array.from(arguments)})}
static /*Swift.(file).KeyPathKind.==(_:KeyPathKind,_:KeyPathKind)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).KeyPathKind.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).KeyPathKind.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).KeyPathKind.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).KeyPathKind.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(KeyPathKind, _DefaultEnumImplementation, false)


class KeyPathComponentKind{

static get external() {return Object.assign(new KeyPathComponentKind(), {rawValue: "external", ...Array.from(arguments)})}

static get struct() {return Object.assign(new KeyPathComponentKind(), {rawValue: "struct", ...Array.from(arguments)})}

static get _class() {return Object.assign(new KeyPathComponentKind(), {rawValue: "_class", ...Array.from(arguments)})}

static get computed() {return Object.assign(new KeyPathComponentKind(), {rawValue: "computed", ...Array.from(arguments)})}

static get optionalChain() {return Object.assign(new KeyPathComponentKind(), {rawValue: "optionalChain", ...Array.from(arguments)})}

static get optionalForce() {return Object.assign(new KeyPathComponentKind(), {rawValue: "optionalForce", ...Array.from(arguments)})}

static get optionalWrap() {return Object.assign(new KeyPathComponentKind(), {rawValue: "optionalWrap", ...Array.from(arguments)})}
static /*Swift.(file).KeyPathComponentKind.==(_:KeyPathComponentKind,_:KeyPathComponentKind)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).KeyPathComponentKind.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).KeyPathComponentKind.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).KeyPathComponentKind.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).KeyPathComponentKind.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(KeyPathComponentKind, _DefaultEnumImplementation, false)


class ComputedPropertyID implements Hashable{
static readonly $struct = true

/*Swift.(file).ComputedPropertyID.value*/
value$get() {
throw 'unsupported variable Swift.(file).ComputedPropertyID.value in ' + this.constructor.name
}
get value() { return this.value$get() };






/*Swift.(file).ComputedPropertyID.kind*/
kind$get() {
throw 'unsupported variable Swift.(file).ComputedPropertyID.kind in ' + this.constructor.name
}
get kind() { return this.kind$get() };





static /*Swift.(file).ComputedPropertyID.==infix(_:ComputedPropertyID,_:ComputedPropertyID)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(x, y, $info?) {
return x == y
}
/*Swift.(file).ComputedPropertyID.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).ComputedPropertyID.hash(into:Hasher) in ' + this.constructor.name
}
/*Swift.(file).ComputedPropertyID.init(value:Int,kind:KeyPathComputedIDKind)*/
/*Swift.(file).ComputedPropertyID.init(value:Int,kind:KeyPathComputedIDKind)*/
initValueIntKindKeyPathComputedIDKind(value, kind, $info?) {
throw 'unsupported method Swift.(file).ComputedPropertyID.init(value:Int,kind:KeyPathComputedIDKind) in ' + this.constructor.name
}



/*Swift.(file).ComputedPropertyID.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).ComputedPropertyID.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}
if(typeof Hashable$implementation != 'undefined') _mixin(ComputedPropertyID, Hashable$implementation, false)


class ComputedArgumentWitnesses{
static readonly $struct = true





/*Swift.(file).ComputedArgumentWitnesses.destroy*/
readonly destroy$get() {
throw 'unsupported variable Swift.(file).ComputedArgumentWitnesses.destroy in ' + this.constructor.name
}
readonly get destroy() { return this.destroy$get() };




/*Swift.(file).ComputedArgumentWitnesses.copy*/
readonly copy$get() {
throw 'unsupported variable Swift.(file).ComputedArgumentWitnesses.copy in ' + this.constructor.name
}
readonly get copy() { return this.copy$get() };




/*Swift.(file).ComputedArgumentWitnesses.equals*/
readonly equals$get() {
throw 'unsupported variable Swift.(file).ComputedArgumentWitnesses.equals in ' + this.constructor.name
}
readonly get equals() { return this.equals$get() };




/*Swift.(file).ComputedArgumentWitnesses.hash*/
readonly hash$get() {
throw 'unsupported variable Swift.(file).ComputedArgumentWitnesses.hash in ' + this.constructor.name
}
readonly get hash() { return this.hash$get() };



/*Swift.(file).ComputedArgumentWitnesses.init(destroy:ComputedArgumentWitnesses.Destroy?,copy:ComputedArgumentWitnesses.Copy,equals:ComputedArgumentWitnesses.Equals,hash:ComputedArgumentWitnesses.Hash)*/
/*Swift.(file).ComputedArgumentWitnesses.init(destroy:ComputedArgumentWitnesses.Destroy?,copy:ComputedArgumentWitnesses.Copy,equals:ComputedArgumentWitnesses.Equals,hash:ComputedArgumentWitnesses.Hash)*/
initDestroyOptionalCopyComputedArgumentWitnessesCopyEqualsComputedArgumentWitnessesEqualsHashComputedArgumentWitnessesHash(destroy, copy, equals, hash, $info?) {
throw 'unsupported method Swift.(file).ComputedArgumentWitnesses.init(destroy:ComputedArgumentWitnesses.Destroy?,copy:ComputedArgumentWitnesses.Copy,equals:ComputedArgumentWitnesses.Equals,hash:ComputedArgumentWitnesses.Hash) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class KeyPathComponent implements Hashable{
static ArgumentRef = class{
static readonly $struct = true
/*Swift.(file).KeyPathComponent.ArgumentRef.init(data:UnsafeRawBufferPointer,witnesses:UnsafePointer<ComputedArgumentWitnesses>,witnessSizeAdjustment:Int)*/
/*Swift.(file).KeyPathComponent.ArgumentRef.init(data:UnsafeRawBufferPointer,witnesses:UnsafePointer<ComputedArgumentWitnesses>,witnessSizeAdjustment:Int)*/
initDataUnsafeRawBufferPointerWitnessesUnsafePointerWitnessSizeAdjustmentInt(data, witnesses, witnessSizeAdjustment, $info?) {
throw 'unsupported method Swift.(file).KeyPathComponent.ArgumentRef.init(data:UnsafeRawBufferPointer,witnesses:UnsafePointer<ComputedArgumentWitnesses>,witnessSizeAdjustment:Int) in ' + this.constructor.name
}

/*Swift.(file).KeyPathComponent.ArgumentRef.data*/
data$get() {
throw 'unsupported variable Swift.(file).KeyPathComponent.ArgumentRef.data in ' + this.constructor.name
}
get data() { return this.data$get() };






/*Swift.(file).KeyPathComponent.ArgumentRef.witnesses*/
witnesses$get() {
throw 'unsupported variable Swift.(file).KeyPathComponent.ArgumentRef.witnesses in ' + this.constructor.name
}
get witnesses() { return this.witnesses$get() };






/*Swift.(file).KeyPathComponent.ArgumentRef.witnessSizeAdjustment*/
witnessSizeAdjustment$get() {
throw 'unsupported variable Swift.(file).KeyPathComponent.ArgumentRef.witnessSizeAdjustment in ' + this.constructor.name
}
get witnessSizeAdjustment() { return this.witnessSizeAdjustment$get() };





init$vars() {let _this = this;

}
}

static struct() {return Object.assign(new KeyPathComponent(), {rawValue: "struct", ...Array.from(arguments)})}

static _class() {return Object.assign(new KeyPathComponent(), {rawValue: "_class", ...Array.from(arguments)})}

static get() {return Object.assign(new KeyPathComponent(), {rawValue: "get", ...Array.from(arguments)})}

static mutatingGetSet() {return Object.assign(new KeyPathComponent(), {rawValue: "mutatingGetSet", ...Array.from(arguments)})}

static nonmutatingGetSet() {return Object.assign(new KeyPathComponent(), {rawValue: "nonmutatingGetSet", ...Array.from(arguments)})}

static get optionalChain() {return Object.assign(new KeyPathComponent(), {rawValue: "optionalChain", ...Array.from(arguments)})}

static get optionalForce() {return Object.assign(new KeyPathComponent(), {rawValue: "optionalForce", ...Array.from(arguments)})}

static get optionalWrap() {return Object.assign(new KeyPathComponent(), {rawValue: "optionalWrap", ...Array.from(arguments)})}
static /*Swift.(file).KeyPathComponent.==infix(_:KeyPathComponent,_:KeyPathComponent)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}
/*Swift.(file).KeyPathComponent.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).KeyPathComponent.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).KeyPathComponent.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).KeyPathComponent.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}
if(typeof Hashable$implementation != 'undefined') _mixin(KeyPathComponent, Hashable$implementation, false)
_mixin(KeyPathComponent, _DefaultEnumImplementation, false)


class ClassHolder<ProjectionType>{


/*Swift.(file).ClassHolder.previous*/
previous$get() {
throw 'unsupported variable Swift.(file).ClassHolder.previous in ' + this.constructor.name
}
get previous() { return this.previous$get() };






/*Swift.(file).ClassHolder.instance*/
instance$get() {
throw 'unsupported variable Swift.(file).ClassHolder.instance in ' + this.constructor.name
}
get instance() { return this.instance$get() };





/*Swift.(file).ClassHolder.init(previous:AnyObject?,instance:AnyObject)*/
/*Swift.(file).ClassHolder.init(previous:AnyObject?,instance:AnyObject)*/
initPreviousOptionalInstanceAnyObject(previous, instance, $info?) {
throw 'unsupported method Swift.(file).ClassHolder.init(previous:AnyObject?,instance:AnyObject) in ' + this.constructor.name
}


init$vars() {let _this = this;

}
}


class MutatingWritebackBuffer<CurValue, NewValue>{

/*Swift.(file).MutatingWritebackBuffer.previous*/
readonly previous$get() {
throw 'unsupported variable Swift.(file).MutatingWritebackBuffer.previous in ' + this.constructor.name
}
readonly get previous() { return this.previous$get() };




/*Swift.(file).MutatingWritebackBuffer.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file).MutatingWritebackBuffer.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };




/*Swift.(file).MutatingWritebackBuffer.set*/
readonly set$get() {
throw 'unsupported variable Swift.(file).MutatingWritebackBuffer.set in ' + this.constructor.name
}
readonly get set() { return this.set$get() };




/*Swift.(file).MutatingWritebackBuffer.argument*/
readonly argument$get() {
throw 'unsupported variable Swift.(file).MutatingWritebackBuffer.argument in ' + this.constructor.name
}
readonly get argument() { return this.argument$get() };




/*Swift.(file).MutatingWritebackBuffer.argumentSize*/
readonly argumentSize$get() {
throw 'unsupported variable Swift.(file).MutatingWritebackBuffer.argumentSize in ' + this.constructor.name
}
readonly get argumentSize() { return this.argumentSize$get() };




/*Swift.(file).MutatingWritebackBuffer.value*/
value$get() {
throw 'unsupported variable Swift.(file).MutatingWritebackBuffer.value in ' + this.constructor.name
}
get value() { return this.value$get() };






/*Swift.(file).MutatingWritebackBuffer.init(previous:AnyObject?,base:UnsafeMutablePointer<CurValue>,set:@convention(thin) (NewValue, inout CurValue, UnsafeRawPointer, Int) -> (),argument:UnsafeRawPointer,argumentSize:Int,value:NewValue)*/
/*Swift.(file).MutatingWritebackBuffer.init(previous:AnyObject?,base:UnsafeMutablePointer<CurValue>,set:@convention(thin) (NewValue, inout CurValue, UnsafeRawPointer, Int) -> (),argument:UnsafeRawPointer,argumentSize:Int,value:NewValue)*/
initPreviousOptionalBaseUnsafeMutablePointerSetfunction_typeArgumentUnsafeRawPointerArgumentSizeIntValue(previous, base, set, argument, argumentSize, value, $info?) {
throw 'unsupported method Swift.(file).MutatingWritebackBuffer.init(previous:AnyObject?,base:UnsafeMutablePointer<CurValue>,set:@convention(thin) (NewValue, inout CurValue, UnsafeRawPointer, Int) -> (),argument:UnsafeRawPointer,argumentSize:Int,value:NewValue) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class NonmutatingWritebackBuffer<CurValue, NewValue>{

/*Swift.(file).NonmutatingWritebackBuffer.previous*/
readonly previous$get() {
throw 'unsupported variable Swift.(file).NonmutatingWritebackBuffer.previous in ' + this.constructor.name
}
readonly get previous() { return this.previous$get() };




/*Swift.(file).NonmutatingWritebackBuffer.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file).NonmutatingWritebackBuffer.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };




/*Swift.(file).NonmutatingWritebackBuffer.set*/
readonly set$get() {
throw 'unsupported variable Swift.(file).NonmutatingWritebackBuffer.set in ' + this.constructor.name
}
readonly get set() { return this.set$get() };




/*Swift.(file).NonmutatingWritebackBuffer.argument*/
readonly argument$get() {
throw 'unsupported variable Swift.(file).NonmutatingWritebackBuffer.argument in ' + this.constructor.name
}
readonly get argument() { return this.argument$get() };




/*Swift.(file).NonmutatingWritebackBuffer.argumentSize*/
readonly argumentSize$get() {
throw 'unsupported variable Swift.(file).NonmutatingWritebackBuffer.argumentSize in ' + this.constructor.name
}
readonly get argumentSize() { return this.argumentSize$get() };




/*Swift.(file).NonmutatingWritebackBuffer.value*/
value$get() {
throw 'unsupported variable Swift.(file).NonmutatingWritebackBuffer.value in ' + this.constructor.name
}
get value() { return this.value$get() };






/*Swift.(file).NonmutatingWritebackBuffer.init(previous:AnyObject?,base:CurValue,set:@convention(thin) (NewValue, CurValue, UnsafeRawPointer, Int) -> (),argument:UnsafeRawPointer,argumentSize:Int,value:NewValue)*/
/*Swift.(file).NonmutatingWritebackBuffer.init(previous:AnyObject?,base:CurValue,set:@convention(thin) (NewValue, CurValue, UnsafeRawPointer, Int) -> (),argument:UnsafeRawPointer,argumentSize:Int,value:NewValue)*/
initPreviousOptionalBaseSetfunction_typeArgumentUnsafeRawPointerArgumentSizeIntValue(previous, base, set, argument, argumentSize, value, $info?) {
throw 'unsupported method Swift.(file).NonmutatingWritebackBuffer.init(previous:AnyObject?,base:CurValue,set:@convention(thin) (NewValue, CurValue, UnsafeRawPointer, Int) -> (),argument:UnsafeRawPointer,argumentSize:Int,value:NewValue) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class KeyPathComputedIDKind{

static get pointer() {return Object.assign(new KeyPathComputedIDKind(), {rawValue: "pointer", ...Array.from(arguments)})}

static get storedPropertyIndex() {return Object.assign(new KeyPathComputedIDKind(), {rawValue: "storedPropertyIndex", ...Array.from(arguments)})}

static get vtableOffset() {return Object.assign(new KeyPathComputedIDKind(), {rawValue: "vtableOffset", ...Array.from(arguments)})}
static /*Swift.(file).KeyPathComputedIDKind.==(_:KeyPathComputedIDKind,_:KeyPathComputedIDKind)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).KeyPathComputedIDKind.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).KeyPathComputedIDKind.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).KeyPathComputedIDKind.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).KeyPathComputedIDKind.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(KeyPathComputedIDKind, _DefaultEnumImplementation, false)


class KeyPathComputedIDResolution{

static get resolved() {return Object.assign(new KeyPathComputedIDResolution(), {rawValue: "resolved", ...Array.from(arguments)})}

static get indirectPointer() {return Object.assign(new KeyPathComputedIDResolution(), {rawValue: "indirectPointer", ...Array.from(arguments)})}

static get functionCall() {return Object.assign(new KeyPathComputedIDResolution(), {rawValue: "functionCall", ...Array.from(arguments)})}
static /*Swift.(file).KeyPathComputedIDResolution.==(_:KeyPathComputedIDResolution,_:KeyPathComputedIDResolution)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).KeyPathComputedIDResolution.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).KeyPathComputedIDResolution.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).KeyPathComputedIDResolution.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).KeyPathComputedIDResolution.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(KeyPathComputedIDResolution, _DefaultEnumImplementation, false)


class RawKeyPathComponent{
static readonly $struct = true
/*Swift.(file).RawKeyPathComponent.init(header:RawKeyPathComponent.Header,body:UnsafeRawBufferPointer)*/
/*Swift.(file).RawKeyPathComponent.init(header:RawKeyPathComponent.Header,body:UnsafeRawBufferPointer)*/
initHeaderRawKeyPathComponentHeaderBodyUnsafeRawBufferPointer(header, body, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.init(header:RawKeyPathComponent.Header,body:UnsafeRawBufferPointer) in ' + this.constructor.name
}

/*Swift.(file).RawKeyPathComponent.header*/
header$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.header in ' + this.constructor.name
}
get header() { return this.header$get() };






/*Swift.(file).RawKeyPathComponent.body*/
body$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.body in ' + this.constructor.name
}
get body() { return this.body$get() };





static Header = class{
static readonly $struct = true

/*Swift.(file).RawKeyPathComponent.Header.payloadMask*/
static payloadMask$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.payloadMask in ' + this.constructor.name
}
static get payloadMask() { return this.payloadMask$get() };




/*Swift.(file).RawKeyPathComponent.Header.discriminatorMask*/
static discriminatorMask$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.discriminatorMask in ' + this.constructor.name
}
static get discriminatorMask() { return this.discriminatorMask$get() };




/*Swift.(file).RawKeyPathComponent.Header.discriminatorShift*/
static discriminatorShift$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.discriminatorShift in ' + this.constructor.name
}
static get discriminatorShift() { return this.discriminatorShift$get() };




/*Swift.(file).RawKeyPathComponent.Header.externalTag*/
static externalTag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.externalTag in ' + this.constructor.name
}
static get externalTag() { return this.externalTag$get() };




/*Swift.(file).RawKeyPathComponent.Header.structTag*/
static structTag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.structTag in ' + this.constructor.name
}
static get structTag() { return this.structTag$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedTag*/
static computedTag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedTag in ' + this.constructor.name
}
static get computedTag() { return this.computedTag$get() };




/*Swift.(file).RawKeyPathComponent.Header.classTag*/
static classTag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.classTag in ' + this.constructor.name
}
static get classTag() { return this.classTag$get() };




/*Swift.(file).RawKeyPathComponent.Header.optionalTag*/
static optionalTag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.optionalTag in ' + this.constructor.name
}
static get optionalTag() { return this.optionalTag$get() };




/*Swift.(file).RawKeyPathComponent.Header.optionalChainPayload*/
static optionalChainPayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.optionalChainPayload in ' + this.constructor.name
}
static get optionalChainPayload() { return this.optionalChainPayload$get() };




/*Swift.(file).RawKeyPathComponent.Header.optionalWrapPayload*/
static optionalWrapPayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.optionalWrapPayload in ' + this.constructor.name
}
static get optionalWrapPayload() { return this.optionalWrapPayload$get() };




/*Swift.(file).RawKeyPathComponent.Header.optionalForcePayload*/
static optionalForcePayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.optionalForcePayload in ' + this.constructor.name
}
static get optionalForcePayload() { return this.optionalForcePayload$get() };




/*Swift.(file).RawKeyPathComponent.Header.endOfReferencePrefixFlag*/
static endOfReferencePrefixFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.endOfReferencePrefixFlag in ' + this.constructor.name
}
static get endOfReferencePrefixFlag() { return this.endOfReferencePrefixFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.storedMutableFlag*/
static storedMutableFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.storedMutableFlag in ' + this.constructor.name
}
static get storedMutableFlag() { return this.storedMutableFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.storedOffsetPayloadMask*/
static storedOffsetPayloadMask$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.storedOffsetPayloadMask in ' + this.constructor.name
}
static get storedOffsetPayloadMask() { return this.storedOffsetPayloadMask$get() };




/*Swift.(file).RawKeyPathComponent.Header.outOfLineOffsetPayload*/
static outOfLineOffsetPayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.outOfLineOffsetPayload in ' + this.constructor.name
}
static get outOfLineOffsetPayload() { return this.outOfLineOffsetPayload$get() };




/*Swift.(file).RawKeyPathComponent.Header.unresolvedFieldOffsetPayload*/
static unresolvedFieldOffsetPayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.unresolvedFieldOffsetPayload in ' + this.constructor.name
}
static get unresolvedFieldOffsetPayload() { return this.unresolvedFieldOffsetPayload$get() };




/*Swift.(file).RawKeyPathComponent.Header.unresolvedIndirectOffsetPayload*/
static unresolvedIndirectOffsetPayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.unresolvedIndirectOffsetPayload in ' + this.constructor.name
}
static get unresolvedIndirectOffsetPayload() { return this.unresolvedIndirectOffsetPayload$get() };




/*Swift.(file).RawKeyPathComponent.Header.maximumOffsetPayload*/
static maximumOffsetPayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.maximumOffsetPayload in ' + this.constructor.name
}
static get maximumOffsetPayload() { return this.maximumOffsetPayload$get() };




/*Swift.(file).RawKeyPathComponent.Header.isStoredMutable*/
isStoredMutable$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.isStoredMutable in ' + this.constructor.name
}
get isStoredMutable() { return this.isStoredMutable$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedMutatingFlag*/
static computedMutatingFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedMutatingFlag in ' + this.constructor.name
}
static get computedMutatingFlag() { return this.computedMutatingFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.isComputedMutating*/
isComputedMutating$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.isComputedMutating in ' + this.constructor.name
}
get isComputedMutating() { return this.isComputedMutating$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedSettableFlag*/
static computedSettableFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedSettableFlag in ' + this.constructor.name
}
static get computedSettableFlag() { return this.computedSettableFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.isComputedSettable*/
isComputedSettable$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.isComputedSettable in ' + this.constructor.name
}
get isComputedSettable() { return this.isComputedSettable$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDByStoredPropertyFlag*/
static computedIDByStoredPropertyFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDByStoredPropertyFlag in ' + this.constructor.name
}
static get computedIDByStoredPropertyFlag() { return this.computedIDByStoredPropertyFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDByVTableOffsetFlag*/
static computedIDByVTableOffsetFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDByVTableOffsetFlag in ' + this.constructor.name
}
static get computedIDByVTableOffsetFlag() { return this.computedIDByVTableOffsetFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDKind*/
computedIDKind$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDKind in ' + this.constructor.name
}
get computedIDKind() { return this.computedIDKind$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedHasArgumentsFlag*/
static computedHasArgumentsFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedHasArgumentsFlag in ' + this.constructor.name
}
static get computedHasArgumentsFlag() { return this.computedHasArgumentsFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.hasComputedArguments*/
hasComputedArguments$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.hasComputedArguments in ' + this.constructor.name
}
get hasComputedArguments() { return this.hasComputedArguments$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedInstantiatedFromExternalWithArgumentsFlag*/
static computedInstantiatedFromExternalWithArgumentsFlag$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedInstantiatedFromExternalWithArgumentsFlag in ' + this.constructor.name
}
static get computedInstantiatedFromExternalWithArgumentsFlag() { return this.computedInstantiatedFromExternalWithArgumentsFlag$get() };




/*Swift.(file).RawKeyPathComponent.Header.isComputedInstantiatedFromExternalWithArguments*/
isComputedInstantiatedFromExternalWithArguments$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.isComputedInstantiatedFromExternalWithArguments in ' + this.constructor.name
}
get isComputedInstantiatedFromExternalWithArguments() { return this.isComputedInstantiatedFromExternalWithArguments$get() };






/*Swift.(file).RawKeyPathComponent.Header.externalWithArgumentsExtraSize*/
static externalWithArgumentsExtraSize$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.externalWithArgumentsExtraSize in ' + this.constructor.name
}
static get externalWithArgumentsExtraSize() { return this.externalWithArgumentsExtraSize$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDResolutionMask*/
static computedIDResolutionMask$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDResolutionMask in ' + this.constructor.name
}
static get computedIDResolutionMask() { return this.computedIDResolutionMask$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDResolved*/
static computedIDResolved$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDResolved in ' + this.constructor.name
}
static get computedIDResolved() { return this.computedIDResolved$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDUnresolvedIndirectPointer*/
static computedIDUnresolvedIndirectPointer$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDUnresolvedIndirectPointer in ' + this.constructor.name
}
static get computedIDUnresolvedIndirectPointer() { return this.computedIDUnresolvedIndirectPointer$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDUnresolvedFunctionCall*/
static computedIDUnresolvedFunctionCall$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDUnresolvedFunctionCall in ' + this.constructor.name
}
static get computedIDUnresolvedFunctionCall() { return this.computedIDUnresolvedFunctionCall$get() };




/*Swift.(file).RawKeyPathComponent.Header.computedIDResolution*/
computedIDResolution$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.computedIDResolution in ' + this.constructor.name
}
get computedIDResolution() { return this.computedIDResolution$get() };









/*Swift.(file).RawKeyPathComponent.Header.discriminator*/
discriminator$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.discriminator in ' + this.constructor.name
}
get discriminator() { return this.discriminator$get() };






/*Swift.(file).RawKeyPathComponent.Header.payload*/
payload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.payload in ' + this.constructor.name
}
get payload() { return this.payload$get() };






/*Swift.(file).RawKeyPathComponent.Header.storedOffsetPayload*/
storedOffsetPayload$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.storedOffsetPayload in ' + this.constructor.name
}
get storedOffsetPayload() { return this.storedOffsetPayload$get() };






/*Swift.(file).RawKeyPathComponent.Header.endOfReferencePrefix*/
endOfReferencePrefix$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.endOfReferencePrefix in ' + this.constructor.name
}
get endOfReferencePrefix() { return this.endOfReferencePrefix$get() };






/*Swift.(file).RawKeyPathComponent.Header.kind*/
kind$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.kind in ' + this.constructor.name
}
get kind() { return this.kind$get() };




/*Swift.(file).RawKeyPathComponent.Header.pointerAlignmentSkew*/
static pointerAlignmentSkew$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.pointerAlignmentSkew in ' + this.constructor.name
}
static get pointerAlignmentSkew() { return this.pointerAlignmentSkew$get() };




/*Swift.(file).RawKeyPathComponent.Header.isTrivialPropertyDescriptor*/
isTrivialPropertyDescriptor$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.isTrivialPropertyDescriptor in ' + this.constructor.name
}
get isTrivialPropertyDescriptor() { return this.isTrivialPropertyDescriptor$get() };




/*Swift.(file).RawKeyPathComponent.Header.patternComponentBodySize*/
patternComponentBodySize$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.patternComponentBodySize in ' + this.constructor.name
}
get patternComponentBodySize() { return this.patternComponentBodySize$get() };




/*Swift.(file).RawKeyPathComponent.Header.propertyDescriptorBodySize*/
propertyDescriptorBodySize$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.Header.propertyDescriptorBodySize in ' + this.constructor.name
}
get propertyDescriptorBodySize() { return this.propertyDescriptorBodySize$get() };




/*Swift.(file).RawKeyPathComponent.Header.init(discriminator:UInt32,payload:UInt32)*/
/*Swift.(file).RawKeyPathComponent.Header.init(discriminator:UInt32,payload:UInt32)*/
initDiscriminatorUInt32PayloadUInt32(discriminator, payload, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.Header.init(discriminator:UInt32,payload:UInt32) in ' + this.constructor.name
}
/*Swift.(file).RawKeyPathComponent.Header.init(optionalForce:())*/
/*Swift.(file).RawKeyPathComponent.Header.init(optionalForce:())*/
initOptionalForcetuple_type(optionalForce, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.Header.init(optionalForce:()) in ' + this.constructor.name
}
/*Swift.(file).RawKeyPathComponent.Header.init(optionalWrap:())*/
/*Swift.(file).RawKeyPathComponent.Header.init(optionalWrap:())*/
initOptionalWraptuple_type(optionalWrap, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.Header.init(optionalWrap:()) in ' + this.constructor.name
}
/*Swift.(file).RawKeyPathComponent.Header.init(optionalChain:())*/
/*Swift.(file).RawKeyPathComponent.Header.init(optionalChain:())*/
initOptionalChaintuple_type(optionalChain, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.Header.init(optionalChain:()) in ' + this.constructor.name
}
/*Swift.(file).RawKeyPathComponent.Header.init(stored:KeyPathStructOrClass,mutable:Bool,inlineOffset:UInt32)*/
/*Swift.(file).RawKeyPathComponent.Header.init(stored:KeyPathStructOrClass,mutable:Bool,inlineOffset:UInt32)*/
initStoredKeyPathStructOrClassMutableBoolInlineOffsetUInt32(kind, mutable, inlineOffset, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.Header.init(stored:KeyPathStructOrClass,mutable:Bool,inlineOffset:UInt32) in ' + this.constructor.name
}
/*Swift.(file).RawKeyPathComponent.Header.init(storedWithOutOfLineOffset:KeyPathStructOrClass,mutable:Bool)*/
/*Swift.(file).RawKeyPathComponent.Header.init(storedWithOutOfLineOffset:KeyPathStructOrClass,mutable:Bool)*/
initStoredWithOutOfLineOffsetKeyPathStructOrClassMutableBool(kind, mutable, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.Header.init(storedWithOutOfLineOffset:KeyPathStructOrClass,mutable:Bool) in ' + this.constructor.name
}
/*Swift.(file).RawKeyPathComponent.Header.init(computedWithIDKind:KeyPathComputedIDKind,mutating:Bool,settable:Bool,hasArguments:Bool,instantiatedFromExternalWithArguments:Bool)*/
/*Swift.(file).RawKeyPathComponent.Header.init(computedWithIDKind:KeyPathComputedIDKind,mutating:Bool,settable:Bool,hasArguments:Bool,instantiatedFromExternalWithArguments:Bool)*/
initComputedWithIDKindKeyPathComputedIDKindMutatingBoolSettableBoolHasArgumentsBoolInstantiatedFromExternalWithArgumentsBool(kind, mutating, settable, hasArguments, instantiatedFromExternalWithArguments, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.Header.init(computedWithIDKind:KeyPathComputedIDKind,mutating:Bool,settable:Bool,hasArguments:Bool,instantiatedFromExternalWithArguments:Bool) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}

/*Swift.(file).RawKeyPathComponent.bodySize*/
bodySize$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.bodySize in ' + this.constructor.name
}
get bodySize() { return this.bodySize$get() };





































/*Swift.(file).RawKeyPathComponent.value*/
value$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.value in ' + this.constructor.name
}
get value() { return this.value$get() };



/*Swift.(file).RawKeyPathComponent.destroy()*/
/*Swift.(file).RawKeyPathComponent.destroy()*/
destroy($info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.destroy() in ' + this.constructor.name
}
/*Swift.(file).RawKeyPathComponent.clone(into:UnsafeMutableRawBufferPointer,endOfReferencePrefix:Bool)*/
/*Swift.(file).RawKeyPathComponent.clone(into:UnsafeMutableRawBufferPointer,endOfReferencePrefix:Bool)*/
cloneIntoEndOfReferencePrefix(buffer$inout, endOfReferencePrefix, $info?) {
throw 'unsupported method Swift.(file).RawKeyPathComponent.clone(into:UnsafeMutableRawBufferPointer,endOfReferencePrefix:Bool) in ' + this.constructor.name
}
static ProjectionResult = class<NewValue, LeafValue>{

static _continue() {return Object.assign(new RawKeyPathComponent.ProjectionResult(), {rawValue: "_continue", ...Array.from(arguments)})}

static _break() {return Object.assign(new RawKeyPathComponent.ProjectionResult(), {rawValue: "_break", ...Array.from(arguments)})}

/*Swift.(file).RawKeyPathComponent.ProjectionResult.assumingContinue*/
assumingContinue$get() {
throw 'unsupported variable Swift.(file).RawKeyPathComponent.ProjectionResult.assumingContinue in ' + this.constructor.name
}
get assumingContinue() { return this.assumingContinue$get() };



init$vars() {let _this = this;

}
}


init$vars() {let _this = this;

}
}
_mixin(RawKeyPathComponent.ProjectionResult, _DefaultEnumImplementation, false)


class KeyPathBuffer{
static readonly $struct = true

/*Swift.(file).KeyPathBuffer.data*/
data$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.data in ' + this.constructor.name
}
get data() { return this.data$get() };






/*Swift.(file).KeyPathBuffer.trivial*/
trivial$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.trivial in ' + this.constructor.name
}
get trivial() { return this.trivial$get() };






/*Swift.(file).KeyPathBuffer.hasReferencePrefix*/
hasReferencePrefix$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.hasReferencePrefix in ' + this.constructor.name
}
get hasReferencePrefix() { return this.hasReferencePrefix$get() };






/*Swift.(file).KeyPathBuffer.mutableData*/
mutableData$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.mutableData in ' + this.constructor.name
}
get mutableData() { return this.mutableData$get() };



static Header = class{
static readonly $struct = true






/*Swift.(file).KeyPathBuffer.Header.sizeMask*/
static sizeMask$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.sizeMask in ' + this.constructor.name
}
static get sizeMask() { return this.sizeMask$get() };




/*Swift.(file).KeyPathBuffer.Header.reservedMask*/
static reservedMask$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.reservedMask in ' + this.constructor.name
}
static get reservedMask() { return this.reservedMask$get() };




/*Swift.(file).KeyPathBuffer.Header.trivialFlag*/
static trivialFlag$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.trivialFlag in ' + this.constructor.name
}
static get trivialFlag() { return this.trivialFlag$get() };




/*Swift.(file).KeyPathBuffer.Header.hasReferencePrefixFlag*/
static hasReferencePrefixFlag$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.hasReferencePrefixFlag in ' + this.constructor.name
}
static get hasReferencePrefixFlag() { return this.hasReferencePrefixFlag$get() };



/*Swift.(file).KeyPathBuffer.Header.init(size:Int,trivial:Bool,hasReferencePrefix:Bool)*/
/*Swift.(file).KeyPathBuffer.Header.init(size:Int,trivial:Bool,hasReferencePrefix:Bool)*/
initSizeIntTrivialBoolHasReferencePrefixBool(size, trivial, hasReferencePrefix, $info?) {
throw 'unsupported method Swift.(file).KeyPathBuffer.Header.init(size:Int,trivial:Bool,hasReferencePrefix:Bool) in ' + this.constructor.name
}

/*Swift.(file).KeyPathBuffer.Header.size*/
size$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.size in ' + this.constructor.name
}
get size() { return this.size$get() };




/*Swift.(file).KeyPathBuffer.Header.trivial*/
trivial$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.trivial in ' + this.constructor.name
}
get trivial() { return this.trivial$get() };




/*Swift.(file).KeyPathBuffer.Header.hasReferencePrefix*/
hasReferencePrefix$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.hasReferencePrefix in ' + this.constructor.name
}
get hasReferencePrefix() { return this.hasReferencePrefix$get() };






/*Swift.(file).KeyPathBuffer.Header.instantiableInLine*/
instantiableInLine$get() {
throw 'unsupported variable Swift.(file).KeyPathBuffer.Header.instantiableInLine in ' + this.constructor.name
}
get instantiableInLine() { return this.instantiableInLine$get() };



/*Swift.(file).KeyPathBuffer.Header.validateReservedBits()*/
/*Swift.(file).KeyPathBuffer.Header.validateReservedBits()*/
validateReservedBits($info?) {
throw 'unsupported method Swift.(file).KeyPathBuffer.Header.validateReservedBits() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
/*Swift.(file).KeyPathBuffer.init(base:UnsafeRawPointer)*/
/*Swift.(file).KeyPathBuffer.init(base:UnsafeRawPointer)*/
initBaseUnsafeRawPointer(base, $info?) {
throw 'unsupported method Swift.(file).KeyPathBuffer.init(base:UnsafeRawPointer) in ' + this.constructor.name
}
/*Swift.(file).KeyPathBuffer.init(partialData:UnsafeRawBufferPointer,trivial:Bool,hasReferencePrefix:Bool)*/
/*Swift.(file).KeyPathBuffer.init(partialData:UnsafeRawBufferPointer,trivial:Bool,hasReferencePrefix:Bool)*/
initPartialDataUnsafeRawBufferPointerTrivialBoolHasReferencePrefixBool(partialData, trivial, hasReferencePrefix, $info?) {
throw 'unsupported method Swift.(file).KeyPathBuffer.init(partialData:UnsafeRawBufferPointer,trivial:Bool,hasReferencePrefix:Bool) in ' + this.constructor.name
}
/*Swift.(file).KeyPathBuffer.destroy()*/
/*Swift.(file).KeyPathBuffer.destroy()*/
destroy($info?) {
throw 'unsupported method Swift.(file).KeyPathBuffer.destroy() in ' + this.constructor.name
}
/*Swift.(file).KeyPathBuffer.next()*/
/*Swift.(file).KeyPathBuffer.next()*/
next($info?) {
throw 'unsupported method Swift.(file).KeyPathBuffer.next() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


interface _AppendKeyPath{

}
class _AppendKeyPath$implementation{/*Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)*/
/*Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)*/
appendingPath(path, $info?) {
let _this = this;
return _tryToAppendKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)*/
/*Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)*/
appendingPath<Root>(path, $info?) {
let _this = this;
return _tryToAppendKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:KeyPath<AppendedRoot, AppendedValue>)*/
/*Swift.(file)._AppendKeyPath.appending(path:KeyPath<AppendedRoot, AppendedValue>)*/
/*!!!DUPLICATE NAME*/
appendingPath<Root, AppendedRoot, AppendedValue>(path, $info?) {
let _this = this;
return _tryToAppendKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<AppendedRoot, AppendedValue>)*/
/*Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<AppendedRoot, AppendedValue>)*/
/*!!!DUPLICATE NAME*/
appendingPath<Root, AppendedRoot, AppendedValue>(path, $info?) {
let _this = this;
return _tryToAppendKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:KeyPath<Value, AppendedValue>)*/
/*Swift.(file)._AppendKeyPath.appending(path:KeyPath<Value, AppendedValue>)*/
/*!!!DUPLICATE NAME*/
appendingPath<Root, Value, AppendedValue>(path, $info?) {
let _this = this;
return _appendingKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)*/
/*Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)*/
/*!!!DUPLICATE NAME*/
appendingPath<Root, Value, AppendedValue>(path, $info?) {
let _this = this;
return _appendingKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)*/
/*Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)*/
/*!!!DUPLICATE NAME*/
appendingPath<Root, Value, AppendedValue>(path, $info?) {
let _this = this;
return _appendingKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)*/
/*Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)*/
/*!!!DUPLICATE NAME*/
appendingPath<Root, Value, AppendedValue>(path, $info?) {
let _this = this;
return _appendingKeyPathsRootLeaf(_this, path)
}
/*Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)*/
/*Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)*/
/*!!!DUPLICATE NAME*/
appendingPath<Root, Value, AppendedValue>(path, $info?) {
let _this = this;
return _appendingKeyPathsRootLeaf(_this, path)
}
}












class KeyPathStructOrClass{

static get struct() {return Object.assign(new KeyPathStructOrClass(), {rawValue: "struct", ...Array.from(arguments)})}

static get _class() {return Object.assign(new KeyPathStructOrClass(), {rawValue: "_class", ...Array.from(arguments)})}
static /*Swift.(file).KeyPathStructOrClass.==(_:KeyPathStructOrClass,_:KeyPathStructOrClass)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).KeyPathStructOrClass.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).KeyPathStructOrClass.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).KeyPathStructOrClass.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).KeyPathStructOrClass.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(KeyPathStructOrClass, _DefaultEnumImplementation, false)


class KeyPathPatternStoredOffset{

static inline() {return Object.assign(new KeyPathPatternStoredOffset(), {rawValue: "inline", ...Array.from(arguments)})}

static outOfLine() {return Object.assign(new KeyPathPatternStoredOffset(), {rawValue: "outOfLine", ...Array.from(arguments)})}

static unresolvedFieldOffset() {return Object.assign(new KeyPathPatternStoredOffset(), {rawValue: "unresolvedFieldOffset", ...Array.from(arguments)})}

static unresolvedIndirectOffset() {return Object.assign(new KeyPathPatternStoredOffset(), {rawValue: "unresolvedIndirectOffset", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}
_mixin(KeyPathPatternStoredOffset, _DefaultEnumImplementation, false)


class KeyPathPatternComputedArguments{
static readonly $struct = true

/*Swift.(file).KeyPathPatternComputedArguments.getLayout*/
getLayout$get() {
throw 'unsupported variable Swift.(file).KeyPathPatternComputedArguments.getLayout in ' + this.constructor.name
}
get getLayout() { return this.getLayout$get() };






/*Swift.(file).KeyPathPatternComputedArguments.witnesses*/
witnesses$get() {
throw 'unsupported variable Swift.(file).KeyPathPatternComputedArguments.witnesses in ' + this.constructor.name
}
get witnesses() { return this.witnesses$get() };






/*Swift.(file).KeyPathPatternComputedArguments.initializer*/
initializer$get() {
throw 'unsupported variable Swift.(file).KeyPathPatternComputedArguments.initializer in ' + this.constructor.name
}
get initializer() { return this.initializer$get() };





/*Swift.(file).KeyPathPatternComputedArguments.init(getLayout:KeyPathComputedArgumentLayoutFn,witnesses:UnsafePointer<ComputedArgumentWitnesses>,initializer:KeyPathComputedArgumentInitializerFn)*/
/*Swift.(file).KeyPathPatternComputedArguments.init(getLayout:KeyPathComputedArgumentLayoutFn,witnesses:UnsafePointer<ComputedArgumentWitnesses>,initializer:KeyPathComputedArgumentInitializerFn)*/
initGetLayoutKeyPathComputedArgumentLayoutFnWitnessesUnsafePointerInitializerKeyPathComputedArgumentInitializerFn(getLayout, witnesses, initializer, $info?) {
throw 'unsupported method Swift.(file).KeyPathPatternComputedArguments.init(getLayout:KeyPathComputedArgumentLayoutFn,witnesses:UnsafePointer<ComputedArgumentWitnesses>,initializer:KeyPathComputedArgumentInitializerFn) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


interface KeyPathPatternVisitor{
/*Swift.(file).KeyPathPatternVisitor.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
/*Swift.(file).KeyPathPatternVisitor.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
visitHeaderGenericEnvironmentRootMetadataRefLeafMetadataRefKvcCompatibilityString(genericEnvironment, rootMetadataRef, leafMetadataRef, kvcCompatibilityString, $info?)
/*Swift.(file).KeyPathPatternVisitor.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
/*Swift.(file).KeyPathPatternVisitor.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
visitStoredComponentKindMutableOffset(kind, mutable, offset, $info?)
/*Swift.(file).KeyPathPatternVisitor.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
/*Swift.(file).KeyPathPatternVisitor.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
visitComputedComponentMutatingIdKindIdResolutionIdValueBaseIdValueGetterSetterArgumentsExternalArgs(mutating, idKind, idResolution, idValueBase, idValue, getter, setter, _arguments, externalArgs, $info?)
/*Swift.(file).KeyPathPatternVisitor.visitOptionalChainComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalChainComponent()*/
visitOptionalChainComponent($info?)
/*Swift.(file).KeyPathPatternVisitor.visitOptionalForceComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalForceComponent()*/
visitOptionalForceComponent($info?)
/*Swift.(file).KeyPathPatternVisitor.visitOptionalWrapComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalWrapComponent()*/
visitOptionalWrapComponent($info?)
/*Swift.(file).KeyPathPatternVisitor.visitIntermediateComponentType(metadataRef:MetadataReference)*/
/*Swift.(file).KeyPathPatternVisitor.visitIntermediateComponentType(metadataRef:MetadataReference)*/
visitIntermediateComponentTypeMetadataRef(metadataRef, $info?)
/*Swift.(file).KeyPathPatternVisitor.finish()*/
/*Swift.(file).KeyPathPatternVisitor.finish()*/
finish($info?)
}
class KeyPathPatternVisitor$implementation{
}


class GetKeyPathClassAndInstanceSizeFromPattern implements KeyPathPatternVisitor{
static readonly $struct = true

/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.size*/
size$get() {
throw 'unsupported variable Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.size in ' + this.constructor.name
}
get size() { return this.size$get() };






/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.capability*/
capability$get() {
throw 'unsupported variable Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.capability in ' + this.constructor.name
}
get capability() { return this.capability$get() };






/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.didChain*/
didChain$get() {
throw 'unsupported variable Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.didChain in ' + this.constructor.name
}
get didChain() { return this.didChain$get() };






/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.root*/
root$get() {
throw 'unsupported variable Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.root in ' + this.constructor.name
}
get root() { return this.root$get() };






/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.leaf*/
leaf$get() {
throw 'unsupported variable Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.leaf in ' + this.constructor.name
}
get leaf() { return this.leaf$get() };






/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.genericEnvironment*/
genericEnvironment$get() {
throw 'unsupported variable Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.genericEnvironment in ' + this.constructor.name
}
get genericEnvironment() { return this.genericEnvironment$get() };






/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.patternArgs*/
readonly patternArgs$get() {
throw 'unsupported variable Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.patternArgs in ' + this.constructor.name
}
readonly get patternArgs() { return this.patternArgs$get() };



/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.init(patternArgs:UnsafeRawPointer?)*/
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.init(patternArgs:UnsafeRawPointer?)*/
initPatternArgsOptional(patternArgs, $info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.init(patternArgs:UnsafeRawPointer?) in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.roundUpToPointerAlignment()*/
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.roundUpToPointerAlignment()*/
roundUpToPointerAlignment($info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.roundUpToPointerAlignment() in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
/*Swift.(file).KeyPathPatternVisitor.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
visitHeaderGenericEnvironmentRootMetadataRefLeafMetadataRefKvcCompatibilityString(genericEnvironment, rootMetadataRef, leafMetadataRef, kvcCompatibilityString, $info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?) in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
/*Swift.(file).KeyPathPatternVisitor.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
visitStoredComponentKindMutableOffset(kind, mutable, offset, $info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset) in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
/*Swift.(file).KeyPathPatternVisitor.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
visitComputedComponentMutatingIdKindIdResolutionIdValueBaseIdValueGetterSetterArgumentsExternalArgs(mutating, idKind, idResolution, idValueBase, idValue, getter, setter, _arguments, externalArgs, $info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?) in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitOptionalChainComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalChainComponent()*/
visitOptionalChainComponent($info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitOptionalChainComponent() in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitOptionalWrapComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalWrapComponent()*/
visitOptionalWrapComponent($info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitOptionalWrapComponent() in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitOptionalForceComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalForceComponent()*/
visitOptionalForceComponent($info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitOptionalForceComponent() in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitIntermediateComponentType(metadataRef:MetadataReference)*/
/*Swift.(file).KeyPathPatternVisitor.visitIntermediateComponentType(metadataRef:MetadataReference)*/
visitIntermediateComponentTypeMetadataRef(_, $info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.visitIntermediateComponentType(metadataRef:MetadataReference) in ' + this.constructor.name
}
/*Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.finish()*/
/*Swift.(file).KeyPathPatternVisitor.finish()*/
finish($info?) {
throw 'unsupported method Swift.(file).GetKeyPathClassAndInstanceSizeFromPattern.finish() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof KeyPathPatternVisitor$implementation != 'undefined') _mixin(GetKeyPathClassAndInstanceSizeFromPattern, KeyPathPatternVisitor$implementation, false)


class InstantiateKeyPathBuffer implements KeyPathPatternVisitor{
static readonly $struct = true

/*Swift.(file).InstantiateKeyPathBuffer.destData*/
destData$get() {
throw 'unsupported variable Swift.(file).InstantiateKeyPathBuffer.destData in ' + this.constructor.name
}
get destData() { return this.destData$get() };






/*Swift.(file).InstantiateKeyPathBuffer.genericEnvironment*/
genericEnvironment$get() {
throw 'unsupported variable Swift.(file).InstantiateKeyPathBuffer.genericEnvironment in ' + this.constructor.name
}
get genericEnvironment() { return this.genericEnvironment$get() };






/*Swift.(file).InstantiateKeyPathBuffer.patternArgs*/
readonly patternArgs$get() {
throw 'unsupported variable Swift.(file).InstantiateKeyPathBuffer.patternArgs in ' + this.constructor.name
}
readonly get patternArgs() { return this.patternArgs$get() };




/*Swift.(file).InstantiateKeyPathBuffer.base*/
base$get() {
throw 'unsupported variable Swift.(file).InstantiateKeyPathBuffer.base in ' + this.constructor.name
}
get base() { return this.base$get() };





/*Swift.(file).InstantiateKeyPathBuffer.init(destData:UnsafeMutableRawBufferPointer,patternArgs:UnsafeRawPointer?,root:Any.Type)*/
/*Swift.(file).InstantiateKeyPathBuffer.init(destData:UnsafeMutableRawBufferPointer,patternArgs:UnsafeRawPointer?,root:Any.Type)*/
initDestDataUnsafeMutableRawBufferPointerPatternArgsOptionalRootprotocol_composition_type(destData, patternArgs, root, $info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.init(destData:UnsafeMutableRawBufferPointer,patternArgs:UnsafeRawPointer?,root:Any.Type) in ' + this.constructor.name
}

/*Swift.(file).InstantiateKeyPathBuffer.isTrivial*/
isTrivial$get() {
throw 'unsupported variable Swift.(file).InstantiateKeyPathBuffer.isTrivial in ' + this.constructor.name
}
get isTrivial() { return this.isTrivial$get() };






/*Swift.(file).InstantiateKeyPathBuffer.endOfReferencePrefixComponent*/
endOfReferencePrefixComponent$get() {
throw 'unsupported variable Swift.(file).InstantiateKeyPathBuffer.endOfReferencePrefixComponent in ' + this.constructor.name
}
get endOfReferencePrefixComponent() { return this.endOfReferencePrefixComponent$get() };






/*Swift.(file).InstantiateKeyPathBuffer.previousComponentAddr*/
previousComponentAddr$get() {
throw 'unsupported variable Swift.(file).InstantiateKeyPathBuffer.previousComponentAddr in ' + this.constructor.name
}
get previousComponentAddr() { return this.previousComponentAddr$get() };





/*Swift.(file).InstantiateKeyPathBuffer.pushDest(_:T)*/
/*Swift.(file).InstantiateKeyPathBuffer.pushDest(_:T)*/
pushDest<T>(value, $info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.pushDest(_:T) in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.updatePreviousComponentAddr()*/
/*Swift.(file).InstantiateKeyPathBuffer.updatePreviousComponentAddr()*/
updatePreviousComponentAddr($info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.updatePreviousComponentAddr() in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
/*Swift.(file).KeyPathPatternVisitor.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
visitHeaderGenericEnvironmentRootMetadataRefLeafMetadataRefKvcCompatibilityString(genericEnvironment, rootMetadataRef, leafMetadataRef, kvcCompatibilityString, $info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?) in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
/*Swift.(file).KeyPathPatternVisitor.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
visitStoredComponentKindMutableOffset(kind, mutable, offset, $info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset) in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
/*Swift.(file).KeyPathPatternVisitor.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
visitComputedComponentMutatingIdKindIdResolutionIdValueBaseIdValueGetterSetterArgumentsExternalArgs(mutating, idKind, idResolution, idValueBase, idValue, getter, setter, _arguments, externalArgs, $info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?) in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.visitOptionalChainComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalChainComponent()*/
visitOptionalChainComponent($info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.visitOptionalChainComponent() in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.visitOptionalWrapComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalWrapComponent()*/
visitOptionalWrapComponent($info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.visitOptionalWrapComponent() in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.visitOptionalForceComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalForceComponent()*/
visitOptionalForceComponent($info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.visitOptionalForceComponent() in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.visitIntermediateComponentType(metadataRef:MetadataReference)*/
/*Swift.(file).KeyPathPatternVisitor.visitIntermediateComponentType(metadataRef:MetadataReference)*/
visitIntermediateComponentTypeMetadataRef(metadataRef, $info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.visitIntermediateComponentType(metadataRef:MetadataReference) in ' + this.constructor.name
}
/*Swift.(file).InstantiateKeyPathBuffer.finish()*/
/*Swift.(file).KeyPathPatternVisitor.finish()*/
finish($info?) {
throw 'unsupported method Swift.(file).InstantiateKeyPathBuffer.finish() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof KeyPathPatternVisitor$implementation != 'undefined') _mixin(InstantiateKeyPathBuffer, KeyPathPatternVisitor$implementation, false)


class ValidatingInstantiateKeyPathBuffer implements KeyPathPatternVisitor{
static readonly $struct = true

/*Swift.(file).ValidatingInstantiateKeyPathBuffer.sizeVisitor*/
sizeVisitor$get() {
throw 'unsupported variable Swift.(file).ValidatingInstantiateKeyPathBuffer.sizeVisitor in ' + this.constructor.name
}
get sizeVisitor() { return this.sizeVisitor$get() };






/*Swift.(file).ValidatingInstantiateKeyPathBuffer.instantiateVisitor*/
instantiateVisitor$get() {
throw 'unsupported variable Swift.(file).ValidatingInstantiateKeyPathBuffer.instantiateVisitor in ' + this.constructor.name
}
get instantiateVisitor() { return this.instantiateVisitor$get() };






/*Swift.(file).ValidatingInstantiateKeyPathBuffer.origDest*/
readonly origDest$get() {
throw 'unsupported variable Swift.(file).ValidatingInstantiateKeyPathBuffer.origDest in ' + this.constructor.name
}
readonly get origDest() { return this.origDest$get() };



/*Swift.(file).ValidatingInstantiateKeyPathBuffer.init(sizeVisitor:GetKeyPathClassAndInstanceSizeFromPattern,instantiateVisitor:InstantiateKeyPathBuffer)*/
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.init(sizeVisitor:GetKeyPathClassAndInstanceSizeFromPattern,instantiateVisitor:InstantiateKeyPathBuffer)*/
initSizeVisitorGetKeyPathClassAndInstanceSizeFromPatternInstantiateVisitorInstantiateKeyPathBuffer(sizeVisitor, instantiateVisitor, $info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.init(sizeVisitor:GetKeyPathClassAndInstanceSizeFromPattern,instantiateVisitor:InstantiateKeyPathBuffer) in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
/*Swift.(file).KeyPathPatternVisitor.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?)*/
visitHeaderGenericEnvironmentRootMetadataRefLeafMetadataRefKvcCompatibilityString(genericEnvironment, rootMetadataRef, leafMetadataRef, kvcCompatibilityString, $info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.visitHeader(genericEnvironment:UnsafeRawPointer?,rootMetadataRef:MetadataReference,leafMetadataRef:MetadataReference,kvcCompatibilityString:UnsafeRawPointer?) in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
/*Swift.(file).KeyPathPatternVisitor.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset)*/
visitStoredComponentKindMutableOffset(kind, mutable, offset, $info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.visitStoredComponent(kind:KeyPathStructOrClass,mutable:Bool,offset:KeyPathPatternStoredOffset) in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
/*Swift.(file).KeyPathPatternVisitor.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?)*/
visitComputedComponentMutatingIdKindIdResolutionIdValueBaseIdValueGetterSetterArgumentsExternalArgs(mutating, idKind, idResolution, idValueBase, idValue, getter, setter, _arguments, externalArgs, $info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.visitComputedComponent(mutating:Bool,idKind:KeyPathComputedIDKind,idResolution:KeyPathComputedIDResolution,idValueBase:UnsafeRawPointer,idValue:Int32,getter:UnsafeRawPointer,setter:UnsafeRawPointer?,arguments:KeyPathPatternComputedArguments?,externalArgs:UnsafeBufferPointer<Int32>?) in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.visitOptionalChainComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalChainComponent()*/
visitOptionalChainComponent($info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.visitOptionalChainComponent() in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.visitOptionalWrapComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalWrapComponent()*/
visitOptionalWrapComponent($info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.visitOptionalWrapComponent() in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.visitOptionalForceComponent()*/
/*Swift.(file).KeyPathPatternVisitor.visitOptionalForceComponent()*/
visitOptionalForceComponent($info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.visitOptionalForceComponent() in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.visitIntermediateComponentType(metadataRef:MetadataReference)*/
/*Swift.(file).KeyPathPatternVisitor.visitIntermediateComponentType(metadataRef:MetadataReference)*/
visitIntermediateComponentTypeMetadataRef(metadataRef, $info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.visitIntermediateComponentType(metadataRef:MetadataReference) in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.finish()*/
/*Swift.(file).KeyPathPatternVisitor.finish()*/
finish($info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.finish() in ' + this.constructor.name
}
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.checkSizeConsistency()*/
/*Swift.(file).ValidatingInstantiateKeyPathBuffer.checkSizeConsistency()*/
checkSizeConsistency($info?) {
throw 'unsupported method Swift.(file).ValidatingInstantiateKeyPathBuffer.checkSizeConsistency() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof KeyPathPatternVisitor$implementation != 'undefined') _mixin(ValidatingInstantiateKeyPathBuffer, KeyPathPatternVisitor$implementation, false)


class ManagedBuffer<Header, Element>{

/*Swift.(file).ManagedBuffer.header*/
header$get() {
throw 'unsupported variable Swift.(file).ManagedBuffer.header in ' + this.constructor.name
}
get header() { return this.header$get() };





/*Swift.(file).ManagedBuffer.init(_doNotCallMe:())*/
/*Swift.(file).ManagedBuffer.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).ManagedBuffer.init(_doNotCallMe:()) in ' + this.constructor.name
}

static /*Swift.(file).ManagedBuffer.create(minimumCapacity:Int,makingHeaderWith:(ManagedBuffer<Header, Element>) throws -> Header)*/
/*Swift.(file).ManagedBuffer.create(minimumCapacity:Int,makingHeaderWith:(ManagedBuffer<Header, Element>) throws -> Header)*/
createMinimumCapacityMakingHeaderWith(minimumCapacity, factory, $info?) {
throw 'unsupported method Swift.(file).ManagedBuffer.create(minimumCapacity:Int,makingHeaderWith:(ManagedBuffer<Header, Element>) throws -> Header) in ' + this.constructor.name
}

/*Swift.(file).ManagedBuffer.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file).ManagedBuffer.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };




/*Swift.(file).ManagedBuffer.firstElementAddress*/
firstElementAddress$get() {
throw 'unsupported variable Swift.(file).ManagedBuffer.firstElementAddress in ' + this.constructor.name
}
get firstElementAddress() { return this.firstElementAddress$get() };




/*Swift.(file).ManagedBuffer.headerAddress*/
headerAddress$get() {
throw 'unsupported variable Swift.(file).ManagedBuffer.headerAddress in ' + this.constructor.name
}
get headerAddress() { return this.headerAddress$get() };



/*Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)*/
/*Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)*/
withUnsafeMutablePointerToHeader<R>(body, $info?) {
let _this = this;
return _this.withUnsafeMutablePointers(((v, _, $info?) => body(v)))
}
/*Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)*/
/*Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)*/
withUnsafeMutablePointerToElements<R>(body, $info?) {
let _this = this;
return _this.withUnsafeMutablePointers((($0, $1, $info?) => body($1)))
}
/*Swift.(file).ManagedBuffer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)*/
/*Swift.(file).ManagedBuffer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)*/
withUnsafeMutablePointers<R>(body, $info?) {
let _this = this;
let $defer = () => {
_fixLifetime(_this);
}
const $result = (() => {
try {;
return body(_this.headerAddress, _this.firstElementAddress);}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}
init$vars() {let _this = this;

}
}




class ManagedBufferPointer<Header, Element> implements Equatable{
static readonly $struct = true





/*Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int,makingHeaderWith:(AnyObject, (AnyObject) -> Int) throws -> Header)*/
/*Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int,makingHeaderWith:(AnyObject, (AnyObject) -> Int) throws -> Header)*/
initBufferClassAnyClassMinimumCapacityIntMakingHeaderWithfunction_type(bufferClass, minimumCapacity, factory, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(ManagedBufferPointer, 'initBufferClassAnyClassMinimumCapacityInt', bufferClass, minimumCapacity, {})));
_this.withUnsafeMutablePointerToHeader((($0, $info?) => $0.initializeTo(factory(_this.buffer, (($0, $info?) => _create(ManagedBufferPointer, 'initUnsafeBufferObjectAnyObject', $0, {}).capacity)))));
_.discardAssignment = _this.header;
return
}
/*Swift.(file).ManagedBufferPointer.init(unsafeBufferObject:AnyObject)*/
/*Swift.(file).ManagedBufferPointer.init(unsafeBufferObject:AnyObject)*/
initUnsafeBufferObjectAnyObject(buffer, $info?) {
throw 'unsupported method Swift.(file).ManagedBufferPointer.init(unsafeBufferObject:AnyObject) in ' + this.constructor.name
}
/*Swift.(file).ManagedBufferPointer.init(_uncheckedUnsafeBufferObject:AnyObject)*/
/*Swift.(file).ManagedBufferPointer.init(_uncheckedUnsafeBufferObject:AnyObject)*/
init_uncheckedUnsafeBufferObjectAnyObject(buffer, $info?) {
throw 'unsupported method Swift.(file).ManagedBufferPointer.init(_uncheckedUnsafeBufferObject:AnyObject) in ' + this.constructor.name
}
/*Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int)*/
/*Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int)*/
initBufferClassAnyClassMinimumCapacityInt(bufferClass, minimumCapacity, $info?) {
let _this = this;
ManagedBufferPointer._checkValidBufferClassCreating(bufferClass, true);
preconditionFileLine(() => Int.$greaterThanOrEqual(minimumCapacity, 0), () => "ManagedBufferPointer must have non-negative capacity", null, null);
_this.init_uncheckedBufferClassAnyClassMinimumCapacityInt(bufferClass, minimumCapacity);
return
}
/*Swift.(file).ManagedBufferPointer.init(_uncheckedBufferClass:AnyClass,minimumCapacity:Int)*/
/*Swift.(file).ManagedBufferPointer.init(_uncheckedBufferClass:AnyClass,minimumCapacity:Int)*/
init_uncheckedBufferClassAnyClassMinimumCapacityInt(_uncheckedBufferClass, minimumCapacity, $info?) {
throw 'unsupported method Swift.(file).ManagedBufferPointer.init(_uncheckedBufferClass:AnyClass,minimumCapacity:Int) in ' + this.constructor.name
}
/*Swift.(file).ManagedBufferPointer.init(_:ManagedBuffer<Header, Element>)*/
/*Swift.(file).ManagedBufferPointer.init(_:ManagedBuffer<Header, Element>)*/
initManagedBuffer(buffer, $info?) {
throw 'unsupported method Swift.(file).ManagedBufferPointer.init(_:ManagedBuffer<Header, Element>) in ' + this.constructor.name
}
/*Swift.(file).ManagedBufferPointer.init(_:Int)*/
/*Swift.(file).ManagedBufferPointer.init(_:Int)*/
initInt(count, $info?) {
let _this = this;
_this.init_uncheckedBufferClassAnyClassMinimumCapacityInt(__BridgingBufferStorage, count);
_this.withUnsafeMutablePointerToHeader((($0, $info?) => $0.initializeTo(_create(_BridgingBufferHeader, 'initInt', count, {}))));
return
}

/*Swift.(file).ManagedBufferPointer.count*/
count$get() {
let _this = this;
return _this.header.count
}
get count() { return this.count$get() };





/*Swift.(file).ManagedBufferPointer.subscript(_:Int)*/
/*Swift.(file).ManagedBufferPointer.subscript(_:Int)*/
subscript$get(i, $info?) {
let _this = this;
return _this.withUnsafeMutablePointerToElements((($0, $info?) => $0.subscript$get(i)))
}


/*Swift.(file).ManagedBufferPointer.baseAddress*/
baseAddress$get() {
let _this = this;
return _this.withUnsafeMutablePointerToElements((($0, $info?) => $0))
}
get baseAddress() { return this.baseAddress$get() };




/*Swift.(file).ManagedBufferPointer.storage*/
storage$get() {
let _this = this;
return _injectIntoOptional(_this.buffer)
}
get storage() { return this.storage$get() };



/*Swift.(file).ManagedBufferPointer.init(_nativeObject:NativeObject)*/
/*Swift.(file).ManagedBufferPointer.init(_nativeObject:NativeObject)*/
init_nativeObjectNativeObject(buffer, $info?) {
throw 'unsupported method Swift.(file).ManagedBufferPointer.init(_nativeObject:NativeObject) in ' + this.constructor.name
}

/*Swift.(file).ManagedBufferPointer.header*/
header$get() {
 return this.header$internal
}
get header() { return this.header$get() };







/*Swift.(file).ManagedBufferPointer.buffer*/
buffer$get() {
throw 'unsupported variable Swift.(file).ManagedBufferPointer.buffer in ' + this.constructor.name
}
get buffer() { return this.buffer$get() };




/*Swift.(file).ManagedBufferPointer.capacity*/
capacity$get() {
let _this = this;
return Int.$divide(Int.$subtractWithOverflow(_this._capacityInBytes, ManagedBufferPointer._elementOffset), MemoryLayout.stride)
}
get capacity() { return this.capacity$get() };



/*Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)*/
/*Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)*/
withUnsafeMutablePointerToHeader<R>(body, $info?) {
let _this = this;
return _this.withUnsafeMutablePointers(((v, _, $info?) => body(v)))
}
/*Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)*/
/*Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)*/
withUnsafeMutablePointerToElements<R>(body, $info?) {
let _this = this;
return _this.withUnsafeMutablePointers((($0, $1, $info?) => body($1)))
}
/*Swift.(file).ManagedBufferPointer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)*/
/*Swift.(file).ManagedBufferPointer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)*/
withUnsafeMutablePointers<R>(body, $info?) {
let _this = this;
let $defer = () => {
_fixLifetime(_this._nativeBuffer);
}
const $result = (() => {
try {;
return body(_this._headerPointer, _this._elementPointer);}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}
/*Swift.(file).ManagedBufferPointer.isUniqueReference()*/
/*Swift.(file).ManagedBufferPointer.isUniqueReference()*/
isUniqueReference($info?) {
let _this = this;
return _isUnique({get: () => _this._nativeBuffer, set: $val => _this._nativeBuffer = $val})
}























static /*Swift.(file).ManagedBufferPointer.==infix(_:ManagedBufferPointer<Header, Element>,_:ManagedBufferPointer<Header, Element>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return UnsafeMutableRawPointer.$equal(lhs._address, rhs._address)
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(ManagedBufferPointer, Equatable$implementation, false)










class MemoryLayout<T>{

/*Swift.(file).MemoryLayout.size*/
static size$get() {
throw 'unsupported variable Swift.(file).MemoryLayout.size in ' + this.constructor.name
}
static get size() { return this.size$get() };




/*Swift.(file).MemoryLayout.stride*/
static stride$get() {
throw 'unsupported variable Swift.(file).MemoryLayout.stride in ' + this.constructor.name
}
static get stride() { return this.stride$get() };




/*Swift.(file).MemoryLayout.alignment*/
static alignment$get() {
throw 'unsupported variable Swift.(file).MemoryLayout.alignment in ' + this.constructor.name
}
static get alignment() { return this.alignment$get() };



static /*Swift.(file).MemoryLayout.size(ofValue:T)*/
/*Swift.(file).MemoryLayout.size(ofValue:T)*/
sizeOfValue(value, $info?) {
let _this = this;
return MemoryLayout.size
}
static /*Swift.(file).MemoryLayout.stride(ofValue:T)*/
/*Swift.(file).MemoryLayout.stride(ofValue:T)*/
strideOfValue(value, $info?) {
let _this = this;
return MemoryLayout.stride
}
static /*Swift.(file).MemoryLayout.alignment(ofValue:T)*/
/*Swift.(file).MemoryLayout.alignment(ofValue:T)*/
alignmentOfValue(value, $info?) {
let _this = this;
return MemoryLayout.alignment
}
static /*Swift.(file).MemoryLayout.offset(of:PartialKeyPath<T>)*/
/*Swift.(file).MemoryLayout.offset(of:PartialKeyPath<T>)*/
offsetOf(key, $info?) {
let _this = this;
return key._storedInlineOffset
}













init$vars() {let _this = this;

}
}
_mixin(MemoryLayout, _DefaultEnumImplementation, false)






interface _SwiftNewtypeWrapper extends RawRepresentable, _HasCustomAnyHashableRepresentation{

}
class _SwiftNewtypeWrapper$implementation{
/*Swift.(file)._SwiftNewtypeWrapper.hashValue*/
hashValue$get() {
let _this = this;
return _this.rawValue.hashValue
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)*/
/*Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}












}
if(typeof RawRepresentable$implementation != 'undefined') _mixin(_SwiftNewtypeWrapper$implementation, RawRepresentable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(_SwiftNewtypeWrapper$implementation, _HasCustomAnyHashableRepresentation$implementation, false)












class _NewtypeWrapperAnyHashableBox<Base> implements _AnyHashableBox{
static readonly $struct = true





/*Swift.(file)._NewtypeWrapperAnyHashableBox.init(_:Base)*/
/*Swift.(file)._NewtypeWrapperAnyHashableBox.init(_:Base)*/
init(value, $info?) {
throw 'unsupported method Swift.(file)._NewtypeWrapperAnyHashableBox.init(_:Base) in ' + this.constructor.name
}














init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_NewtypeWrapperAnyHashableBox, _AnyHashableBox$implementation, false)


class _OptionalNilComparisonType implements ExpressibleByNilLiteral{
static readonly $struct = true
/*Swift.(file)._OptionalNilComparisonType.init(nilLiteral:())*/
/*Swift.(file).ExpressibleByNilLiteral.init(nilLiteral:())*/
initNilLiteraltuple_type(nilLiteral, $info?) {

}
init$vars() {let _this = this;

}
}
if(typeof ExpressibleByNilLiteral$implementation != 'undefined') _mixin(_OptionalNilComparisonType, ExpressibleByNilLiteral$implementation, false)


interface TextOutputStream{


/*Swift.(file).TextOutputStream.write(_:String)*/
/*Swift.(file).TextOutputStream.write(_:String)*/
write(string, $info?)

}
class TextOutputStream$implementation{



}




interface TextOutputStreamable{
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?)
}
class TextOutputStreamable$implementation{
}


interface CustomStringConvertible{

/*Swift.(file).CustomStringConvertible.description*/
description;



}
class CustomStringConvertible$implementation{
}


interface LosslessStringConvertible extends CustomStringConvertible{
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString(description, $info?)
}
class LosslessStringConvertible$implementation{
}
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(LosslessStringConvertible$implementation, CustomStringConvertible$implementation, false)


interface CustomDebugStringConvertible{

/*Swift.(file).CustomDebugStringConvertible.debugDescription*/
debugDescription;



}
class CustomDebugStringConvertible$implementation{
}


class _Stdout implements TextOutputStream{
static readonly $struct = true
/*Swift.(file)._Stdout.init()*/
/*Swift.(file)._Stdout.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._Stdout.init() in ' + this.constructor.name
}


/*Swift.(file)._Stdout.write(_:String)*/
/*Swift.(file).TextOutputStream.write(_:String)*/
write(string, $info?) {
throw 'unsupported method Swift.(file)._Stdout.write(_:String) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof TextOutputStream$implementation != 'undefined') _mixin(_Stdout, TextOutputStream$implementation, false)


class _TeeStream<L, R> implements TextOutputStream{
static readonly $struct = true
/*Swift.(file)._TeeStream.init(left:L,right:R)*/
/*Swift.(file)._TeeStream.init(left:L,right:R)*/
initLeftRight(left, right, $info?) {
throw 'unsupported method Swift.(file)._TeeStream.init(left:L,right:R) in ' + this.constructor.name
}

/*Swift.(file)._TeeStream.left*/
left$get() {
throw 'unsupported variable Swift.(file)._TeeStream.left in ' + this.constructor.name
}
get left() { return this.left$get() };






/*Swift.(file)._TeeStream.right*/
right$get() {
throw 'unsupported variable Swift.(file)._TeeStream.right in ' + this.constructor.name
}
get right() { return this.right$get() };





/*Swift.(file)._TeeStream.write(_:String)*/
/*Swift.(file).TextOutputStream.write(_:String)*/
write(string, $info?) {
throw 'unsupported method Swift.(file)._TeeStream.write(_:String) in ' + this.constructor.name
}


init$vars() {let _this = this;

}
}
if(typeof TextOutputStream$implementation != 'undefined') _mixin(_TeeStream, TextOutputStream$implementation, false)


interface RandomNumberGenerator{
/*Swift.(file).RandomNumberGenerator.next()*/
/*Swift.(file).RandomNumberGenerator.next()*/
next($info?)
}
class RandomNumberGenerator$implementation{
/*Swift.(file).RandomNumberGenerator.next()*/
/*Swift.(file).RandomNumberGenerator.next()*/
next<T>($info?) {
let _this = this;
return ((function(){throw '!unclarifiedGeneric:T'})())._randomUsing({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RandomNumberGenerator.next(upperBound:T)*/
/*Swift.(file).RandomNumberGenerator.next(upperBound:T)*/
nextUpperBound<T>(upperBound, $info?) {
let _this = this;
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).$notEqual(upperBound, 0), () => "upperBound cannot be zero.", null, null);
const tmp = ((function(){throw '!unclarifiedGeneric:T'})()).$add(((function(){throw '!unclarifiedGeneric:T'})()).$remainder(((function(){throw '!unclarifiedGeneric:T'})()).max, upperBound), 1);
const range = (((function(){throw '!unclarifiedGeneric:T'})()).$equal(tmp, upperBound) ? 0 : tmp);
let random = 0;
do {
random = _this.next( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
} while(((function(){throw '!unclarifiedGeneric:T'})()).$lessThan(random, range));
return ((function(){throw '!unclarifiedGeneric:T'})()).$remainder(random, upperBound)
}
}




class SystemRandomNumberGenerator implements RandomNumberGenerator{
static readonly $struct = true
/*Swift.(file).SystemRandomNumberGenerator.init()*/
/*Swift.(file).SystemRandomNumberGenerator.init()*/
init($info?) {
let _this = this;
return
}
/*Swift.(file).SystemRandomNumberGenerator.next()*/
/*Swift.(file).RandomNumberGenerator.next()*/
next($info?) {
let _this = this;
return ((function(){throw '!unclarifiedGeneric:T'})())._randomUsing({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
init$vars() {let _this = this;

}
}
if(typeof RandomNumberGenerator$implementation != 'undefined') _mixin(SystemRandomNumberGenerator, RandomNumberGenerator$implementation, false)


interface RangeExpression<Bound>{

/*Swift.(file).RangeExpression.relative(to:C)*/
/*Swift.(file).RangeExpression.relative(to:C)*/
relativeTo<C>(collection, $info?)
/*Swift.(file).RangeExpression.contains(_:Self.Bound)*/
/*Swift.(file).RangeExpression.contains(_:Self.Bound)*/
contains(_element, $info?)
}
class RangeExpression$implementation{
static /*Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)*/
/*Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)*/
$patternMatch(pattern, value, $info?) {
let _this = this;
return pattern.contains(value)
}
}




class UnboundedRange_{
static /*Swift.(file).UnboundedRange_....postfix(_:UnboundedRange_)*/
/*Swift.(file).UnboundedRange_....postfix(_:UnboundedRange_)*/
$openEndedRange(_, $info?) {
/*return _...*/
}
init$vars() {let _this = this;

}
}
_mixin(UnboundedRange_, _DefaultEnumImplementation, false)


class Result<Success, Failure> implements Equatable, Hashable{

static success() {return Object.assign(new Result(), {rawValue: "success", ...Array.from(arguments)})}

static failure() {return Object.assign(new Result(), {rawValue: "failure", ...Array.from(arguments)})}
/*Swift.(file).Result.map(_:(Success) -> NewSuccess)*/
/*Swift.(file).Result.map(_:(Success) -> NewSuccess)*/
mapSwift<NewSuccess>(transform, $info?) {
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success(transform(success));
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure(failure);
}
}
/*Swift.(file).Result.mapError(_:(Failure) -> NewFailure)*/
/*Swift.(file).Result.mapError(_:(Failure) -> NewFailure)*/
mapError<NewFailure>(transform, $info?) {
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success(success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure(transform(failure));
}
}
/*Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)*/
/*Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)*/
flatMap<NewSuccess>(transform, $info?) {
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return transform(success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure(failure);
}
}
/*Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)*/
/*Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)*/
flatMapError<NewFailure>(transform, $info?) {
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success(success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return transform(failure);
}
}
/*Swift.(file).Result.get()*/
/*Swift.(file).Result.get()*/
get($info?) {
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return success;
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
throw failure;
}
}
/*Swift.(file).Result.init(catching:() throws -> Success)*/
/*Swift.(file).Result.init(catching:() throws -> Success)*/
initCatchingfunction_type(body, $info?) {
let _this = this;
try {
$info.$setThis(_this = _cloneStruct(Result.success(body( {}))));
} catch(error) {
if((true)) {
$info.$setThis(_this = _cloneStruct(Result.failure(error)));
}
else throw error
};
return
}
static /*Swift.(file).Result.==(_:Result<Success, Failure>,_:Result<Success, Failure>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).Result.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Result.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Result.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Result.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(Result, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(Result, Hashable$implementation, false)
_mixin(Result, _DefaultEnumImplementation, false)








class _RuntimeFunctionCounters{
static readonly $struct = true


/*Swift.(file)._RuntimeFunctionCounters.runtimeFunctionNames*/
static readonly runtimeFunctionNames$get() {
throw 'unsupported variable Swift.(file)._RuntimeFunctionCounters.runtimeFunctionNames in ' + this.constructor.name
}
static readonly get runtimeFunctionNames() { return this.runtimeFunctionNames$get() };




/*Swift.(file)._RuntimeFunctionCounters.runtimeFunctionCountersOffsets*/
static readonly runtimeFunctionCountersOffsets$get() {
throw 'unsupported variable Swift.(file)._RuntimeFunctionCounters.runtimeFunctionCountersOffsets in ' + this.constructor.name
}
static readonly get runtimeFunctionCountersOffsets() { return this.runtimeFunctionCountersOffsets$get() };




/*Swift.(file)._RuntimeFunctionCounters.numRuntimeFunctionCounters*/
static readonly numRuntimeFunctionCounters$get() {
throw 'unsupported variable Swift.(file)._RuntimeFunctionCounters.numRuntimeFunctionCounters in ' + this.constructor.name
}
static readonly get numRuntimeFunctionCounters() { return this.numRuntimeFunctionCounters$get() };




/*Swift.(file)._RuntimeFunctionCounters.runtimeFunctionNameToIndex*/
static readonly runtimeFunctionNameToIndex$get() {
throw 'unsupported variable Swift.(file)._RuntimeFunctionCounters.runtimeFunctionNameToIndex in ' + this.constructor.name
}
static readonly get runtimeFunctionNameToIndex() { return this.runtimeFunctionNameToIndex$get() };




static /*Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionNames()*/
/*Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionNames()*/
getRuntimeFunctionNames($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionNames() in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionCountersOffsets()*/
/*Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionCountersOffsets()*/
getRuntimeFunctionCountersOffsets($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionCountersOffsets() in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.getNumRuntimeFunctionCounters()*/
/*Swift.(file)._RuntimeFunctionCounters.getNumRuntimeFunctionCounters()*/
getNumRuntimeFunctionCounters($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.getNumRuntimeFunctionCounters() in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.dumpObjectsRuntimeFunctionPointers()*/
/*Swift.(file)._RuntimeFunctionCounters.dumpObjectsRuntimeFunctionPointers()*/
dumpObjectsRuntimeFunctionPointers($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.dumpObjectsRuntimeFunctionPointers() in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCountersUpdateHandler(handler:_RuntimeFunctionCounters.RuntimeFunctionCountersUpdateHandler?)*/
/*Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCountersUpdateHandler(handler:_RuntimeFunctionCounters.RuntimeFunctionCountersUpdateHandler?)*/
setGlobalRuntimeFunctionCountersUpdateHandlerHandler(handler, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCountersUpdateHandler(handler:_RuntimeFunctionCounters.RuntimeFunctionCountersUpdateHandler?) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.collectAllReferencesInsideObject(_:Any)*/
/*Swift.(file)._RuntimeFunctionCounters.collectAllReferencesInsideObject(_:Any)*/
collectAllReferencesInsideObject(value, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.collectAllReferencesInsideObject(_:Any) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionNameToIndex()*/
/*Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionNameToIndex()*/
getRuntimeFunctionNameToIndex($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.getRuntimeFunctionNameToIndex() in ' + this.constructor.name
}
/*Swift.(file)._RuntimeFunctionCounters.init()*/
/*Swift.(file)._RuntimeFunctionCounters.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.init() in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.getObjectRuntimeFunctionCounters(_:UnsafeRawPointer,_:_RuntimeFunctionCountersState)*/
/*Swift.(file)._RuntimeFunctionCounters.getObjectRuntimeFunctionCounters(_:UnsafeRawPointer,_:_RuntimeFunctionCountersState)*/
getObjectRuntimeFunctionCounters(object, result$inout, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.getObjectRuntimeFunctionCounters(_:UnsafeRawPointer,_:_RuntimeFunctionCountersState) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.getGlobalRuntimeFunctionCounters(_:_RuntimeFunctionCountersState)*/
/*Swift.(file)._RuntimeFunctionCounters.getGlobalRuntimeFunctionCounters(_:_RuntimeFunctionCountersState)*/
getGlobalRuntimeFunctionCounters(result$inout, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.getGlobalRuntimeFunctionCounters(_:_RuntimeFunctionCountersState) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCounters(_:_RuntimeFunctionCountersState)*/
/*Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCounters(_:_RuntimeFunctionCountersState)*/
setGlobalRuntimeFunctionCounters(state$inout, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCounters(_:_RuntimeFunctionCountersState) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.setObjectRuntimeFunctionCounters(_:UnsafeRawPointer,_:_RuntimeFunctionCountersState)*/
/*Swift.(file)._RuntimeFunctionCounters.setObjectRuntimeFunctionCounters(_:UnsafeRawPointer,_:_RuntimeFunctionCountersState)*/
setObjectRuntimeFunctionCounters(object, state$inout, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.setObjectRuntimeFunctionCounters(_:UnsafeRawPointer,_:_RuntimeFunctionCountersState) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCountersMode(enable:Bool)*/
/*Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCountersMode(enable:Bool)*/
setGlobalRuntimeFunctionCountersModeEnable(enable, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.setGlobalRuntimeFunctionCountersMode(enable:Bool) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.setPerObjectRuntimeFunctionCountersMode(enable:Bool)*/
/*Swift.(file)._RuntimeFunctionCounters.setPerObjectRuntimeFunctionCountersMode(enable:Bool)*/
setPerObjectRuntimeFunctionCountersModeEnable(enable, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.setPerObjectRuntimeFunctionCountersMode(enable:Bool) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.enableRuntimeFunctionCountersUpdates(mode:(globalMode: Bool, perObjectMode: Bool))*/
/*Swift.(file)._RuntimeFunctionCounters.enableRuntimeFunctionCountersUpdates(mode:(globalMode: Bool, perObjectMode: Bool))*/
enableRuntimeFunctionCountersUpdatesMode(mode, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.enableRuntimeFunctionCountersUpdates(mode:(globalMode: Bool, perObjectMode: Bool)) in ' + this.constructor.name
}
static /*Swift.(file)._RuntimeFunctionCounters.disableRuntimeFunctionCountersUpdates()*/
/*Swift.(file)._RuntimeFunctionCounters.disableRuntimeFunctionCountersUpdates()*/
disableRuntimeFunctionCountersUpdates($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCounters.disableRuntimeFunctionCountersUpdates() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}




interface _RuntimeFunctionCountersStats extends CustomDebugStringConvertible{
/*Swift.(file)._RuntimeFunctionCountersStats.init()*/
/*Swift.(file)._RuntimeFunctionCountersStats.init()*/
init($info?)
/*Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool,to:T)*/
/*Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool,to:T)*/
dumpSkipUnchangedTo<T>(skipUnchanged, to$inout, $info?)
/*Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool,to:T)*/
/*Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool,to:T)*/
dumpDiffSkipUnchangedTo<T>(after, skipUnchanged, to$inout, $info?)
/*Swift.(file)._RuntimeFunctionCountersStats.diff(_:Self)*/
/*Swift.(file)._RuntimeFunctionCountersStats.diff(_:Self)*/
diff(other, $info?)
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$get(counterName, $info?)/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$set(newValue, counterName, $info?)



/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$get(index, $info?)/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, index, $info?)



}
class _RuntimeFunctionCountersStats$implementation{
/*Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool)*/
/*Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool)*/
dumpSkipUnchanged(skipUnchanged, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool) in ' + this.constructor.name
}
/*Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool)*/
/*Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool)*/
dumpDiffSkipUnchanged(after, skipUnchanged, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool) in ' + this.constructor.name
}

/*Swift.(file)._RuntimeFunctionCountersStats.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file)._RuntimeFunctionCountersStats.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool,to:T)*/
/*Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool,to:T)*/
dumpSkipUnchangedTo<T>(skipUnchanged, to$inout, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersStats.dump(skipUnchanged:Bool,to:T) in ' + this.constructor.name
}
/*Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool,to:T)*/
/*Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool,to:T)*/
dumpDiffSkipUnchangedTo<T>(after, skipUnchanged, to$inout, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersStats.dumpDiff(_:Self,skipUnchanged:Bool,to:T) in ' + this.constructor.name
}
/*Swift.(file)._RuntimeFunctionCountersStats.diff(_:Self)*/
/*Swift.(file)._RuntimeFunctionCountersStats.diff(_:Self)*/
diff(other, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersStats.diff(_:Self) in ' + this.constructor.name
}
}
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(_RuntimeFunctionCountersStats$implementation, CustomDebugStringConvertible$implementation, false)








class _RuntimeFunctionCountersState implements _RuntimeFunctionCountersStats{
static readonly $struct = true


/*Swift.(file)._RuntimeFunctionCountersState.counters*/
counters$get() {
throw 'unsupported variable Swift.(file)._RuntimeFunctionCountersState.counters in ' + this.constructor.name
}
get counters() { return this.counters$get() };





/*Swift.(file)._RuntimeFunctionCountersState.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$get(counterName, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersState.subscript(_:String) in ' + this.constructor.name
}/*Swift.(file)._RuntimeFunctionCountersState.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$set(newValue, counterName, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersState.subscript(_:String) in ' + this.constructor.name
}



/*Swift.(file)._RuntimeFunctionCountersState.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersState.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file)._RuntimeFunctionCountersState.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersState.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file)._RuntimeFunctionCountersState.init(counters:_RuntimeFunctionCountersState.Counters)*/
/*Swift.(file)._RuntimeFunctionCountersState.init(counters:_RuntimeFunctionCountersState.Counters)*/
initCounters_RuntimeFunctionCountersStateCounters(counters, $info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersState.init(counters:_RuntimeFunctionCountersState.Counters) in ' + this.constructor.name
}
/*Swift.(file)._RuntimeFunctionCountersState.init()*/
/*Swift.(file)._RuntimeFunctionCountersStats.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._RuntimeFunctionCountersState.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof _RuntimeFunctionCountersStats$implementation != 'undefined') _mixin(_RuntimeFunctionCountersState, _RuntimeFunctionCountersStats$implementation, false)


class _GlobalRuntimeFunctionCountersState implements _RuntimeFunctionCountersStats{
static readonly $struct = true

/*Swift.(file)._GlobalRuntimeFunctionCountersState.state*/
state$get() {
throw 'unsupported variable Swift.(file)._GlobalRuntimeFunctionCountersState.state in ' + this.constructor.name
}
get state() { return this.state$get() };





/*Swift.(file)._GlobalRuntimeFunctionCountersState.init()*/
/*Swift.(file)._RuntimeFunctionCountersStats.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._GlobalRuntimeFunctionCountersState.init() in ' + this.constructor.name
}
/*Swift.(file)._GlobalRuntimeFunctionCountersState.getGlobalRuntimeFunctionCounters()*/
/*Swift.(file)._GlobalRuntimeFunctionCountersState.getGlobalRuntimeFunctionCounters()*/
getGlobalRuntimeFunctionCounters($info?) {
throw 'unsupported method Swift.(file)._GlobalRuntimeFunctionCountersState.getGlobalRuntimeFunctionCounters() in ' + this.constructor.name
}
/*Swift.(file)._GlobalRuntimeFunctionCountersState.setGlobalRuntimeFunctionCounters()*/
/*Swift.(file)._GlobalRuntimeFunctionCountersState.setGlobalRuntimeFunctionCounters()*/
setGlobalRuntimeFunctionCounters($info?) {
throw 'unsupported method Swift.(file)._GlobalRuntimeFunctionCountersState.setGlobalRuntimeFunctionCounters() in ' + this.constructor.name
}
/*Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:String) in ' + this.constructor.name
}/*Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:String) in ' + this.constructor.name
}



/*Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file)._GlobalRuntimeFunctionCountersState.subscript(_:Int) in ' + this.constructor.name
}



init$vars() {let _this = this;

}
}
if(typeof _RuntimeFunctionCountersStats$implementation != 'undefined') _mixin(_GlobalRuntimeFunctionCountersState, _RuntimeFunctionCountersStats$implementation, false)


class _ObjectRuntimeFunctionCountersState implements _RuntimeFunctionCountersStats{
static readonly $struct = true

/*Swift.(file)._ObjectRuntimeFunctionCountersState.state*/
state$get() {
throw 'unsupported variable Swift.(file)._ObjectRuntimeFunctionCountersState.state in ' + this.constructor.name
}
get state() { return this.state$get() };





/*Swift.(file)._ObjectRuntimeFunctionCountersState.init(_:UnsafeRawPointer)*/
/*Swift.(file)._ObjectRuntimeFunctionCountersState.init(_:UnsafeRawPointer)*/
initUnsafeRawPointer(p, $info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.init(_:UnsafeRawPointer) in ' + this.constructor.name
}
/*Swift.(file)._ObjectRuntimeFunctionCountersState.init()*/
/*Swift.(file)._RuntimeFunctionCountersStats.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.init() in ' + this.constructor.name
}
/*Swift.(file)._ObjectRuntimeFunctionCountersState.getObjectRuntimeFunctionCounters(_:UnsafeRawPointer)*/
/*Swift.(file)._ObjectRuntimeFunctionCountersState.getObjectRuntimeFunctionCounters(_:UnsafeRawPointer)*/
getObjectRuntimeFunctionCounters(o, $info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.getObjectRuntimeFunctionCounters(_:UnsafeRawPointer) in ' + this.constructor.name
}
/*Swift.(file)._ObjectRuntimeFunctionCountersState.setObjectRuntimeFunctionCounters(_:UnsafeRawPointer)*/
/*Swift.(file)._ObjectRuntimeFunctionCountersState.setObjectRuntimeFunctionCounters(_:UnsafeRawPointer)*/
setObjectRuntimeFunctionCounters(o, $info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.setObjectRuntimeFunctionCounters(_:UnsafeRawPointer) in ' + this.constructor.name
}
/*Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:String) in ' + this.constructor.name
}/*Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:String)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:String)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:String) in ' + this.constructor.name
}



/*Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:Int)*/
/*Swift.(file)._RuntimeFunctionCountersStats.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file)._ObjectRuntimeFunctionCountersState.subscript(_:Int) in ' + this.constructor.name
}



init$vars() {let _this = this;

}
}
if(typeof _RuntimeFunctionCountersStats$implementation != 'undefined') _mixin(_ObjectRuntimeFunctionCountersState, _RuntimeFunctionCountersStats$implementation, false)


interface IteratorProtocol<Element>{

/*Swift.(file).IteratorProtocol.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?)
}
class IteratorProtocol$implementation{
}


interface Sequence<Element, Iterator>{


/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?)

/*Swift.(file).Sequence.underestimatedCount*/
underestimatedCount;






/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?)
}
class Sequence$implementation{
/*Swift.(file).Sequence.shuffled(using:T)*/
/*Swift.(file).Sequence.shuffled(using:T)*/
shuffledUsing<T>(generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(ContiguousArray, 'initBuffer', _this, {});
result.shuffleUsing({get: () => generator, set: $val => generator = $val}, {$setThis: $val => result = $val});
return _create(Array, 'initBuffer', result, {});})()
generator$inout.set(generator)
return $result
}
/*Swift.(file).Sequence.shuffled()*/
/*Swift.(file).Sequence.shuffled()*/
shuffled($info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.shuffledUsing({get: () => g, set: $val => g = $val})
}

/*Swift.(file).Sequence.joined()*/
/*Swift.(file).Sequence.joined()*/
joined($info?) {
let _this = this;
return _create(FlattenSequence, 'init_base', _this, {})
}
/*Swift.(file).Sequence.joined(separator:Separator)*/
/*Swift.(file).Sequence.joined(separator:Separator)*/
joinedSeparator<Separator>(separator, $info?) {
let _this = this;
return _create(JoinedSequence, 'initBaseSeparator', _this, separator, {})
}

/*Swift.(file).Sequence.lazy*/
lazy$get() {
let _this = this;
return _create(LazySequence, 'init_base', _this, {})
}
get lazy() { return this.lazy$get() };




/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}
/*Swift.(file).Sequence.map(_:(Self.Element) throws -> T)*/
/*Swift.(file).Sequence.map(_:(Self.Element) throws -> T)*/
mapSwift<T>(transform, $info?) {
let _this = this;
let result = _create(Array, 'init', {});
let iterator = _this.makeIterator( {});
while(true){
const $ifLet0, _element_1
if(!((($ifLet0 = iterator.next( {$setThis: $val => iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
result.append(transform(_element_1), {$setThis: $val => result = $val});
};
return result
}
/*Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
let _this = this;
return _this._filter(isIncluded)
}


/*Swift.(file).Sequence.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return 0
}
get underestimatedCount() { return this.underestimatedCount$get() };




/*Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)*/
/*Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)*/
forEachSwift(body, $info?) {
let _this = this;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
body(_element_1);
}
}
}
/*Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)*/
firstWhere(predicate, $info?) {
let _this = this;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((predicate(_element_1))) {
return _injectIntoOptional(_element_1);
};
}
};
return _injectIntoOptional(null)
}
/*Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)*/
/*Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)*/
splitSeparatorMaxSplitsOmittingEmptySubsequences(separator, maxSplits, omittingEmptySubsequences, $info?) {
let _this = this;
return _this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, (($0, $info?) => (_.arg0 = $0).constructor.$equal(_.arg0, separator)))
}
/*Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)*/
splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, isSeparator, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(maxSplits, 0), () => "Must take zero or more splits", null, null);
const whole = _create(Array, 'initBuffer', _this, {});
return whole.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, isSeparator)
}
/*Swift.(file).Sequence.suffix(_:Int)*/
/*Swift.(file).Sequence.suffix(_:Int)*/
suffix(maxLength, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(maxLength, 0), () => "Can't take a suffix of negative length from a sequence", null, null);
if(!((Int.$notEqual(maxLength, 0)))) {
return _create(Array, 'initArrayLiteralArray', [], {});
};
let ringBuffer = _create(ContiguousArray, 'init', {});
let i = 0;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((Int.$lessThan(ringBuffer.count, maxLength))) {
ringBuffer.append(_element_1, {$setThis: $val => ringBuffer = $val});
}
else {
ringBuffer.subscript$set(_element_1, i, {$setThis: $val => ringBuffer = $val});
i = Int.$remainder(Int.$add(i, 1), maxLength);
};
}
};
if((Int.$notEqual(i, ringBuffer.startIndex))) {
let rotated = _create(ContiguousArray, 'init', {});
ContiguousArray.$addAndAssign({get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get(Int.$halfOpenRange(i, ringBuffer.endIndex)));
ContiguousArray.$addAndAssign({get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get(Int.$halfOpenRange(0, i)));
return _create(Array, 'initBuffer', rotated, {});
}
else {
return _create(Array, 'initBuffer', ringBuffer, {});
}
}
/*Swift.(file).Sequence.dropFirst(_:Int)*/
/*Swift.(file).Sequence.dropFirst(_:Int)*/
dropFirst(k, $info?) {
let _this = this;
return _create(DropFirstSequence, 'initDroppingInt', _this, k, {})
}
/*Swift.(file).Sequence.dropLast(_:Int)*/
/*Swift.(file).Sequence.dropLast(_:Int)*/
dropLast(k, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Can't drop a negative number of elements from a sequence", null, null);
if(!((Int.$notEqual(k, 0)))) {
return _create(Array, 'initBuffer', _this, {});
};
let result = _create(ContiguousArray, 'init', {});
let ringBuffer = _create(ContiguousArray, 'init', {});
let i = ringBuffer.startIndex;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((Int.$lessThan(ringBuffer.count, k))) {
ringBuffer.append(_element_1, {$setThis: $val => ringBuffer = $val});
}
else {
result.append(ringBuffer.subscript$get(i), {$setThis: $val => result = $val});
ringBuffer.subscript$set(_element_1, i, {$setThis: $val => ringBuffer = $val});
i = Int.$remainder(Int.$add(i, 1), k);
};
}
};
return _create(Array, 'initBuffer', result, {})
}
/*Swift.(file).Sequence.drop(while:(Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.drop(while:(Self.Element) throws -> Bool)*/
dropWhile(predicate, $info?) {
let _this = this;
return _create(DropWhileSequence, 'initPredicatefunction_type', _this, predicate, {})
}
/*Swift.(file).Sequence.prefix(_:Int)*/
/*Swift.(file).Sequence.prefix(_:Int)*/
prefix(maxLength, $info?) {
let _this = this;
return _create(PrefixSequence, 'initMaxLengthInt', _this, maxLength, {})
}
/*Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)*/
prefixWhile(predicate, $info?) {
let _this = this;
let result = _create(ContiguousArray, 'init', {});
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if(!((predicate(_element_1)))) {
break;
};
result.append(_element_1, {$setThis: $val => result = $val});
}
};
return _create(Array, 'initBuffer', result, {})
}

/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(null)
}
/*Swift.(file).Sequence.enumerated()*/
/*Swift.(file).Sequence.enumerated()*/
enumerated($info?) {
let _this = this;
return _create(EnumeratedSequence, 'init_base', _this, {})
}
/*Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)*/
minBy(areInIncreasingOrder, $info?) {
let _this = this;
let it = _this.makeIterator( {});
const $ifLet0, result_1
if(!((($ifLet0 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
while(true){
const $ifLet2, e_3
if(!((($ifLet2 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet2.rawValue == 'some' && ((e_3 = $ifLet2[0])||true))) break
if((areInIncreasingOrder(e_3, result_1))) {
result_1 = e_3;
};
};
return _injectIntoOptional(result_1)
}
/*Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)*/
maxBy(areInIncreasingOrder, $info?) {
let _this = this;
let it = _this.makeIterator( {});
const $ifLet0, result_1
if(!((($ifLet0 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
while(true){
const $ifLet2, e_3
if(!((($ifLet2 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet2.rawValue == 'some' && ((e_3 = $ifLet2[0])||true))) break
if((areInIncreasingOrder(result_1, e_3))) {
result_1 = e_3;
};
};
return _injectIntoOptional(result_1)
}
/*Swift.(file).Sequence.min()*/
/*Swift.(file).Sequence.min()*/
min($info?) {
let _this = this;
return _this.minBy(this.first[0].constructor.$lessThan)
}
/*Swift.(file).Sequence.max()*/
/*Swift.(file).Sequence.max()*/
max($info?) {
let _this = this;
return _this.maxBy(this.first[0].constructor.$lessThan)
}
/*Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)*/
/*Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)*/
startsWithBy<PossiblePrefix>(possiblePrefix, areEquivalent, $info?) {
let _this = this;
let possiblePrefixIterator = possiblePrefix.makeIterator( {});
{
let $e0$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, e0_1;
if(!((($ifLet0 = $e0$generator.next( {$setThis: $val => $e0$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e0_1 = $ifLet0[0])||true))) break
const $ifLet2, e1_3
if((($ifLet2 = possiblePrefixIterator.next( {$setThis: $val => possiblePrefixIterator = $val}))||true) && $ifLet2.rawValue == 'some' && ((e1_3 = $ifLet2[0])||true)) {
if((Bool.$not(areEquivalent(e0_1, e1_3)))) {
return false;
};
}
else {
return true;
};
}
};
return Optional.wrappedEqualsOptionalNilComparisonType(possiblePrefixIterator.next( {$setThis: $val => possiblePrefixIterator = $val}), _injectIntoOptional(null))
}
/*Swift.(file).Sequence.starts(with:PossiblePrefix)*/
/*Swift.(file).Sequence.starts(with:PossiblePrefix)*/
startsWithSwift<PossiblePrefix>(possiblePrefix, $info?) {
let _this = this;
return _this.startsWithBy(possiblePrefix, this.first[0].constructor.$equal)
}
/*Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)*/
/*Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)*/
elementsEqualBy<OtherSequence>(other, areEquivalent, $info?) {
let _this = this;
let iter1 = _this.makeIterator( {});
let iter2 = other.makeIterator( {});
while(true){
if(!((true))) break
const $match = {0: iter1.next( {$setThis: $val => iter1 = $val}), 1: iter2.next( {$setThis: $val => iter2 = $val})}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const e1 = $match[0][0]
const e2 = $match[1][0]
if((Bool.$not(areEquivalent(e1, e2)))) {
return false;
};
}
else if((($match[0].rawValue == 'some' && $match[1].rawValue == Optional.none.rawValue) || ($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == 'some'))) {
return false;
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
};
}
}
/*Swift.(file).Sequence.elementsEqual(_:OtherSequence)*/
/*Swift.(file).Sequence.elementsEqual(_:OtherSequence)*/
elementsEqual<OtherSequence>(other, $info?) {
let _this = this;
return _this.elementsEqualBy(other, this.first[0].constructor.$equal)
}
/*Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)*/
lexicographicallyPrecedesBy<OtherSequence>(other, areInIncreasingOrder, $info?) {
let _this = this;
let iter1 = _this.makeIterator( {});
let iter2 = other.makeIterator( {});
while(true){
if(!((true))) break
const $ifLet0, e1_1
if((($ifLet0 = iter1.next( {$setThis: $val => iter1 = $val}))||true) && $ifLet0.rawValue == 'some' && ((e1_1 = $ifLet0[0])||true)) {
const $ifLet2, e2_3
if((($ifLet2 = iter2.next( {$setThis: $val => iter2 = $val}))||true) && $ifLet2.rawValue == 'some' && ((e2_3 = $ifLet2[0])||true)) {
if((areInIncreasingOrder(e1_1, e2_3))) {
return true;
};
if((areInIncreasingOrder(e2_3, e1_1))) {
return false;
};
continue;
};
return false;
};
return Optional.wrappedNotEqualsOptionalNilComparisonType(iter2.next( {$setThis: $val => iter2 = $val}), _injectIntoOptional(null));
}
}
/*Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)*/
/*Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)*/
lexicographicallyPrecedes<OtherSequence>(other, $info?) {
let _this = this;
return _this.lexicographicallyPrecedesBy(other, this.first[0].constructor.$lessThan)
}
/*Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)*/
containsWhere(predicate, $info?) {
let _this = this;
{
let $e$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, e_1;
if(!((($ifLet0 = $e$generator.next( {$setThis: $val => $e$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e_1 = $ifLet0[0])||true))) break
if((predicate(e_1))) {
return true;
};
}
};
return false
}
/*Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)*/
allSatisfy(predicate, $info?) {
let _this = this;
return Bool.$not(_this.containsWhere((($0, $info?) => Bool.$not(predicate($0)))))
}
/*Swift.(file).Sequence.contains(_:Self.Element)*/
/*Swift.(file).Sequence.contains(_:Self.Element)*/
contains(_element, $info?) {
let _this = this;
const $ifLet0, result_1
if((($ifLet0 = _this._customContainsEquatableElement(_element))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return result_1;
}
else {
return _this.containsWhere((($0, $info?) => (_.arg0 = $0).constructor.$equal(_.arg0, _element)));
}
}
/*Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)*/
/*Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)*/
reduceSwift<Result>(initialResult, nextPartialResult, $info?) {
let _this = this;
let accumulator = initialResult;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
accumulator = nextPartialResult(accumulator, _element_1);
}
};
return accumulator
}
/*Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())*/
/*Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())*/
reduceInto<Result>(initialResult, updateAccumulatingResult, $info?) {
let _this = this;
let accumulator = initialResult;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
updateAccumulatingResult({get: () => accumulator, set: $val => accumulator = $val}, _element_1);
}
};
return accumulator
}
/*Swift.(file).Sequence.reversed()*/
/*Swift.(file).Sequence.reversed()*/
reversed($info?) {
let _this = this;
let result = _create(Array, 'initBuffer', _this, {});
const count = result.count;
{
let $i$generator = _cloneStruct(Int.$halfOpenRange(0, Int.$divide(count, 2)).makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.swapAt(i_1, Int.$subtract(count, Int.$add(i_1, 1)), {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)*/
/*Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)*/
flatMap<SegmentOfResult>(transform, $info?) {
let _this = this;
let result = _create(Array, 'initArrayLiteralArray', [], {});
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
result.appendContentsOf(transform(_element_1), {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)*/
/*Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)*/
compactMap<ElementOfResult>(transform, $info?) {
let _this = this;
return _this._compactMap(transform)
}

/*Swift.(file).Sequence.sorted()*/
/*Swift.(file).Sequence.sorted()*/
sorted($info?) {
let _this = this;
return _this.sortedBy(this.first[0].constructor.$lessThan)
}
/*Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)*/
/*Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)*/
sortedBy(areInIncreasingOrder, $info?) {
let _this = this;
let result = _create(Array, 'initBuffer', _this, {});
result.sortBy(areInIncreasingOrder, {$setThis: $val => result = $val});
return result
}
/*Swift.(file).Sequence.joined(separator:String)*/
/*Swift.(file).Sequence.joined(separator:String)*/
/*!!!DUPLICATE NAME*/
joinedSeparator(separator, $info?) {
let _this = this;
let result = "";
if((separator.isEmpty)) {
{
let $x$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, x_1;
if(!((($ifLet0 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true))) break
result.append(_create(String, 'initString', x_1, {}), {$setThis: $val => result = $val});
}
};
return result;
};
let iter = _this.makeIterator( {});
const $ifLet2, first_3
if((($ifLet2 = iter.next( {$setThis: $val => iter = $val}))||true) && $ifLet2.rawValue == 'some' && ((first_3 = $ifLet2[0])||true)) {
result.append(_create(String, 'initString', first_3, {}), {$setThis: $val => result = $val});
while(true){
const $ifLet4, next_5
if(!((($ifLet4 = iter.next( {$setThis: $val => iter = $val}))||true) && $ifLet4.rawValue == 'some' && ((next_5 = $ifLet4[0])||true))) break
result.append(separator, {$setThis: $val => result = $val});
result.append(_create(String, 'initString', next_5, {}), {$setThis: $val => result = $val});
};
};
return result
}

static /*Swift.(file).Sequence.+infix(_:Self,_:String)*/
/*Swift.(file).Sequence.+infix(_:Self,_:String)*/
$add(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).Sequence.+infix(_:String,_:Self)*/
/*Swift.(file).Sequence.+infix(_:String,_:Self)*/
/*!!!DUPLICATE NAME*/
$add(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
/*Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)*/
/*Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)*/
/*!!!DUPLICATE NAME*/
flatMap<ElementOfResult>(transform, $info?) {
let _this = this;
return _this._compactMap(transform)
}
}
























































class DropFirstSequence<Base> implements Sequence{
static readonly $struct = true






/*Swift.(file).DropFirstSequence.init(_:Base,dropping:Int)*/
/*Swift.(file).DropFirstSequence.init(_:Base,dropping:Int)*/
initDroppingInt(base, limit, $info?) {
throw 'unsupported method Swift.(file).DropFirstSequence.init(_:Base,dropping:Int) in ' + this.constructor.name
}



/*Swift.(file).DropFirstSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
let it = _this._base.makeIterator( {});
let dropped = 0;
while(true){
if(!((Int.$lessThan(dropped, _this._limit)) && (Optional.wrappedNotEqualsOptionalNilComparisonType(it.next( {$setThis: $val => it = $val}), _injectIntoOptional(null))))) break
Int.infix_38_43_61({get: () => dropped, set: $val => dropped = $val}, 1);
};
return it
}
/*Swift.(file).DropFirstSequence.dropFirst(_:Int)*/
/*Swift.(file).DropFirstSequence.dropFirst(_:Int)*/
dropFirst(k, $info?) {
let _this = this;
return _create(DropFirstSequence, 'initDroppingInt', _this._base, Int.$add(_this._limit, k), {})
}
init$vars() {let _this = this;

}
}
if(typeof Sequence$implementation != 'undefined') _mixin(DropFirstSequence, Sequence$implementation, false)




class PrefixSequence<Base> implements Sequence{
static readonly $struct = true








/*Swift.(file).PrefixSequence.init(_:Base,maxLength:Int)*/
/*Swift.(file).PrefixSequence.init(_:Base,maxLength:Int)*/
initMaxLengthInt(base, maxLength, $info?) {
throw 'unsupported method Swift.(file).PrefixSequence.init(_:Base,maxLength:Int) in ' + this.constructor.name
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true










/*Swift.(file).PrefixSequence.Iterator.init(_:Base.Iterator,maxLength:Int)*/
/*Swift.(file).PrefixSequence.Iterator.init(_:Base.Iterator,maxLength:Int)*/
initMaxLengthInt(base, maxLength, $info?) {
let _this = this;
_this._base = base;
_this._remaining = maxLength;
return
}

/*Swift.(file).PrefixSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if((Int.$notEqual(_this._remaining, 0))) {
Int.infix_38_45_61({get: () => _this._remaining, set: $val => _this._remaining = $val}, 1);
return _this._base.next( {$setThis: $val => _this._base = $val});
}
else {
return _injectIntoOptional(null);
}
}
init$vars() {let _this = this;

}
}
/*Swift.(file).PrefixSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(PrefixSequence.Iterator, 'initMaxLengthInt', _this._base.makeIterator( {}), _this._maxLength, {})
}
/*Swift.(file).PrefixSequence.prefix(_:Int)*/
/*Swift.(file).PrefixSequence.prefix(_:Int)*/
prefix(maxLength, $info?) {
let _this = this;
const _length = min(maxLength, _this._maxLength);
return _create(PrefixSequence, 'initMaxLengthInt', _this._base, _length, {})
}

init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(PrefixSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(PrefixSequence, Sequence$implementation, false)






class DropWhileSequence<Base> implements Sequence{
static readonly $struct = true











/*Swift.(file).DropWhileSequence.init(iterator:Base.Iterator,predicate:(DropWhileSequence<Base>.Element) throws -> Bool)*/
/*Swift.(file).DropWhileSequence.init(iterator:Base.Iterator,predicate:(DropWhileSequence<Base>.Element) throws -> Bool)*/
initIteratorPredicatefunction_type(iterator, predicate, $info?) {
throw 'unsupported method Swift.(file).DropWhileSequence.init(iterator:Base.Iterator,predicate:(DropWhileSequence<Base>.Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).DropWhileSequence.init(_:Base,predicate:(DropWhileSequence<Base>.Element) throws -> Bool)*/
/*Swift.(file).DropWhileSequence.init(_:Base,predicate:(DropWhileSequence<Base>.Element) throws -> Bool)*/
initPredicatefunction_type(base, predicate, $info?) {
throw 'unsupported method Swift.(file).DropWhileSequence.init(_:Base,predicate:(DropWhileSequence<Base>.Element) throws -> Bool) in ' + this.constructor.name
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true










/*Swift.(file).DropWhileSequence.Iterator.init(_:Base.Iterator,nextElement:DropWhileSequence<Base>.Iterator.Element?)*/
/*Swift.(file).DropWhileSequence.Iterator.init(_:Base.Iterator,nextElement:DropWhileSequence<Base>.Iterator.Element?)*/
initNextElementOptional(iterator, nextElement, $info?) {
let _this = this;
_this._iterator = iterator;
_this._nextElement = nextElement;
return
}

/*Swift.(file).DropWhileSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const $ifLet0, next_1
if(!((($ifLet0 = _this._nextElement)||true) && $ifLet0.rawValue == 'some' && ((next_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
_this._nextElement = _this._iterator.next( {$setThis: $val => _this._iterator = $val});
return _injectIntoOptional(next_1)
}
init$vars() {let _this = this;

}
}
/*Swift.(file).DropWhileSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(DropWhileSequence.Iterator, 'initNextElementOptional', _this._iterator, _this._nextElement, {})
}
/*Swift.(file).DropWhileSequence.drop(while:(DropWhileSequence<Base>.Element) throws -> Bool)*/
/*Swift.(file).DropWhileSequence.drop(while:(DropWhileSequence<Base>.Element) throws -> Bool)*/
dropWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).DropWhileSequence.drop(while:(DropWhileSequence<Base>.Element) throws -> Bool) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(DropWhileSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(DropWhileSequence, Sequence$implementation, false)






class IteratorSequence<Base> implements IteratorProtocol, Sequence{
static readonly $struct = true





/*Swift.(file).IteratorSequence.init(_:Base)*/
/*Swift.(file).IteratorSequence.init(_:Base)*/
init(base, $info?) {
let _this = this;
_this._base = base;
return
}
/*Swift.(file).IteratorSequence.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
return _this._base.next( {$setThis: $val => _this._base = $val})
}


init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(IteratorSequence, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(IteratorSequence, Sequence$implementation, false)




class _SetAnyHashableBox<Element> implements _AnyHashableBox{
static readonly $struct = true






/*Swift.(file)._SetAnyHashableBox.init(_:Set<Element>)*/
/*Swift.(file)._SetAnyHashableBox.init(_:Set<Element>)*/
initSet(value, $info?) {
throw 'unsupported method Swift.(file)._SetAnyHashableBox.init(_:Set<Element>) in ' + this.constructor.name
}














init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_SetAnyHashableBox, _AnyHashableBox$implementation, false)


interface SetAlgebra<Element> extends Equatable, ExpressibleByArrayLiteral{

/*Swift.(file).SetAlgebra.init()*/
/*Swift.(file).SetAlgebra.init()*/
init($info?)
/*Swift.(file).SetAlgebra.contains(_:Self.Element)*/
/*Swift.(file).SetAlgebra.contains(_:Self.Element)*/
contains(member, $info?)
/*Swift.(file).SetAlgebra.union(_:Self)*/
/*Swift.(file).SetAlgebra.union(_:Self)*/
union(other, $info?)
/*Swift.(file).SetAlgebra.intersection(_:Self)*/
/*Swift.(file).SetAlgebra.intersection(_:Self)*/
intersection(other, $info?)
/*Swift.(file).SetAlgebra.symmetricDifference(_:Self)*/
/*Swift.(file).SetAlgebra.symmetricDifference(_:Self)*/
symmetricDifference(other, $info?)
/*Swift.(file).SetAlgebra.insert(_:Self.Element)*/
/*Swift.(file).SetAlgebra.insert(_:Self.Element)*/
insert(newMember, $info?)
/*Swift.(file).SetAlgebra.remove(_:Self.Element)*/
/*Swift.(file).SetAlgebra.remove(_:Self.Element)*/
remove(member, $info?)
/*Swift.(file).SetAlgebra.update(with:Self.Element)*/
/*Swift.(file).SetAlgebra.update(with:Self.Element)*/
updateWith(newMember, $info?)
/*Swift.(file).SetAlgebra.formUnion(_:Self)*/
/*Swift.(file).SetAlgebra.formUnion(_:Self)*/
formUnion(other, $info?)
/*Swift.(file).SetAlgebra.formIntersection(_:Self)*/
/*Swift.(file).SetAlgebra.formIntersection(_:Self)*/
formIntersection(other, $info?)
/*Swift.(file).SetAlgebra.formSymmetricDifference(_:Self)*/
/*Swift.(file).SetAlgebra.formSymmetricDifference(_:Self)*/
formSymmetricDifference(other, $info?)
/*Swift.(file).SetAlgebra.subtracting(_:Self)*/
/*Swift.(file).SetAlgebra.subtracting(_:Self)*/
subtracting(other, $info?)
/*Swift.(file).SetAlgebra.isSubset(of:Self)*/
/*Swift.(file).SetAlgebra.isSubset(of:Self)*/
isSubsetOf(other, $info?)
/*Swift.(file).SetAlgebra.isDisjoint(with:Self)*/
/*Swift.(file).SetAlgebra.isDisjoint(with:Self)*/
isDisjointWith(other, $info?)
/*Swift.(file).SetAlgebra.isSuperset(of:Self)*/
/*Swift.(file).SetAlgebra.isSuperset(of:Self)*/
isSupersetOf(other, $info?)

/*Swift.(file).SetAlgebra.isEmpty*/
isEmpty;



/*Swift.(file).SetAlgebra.init(_:S)*/
/*Swift.(file).SetAlgebra.init(_:S)*/
initSource<S>(sequence, $info?)
/*Swift.(file).SetAlgebra.subtract(_:Self)*/
/*Swift.(file).SetAlgebra.subtract(_:Self)*/
subtract(other, $info?)
}
class SetAlgebra$implementation{
/*Swift.(file).SetAlgebra.init(_:S)*/
/*Swift.(file).SetAlgebra.init(_:S)*/
initSource<S>(sequence, $info?) {
let _this = this;
_this.init( {});
{
let $e$generator = sequence.makeIterator( {});
while(true) {
const $ifLet0, e_1;
if(!((($ifLet0 = $e$generator.next( {$setThis: $val => $e$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e_1 = $ifLet0[0])||true))) break
_this.insert(e_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return
}
/*Swift.(file).SetAlgebra.subtract(_:Self)*/
/*Swift.(file).SetAlgebra.subtract(_:Self)*/
subtract(other, $info?) {
let _this = this;
_this.formIntersection(_this.symmetricDifference(other), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).SetAlgebra.isSubset(of:Self)*/
/*Swift.(file).SetAlgebra.isSubset(of:Self)*/
isSubsetOf(other, $info?) {
let _this = this;
return (_.arg0 = _this.intersection(other)).constructor.$equal(_.arg0, _this)
}
/*Swift.(file).SetAlgebra.isSuperset(of:Self)*/
/*Swift.(file).SetAlgebra.isSuperset(of:Self)*/
isSupersetOf(other, $info?) {
let _this = this;
return other.isSubsetOf(_this)
}
/*Swift.(file).SetAlgebra.isDisjoint(with:Self)*/
/*Swift.(file).SetAlgebra.isDisjoint(with:Self)*/
isDisjointWith(other, $info?) {
let _this = this;
return _this.intersection(other).isEmpty
}
/*Swift.(file).SetAlgebra.subtracting(_:Self)*/
/*Swift.(file).SetAlgebra.subtracting(_:Self)*/
subtracting(other, $info?) {
let _this = this;
return _this.intersection(_this.symmetricDifference(other))
}

/*Swift.(file).SetAlgebra.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this).constructor.$equal(_.arg0, _create(_this.constructor, 'init', {}))
}
get isEmpty() { return this.isEmpty$get() };



/*Swift.(file).SetAlgebra.isStrictSuperset(of:Self)*/
/*Swift.(file).SetAlgebra.isStrictSuperset(of:Self)*/
isStrictSupersetOf(other, $info?) {
let _this = this;
return Bool.$logicalAND(_this.isSupersetOf(other), () => (_.arg0 = _this).constructor.$notEqual(_.arg0, other))
}
/*Swift.(file).SetAlgebra.isStrictSubset(of:Self)*/
/*Swift.(file).SetAlgebra.isStrictSubset(of:Self)*/
isStrictSubsetOf(other, $info?) {
let _this = this;
return other.isStrictSupersetOf(_this)
}
/*Swift.(file).SetAlgebra.init(arrayLiteral:[Self.Element])*/
/*Swift.(file).SetAlgebra.init(arrayLiteral:[Self.Element])*/
initArrayLiteralArray(arrayLiteral, $info?) {
let _this = this;
_this.initSource(arrayLiteral);
return
}
}
if(typeof Equatable$implementation != 'undefined') _mixin(SetAlgebra$implementation, Equatable$implementation, false)
if(typeof ExpressibleByArrayLiteral$implementation != 'undefined') _mixin(SetAlgebra$implementation, ExpressibleByArrayLiteral$implementation, false)






class _SetBuilder<Element>{
static readonly $struct = true








/*Swift.(file)._SetBuilder.init(count:Int)*/
/*Swift.(file)._SetBuilder.init(count:Int)*/
initCountInt(count, $info?) {
throw 'unsupported method Swift.(file)._SetBuilder.init(count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SetBuilder.add(member:Element)*/
/*Swift.(file)._SetBuilder.add(member:Element)*/
addMember(member, $info?) {
throw 'unsupported method Swift.(file)._SetBuilder.add(member:Element) in ' + this.constructor.name
}
/*Swift.(file)._SetBuilder.take()*/
/*Swift.(file)._SetBuilder.take()*/
take($info?) {
throw 'unsupported method Swift.(file)._SetBuilder.take() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


interface _SetBuffer<Element, Index>{



/*Swift.(file)._SetBuffer.startIndex*/
startIndex;




/*Swift.(file)._SetBuffer.endIndex*/
endIndex;



/*Swift.(file)._SetBuffer.index(after:Self.Index)*/
/*Swift.(file)._SetBuffer.index(after:Self.Index)*/
indexAfter(i, $info?)
/*Swift.(file)._SetBuffer.index(for:Self.Element)*/
/*Swift.(file)._SetBuffer.index(for:Self.Element)*/
indexFor(_element, $info?)

/*Swift.(file)._SetBuffer.count*/
count;



/*Swift.(file)._SetBuffer.contains(_:Self.Element)*/
/*Swift.(file)._SetBuffer.contains(_:Self.Element)*/
contains(member, $info?)
/*Swift.(file)._SetBuffer.element(at:Self.Index)*/
/*Swift.(file)._SetBuffer.element(at:Self.Index)*/
elementAt(i, $info?)
}
class _SetBuffer$implementation{
}


interface _ShadowProtocol{
}


interface _NSFastEnumeration extends _ShadowProtocol{
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?)
}
class _NSFastEnumeration$implementation{
}
if(typeof _ShadowProtocol$implementation != 'undefined') _mixin(_NSFastEnumeration$implementation, _ShadowProtocol$implementation, false)


interface _NSEnumerator extends _ShadowProtocol{
/*Swift.(file)._NSEnumerator.init()*/
/*Swift.(file)._NSEnumerator.init()*/
init($info?)
/*Swift.(file)._NSEnumerator.nextObject()*/
/*Swift.(file)._NSEnumerator.nextObject()*/
nextObject($info?)
}
class _NSEnumerator$implementation{
}
if(typeof _ShadowProtocol$implementation != 'undefined') _mixin(_NSEnumerator$implementation, _ShadowProtocol$implementation, false)


interface _NSCopying extends _ShadowProtocol{
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?)
}
class _NSCopying$implementation{
}
if(typeof _ShadowProtocol$implementation != 'undefined') _mixin(_NSCopying$implementation, _ShadowProtocol$implementation, false)


interface _NSArrayCore extends _NSCopying, _NSFastEnumeration{
/*Swift.(file)._NSArrayCore.objectAt(_:Int)*/
/*Swift.(file)._NSArrayCore.objectAt(_:Int)*/
objectAt(index, $info?)
/*Swift.(file)._NSArrayCore.getObjects(_:UnsafeMutablePointer<AnyObject>,range:_SwiftNSRange)*/
/*Swift.(file)._NSArrayCore.getObjects(_:UnsafeMutablePointer<AnyObject>,range:_SwiftNSRange)*/
getObjectsRange(_, range, $info?)
/*Swift.(file)._NSArrayCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?)

/*Swift.(file)._NSArrayCore.count*/
count;



}
class _NSArrayCore$implementation{
}
if(typeof _NSCopying$implementation != 'undefined') _mixin(_NSArrayCore$implementation, _NSCopying$implementation, false)
if(typeof _NSFastEnumeration$implementation != 'undefined') _mixin(_NSArrayCore$implementation, _NSFastEnumeration$implementation, false)


interface _NSDictionaryCore extends _NSCopying, _NSFastEnumeration{
/*Swift.(file)._NSDictionaryCore.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
/*Swift.(file)._NSDictionaryCore.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
initObjectsUnsafePointerForKeysUnsafeRawPointerCountInt(objects, forKeys, count, $info?)

/*Swift.(file)._NSDictionaryCore.count*/
count;



/*Swift.(file)._NSDictionaryCore.object(forKey:AnyObject)*/
/*Swift.(file)._NSDictionaryCore.object(forKey:AnyObject)*/
objectForKey(aKey, $info?)
/*Swift.(file)._NSDictionaryCore.keyEnumerator()*/
/*Swift.(file)._NSDictionaryCore.keyEnumerator()*/
keyEnumerator($info?)
/*Swift.(file)._NSDictionaryCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?)
/*Swift.(file)._NSDictionaryCore.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
getObjectsAndKeysCount(objects, keys, count, $info?)
/*Swift.(file)._NSDictionaryCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?)
}
class _NSDictionaryCore$implementation{
}
if(typeof _NSCopying$implementation != 'undefined') _mixin(_NSDictionaryCore$implementation, _NSCopying$implementation, false)
if(typeof _NSFastEnumeration$implementation != 'undefined') _mixin(_NSDictionaryCore$implementation, _NSFastEnumeration$implementation, false)


interface _NSDictionary extends _NSDictionaryCore{
/*Swift.(file)._NSDictionary.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
getObjectsAndKeysCount(objects, keys, count, $info?)
}
class _NSDictionary$implementation{
}
if(typeof _NSDictionaryCore$implementation != 'undefined') _mixin(_NSDictionary$implementation, _NSDictionaryCore$implementation, false)


interface _NSSetCore extends _NSCopying, _NSFastEnumeration{
/*Swift.(file)._NSSetCore.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
/*Swift.(file)._NSSetCore.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
initObjectsUnsafePointerCountInt(objects, count, $info?)

/*Swift.(file)._NSSetCore.count*/
count;



/*Swift.(file)._NSSetCore.member(_:AnyObject)*/
/*Swift.(file)._NSSetCore.member(_:AnyObject)*/
member(object, $info?)
/*Swift.(file)._NSSetCore.objectEnumerator()*/
/*Swift.(file)._NSSetCore.objectEnumerator()*/
objectEnumerator($info?)
/*Swift.(file)._NSSetCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?)
/*Swift.(file)._NSSetCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?)
}
class _NSSetCore$implementation{
}
if(typeof _NSCopying$implementation != 'undefined') _mixin(_NSSetCore$implementation, _NSCopying$implementation, false)
if(typeof _NSFastEnumeration$implementation != 'undefined') _mixin(_NSSetCore$implementation, _NSFastEnumeration$implementation, false)


interface _NSSet extends _NSSetCore{
}


interface _NSNumber{

/*Swift.(file)._NSNumber.doubleValue*/
doubleValue;




/*Swift.(file)._NSNumber.floatValue*/
floatValue;




/*Swift.(file)._NSNumber.unsignedLongLongValue*/
unsignedLongLongValue;




/*Swift.(file)._NSNumber.longLongValue*/
longLongValue;




/*Swift.(file)._NSNumber.objCType*/
objCType;



}
class _NSNumber$implementation{
}


class _SmallBuffer<T>{
static readonly $struct = true





/*Swift.(file)._SmallBuffer.init()*/
/*Swift.(file)._SmallBuffer.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SmallBuffer.init() in ' + this.constructor.name
}

/*Swift.(file)._SmallBuffer.stride*/
stride$get() {
let _this = this;
return MemoryLayout.stride
}
get stride() { return this.stride$get() };




/*Swift.(file)._SmallBuffer.byteCapacity*/
byteCapacity$get() {
let _this = this;
return MemoryLayout.strideOfValue(_this._inlineStorage)
}
get byteCapacity() { return this.byteCapacity$get() };




/*Swift.(file)._SmallBuffer.capacity*/
capacity$get() {
let _this = this;
return Int.$divide(_this.byteCapacity, _this.stride)
}
get capacity() { return this.capacity$get() };



/*Swift.(file)._SmallBuffer.subscript(_:Int)*/
/*Swift.(file)._SmallBuffer.subscript(_:Int)*/
subscript$get(i, $info?) {
let _this = this;
const capacity = _this.capacity;
return withUnsafeBytesOf(_this._inlineStorage, (($0, $info?) => { 
const rawPtr = _cloneStruct($0.baseAddress._unsafelyUnwrappedUnchecked);
const bufPtr = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(rawPtr.assumingMemoryBoundTo(((function(){throw '!unclarifiedGeneric:T'})()))), capacity, {});
return bufPtr.subscript_unchecked$get(i); }));

}/*Swift.(file)._SmallBuffer.subscript(_:Int)*/
/*Swift.(file)._SmallBuffer.subscript(_:Int)*/
subscript$set(newValue, i, $info?) {
let _this = this;
const capacity = _this.capacity;
withUnsafeMutableBytesOf({get: () => _this._inlineStorage, set: $val => _this._inlineStorage = $val}, (($0, $info?) => { 
const rawPtr = _cloneStruct($0.baseAddress._unsafelyUnwrappedUnchecked);
const bufPtr = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(rawPtr.assumingMemoryBoundTo(((function(){throw '!unclarifiedGeneric:T'})()))), capacity, {});
bufPtr.subscript_unchecked$set(newValue, i, {$setThis: $val => bufPtr = _cloneStruct($val)}); }))
}




init$vars() {let _this = this;

}
}








class StrideToIterator<Element> implements IteratorProtocol{
static readonly $struct = true














/*Swift.(file).StrideToIterator.init(_start:Element,end:Element,stride:Element.Stride)*/
/*Swift.(file).StrideToIterator.init(_start:Element,end:Element,stride:Element.Stride)*/
init_startEndStride(_start, end, stride, $info?) {
throw 'unsupported method Swift.(file).StrideToIterator.init(_start:Element,end:Element,stride:Element.Stride) in ' + this.constructor.name
}
/*Swift.(file).StrideToIterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const result = _this._current["1"];
if(((((function(){throw '!unclarifiedGeneric:Element.Stride'})()).$greaterThan(_this._stride, 0) ? (_.arg0 = result).constructor.$greaterThanOrEqual(_.arg0, _this._end) : (_.arg1 = result).constructor.$lessThanOrEqual(_.arg1, _this._end)))) {
return _injectIntoOptional(null);
};
_this._current = ((function(){throw '!unclarifiedGeneric:Element'})())._stepAfterFromBy(_this._current, _this._start, _this._stride);
return _injectIntoOptional(result)
}

init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(StrideToIterator, IteratorProtocol$implementation, false)




class StrideThroughIterator<Element> implements IteratorProtocol{
static readonly $struct = true



















/*Swift.(file).StrideThroughIterator.init(_start:Element,end:Element,stride:Element.Stride)*/
/*Swift.(file).StrideThroughIterator.init(_start:Element,end:Element,stride:Element.Stride)*/
init_startEndStride(_start, end, stride, $info?) {
throw 'unsupported method Swift.(file).StrideThroughIterator.init(_start:Element,end:Element,stride:Element.Stride) in ' + this.constructor.name
}
/*Swift.(file).StrideThroughIterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const result = _this._current["1"];
if(((((function(){throw '!unclarifiedGeneric:Element.Stride'})()).$greaterThan(_this._stride, 0) ? (_.arg0 = result).constructor.$greaterThanOrEqual(_.arg0, _this._end) : (_.arg1 = result).constructor.$lessThanOrEqual(_.arg1, _this._end)))) {
if((Bool.$logicalAND((_.arg2 = result).constructor.$equal(_.arg2, _this._end), () => Bool.$not(_this._didReturnEnd)))) {
_this._didReturnEnd = true;
return _injectIntoOptional(result);
};
return _injectIntoOptional(null);
};
_this._current = ((function(){throw '!unclarifiedGeneric:Element'})())._stepAfterFromBy(_this._current, _this._start, _this._stride);
return _injectIntoOptional(result)
}

init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(StrideThroughIterator, IteratorProtocol$implementation, false)




class _StringBreadcrumbs{

/*Swift.(file)._StringBreadcrumbs.breadcrumbStride*/
static breadcrumbStride$get() {
throw 'unsupported variable Swift.(file)._StringBreadcrumbs.breadcrumbStride in ' + this.constructor.name
}
static get breadcrumbStride() { return this.breadcrumbStride$get() };




/*Swift.(file)._StringBreadcrumbs.utf16Length*/
utf16Length$get() {
throw 'unsupported variable Swift.(file)._StringBreadcrumbs.utf16Length in ' + this.constructor.name
}
get utf16Length() { return this.utf16Length$get() };






/*Swift.(file)._StringBreadcrumbs.crumbs*/
crumbs$get() {
throw 'unsupported variable Swift.(file)._StringBreadcrumbs.crumbs in ' + this.constructor.name
}
get crumbs() { return this.crumbs$get() };





/*Swift.(file)._StringBreadcrumbs.init(_:String)*/
/*Swift.(file)._StringBreadcrumbs.init(_:String)*/
initString(str, $info?) {
throw 'unsupported method Swift.(file)._StringBreadcrumbs.init(_:String) in ' + this.constructor.name
}


/*Swift.(file)._StringBreadcrumbs.stride*/
stride$get() {
let _this = this;
return _StringBreadcrumbs.breadcrumbStride
}
get stride() { return this.stride$get() };



/*Swift.(file)._StringBreadcrumbs.getBreadcrumb(forOffset:Int)*/
/*Swift.(file)._StringBreadcrumbs.getBreadcrumb(forOffset:Int)*/
getBreadcrumbForOffset(offset, $info?) {
let _this = this;
return {0: _this.crumbs.subscript$get(Int.$divide(offset, _this.stride)), 1: Int.$remainder(offset, _this.stride)}
}
/*Swift.(file)._StringBreadcrumbs.getBreadcrumb(forIndex:String.Index)*/
/*Swift.(file)._StringBreadcrumbs.getBreadcrumb(forIndex:String.Index)*/
getBreadcrumbForIndex(idx, $info?) {
let _this = this;
let lowerBound = Int.$divide(Int.$divide(idx._encodedOffset, 3), _this.stride);
let upperBound = min(Int.$add(1, Int.$divide(idx._encodedOffset, _this.stride)), _this.crumbs.count);
while(true){
if(!((Int.$greaterThan(Int.$subtractWithOverflow(upperBound, lowerBound), 1)))) break
const mid = Int.$add(lowerBound, Int.$divide(Int.$subtractWithOverflow(upperBound, lowerBound), 2));
if((String.Index.$lessThanOrEqual(_this.crumbs.subscript$get(mid), idx))) {
lowerBound = mid;
}
else {
upperBound = mid;
};
};
const crumb = _cloneStruct(_this.crumbs.subscript$get(lowerBound));
return {0: crumb, 1: Int.$multiplyIgnoringOverflow(lowerBound, _this.stride)}
}

init$vars() {let _this = this;

}
}




class _KnownCocoaString{

static get storage() {return Object.assign(new _KnownCocoaString(), {rawValue: "storage", ...Array.from(arguments)})}

static get shared() {return Object.assign(new _KnownCocoaString(), {rawValue: "shared", ...Array.from(arguments)})}

static get cocoa() {return Object.assign(new _KnownCocoaString(), {rawValue: "cocoa", ...Array.from(arguments)})}

static get tagged() {return Object.assign(new _KnownCocoaString(), {rawValue: "tagged", ...Array.from(arguments)})}
/*Swift.(file)._KnownCocoaString.init(_:_CocoaString)*/
/*Swift.(file)._KnownCocoaString.init(_:_CocoaString)*/
init_CocoaString(str, $info?) {
throw 'unsupported method Swift.(file)._KnownCocoaString.init(_:_CocoaString) in ' + this.constructor.name
}
static /*Swift.(file)._KnownCocoaString.==(_:_KnownCocoaString,_:_KnownCocoaString)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file)._KnownCocoaString.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file)._KnownCocoaString.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file)._KnownCocoaString.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file)._KnownCocoaString.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(_KnownCocoaString, _DefaultEnumImplementation, false)


class CocoaStringPointer{

static ascii() {return Object.assign(new CocoaStringPointer(), {rawValue: "ascii", ...Array.from(arguments)})}

static utf8() {return Object.assign(new CocoaStringPointer(), {rawValue: "utf8", ...Array.from(arguments)})}

static utf16() {return Object.assign(new CocoaStringPointer(), {rawValue: "utf16", ...Array.from(arguments)})}

static get none() {return Object.assign(new CocoaStringPointer(), {rawValue: "none", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}
_mixin(CocoaStringPointer, _DefaultEnumImplementation, false)


class __SwiftNativeNSString{
/*Swift.(file).__SwiftNativeNSString.init()*/
/*Swift.(file).__SwiftNativeNSString.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSString.init() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class _StringComparisonResult{

static get equal() {return Object.assign(new _StringComparisonResult(), {rawValue: "equal", ...Array.from(arguments)})}

static get less() {return Object.assign(new _StringComparisonResult(), {rawValue: "less", ...Array.from(arguments)})}
/*Swift.(file)._StringComparisonResult.init(signedNotation:Int)*/
/*Swift.(file)._StringComparisonResult.init(signedNotation:Int)*/
initSignedNotationInt(int, $info?) {
throw 'unsupported method Swift.(file)._StringComparisonResult.init(signedNotation:Int) in ' + this.constructor.name
}
static /*Swift.(file)._StringComparisonResult.==infix(_:_StringComparisonResult,_:_StringComparisonResult)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}



/*Swift.(file)._StringComparisonResult.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file)._StringComparisonResult.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file)._StringComparisonResult.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file)._StringComparisonResult.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(_StringComparisonResult, _DefaultEnumImplementation, false)


class _StringGuts{
static readonly $struct = true





/*Swift.(file)._StringGuts.init(_:_StringObject)*/
/*Swift.(file)._StringGuts.init(_:_StringObject)*/
init_StringObject(object, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.init(_:_StringObject) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.init()*/
/*Swift.(file)._StringGuts.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._StringGuts.init() in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.getBreadcrumbsPtr()*/
/*Swift.(file)._StringGuts.getBreadcrumbsPtr()*/
getBreadcrumbsPtr($info?) {
throw 'unsupported method Swift.(file)._StringGuts.getBreadcrumbsPtr() in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.populateBreadcrumbs(_:UnsafeMutablePointer<_StringBreadcrumbs?>)*/
/*Swift.(file)._StringGuts.populateBreadcrumbs(_:UnsafeMutablePointer<_StringBreadcrumbs?>)*/
populateBreadcrumbs(mutPtr, $info?) {
let _this = this;
const crumbs = _create(_StringBreadcrumbs, 'initString', _create(String, 'init_StringGuts', _this, {}), {});
_stdlib_atomicInitializeARCRefObjectDesired(_create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', mutPtr, {}).assumingMemoryBoundTo(Optional), crumbs)
}

/*Swift.(file)._StringGuts.rawBits*/
rawBits$get() {
let _this = this;
return _this._object.rawBits
}
get rawBits() { return this.rawBits$get() };



/*Swift.(file)._StringGuts.init(_:_SmallString)*/
/*Swift.(file)._StringGuts.init(_:_SmallString)*/
init_SmallString(smol, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.init(_:_SmallString) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.init(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
/*Swift.(file)._StringGuts.init(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
initUnsafeBufferPointerIsASCIIBool(bufPtr, isASCII, $info?) {
let _this = this;
_this.init_StringObject(_create(_StringObject, 'initImmortalUnsafeBufferPointerIsASCIIBool', bufPtr, isASCII, {}));
return
}
/*Swift.(file)._StringGuts.init(_:__StringStorage)*/
/*Swift.(file)._StringGuts.init(_:__StringStorage)*/
init__StringStorage(storage, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.init(_:__StringStorage) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.init(_:__SharedStringStorage)*/
/*Swift.(file)._StringGuts.init(_:__SharedStringStorage)*/
init__SharedStringStorage(storage, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.init(_:__SharedStringStorage) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)*/
/*Swift.(file)._StringGuts.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)*/
initCocoaAnyObjectProvidesFastUTF8BoolIsASCIIBoolLengthInt(cocoa, providesFastUTF8, isASCII, _length, $info?) {
let _this = this;
_this.init_StringObject(_create(_StringObject, 'initCocoaAnyObjectProvidesFastUTF8BoolIsASCIIBoolLengthInt', cocoa, providesFastUTF8, isASCII, _length, {}));
return
}

/*Swift.(file)._StringGuts.count*/
count$get() {
let _this = this;
return _this._object.count
}
get count() { return this.count$get() };




/*Swift.(file)._StringGuts.isEmpty*/
isEmpty$get() {
let _this = this;
return Int.$equal(_this.count, 0)
}
get isEmpty() { return this.isEmpty$get() };




/*Swift.(file)._StringGuts.isSmall*/
isSmall$get() {
let _this = this;
return _this._object.isSmall
}
get isSmall() { return this.isSmall$get() };




/*Swift.(file)._StringGuts.isSmallASCII*/
isSmallASCII$get() {
let _this = this;
return Bool.$logicalAND(_this._object.isSmall, () => _this._object.smallIsASCII)
}
get isSmallASCII() { return this.isSmallASCII$get() };




/*Swift.(file)._StringGuts.asSmall*/
asSmall$get() {
let _this = this;
return _create(_SmallString, 'init_StringObject', _this._object, {})
}
get asSmall() { return this.asSmall$get() };




/*Swift.(file)._StringGuts.isASCII*/
isASCII$get() {
let _this = this;
return _this._object.isASCII
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file)._StringGuts.isFastASCII*/
isFastASCII$get() {
let _this = this;
return Bool.$logicalAND(_this.isFastUTF8, () => _this._object.isASCII)
}
get isFastASCII() { return this.isFastASCII$get() };




/*Swift.(file)._StringGuts.isNFC*/
isNFC$get() {
let _this = this;
return _this._object.isNFC
}
get isNFC() { return this.isNFC$get() };




/*Swift.(file)._StringGuts.isNFCFastUTF8*/
isNFCFastUTF8$get() {
let _this = this;
return Bool.$logicalAND(_this._object.isNFC, () => _this.isFastUTF8)
}
get isNFCFastUTF8() { return this.isNFCFastUTF8$get() };




/*Swift.(file)._StringGuts.hasNativeStorage*/
hasNativeStorage$get() {
let _this = this;
return _this._object.hasNativeStorage
}
get hasNativeStorage() { return this.hasNativeStorage$get() };




/*Swift.(file)._StringGuts.hasSharedStorage*/
hasSharedStorage$get() {
let _this = this;
return _this._object.hasSharedStorage
}
get hasSharedStorage() { return this.hasSharedStorage$get() };




/*Swift.(file)._StringGuts.hasBreadcrumbs*/
hasBreadcrumbs$get() {
let _this = this;
return Bool.$logicalOR(_this.hasNativeStorage, () => _this.hasSharedStorage)
}
get hasBreadcrumbs() { return this.hasBreadcrumbs$get() };




/*Swift.(file)._StringGuts.isFastUTF8*/
isFastUTF8$get() {
let _this = this;
return _fastPath(_this._object.providesFastUTF8)
}
get isFastUTF8() { return this.isFastUTF8$get() };




/*Swift.(file)._StringGuts.isForeign*/
isForeign$get() {
let _this = this;
return _slowPath(_this._object.isForeign)
}
get isForeign() { return this.isForeign$get() };



/*Swift.(file)._StringGuts.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
/*Swift.(file)._StringGuts.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
withFastUTF8<R>(f, $info?) {
let _this = this;
if((_this.isSmall)) {
return _create(_SmallString, 'init_StringObject', _this._object, {}).withUTF8(f);
};
let $defer = () => {
_fixLifetime(_this);
}
const $result = (() => {
try {;
return f(_this._object.fastUTF8);}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}
/*Swift.(file)._StringGuts.withFastUTF8(range:Range<Int>,_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
/*Swift.(file)._StringGuts.withFastUTF8(range:Range<Int>,_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
withFastUTF8Range<R>(range, f, $info?) {
let _this = this;
return _this.withFastUTF8(((wholeUTF8, $info?) => f(_create(UnsafeBufferPointer, 'initRebasingSlice', wholeUTF8.subscriptRange$get(range), {}))))
}
/*Swift.(file)._StringGuts.withFastCChar(_:(UnsafeBufferPointer<CChar>) throws -> R)*/
/*Swift.(file)._StringGuts.withFastCChar(_:(UnsafeBufferPointer<CChar>) throws -> R)*/
withFastCChar<R>(f, $info?) {
let _this = this;
return _this.withFastUTF8(((utf8, $info?) => { 
const ptr = _cloneStruct(utf8.baseAddress._unsafelyUnwrappedUnchecked._asCChar);
return f(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(ptr), utf8.count, {})); }))
}


/*Swift.(file)._StringGuts.withCString(_:(UnsafePointer<Int8>) throws -> Result)*/
/*Swift.(file)._StringGuts.withCString(_:(UnsafePointer<Int8>) throws -> Result)*/
withCString<Result>(body, $info?) {
let _this = this;
if((_slowPath(Bool.$not(_this._object.isFastZeroTerminated)))) {
return _this._slowWithCString(body);
};
return _this.withFastCChar((($0, $info?) => body($0.baseAddress._unsafelyUnwrappedUnchecked)))
}

/*Swift.(file)._StringGuts.copyUTF8(into:UnsafeMutableBufferPointer<UInt8>)*/
/*Swift.(file)._StringGuts.copyUTF8(into:UnsafeMutableBufferPointer<UInt8>)*/
copyUTF8Into(mbp, $info?) {
let _this = this;
const ptr = _cloneStruct(mbp.baseAddress._unsafelyUnwrappedUnchecked);
if((_fastPath(_this.isFastUTF8))) {
return _this.withFastUTF8(((utf8, $info?) => { 
if(!((Int.$lessThanOrEqual(utf8.count, mbp.count)))) {
return _injectIntoOptional(null);
};
const utf8Start = _cloneStruct(utf8.baseAddress._unsafelyUnwrappedUnchecked);
ptr.initializeFromCount(utf8Start, utf8.count);
return _injectIntoOptional(utf8.count); }));
};
return _this._foreignCopyUTF8Into(mbp)
}


/*Swift.(file)._StringGuts.utf8Count*/
utf8Count$get() {
let _this = this;
if((_fastPath(_this.isFastUTF8))) {
return _this.count;
};
return _create(String, 'init_StringGuts', _this, {}).utf8.count
}
get utf8Count() { return this.utf8Count$get() };





/*Swift.(file)._StringGuts.startIndex*/
startIndex$get() {
let _this = this;
return _create(_StringGuts.Index, 'init_encodedOffsetInt', 0, {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._StringGuts.endIndex*/
endIndex$get() {
let _this = this;
return _create(_StringGuts.Index, 'init_encodedOffsetInt', _this.count, {})
}
get endIndex() { return this.endIndex$get() };










/*Swift.(file)._StringGuts.startASCII*/
startASCII$get() {
let _this = this;
return _create(UnsafeMutablePointer, 'initMutatingUnsafePointer', _this._object.fastUTF8.baseAddress[0], {})
}
get startASCII() { return this.startASCII$get() };




/*Swift.(file)._StringGuts.startUTF16*/
startUTF16$get() {
let _this = this;
fatalErrorFileLine(() => "Not contiguous UTF-16", null, null)
}
get startUTF16() { return this.startUTF16$get() };




/*Swift.(file)._StringGuts.nativeCapacity*/
nativeCapacity$get() {
let _this = this;
if(!((_this.hasNativeStorage))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this._object.nativeStorage.capacity)
}
get nativeCapacity() { return this.nativeCapacity$get() };




/*Swift.(file)._StringGuts.nativeUnusedCapacity*/
nativeUnusedCapacity$get() {
let _this = this;
if(!((_this.hasNativeStorage))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this._object.nativeStorage.unusedCapacity)
}
get nativeUnusedCapacity() { return this.nativeUnusedCapacity$get() };




/*Swift.(file)._StringGuts.uniqueNativeCapacity*/
uniqueNativeCapacity$get() {
let _this = this;
if(!((_this.isUniqueNative))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this._object.nativeStorage.capacity)
}
get uniqueNativeCapacity() { return this.uniqueNativeCapacity$get() };




/*Swift.(file)._StringGuts.uniqueNativeUnusedCapacity*/
uniqueNativeUnusedCapacity$get() {
let _this = this;
if(!((_this.isUniqueNative))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this._object.nativeStorage.unusedCapacity)
}
get uniqueNativeUnusedCapacity() { return this.uniqueNativeUnusedCapacity$get() };




/*Swift.(file)._StringGuts.isUniqueNative*/
isUniqueNative$get() {
let _this = this;
if(!((_this.hasNativeStorage))) {
return false;
};
let $defer = () => {
_fixLifetime(_this);
}
const $result = (() => {
try {;
let bits = _this._object.largeAddressBits;
return _isUnique_native({get: () => bits, set: $val => bits = $val});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}
get isUniqueNative() { return this.isUniqueNative$get() };



/*Swift.(file)._StringGuts.init(_initialCapacity:Int)*/
/*Swift.(file)._StringGuts.init(_initialCapacity:Int)*/
init_initialCapacityInt(capacity, $info?) {
let _this = this;
_this.init( {});
if((_slowPath(Int.$greaterThan(capacity, _SmallString.capacity)))) {
_this.grow(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
};
return
}
/*Swift.(file)._StringGuts.reserveCapacity(_:Int)*/
/*Swift.(file)._StringGuts.reserveCapacity(_:Int)*/
reserveCapacity(n, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.reserveCapacity(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.grow(_:Int)*/
/*Swift.(file)._StringGuts.grow(_:Int)*/
grow(n, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.grow(_:Int) in ' + this.constructor.name
}

/*Swift.(file)._StringGuts.prepareForAppendInPlace(otherUTF8Count:Int)*/
/*Swift.(file)._StringGuts.prepareForAppendInPlace(otherUTF8Count:Int)*/
prepareForAppendInPlaceOtherUTF8Count(otherCount, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.prepareForAppendInPlace(otherUTF8Count:Int) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.append(_:_StringGuts)*/
/*Swift.(file)._StringGuts.append(_:_StringGuts)*/
append(other, $info?) {
let _this = this;
if((Bool.$logicalAND(_this.isSmall, () => other.isSmall))) {
const $ifLet0, smol_1
if((($ifLet0 = _create(_SmallString, 'init_SmallStringAppending_SmallString', _this.asSmall, other.asSmall, {}))||true) && $ifLet0.rawValue == 'some' && ((smol_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init_SmallString', smol_1, {})));
return ;
};
};
_this.append(_create(_StringGutsSlice, 'init_StringGuts', other, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file)._StringGuts.append(_:_StringGutsSlice)*/
/*Swift.(file)._StringGuts.append(_:_StringGutsSlice)*/
/*!!!DUPLICATE NAME*/
append(slicedOther, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.append(_:_StringGutsSlice) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
/*Swift.(file)._StringGuts.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
appendInPlaceIsASCII(other, isASCII, $info?) {
let _this = this;
_this._object.nativeStorage.appendInPlaceIsASCII(other, isASCII);
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init__StringStorage', _this._object.nativeStorage, {})))
}

/*Swift.(file)._StringGuts.clear()*/
/*Swift.(file)._StringGuts.clear()*/
clear($info?) {
let _this = this;
if(!((_this.isUniqueNative))) {
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init', {})));
return ;
};
_this._object.nativeStorage.clear( {});
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init__StringStorage', _this._object.nativeStorage, {})))
}
/*Swift.(file)._StringGuts.remove(from:_StringGuts.Index,to:_StringGuts.Index)*/
/*Swift.(file)._StringGuts.remove(from:_StringGuts.Index,to:_StringGuts.Index)*/
removeFromTo(lower, upper, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.remove(from:_StringGuts.Index,to:_StringGuts.Index) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.replaceSubrange(_:Range<_StringGuts.Index>,with:C)*/
/*Swift.(file)._StringGuts.replaceSubrange(_:Range<_StringGuts.Index>,with:C)*/
replaceSubrangeWith<C>(bounds, newElements, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.replaceSubrange(_:Range<_StringGuts.Index>,with:C) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:Range<_StringGuts.Index>,with:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
/*Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:Range<_StringGuts.Index>,with:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
uniqueNativeReplaceSubrangeWithIsASCII(bounds, codeUnits, isASCII, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:Range<_StringGuts.Index>,with:UnsafeBufferPointer<UInt8>,isASCII:Bool) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:Range<_StringGuts.Index>,with:C)*/
/*Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:Range<_StringGuts.Index>,with:C)*/
uniqueNativeReplaceSubrangeWith<C>(bounds, codeUnits, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:Range<_StringGuts.Index>,with:C) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.foreignHasNormalizationBoundary(before:String.Index)*/
/*Swift.(file)._StringGuts.foreignHasNormalizationBoundary(before:String.Index)*/
foreignHasNormalizationBoundaryBefore(index, $info?) {
let _this = this;
const offset = index._encodedOffset;
if((Bool.$logicalOR(Int.$equal(offset, 0), () => Int.$equal(offset, _this.count)))) {
return true;
};
const scalar = _cloneStruct(_this.foreignErrorCorrectedScalarStartingAt(index)["0"]);
return scalar._hasNormalizationBoundaryBefore
}

/*Swift.(file)._StringGuts.scalarAlign(_:_StringGuts.Index)*/
/*Swift.(file)._StringGuts.scalarAlign(_:_StringGuts.Index)*/
scalarAlign(idx, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.scalarAlign(_:_StringGuts.Index) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.fastUTF8ScalarLength(startingAt:Int)*/
/*Swift.(file)._StringGuts.fastUTF8ScalarLength(startingAt:Int)*/
fastUTF8ScalarLengthStartingAt(i, $info?) {
let _this = this;
const len = _utf8ScalarLength(_this.withFastUTF8((($0, $info?) => $0.subscript$get(i))));
return len
}
/*Swift.(file)._StringGuts.fastUTF8ScalarLength(endingAt:Int)*/
/*Swift.(file)._StringGuts.fastUTF8ScalarLength(endingAt:Int)*/
fastUTF8ScalarLengthEndingAt(i, $info?) {
let _this = this;
return _this.withFastUTF8(((utf8, $info?) => { 
let len = 1;
while(true){
if(!((UTF8.isContinuation(utf8.subscript$get(Int.$subtractWithOverflow(i, len)))))) break
Int.$addAndAssign({get: () => len, set: $val => len = $val}, 1);
};
return len; }))
}
/*Swift.(file)._StringGuts.fastUTF8Scalar(startingAt:Int)*/
/*Swift.(file)._StringGuts.fastUTF8Scalar(startingAt:Int)*/
fastUTF8ScalarStartingAt(i, $info?) {
let _this = this;
return _this.withFastUTF8((($0, $info?) => _decodeScalarStartingAt($0, i)["0"]))
}
/*Swift.(file)._StringGuts.isOnUnicodeScalarBoundary(_:String.Index)*/
/*Swift.(file)._StringGuts.isOnUnicodeScalarBoundary(_:String.Index)*/
isOnUnicodeScalarBoundary(i, $info?) {
let _this = this;
if(!((Int.$equal(i.transcodedOffset, 0)))) {
return false;
};
if((Bool.$logicalOR(String.Index.$equal(i, _this.startIndex), () => String.Index.$equal(i, _this.endIndex)))) {
return true;
};
if((_fastPath(_this.isFastUTF8))) {
return _this.withFastUTF8((($0, $info?) => Bool.$not(UTF8.isContinuation($0.subscript$get(i._encodedOffset)))));
};
return String.Index.$equal(i, _this.foreignScalarAlign(i))
}

/*Swift.(file)._StringGuts.foreignErrorCorrectedScalar(startingAt:String.Index)*/
/*Swift.(file)._StringGuts.foreignErrorCorrectedScalar(startingAt:String.Index)*/
foreignErrorCorrectedScalarStartingAt(idx, $info?) {
let _this = this;
const start = idx._encodedOffset;
const leading = _this._getForeignCodeUnitAt(start);
if((_fastPath(Bool.$not(UTF16.isSurrogate(leading))))) {
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', _create(UInt32, 'initT', leading, {}), {}), 1: 1};
};
const nextOffset = Int.$addWithOverflow(start, 1);
if((_slowPath(Bool.$logicalOR(UTF16.isTrailSurrogate(leading), () => Int.$equal(nextOffset, _this.count))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
const trailing = _this._getForeignCodeUnitAt(nextOffset);
if((_slowPath(Bool.$not(UTF16.isTrailSurrogate(trailing))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
return {0: UTF16._decodeSurrogates(leading, trailing), 1: 2}
}
/*Swift.(file)._StringGuts.foreignErrorCorrectedScalar(endingAt:String.Index)*/
/*Swift.(file)._StringGuts.foreignErrorCorrectedScalar(endingAt:String.Index)*/
foreignErrorCorrectedScalarEndingAt(idx, $info?) {
let _this = this;
const end = idx._encodedOffset;
const trailing = _this._getForeignCodeUnitAt(Int.$subtractWithOverflow(end, 1));
if((_fastPath(Bool.$not(UTF16.isSurrogate(trailing))))) {
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', _create(UInt32, 'initT', trailing, {}), {}), 1: 1};
};
const priorOffset = Int.$subtractWithOverflow(end, 2);
if((_slowPath(Bool.$logicalOR(UTF16.isLeadSurrogate(trailing), () => Int.$lessThan(priorOffset, 0))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
const leading = _this._getForeignCodeUnitAt(priorOffset);
if((_slowPath(Bool.$not(UTF16.isLeadSurrogate(leading))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
return {0: UTF16._decodeSurrogates(leading, trailing), 1: 2}
}
/*Swift.(file)._StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:String.Index)*/
/*Swift.(file)._StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:String.Index)*/
foreignErrorCorrectedUTF16CodeUnitAt(idx, $info?) {
let _this = this;
const start = idx._encodedOffset;
const cu = _this._getForeignCodeUnitAt(start);
if((_fastPath(Bool.$not(UTF16.isSurrogate(cu))))) {
return cu;
};
if((UTF16.isLeadSurrogate(cu))) {
const nextOffset = Int.$addWithOverflow(start, 1);
if(!((Int.$lessThan(nextOffset, _this.count)) && (UTF16.isTrailSurrogate(_this._getForeignCodeUnitAt(nextOffset))))) {
return UTF16._replacementCodeUnit;
};
}
else {
const priorOffset = Int.$subtractWithOverflow(start, 1);
if(!((Int.$greaterThanOrEqual(priorOffset, 0)) && (UTF16.isLeadSurrogate(_this._getForeignCodeUnitAt(priorOffset))))) {
return UTF16._replacementCodeUnit;
};
};
return cu
}
/*Swift.(file)._StringGuts.foreignScalarAlign(_:_StringGuts.Index)*/
/*Swift.(file)._StringGuts.foreignScalarAlign(_:_StringGuts.Index)*/
foreignScalarAlign(idx, $info?) {
throw 'unsupported method Swift.(file)._StringGuts.foreignScalarAlign(_:_StringGuts.Index) in ' + this.constructor.name
}
/*Swift.(file)._StringGuts.foreignErrorCorrectedGrapheme(startingAt:Int,endingAt:Int)*/
/*Swift.(file)._StringGuts.foreignErrorCorrectedGrapheme(startingAt:Int,endingAt:Int)*/
foreignErrorCorrectedGraphemeStartingAtEndingAt(start, end, $info?) {
let _this = this;
const count = Int.$subtractWithOverflow(end, start);
if((Int.$equal(Int.$subtractWithOverflow(start, end), 1))) {
return _create(Character, 'initString', _create(String, 'initUnicodeScalar', _this.foreignErrorCorrectedScalarStartingAt(_create(String.Index, 'init_encodedOffsetInt', start, {}))["0"], {}), {});
};
let cus = _create(Array, 'initRepeatingCountInt', 0, count, {});
cus.withUnsafeMutableBufferPointer((($0$inout, $info?) => _cocoaStringCopyCharactersFromRangeInto(_this._object.cocoaObject, Int.$halfOpenRange(start, end), $0.baseAddress._unsafelyUnwrappedUnchecked)), {$setThis: $val => cus = $val});
return cus.withUnsafeBufferPointer((($0, $info?) => _create(Character, 'initString', String._uncheckedFromUTF16($0), {})))
}
/*Swift.(file)._StringGuts.errorCorrectedScalar(startingAt:Int)*/
/*Swift.(file)._StringGuts.errorCorrectedScalar(startingAt:Int)*/
errorCorrectedScalarStartingAt(i, $info?) {
let _this = this;
if((_fastPath(_this.isFastUTF8))) {
return _this.withFastUTF8((($0, $info?) => _decodeScalarStartingAt($0, i)));
};
return _this.foreignErrorCorrectedScalarStartingAt(_create(String.Index, 'init_encodedOffsetInt', i, {}))
}
/*Swift.(file)._StringGuts.errorCorrectedCharacter(startingAt:Int,endingAt:Int)*/
/*Swift.(file)._StringGuts.errorCorrectedCharacter(startingAt:Int,endingAt:Int)*/
errorCorrectedCharacterStartingAtEndingAt(start, end, $info?) {
let _this = this;
if((_fastPath(_this.isFastUTF8))) {
return _this.withFastUTF8Range(Int.$halfOpenRange(start, end), ((utf8, $info?) => _create(Character, 'initUncheckedString', String._uncheckedFromUTF8(utf8), {})));
};
return _this.foreignErrorCorrectedGraphemeStartingAtEndingAt(start, end)
}
/*Swift.(file)._StringGuts.isOnGraphemeClusterBoundary(_:String.Index)*/
/*Swift.(file)._StringGuts.isOnGraphemeClusterBoundary(_:String.Index)*/
isOnGraphemeClusterBoundary(i, $info?) {
let _this = this;
if(!((Int.$equal(i.transcodedOffset, 0)))) {
return false;
};
const offset = i._encodedOffset;
if((Bool.$logicalOR(Int.$equal(offset, 0), () => Int.$equal(offset, _this.count)))) {
return true;
};
if(!((_this.isOnUnicodeScalarBoundary(i)))) {
return false;
};
const str = _create(String, 'init_StringGuts', _this, {});
return String.Index.$equal(i, str.indexBefore(str.indexAfter(i)))
}




init$vars() {let _this = this;

}
}




































class _StringGutsSlice{
static readonly $struct = true










/*Swift.(file)._StringGutsSlice.init(_:_StringGuts)*/
/*Swift.(file)._StringGutsSlice.init(_:_StringGuts)*/
init_StringGuts(guts, $info?) {
throw 'unsupported method Swift.(file)._StringGutsSlice.init(_:_StringGuts) in ' + this.constructor.name
}
/*Swift.(file)._StringGutsSlice.init(_:_StringGuts,_:Range<Int>)*/
/*Swift.(file)._StringGutsSlice.init(_:_StringGuts,_:Range<Int>)*/
init_StringGutsRange(guts, offsetRange, $info?) {
throw 'unsupported method Swift.(file)._StringGutsSlice.init(_:_StringGuts,_:Range<Int>) in ' + this.constructor.name
}

/*Swift.(file)._StringGutsSlice.start*/
start$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.start in ' + this.constructor.name
}
get start() { return this.start$get() };




/*Swift.(file)._StringGutsSlice.end*/
end$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.end in ' + this.constructor.name
}
get end() { return this.end$get() };




/*Swift.(file)._StringGutsSlice.count*/
count$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.count in ' + this.constructor.name
}
get count() { return this.count$get() };




/*Swift.(file)._StringGutsSlice.isNFCFastUTF8*/
isNFCFastUTF8$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.isNFCFastUTF8 in ' + this.constructor.name
}
get isNFCFastUTF8() { return this.isNFCFastUTF8$get() };




/*Swift.(file)._StringGutsSlice.isASCII*/
isASCII$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.isASCII in ' + this.constructor.name
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file)._StringGutsSlice.isFastUTF8*/
isFastUTF8$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.isFastUTF8 in ' + this.constructor.name
}
get isFastUTF8() { return this.isFastUTF8$get() };




/*Swift.(file)._StringGutsSlice.utf8Count*/
utf8Count$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.utf8Count in ' + this.constructor.name
}
get utf8Count() { return this.utf8Count$get() };




/*Swift.(file)._StringGutsSlice.range*/
range$get() {
throw 'unsupported variable Swift.(file)._StringGutsSlice.range in ' + this.constructor.name
}
get range() { return this.range$get() };



/*Swift.(file)._StringGutsSlice.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
/*Swift.(file)._StringGutsSlice.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
withFastUTF8<R>(f, $info?) {
throw 'unsupported method Swift.(file)._StringGutsSlice.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._StringGutsSlice.foreignErrorCorrectedScalar(startingAt:String.Index)*/
/*Swift.(file)._StringGutsSlice.foreignErrorCorrectedScalar(startingAt:String.Index)*/
foreignErrorCorrectedScalarStartingAt(idx, $info?) {
throw 'unsupported method Swift.(file)._StringGutsSlice.foreignErrorCorrectedScalar(startingAt:String.Index) in ' + this.constructor.name
}
/*Swift.(file)._StringGutsSlice.foreignHasNormalizationBoundary(before:String.Index)*/
/*Swift.(file)._StringGutsSlice.foreignHasNormalizationBoundary(before:String.Index)*/
foreignHasNormalizationBoundaryBefore(index, $info?) {
throw 'unsupported method Swift.(file)._StringGutsSlice.foreignHasNormalizationBoundary(before:String.Index) in ' + this.constructor.name
}



/*Swift.(file)._StringGutsSlice.compare(with:_StringGutsSlice,expecting:_StringComparisonResult)*/
/*Swift.(file)._StringGutsSlice.compare(with:_StringGutsSlice,expecting:_StringComparisonResult)*/
compareWithExpecting(other, expecting, $info?) {
throw 'unsupported method Swift.(file)._StringGutsSlice.compare(with:_StringGutsSlice,expecting:_StringComparisonResult) in ' + this.constructor.name
}


init$vars() {let _this = this;

}
}


class _StringObject{
static readonly $struct = true
static Nibbles = class{

/*Swift.(file)._StringObject.Nibbles.emptyString*/
static emptyString$get() {
let _this = this;
return _StringObject.Nibbles.smallIsASCII(true);
}
static get emptyString() { return this.emptyString$get()
}
static get emptyString() { return this.emptyString$get() };




/*Swift.(file)._StringObject.Nibbles.largeAddressMask*/
static largeAddressMask$get() {
let _this = this;
return 0x0FFFFFFFFFFFFFFF;
}
static get largeAddressMask() { return this.largeAddressMask$get()
}
static get largeAddressMask() { return this.largeAddressMask$get() };




/*Swift.(file)._StringObject.Nibbles.discriminatorMask*/
static discriminatorMask$get() {
let _this = this;
return UInt64.$bitwiseNot(_this.largeAddressMask);
}
static get discriminatorMask() { return this.discriminatorMask$get()
}
static get discriminatorMask() { return this.discriminatorMask$get() };



static /*Swift.(file)._StringObject.Nibbles.small(isASCII:Bool)*/
/*Swift.(file)._StringObject.Nibbles.small(isASCII:Bool)*/
smallIsASCII(isASCII, $info?) {
let _this = this;
return (isASCII ? 0xE000000000000000 : 0xA000000000000000)
}
static /*Swift.(file)._StringObject.Nibbles.small(withCount:Int,isASCII:Bool)*/
/*Swift.(file)._StringObject.Nibbles.small(withCount:Int,isASCII:Bool)*/
smallWithCountIsASCII(count, isASCII, $info?) {
let _this = this;
return UInt64.$bitwiseOR(_this.smallIsASCII(isASCII), UInt64.infix_38_60_60(_create(UInt64, 'initTruncatingIfNeeded', count, {}), 56))
}
static /*Swift.(file)._StringObject.Nibbles.largeImmortal()*/
/*Swift.(file)._StringObject.Nibbles.largeImmortal()*/
largeImmortal($info?) {
let _this = this;
return 0x8000000000000000
}
static /*Swift.(file)._StringObject.Nibbles.largeMortal()*/
/*Swift.(file)._StringObject.Nibbles.largeMortal()*/
largeMortal($info?) {
let _this = this;
return 0x0000000000000000
}
static /*Swift.(file)._StringObject.Nibbles.largeCocoa(providesFastUTF8:Bool)*/
/*Swift.(file)._StringObject.Nibbles.largeCocoa(providesFastUTF8:Bool)*/
largeCocoaProvidesFastUTF8(providesFastUTF8, $info?) {
let _this = this;
return (providesFastUTF8 ? 0x4000000000000000 : 0x5000000000000000)
}
init$vars() {let _this = this;

}
}
static CountAndFlags = class{
static readonly $struct = true





/*Swift.(file)._StringObject.CountAndFlags.init(zero:())*/
/*Swift.(file)._StringObject.CountAndFlags.init(zero:())*/
initZerotuple_type(zero, $info?) {
throw 'unsupported method Swift.(file)._StringObject.CountAndFlags.init(zero:()) in ' + this.constructor.name
}


/*Swift.(file)._StringObject.CountAndFlags.rawBits*/
rawBits$get() {
let _this = this;
return _this._storage
}
get rawBits() { return this.rawBits$get() };



/*Swift.(file)._StringObject.CountAndFlags.init(rawUnchecked:_StringObject.CountAndFlags.RawBitPattern)*/
/*Swift.(file)._StringObject.CountAndFlags.init(rawUnchecked:_StringObject.CountAndFlags.RawBitPattern)*/
initRawUnchecked_StringObjectCountAndFlagsRawBitPattern(bits, $info?) {
let _this = this;
_this._storage = bits;
return
}
/*Swift.(file)._StringObject.CountAndFlags.init(raw:_StringObject.CountAndFlags.RawBitPattern)*/
/*Swift.(file)._StringObject.CountAndFlags.init(raw:_StringObject.CountAndFlags.RawBitPattern)*/
initRaw_StringObjectCountAndFlagsRawBitPattern(bits, $info?) {
let _this = this;
_this.initRawUnchecked_StringObjectCountAndFlagsRawBitPattern(bits);
_this._invariantCheck( {});
return
}

/*Swift.(file)._StringObject.CountAndFlags.countMask*/
static countMask$get() {
let _this = this;
return 0x0000FFFFFFFFFFFF;
}
static get countMask() { return this.countMask$get()
}
static get countMask() { return this.countMask$get() };




/*Swift.(file)._StringObject.CountAndFlags.flagsMask*/
static flagsMask$get() {
let _this = this;
return UInt64.$bitwiseNot(_this.countMask);
}
static get flagsMask() { return this.flagsMask$get()
}
static get flagsMask() { return this.flagsMask$get() };




/*Swift.(file)._StringObject.CountAndFlags.isASCIIMask*/
static isASCIIMask$get() {
let _this = this;
return 0x8000000000000000;
}
static get isASCIIMask() { return this.isASCIIMask$get()
}
static get isASCIIMask() { return this.isASCIIMask$get() };




/*Swift.(file)._StringObject.CountAndFlags.isNFCMask*/
static isNFCMask$get() {
let _this = this;
return 0x4000000000000000;
}
static get isNFCMask() { return this.isNFCMask$get()
}
static get isNFCMask() { return this.isNFCMask$get() };




/*Swift.(file)._StringObject.CountAndFlags.isNativelyStoredMask*/
static isNativelyStoredMask$get() {
let _this = this;
return 0x2000000000000000;
}
static get isNativelyStoredMask() { return this.isNativelyStoredMask$get()
}
static get isNativelyStoredMask() { return this.isNativelyStoredMask$get() };




/*Swift.(file)._StringObject.CountAndFlags.isTailAllocatedMask*/
static isTailAllocatedMask$get() {
let _this = this;
return 0x1000000000000000;
}
static get isTailAllocatedMask() { return this.isTailAllocatedMask$get()
}
static get isTailAllocatedMask() { return this.isTailAllocatedMask$get() };



/*Swift.(file)._StringObject.CountAndFlags.init(count:Int,isASCII:Bool,isNFC:Bool,isNativelyStored:Bool,isTailAllocated:Bool)*/
/*Swift.(file)._StringObject.CountAndFlags.init(count:Int,isASCII:Bool,isNFC:Bool,isNativelyStored:Bool,isTailAllocated:Bool)*/
initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool(count, isASCII, isNFC, isNativelyStored, isTailAllocated, $info?) {
let _this = this;
let rawBits = _create(UInt64, 'initTruncatingIfNeeded', count, {});
if((isASCII)) {
UInt64.$bitwiseORAndAssign({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isASCIIMask);
};
if((isNFC)) {
UInt64.$bitwiseORAndAssign({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isNFCMask);
};
if((isNativelyStored)) {
UInt64.$bitwiseORAndAssign({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isNativelyStoredMask);
};
if((isTailAllocated)) {
UInt64.$bitwiseORAndAssign({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isTailAllocatedMask);
};
_this.initRaw_StringObjectCountAndFlagsRawBitPattern(rawBits);
return
}
/*Swift.(file)._StringObject.CountAndFlags.init(count:Int,flags:UInt16)*/
/*Swift.(file)._StringObject.CountAndFlags.init(count:Int,flags:UInt16)*/
initCountIntFlagsUInt16(count, flags, $info?) {
let _this = this;
const rawBits = UInt64.$bitwiseOR(UInt64.infix_38_60_60(_create(UInt64, 'initTruncatingIfNeeded', flags, {}), 48), _create(UInt64, 'initTruncatingIfNeeded', count, {}));
_this.initRaw_StringObjectCountAndFlagsRawBitPattern(rawBits);
return
}
/*Swift.(file)._StringObject.CountAndFlags.init(immortalCount:Int,isASCII:Bool)*/
/*Swift.(file)._StringObject.CountAndFlags.init(immortalCount:Int,isASCII:Bool)*/
initImmortalCountIntIsASCIIBool(immortalCount, isASCII, $info?) {
let _this = this;
_this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool(immortalCount, isASCII, isASCII, false, true);
return
}
/*Swift.(file)._StringObject.CountAndFlags.init(mortalCount:Int,isASCII:Bool)*/
/*Swift.(file)._StringObject.CountAndFlags.init(mortalCount:Int,isASCII:Bool)*/
initMortalCountIntIsASCIIBool(mortalCount, isASCII, $info?) {
let _this = this;
_this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool(mortalCount, isASCII, isASCII, true, true);
return
}
/*Swift.(file)._StringObject.CountAndFlags.init(sharedCount:Int,isASCII:Bool)*/
/*Swift.(file)._StringObject.CountAndFlags.init(sharedCount:Int,isASCII:Bool)*/
initSharedCountIntIsASCIIBool(sharedCount, isASCII, $info?) {
let _this = this;
_this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool(sharedCount, isASCII, isASCII, false, false);
return
}

/*Swift.(file)._StringObject.CountAndFlags.count*/
count$get() {
let _this = this;
return _create(Int, 'initTruncatingIfNeeded', UInt64.$bitwiseAND(_this._storage, _StringObject.CountAndFlags.countMask), {})
}
get count() { return this.count$get() };




/*Swift.(file)._StringObject.CountAndFlags.flags*/
flags$get() {
let _this = this;
return _create(UInt16, 'initTruncatingIfNeeded', UInt64.infix_38_62_62(_this._storage, 48), {})
}
get flags() { return this.flags$get() };




/*Swift.(file)._StringObject.CountAndFlags.isASCII*/
isASCII$get() {
let _this = this;
return Int.$notEqual(0, UInt64.$bitwiseAND(_this._storage, _StringObject.CountAndFlags.isASCIIMask))
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file)._StringObject.CountAndFlags.isNFC*/
isNFC$get() {
let _this = this;
return Int.$notEqual(0, UInt64.$bitwiseAND(_this._storage, _StringObject.CountAndFlags.isNFCMask))
}
get isNFC() { return this.isNFC$get() };




/*Swift.(file)._StringObject.CountAndFlags.isNativelyStored*/
isNativelyStored$get() {
let _this = this;
return Int.$notEqual(0, UInt64.$bitwiseAND(_this._storage, _StringObject.CountAndFlags.isNativelyStoredMask))
}
get isNativelyStored() { return this.isNativelyStored$get() };




/*Swift.(file)._StringObject.CountAndFlags.isTailAllocated*/
isTailAllocated$get() {
let _this = this;
return Int.$notEqual(0, UInt64.$bitwiseAND(_this._storage, _StringObject.CountAndFlags.isTailAllocatedMask))
}
get isTailAllocated() { return this.isTailAllocated$get() };




init$vars() {let _this = this;

}
}










/*Swift.(file)._StringObject.init(zero:())*/
/*Swift.(file)._StringObject.init(zero:())*/
initZerotuple_type(zero, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(zero:()) in ' + this.constructor.name
}





/*Swift.(file)._StringObject.rawBits*/
rawBits$get() {
let _this = this;
return {0: _this._countAndFlagsBits, 1: _this.discriminatedObjectRawBits}
}
get rawBits() { return this.rawBits$get() };



/*Swift.(file)._StringObject.init(bridgeObject:BridgeObject,countAndFlags:_StringObject.CountAndFlags)*/
/*Swift.(file)._StringObject.init(bridgeObject:BridgeObject,countAndFlags:_StringObject.CountAndFlags)*/
initBridgeObjectBridgeObjectCountAndFlags_StringObjectCountAndFlags(bridgeObject, countAndFlags, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(bridgeObject:BridgeObject,countAndFlags:_StringObject.CountAndFlags) in ' + this.constructor.name
}
/*Swift.(file)._StringObject.init(object:AnyObject,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags)*/
/*Swift.(file)._StringObject.init(object:AnyObject,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags)*/
initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(object, discriminator, countAndFlags, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(object:AnyObject,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags) in ' + this.constructor.name
}
/*Swift.(file)._StringObject.init(pointerBits:UInt64,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags)*/
/*Swift.(file)._StringObject.init(pointerBits:UInt64,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags)*/
initPointerBitsUInt64DiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(pointerBits, discriminator, countAndFlags, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(pointerBits:UInt64,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags) in ' + this.constructor.name
}
/*Swift.(file)._StringObject.init(rawUncheckedValue:_StringObject.RawBitPattern)*/
/*Swift.(file)._StringObject.init(rawUncheckedValue:_StringObject.RawBitPattern)*/
initRawUncheckedValue_StringObjectRawBitPattern(bits, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(rawUncheckedValue:_StringObject.RawBitPattern) in ' + this.constructor.name
}
/*Swift.(file)._StringObject.init(rawValue:_StringObject.RawBitPattern)*/
/*Swift.(file)._StringObject.init(rawValue:_StringObject.RawBitPattern)*/
initRawValue_StringObjectRawBitPattern(bits, $info?) {
let _this = this;
_this.initRawUncheckedValue_StringObjectRawBitPattern(bits);
_this._invariantCheck( {});
return
}

/*Swift.(file)._StringObject.discriminatedObjectRawBits*/
discriminatedObjectRawBits$get() {
throw 'unsupported variable Swift.(file)._StringObject.discriminatedObjectRawBits in ' + this.constructor.name
}
get discriminatedObjectRawBits() { return this.discriminatedObjectRawBits$get() };




/*Swift.(file)._StringObject.nativeBias*/
static nativeBias$get() {
let _this = this;
return 32;
}
static get nativeBias() { return this.nativeBias$get()
}
static get nativeBias() { return this.nativeBias$get() };




/*Swift.(file)._StringObject.isImmortal*/
isImmortal$get() {
let _this = this;
return UInt64.$notEqual(UInt64.$bitwiseAND(_this.discriminatedObjectRawBits, 0x8000000000000000), 0)
}
get isImmortal() { return this.isImmortal$get() };




/*Swift.(file)._StringObject.isMortal*/
isMortal$get() {
let _this = this;
return Bool.$not(_this.isImmortal)
}
get isMortal() { return this.isMortal$get() };




/*Swift.(file)._StringObject.isSmall*/
isSmall$get() {
let _this = this;
return UInt64.$notEqual(UInt64.$bitwiseAND(_this.discriminatedObjectRawBits, 0x2000000000000000), 0)
}
get isSmall() { return this.isSmall$get() };




/*Swift.(file)._StringObject.isLarge*/
isLarge$get() {
let _this = this;
return Bool.$not(_this.isSmall)
}
get isLarge() { return this.isLarge$get() };




/*Swift.(file)._StringObject.providesFastUTF8*/
providesFastUTF8$get() {
let _this = this;
return UInt64.$equal(UInt64.$bitwiseAND(_this.discriminatedObjectRawBits, 0x1000000000000000), 0)
}
get providesFastUTF8() { return this.providesFastUTF8$get() };




/*Swift.(file)._StringObject.isForeign*/
isForeign$get() {
let _this = this;
return Bool.$not(_this.providesFastUTF8)
}
get isForeign() { return this.isForeign$get() };




/*Swift.(file)._StringObject.hasStorage*/
hasStorage$get() {
let _this = this;
return UInt64.$equal(UInt64.$bitwiseAND(_this.discriminatedObjectRawBits, 0xF000000000000000), 0)
}
get hasStorage() { return this.hasStorage$get() };




/*Swift.(file)._StringObject.hasNativeStorage*/
hasNativeStorage$get() {
let _this = this;
const bits = UInt64.$bitwiseAND(UInt64.$bitwiseNot(_this.discriminatedObjectRawBits), _this._countAndFlagsBits);
const result = UInt64.$notEqual(UInt64.$bitwiseAND(bits, 0x2000000000000000), 0);
return result
}
get hasNativeStorage() { return this.hasNativeStorage$get() };




/*Swift.(file)._StringObject.hasSharedStorage*/
hasSharedStorage$get() {
let _this = this;
return Bool.$logicalAND(_this.hasStorage, () => Bool.$not(_this.hasNativeStorage))
}
get hasSharedStorage() { return this.hasSharedStorage$get() };




/*Swift.(file)._StringObject.largeFastIsTailAllocated*/
largeFastIsTailAllocated$get() {
let _this = this;
return _this._countAndFlags.isTailAllocated
}
get largeFastIsTailAllocated() { return this.largeFastIsTailAllocated$get() };




/*Swift.(file)._StringObject.largeFastIsShared*/
largeFastIsShared$get() {
let _this = this;
return Bool.$not(_this.largeFastIsTailAllocated)
}
get largeFastIsShared() { return this.largeFastIsShared$get() };




/*Swift.(file)._StringObject.largeIsCocoa*/
largeIsCocoa$get() {
let _this = this;
return UInt64.$notEqual(UInt64.$bitwiseAND(_this.discriminatedObjectRawBits, 0x4000000000000000), 0)
}
get largeIsCocoa() { return this.largeIsCocoa$get() };




/*Swift.(file)._StringObject.isPreferredRepresentation*/
isPreferredRepresentation$get() {
let _this = this;
return _fastPath(Bool.$logicalOR(_this.isSmall, () => _this._countAndFlags.isTailAllocated))
}
get isPreferredRepresentation() { return this.isPreferredRepresentation$get() };



/*Swift.(file)._StringObject.init(_:_SmallString)*/
/*Swift.(file)._StringObject.init(_:_SmallString)*/
init_SmallString(small, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(_:_SmallString) in ' + this.constructor.name
}
static /*Swift.(file)._StringObject.getSmallCount(fromRaw:UInt64)*/
/*Swift.(file)._StringObject.getSmallCount(fromRaw:UInt64)*/
getSmallCountFromRaw(x, $info?) {
let _this = this;
return _create(Int, 'initTruncatingIfNeeded', UInt64.infix_38_62_62(UInt64.$bitwiseAND(x, 0x0F00000000000000), 56), {})
}

/*Swift.(file)._StringObject.smallCount*/
smallCount$get() {
let _this = this;
return _StringObject.getSmallCountFromRaw(_this.discriminatedObjectRawBits)
}
get smallCount() { return this.smallCount$get() };



static /*Swift.(file)._StringObject.getSmallIsASCII(fromRaw:UInt64)*/
/*Swift.(file)._StringObject.getSmallIsASCII(fromRaw:UInt64)*/
getSmallIsASCIIFromRaw(x, $info?) {
let _this = this;
return UInt64.$notEqual(UInt64.$bitwiseAND(x, 0x4000000000000000), 0)
}

/*Swift.(file)._StringObject.smallIsASCII*/
smallIsASCII$get() {
let _this = this;
return _StringObject.getSmallIsASCIIFromRaw(_this.discriminatedObjectRawBits)
}
get smallIsASCII() { return this.smallIsASCII$get() };



/*Swift.(file)._StringObject.init(empty:())*/
/*Swift.(file)._StringObject.init(empty:())*/
initEmptytuple_type(empty, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(empty:()) in ' + this.constructor.name
}

/*Swift.(file)._StringObject.largeCount*/
largeCount$get() {
let _this = this;
return _this._countAndFlags.count
}
get largeCount() { return this.largeCount$get() };




/*Swift.(file)._StringObject.largeAddressBits*/
largeAddressBits$get() {
let _this = this;
return _create(UInt, 'initTruncatingIfNeeded', UInt64.$bitwiseAND(_this.discriminatedObjectRawBits, _StringObject.Nibbles.largeAddressMask), {})
}
get largeAddressBits() { return this.largeAddressBits$get() };




/*Swift.(file)._StringObject.nativeUTF8Start*/
nativeUTF8Start$get() {
let _this = this;
return _create(UnsafePointer, 'initBitPatternUInt', UInt.$addWithOverflow(_this.largeAddressBits, _StringObject.nativeBias), {})._unsafelyUnwrappedUnchecked
}
get nativeUTF8Start() { return this.nativeUTF8Start$get() };




/*Swift.(file)._StringObject.nativeUTF8*/
nativeUTF8$get() {
let _this = this;
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(_this.nativeUTF8Start), _this.largeCount, {})
}
get nativeUTF8() { return this.nativeUTF8$get() };



/*Swift.(file)._StringObject.getSharedUTF8Start()*/
/*Swift.(file)._StringObject.getSharedUTF8Start()*/
getSharedUTF8Start($info?) {
let _this = this;
if((_this.largeIsCocoa)) {
return _cocoaUTF8Pointer(_this.cocoaObject)._unsafelyUnwrappedUnchecked;
};
return _this.sharedStorage.start
}

/*Swift.(file)._StringObject.sharedUTF8*/
sharedUTF8$get() {
let _this = this;
const start = _cloneStruct(_this.getSharedUTF8Start( {}));
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(start), _this.largeCount, {})
}
get sharedUTF8() { return this.sharedUTF8$get() };




/*Swift.(file)._StringObject.nativeStorage*/
nativeStorage$get() {
throw 'unsupported variable Swift.(file)._StringObject.nativeStorage in ' + this.constructor.name
}
get nativeStorage() { return this.nativeStorage$get() };




/*Swift.(file)._StringObject.sharedStorage*/
sharedStorage$get() {
throw 'unsupported variable Swift.(file)._StringObject.sharedStorage in ' + this.constructor.name
}
get sharedStorage() { return this.sharedStorage$get() };




/*Swift.(file)._StringObject.cocoaObject*/
cocoaObject$get() {
throw 'unsupported variable Swift.(file)._StringObject.cocoaObject in ' + this.constructor.name
}
get cocoaObject() { return this.cocoaObject$get() };




/*Swift.(file)._StringObject.count*/
count$get() {
let _this = this;
return (_this.isSmall ? _this.smallCount : _this.largeCount)
}
get count() { return this.count$get() };




/*Swift.(file)._StringObject.isASCII*/
isASCII$get() {
let _this = this;
if((_this.isSmall)) {
return _this.smallIsASCII;
};
return _this._countAndFlags.isASCII
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file)._StringObject.isNFC*/
isNFC$get() {
let _this = this;
if((_this.isSmall)) {
return _this.smallIsASCII;
};
return _this._countAndFlags.isNFC
}
get isNFC() { return this.isNFC$get() };




/*Swift.(file)._StringObject.fastUTF8*/
fastUTF8$get() {
let _this = this;
if(!((_fastPath(_this.largeFastIsTailAllocated)))) {
return _this.sharedUTF8;
};
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(_this.nativeUTF8Start), _this.largeCount, {})
}
get fastUTF8() { return this.fastUTF8$get() };




/*Swift.(file)._StringObject.hasObjCBridgeableObject*/
hasObjCBridgeableObject$get() {
let _this = this;
return Bool.$not(_this.isImmortal)
}
get hasObjCBridgeableObject() { return this.hasObjCBridgeableObject$get() };




/*Swift.(file)._StringObject.objCBridgeableObject*/
objCBridgeableObject$get() {
throw 'unsupported variable Swift.(file)._StringObject.objCBridgeableObject in ' + this.constructor.name
}
get objCBridgeableObject() { return this.objCBridgeableObject$get() };




/*Swift.(file)._StringObject.isFastZeroTerminated*/
isFastZeroTerminated$get() {
let _this = this;
if((_slowPath(Bool.$not(_this.providesFastUTF8)))) {
return false;
};
if((_this.isSmall)) {
return true;
};
return _this.largeFastIsTailAllocated
}
get isFastZeroTerminated() { return this.isFastZeroTerminated$get() };



/*Swift.(file)._StringObject.init(immortal:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
/*Swift.(file)._StringObject.init(immortal:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
initImmortalUnsafeBufferPointerIsASCIIBool(bufPtr, isASCII, $info?) {
let _this = this;
const countAndFlags = _create(_StringObject.CountAndFlags, 'initImmortalCountIntIsASCIIBool', bufPtr.count, isASCII, {});
const biasedAddress = UInt.$subtractWithOverflow(_create(UInt, 'initBitPatternOptional', _injectIntoOptional(bufPtr.baseAddress._unsafelyUnwrappedUnchecked), {}), _StringObject.nativeBias);
_this.initPointerBitsUInt64DiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(_create(UInt64, 'initTruncatingIfNeeded', biasedAddress, {}), _StringObject.Nibbles.largeImmortal( {}), countAndFlags);
return
}
/*Swift.(file)._StringObject.init(_:__StringStorage)*/
/*Swift.(file)._StringObject.init(_:__StringStorage)*/
init__StringStorage(storage, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(_:__StringStorage) in ' + this.constructor.name
}
/*Swift.(file)._StringObject.init(_:__SharedStringStorage)*/
/*Swift.(file)._StringObject.init(_:__SharedStringStorage)*/
init__SharedStringStorage(storage, $info?) {
throw 'unsupported method Swift.(file)._StringObject.init(_:__SharedStringStorage) in ' + this.constructor.name
}
/*Swift.(file)._StringObject.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)*/
/*Swift.(file)._StringObject.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)*/
initCocoaAnyObjectProvidesFastUTF8BoolIsASCIIBoolLengthInt(cocoa, providesFastUTF8, isASCII, _length, $info?) {
let _this = this;
const countAndFlags = _create(_StringObject.CountAndFlags, 'initSharedCountIntIsASCIIBool', _length, isASCII, {});
const discriminator = _StringObject.Nibbles.largeCocoaProvidesFastUTF8(providesFastUTF8);
_this.initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(cocoa, discriminator, countAndFlags);
return
}


init$vars() {let _this = this;

}
}
_mixin(_StringObject.Nibbles, _DefaultEnumImplementation, false)


















class DefaultStringInterpolation implements StringInterpolationProtocol, CustomStringConvertible, TextOutputStream{
static readonly $struct = true





/*Swift.(file).DefaultStringInterpolation.init(literalCapacity:Int,interpolationCount:Int)*/
/*Swift.(file).StringInterpolationProtocol.init(literalCapacity:Int,interpolationCount:Int)*/
initLiteralCapacityIntInterpolationCountInt(literalCapacity, interpolationCount, $info?) {
let _this = this;
const capacityPerInterpolation = 2;
const initialCapacity = Int.$add(literalCapacity, Int.$multiply(interpolationCount, capacityPerInterpolation));
_this._storage = _create(String, 'init_StringGuts', _create(_StringGuts, 'init_initialCapacityInt', initialCapacity, {}), {});
return
}
/*Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)*/
/*Swift.(file).StringInterpolationProtocol.appendLiteral(_:Self.StringLiteralType)*/
appendLiteral(literal, $info?) {
let _this = this;
literal.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
appendInterpolation<T>(value, $info?) {
let _this = this;
value.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
appendInterpolation<T>(value, $info?) {
let _this = this;
value.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
appendInterpolation<T>(value, $info?) {
let _this = this;
value.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
/*Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)*/
appendInterpolation<T>(value, $info?) {
let _this = this;
value.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).DefaultStringInterpolation.make()*/
/*Swift.(file).DefaultStringInterpolation.make()*/
make($info?) {
let _this = this;
return _this._storage
}


/*Swift.(file).DefaultStringInterpolation.description*/
description$get() {
let _this = this;
return _this._storage
}
get description() { return this.description$get() };



/*Swift.(file).DefaultStringInterpolation.write(_:String)*/
/*Swift.(file).TextOutputStream.write(_:String)*/
write(string, $info?) {
let _this = this;
_this._storage.append(string, {$setThis: $val => _this._storage = $val})
}

init$vars() {let _this = this;

}
}
if(typeof StringInterpolationProtocol$implementation != 'undefined') _mixin(DefaultStringInterpolation, StringInterpolationProtocol$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(DefaultStringInterpolation, CustomStringConvertible$implementation, false)
if(typeof TextOutputStream$implementation != 'undefined') _mixin(DefaultStringInterpolation, TextOutputStream$implementation, false)






class _Normalization{












init$vars() {let _this = this;

}
}
_mixin(_Normalization, _DefaultEnumImplementation, false)


class NormalizationResult{
static readonly $struct = true

/*Swift.(file).NormalizationResult.amountFilled*/
amountFilled$get() {
throw 'unsupported variable Swift.(file).NormalizationResult.amountFilled in ' + this.constructor.name
}
get amountFilled() { return this.amountFilled$get() };






/*Swift.(file).NormalizationResult.nextReadPosition*/
nextReadPosition$get() {
throw 'unsupported variable Swift.(file).NormalizationResult.nextReadPosition in ' + this.constructor.name
}
get nextReadPosition() { return this.nextReadPosition$get() };






/*Swift.(file).NormalizationResult.allocatedBuffers*/
allocatedBuffers$get() {
throw 'unsupported variable Swift.(file).NormalizationResult.allocatedBuffers in ' + this.constructor.name
}
get allocatedBuffers() { return this.allocatedBuffers$get() };





/*Swift.(file).NormalizationResult.init(amountFilled:Int,nextReadPosition:String.Index,allocatedBuffers:Bool)*/
/*Swift.(file).NormalizationResult.init(amountFilled:Int,nextReadPosition:String.Index,allocatedBuffers:Bool)*/
initAmountFilledIntNextReadPositionStringIndexAllocatedBuffersBool(amountFilled, nextReadPosition, allocatedBuffers, $info?) {
throw 'unsupported method Swift.(file).NormalizationResult.init(amountFilled:Int,nextReadPosition:String.Index,allocatedBuffers:Bool) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class _BufferToCopy{

static get none() {return Object.assign(new _BufferToCopy(), {rawValue: "none", ...Array.from(arguments)})}

static get output() {return Object.assign(new _BufferToCopy(), {rawValue: "output", ...Array.from(arguments)})}

static get icuInput() {return Object.assign(new _BufferToCopy(), {rawValue: "icuInput", ...Array.from(arguments)})}

static get icuOutput() {return Object.assign(new _BufferToCopy(), {rawValue: "icuOutput", ...Array.from(arguments)})}
static /*Swift.(file)._BufferToCopy.==(_:_BufferToCopy,_:_BufferToCopy)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file)._BufferToCopy.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file)._BufferToCopy.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file)._BufferToCopy.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file)._BufferToCopy.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(_BufferToCopy, _DefaultEnumImplementation, false)


interface _AbstractStringStorage extends _NSCopying{

/*Swift.(file)._AbstractStringStorage.asString*/
asString;




/*Swift.(file)._AbstractStringStorage.count*/
count;




/*Swift.(file)._AbstractStringStorage.isASCII*/
isASCII;




/*Swift.(file)._AbstractStringStorage.start*/
start;




/*Swift.(file)._AbstractStringStorage.UTF16Length*/
UTF16Length;



}
class _AbstractStringStorage$implementation{





}
if(typeof _NSCopying$implementation != 'undefined') _mixin(_AbstractStringStorage$implementation, _NSCopying$implementation, false)




class __StringStorage extends __SwiftNativeNSString implements _AbstractStringStorage{











/*Swift.(file).__StringStorage.count*/
count$get() {
throw 'unsupported variable Swift.(file).__StringStorage.count in ' + this.constructor.name
}
get count() { return this.count$get() };







/*Swift.(file).__StringStorage.isASCII*/
isASCII$get() {
throw 'unsupported variable Swift.(file).__StringStorage.isASCII in ' + this.constructor.name
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file).__StringStorage.asString*/
asString$get() {
throw 'unsupported variable Swift.(file).__StringStorage.asString in ' + this.constructor.name
}
get asString() { return this.asString$get() };




/*Swift.(file).__StringStorage.UTF16Length*/
UTF16Length$get() {
throw 'unsupported variable Swift.(file).__StringStorage.UTF16Length in ' + this.constructor.name
}
get UTF16Length() { return this.UTF16Length$get() };




/*Swift.(file).__StringStorage.hash*/
hash$get() {
throw 'unsupported variable Swift.(file).__StringStorage.hash in ' + this.constructor.name
}
get hash() { return this.hash$get() };



/*Swift.(file).__StringStorage.character(at:Int)*/
/*Swift.(file).__StringStorage.character(at:Int)*/
characterAt(offset, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.character(at:Int) in ' + this.constructor.name
}
/*Swift.(file).__StringStorage.getCharacters(_:UnsafeMutablePointer<UInt16>,range:_SwiftNSRange)*/
/*Swift.(file).__StringStorage.getCharacters(_:UnsafeMutablePointer<UInt16>,range:_SwiftNSRange)*/
getCharactersRange(buffer, aRange, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.getCharacters(_:UnsafeMutablePointer<UInt16>,range:_SwiftNSRange) in ' + this.constructor.name
}


/*Swift.(file).__StringStorage.cString(encoding:UInt)*/
/*Swift.(file).__StringStorage.cString(encoding:UInt)*/
cStringEncoding(encoding, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.cString(encoding:UInt) in ' + this.constructor.name
}
/*Swift.(file).__StringStorage.getCString(_:UnsafeMutablePointer<UInt8>,maxLength:Int,encoding:UInt)*/
/*Swift.(file).__StringStorage.getCString(_:UnsafeMutablePointer<UInt8>,maxLength:Int,encoding:UInt)*/
getCStringMaxLengthEncoding(outputPtr, maxLength, encoding, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.getCString(_:UnsafeMutablePointer<UInt8>,maxLength:Int,encoding:UInt) in ' + this.constructor.name
}

/*Swift.(file).__StringStorage.fastestEncoding*/
fastestEncoding$get() {
throw 'unsupported variable Swift.(file).__StringStorage.fastestEncoding in ' + this.constructor.name
}
get fastestEncoding() { return this.fastestEncoding$get() };



/*Swift.(file).__StringStorage.isEqual(to:AnyObject?)*/
/*Swift.(file).__StringStorage.isEqual(to:AnyObject?)*/
isEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.isEqual(to:AnyObject?) in ' + this.constructor.name
}
/*Swift.(file).__StringStorage.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}
/*Swift.(file).__StringStorage.init(_doNotCallMe:())*/
/*Swift.(file).__StringStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.init(_doNotCallMe:()) in ' + this.constructor.name
}

/*Swift.(file).__StringStorage.init()*/
/*Swift.(file).__SwiftNativeNSString.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__StringStorage.init() in ' + this.constructor.name
}
static /*Swift.(file).__StringStorage.create(realCodeUnitCapacity:Int,countAndFlags:CountAndFlags)*/
/*Swift.(file).__StringStorage.create(realCodeUnitCapacity:Int,countAndFlags:CountAndFlags)*/
createRealCodeUnitCapacityCountAndFlags(realCodeUnitCapacity, countAndFlags, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.create(realCodeUnitCapacity:Int,countAndFlags:CountAndFlags) in ' + this.constructor.name
}
static /*Swift.(file).__StringStorage.create(capacity:Int,countAndFlags:CountAndFlags)*/
/*Swift.(file).__StringStorage.create(capacity:Int,countAndFlags:CountAndFlags)*/
createCapacityCountAndFlags(capacity, countAndFlags, $info?) {
throw 'unsupported method Swift.(file).__StringStorage.create(capacity:Int,countAndFlags:CountAndFlags) in ' + this.constructor.name
}
static /*Swift.(file).__StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,capacity:Int,isASCII:Bool)*/
/*Swift.(file).__StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,capacity:Int,isASCII:Bool)*/
createInitializingFromCapacityIsASCII(bufPtr, capacity, isASCII, $info?) {
let _this = this;
const countAndFlags = _create(CountAndFlags, 'initMortalCountIntIsASCIIBool', bufPtr.count, isASCII, {});
const storage = __StringStorage.createCapacityCountAndFlags(capacity, countAndFlags);
const addr = _cloneStruct(bufPtr.baseAddress._unsafelyUnwrappedUnchecked);
storage.mutableStart.initializeFromCount(addr, bufPtr.count);
storage._invariantCheck( {});
return storage
}
static /*Swift.(file).__StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
/*Swift.(file).__StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
createInitializingFromIsASCII(bufPtr, isASCII, $info?) {
let _this = this;
return __StringStorage.createInitializingFromCapacityIsASCII(bufPtr, bufPtr.count, isASCII)
}

/*Swift.(file).__StringStorage.mutableStart*/
mutableStart$get() {
throw 'unsupported variable Swift.(file).__StringStorage.mutableStart in ' + this.constructor.name
}
get mutableStart() { return this.mutableStart$get() };




/*Swift.(file).__StringStorage.mutableEnd*/
mutableEnd$get() {
let _this = this;
return UnsafeMutablePointer.$add(_this.mutableStart, _this.count)
}
get mutableEnd() { return this.mutableEnd$get() };




/*Swift.(file).__StringStorage.start*/
start$get() {
let _this = this;
return _create(UnsafePointer, 'init', _this.mutableStart, {})
}
get start() { return this.start$get() };




/*Swift.(file).__StringStorage.end*/
end$get() {
let _this = this;
return _create(UnsafePointer, 'init', _this.mutableEnd, {})
}
get end() { return this.end$get() };




/*Swift.(file).__StringStorage.terminator*/
terminator$get() {
let _this = this;
return _this.mutableEnd
}
get terminator() { return this.terminator$get() };




/*Swift.(file).__StringStorage.codeUnits*/
codeUnits$get() {
let _this = this;
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(_this.start), _this.count, {})
}
get codeUnits() { return this.codeUnits$get() };







/*Swift.(file).__StringStorage.capacity*/
capacity$get() {
let _this = this;
return Int.$subtractWithOverflow(_this._realCapacity, 1)
}
get capacity() { return this.capacity$get() };




/*Swift.(file).__StringStorage.unusedStorage*/
unusedStorage$get() {
let _this = this;
return _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(_this.mutableEnd), _this.unusedCapacity, {})
}
get unusedStorage() { return this.unusedStorage$get() };




/*Swift.(file).__StringStorage.unusedCapacity*/
unusedCapacity$get() {
let _this = this;
return Int.$subtractWithOverflow(Int.$subtractWithOverflow(_this._realCapacity, _this.count), 1)
}
get unusedCapacity() { return this.unusedCapacity$get() };






/*Swift.(file).__StringStorage.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
/*Swift.(file).__StringStorage.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)*/
appendInPlaceIsASCII(other, isASCII, $info?) {
let _this = this;
const srcAddr = _cloneStruct(other.baseAddress._unsafelyUnwrappedUnchecked);
const srcCount = other.count;
_this.mutableEnd.initializeFromCount(srcAddr, srcCount);
_this._postAppendAdjustAppendedCountAppendedIsASCII(srcCount, isASCII)
}
/*Swift.(file).__StringStorage.appendInPlace(_:Iter,isASCII:Bool)*/
/*Swift.(file).__StringStorage.appendInPlace(_:Iter,isASCII:Bool)*/
/*!!!DUPLICATE NAME*/
appendInPlaceIsASCII<Iter>(other$inout, isASCII, $info?) {
let _this = this;
let other = other$inout.get()
const $result = (() => {
let srcCount = 0;
while(true){
const $ifLet0, cu_1
if(!((($ifLet0 = other.next( {$setThis: $val => other = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
_this.unusedStorage.subscript$set(cu_1, srcCount, {$setThis: $val => _this.unusedStorage = _cloneStruct($val)});
Int.$addAndAssign({get: () => srcCount, set: $val => srcCount = $val}, 1);
};
_this._postAppendAdjustAppendedCountAppendedIsASCII(srcCount, isASCII);})()
other$inout.set(other)
return $result
}
/*Swift.(file).__StringStorage.clear()*/
/*Swift.(file).__StringStorage.clear()*/
clear($info?) {
let _this = this;
_this._postRRCAdjustNewCountNewIsASCII(0, true)
}
/*Swift.(file).__StringStorage.remove(from:Int,to:Int)*/
/*Swift.(file).__StringStorage.remove(from:Int,to:Int)*/
removeFromTo(lower, upper, $info?) {
let _this = this;
const lowerPtr = _cloneStruct(UnsafeMutablePointer.$add(_this.mutableStart, lower));
const upperPtr = _cloneStruct(UnsafeMutablePointer.$add(_this.mutableStart, upper));
const tailCount = UnsafeMutablePointer.$subtract(_this.mutableEnd, upperPtr);
lowerPtr.moveInitializeFromCount(upperPtr, tailCount);
_this._postRRCAdjustNewCountNewIsASCII(Int.$subtractWithOverflow(_this.count, Int.$subtractWithOverflow(upper, lower)), _this.isASCII)
}

/*Swift.(file).__StringStorage.replace(from:Int,to:Int,with:UnsafeBufferPointer<UInt8>)*/
/*Swift.(file).__StringStorage.replace(from:Int,to:Int,with:UnsafeBufferPointer<UInt8>)*/
replaceFromToWith(lower, upper, replacement, $info?) {
let _this = this;
const replCount = replacement.count;
const lowerPtr = _cloneStruct(UnsafeMutablePointer.$add(_this.mutableStart, lower));
const tailCount = _this._slideTailSrcDst(UnsafeMutablePointer.$add(_this.mutableStart, upper), UnsafeMutablePointer.$add(lowerPtr, replCount));
lowerPtr.moveInitializeFromCount(_create(UnsafeMutablePointer, 'initMutatingUnsafePointer', replacement.baseAddress._unsafelyUnwrappedUnchecked, {}), replCount);
const isASCII = Bool.$logicalAND(_this.isASCII, () => _allASCII(replacement));
_this._postRRCAdjustNewCountNewIsASCII(Int.$add(Int.$add(lower, replCount), tailCount), isASCII)
}
/*Swift.(file).__StringStorage.replace(from:Int,to:Int,with:C,replacementCount:Int)*/
/*Swift.(file).__StringStorage.replace(from:Int,to:Int,with:C,replacementCount:Int)*/
replaceFromToWithReplacementCount<C>(lower, upper, replacement, replCount, $info?) {
let _this = this;
const lowerPtr = _cloneStruct(UnsafeMutablePointer.$add(_this.mutableStart, lower));
const tailCount = _this._slideTailSrcDst(UnsafeMutablePointer.$add(_this.mutableStart, upper), UnsafeMutablePointer.$add(lowerPtr, replCount));
let isASCII = _this.isASCII;
let srcCount = 0;
{
let $cu$generator = replacement.makeIterator( {});
while(true) {
const $ifLet0, cu_1;
if(!((($ifLet0 = $cu$generator.next( {$setThis: $val => $cu$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
if((UInt8.$greaterThanOrEqual(cu_1, 0x80))) {
isASCII = false;
};
lowerPtr.subscript$set(cu_1, srcCount, {$setThis: $val => lowerPtr = _cloneStruct($val)});
Int.$addAndAssign({get: () => srcCount, set: $val => srcCount = $val}, 1);
}
};
_this._postRRCAdjustNewCountNewIsASCII(Int.$add(Int.$add(lower, replCount), tailCount), isASCII)
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _AbstractStringStorage$implementation != 'undefined') _mixin(__StringStorage, _AbstractStringStorage$implementation, false)










class __SharedStringStorage extends __SwiftNativeNSString implements _AbstractStringStorage{






/*Swift.(file).__SharedStringStorage.start*/
start$get() {
throw 'unsupported variable Swift.(file).__SharedStringStorage.start in ' + this.constructor.name
}
get start() { return this.start$get() };
















/*Swift.(file).__SharedStringStorage.count*/
count$get() {
throw 'unsupported variable Swift.(file).__SharedStringStorage.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file).__SharedStringStorage.init(immortal:UnsafePointer<UInt8>,countAndFlags:_StringObject.CountAndFlags)*/
/*Swift.(file).__SharedStringStorage.init(immortal:UnsafePointer<UInt8>,countAndFlags:_StringObject.CountAndFlags)*/
initImmortalUnsafePointerCountAndFlags_StringObjectCountAndFlags(ptr, countAndFlags, $info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.init(immortal:UnsafePointer<UInt8>,countAndFlags:_StringObject.CountAndFlags) in ' + this.constructor.name
}

/*Swift.(file).__SharedStringStorage.isASCII*/
isASCII$get() {
throw 'unsupported variable Swift.(file).__SharedStringStorage.isASCII in ' + this.constructor.name
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file).__SharedStringStorage.asString*/
asString$get() {
throw 'unsupported variable Swift.(file).__SharedStringStorage.asString in ' + this.constructor.name
}
get asString() { return this.asString$get() };




/*Swift.(file).__SharedStringStorage.UTF16Length*/
UTF16Length$get() {
throw 'unsupported variable Swift.(file).__SharedStringStorage.UTF16Length in ' + this.constructor.name
}
get UTF16Length() { return this.UTF16Length$get() };




/*Swift.(file).__SharedStringStorage.hash*/
hash$get() {
throw 'unsupported variable Swift.(file).__SharedStringStorage.hash in ' + this.constructor.name
}
get hash() { return this.hash$get() };



/*Swift.(file).__SharedStringStorage.character(at:Int)*/
/*Swift.(file).__SharedStringStorage.character(at:Int)*/
characterAt(offset, $info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.character(at:Int) in ' + this.constructor.name
}
/*Swift.(file).__SharedStringStorage.getCharacters(_:UnsafeMutablePointer<UInt16>,range:_SwiftNSRange)*/
/*Swift.(file).__SharedStringStorage.getCharacters(_:UnsafeMutablePointer<UInt16>,range:_SwiftNSRange)*/
getCharactersRange(buffer, aRange, $info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.getCharacters(_:UnsafeMutablePointer<UInt16>,range:_SwiftNSRange) in ' + this.constructor.name
}

/*Swift.(file).__SharedStringStorage.fastestEncoding*/
fastestEncoding$get() {
throw 'unsupported variable Swift.(file).__SharedStringStorage.fastestEncoding in ' + this.constructor.name
}
get fastestEncoding() { return this.fastestEncoding$get() };





/*Swift.(file).__SharedStringStorage.cString(encoding:UInt)*/
/*Swift.(file).__SharedStringStorage.cString(encoding:UInt)*/
cStringEncoding(encoding, $info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.cString(encoding:UInt) in ' + this.constructor.name
}
/*Swift.(file).__SharedStringStorage.getCString(_:UnsafeMutablePointer<UInt8>,maxLength:Int,encoding:UInt)*/
/*Swift.(file).__SharedStringStorage.getCString(_:UnsafeMutablePointer<UInt8>,maxLength:Int,encoding:UInt)*/
getCStringMaxLengthEncoding(outputPtr, maxLength, encoding, $info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.getCString(_:UnsafeMutablePointer<UInt8>,maxLength:Int,encoding:UInt) in ' + this.constructor.name
}
/*Swift.(file).__SharedStringStorage.isEqual(to:AnyObject?)*/
/*Swift.(file).__SharedStringStorage.isEqual(to:AnyObject?)*/
isEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.isEqual(to:AnyObject?) in ' + this.constructor.name
}
/*Swift.(file).__SharedStringStorage.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}
/*Swift.(file).__SharedStringStorage.init()*/
/*Swift.(file).__SwiftNativeNSString.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SharedStringStorage.init() in ' + this.constructor.name
}


init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _AbstractStringStorage$implementation != 'undefined') _mixin(__SharedStringStorage, _AbstractStringStorage$implementation, false)




class _OpaqueStringSwitchCache{
static readonly $struct = true

/*Swift.(file)._OpaqueStringSwitchCache.a*/
a$get() {
throw 'unsupported variable Swift.(file)._OpaqueStringSwitchCache.a in ' + this.constructor.name
}
get a() { return this.a$get() };






/*Swift.(file)._OpaqueStringSwitchCache.b*/
b$get() {
throw 'unsupported variable Swift.(file)._OpaqueStringSwitchCache.b in ' + this.constructor.name
}
get b() { return this.b$get() };





/*Swift.(file)._OpaqueStringSwitchCache.init(a:Word,b:Word)*/
/*Swift.(file)._OpaqueStringSwitchCache.init(a:Word,b:Word)*/
initAWordBWord(a, b, $info?) {
throw 'unsupported method Swift.(file)._OpaqueStringSwitchCache.init(a:Word,b:Word) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class _StringSwitchContext{
static readonly $struct = true
/*Swift.(file)._StringSwitchContext.init(cases:[StaticString],cachePtr:UnsafeMutablePointer<_StringSwitchCache>)*/
/*Swift.(file)._StringSwitchContext.init(cases:[StaticString],cachePtr:UnsafeMutablePointer<_StringSwitchCache>)*/
initCasesArrayCachePtrUnsafeMutablePointer(cases, cachePtr, $info?) {
throw 'unsupported method Swift.(file)._StringSwitchContext.init(cases:[StaticString],cachePtr:UnsafeMutablePointer<_StringSwitchCache>) in ' + this.constructor.name
}

/*Swift.(file)._StringSwitchContext.cases*/
readonly cases$get() {
throw 'unsupported variable Swift.(file)._StringSwitchContext.cases in ' + this.constructor.name
}
readonly get cases() { return this.cases$get() };




/*Swift.(file)._StringSwitchContext.cachePtr*/
readonly cachePtr$get() {
throw 'unsupported variable Swift.(file)._StringSwitchContext.cachePtr in ' + this.constructor.name
}
readonly get cachePtr() { return this.cachePtr$get() };



init$vars() {let _this = this;

}
}


class _StringRepresentation{
static readonly $struct = true















static _Form = class{

static get _small() {return Object.assign(new _StringRepresentation._Form(), {rawValue: "_small", ...Array.from(arguments)})}

static _cocoa() {return Object.assign(new _StringRepresentation._Form(), {rawValue: "_cocoa", ...Array.from(arguments)})}

static _native() {return Object.assign(new _StringRepresentation._Form(), {rawValue: "_native", ...Array.from(arguments)})}

static _immortal() {return Object.assign(new _StringRepresentation._Form(), {rawValue: "_immortal", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}








/*Swift.(file)._StringRepresentation.init(_isASCII:Bool,_count:Int,_capacity:Int,_form:_StringRepresentation._Form)*/
/*Swift.(file)._StringRepresentation.init(_isASCII:Bool,_count:Int,_capacity:Int,_form:_StringRepresentation._Form)*/
init_isASCIIBool_countInt_capacityInt_form_StringRepresentation_Form(_isASCII, _count, _capacity, _form, $info?) {
throw 'unsupported method Swift.(file)._StringRepresentation.init(_isASCII:Bool,_count:Int,_capacity:Int,_form:_StringRepresentation._Form) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(_StringRepresentation._Form, _DefaultEnumImplementation, false)


class UTF8ExtraInfo implements Equatable{
static readonly $struct = true

/*Swift.(file).UTF8ExtraInfo.isASCII*/
isASCII$get() {
throw 'unsupported variable Swift.(file).UTF8ExtraInfo.isASCII in ' + this.constructor.name
}
get isASCII() { return this.isASCII$get() };





/*Swift.(file).UTF8ExtraInfo.init(isASCII:Bool)*/
/*Swift.(file).UTF8ExtraInfo.init(isASCII:Bool)*/
initIsASCIIBool(isASCII, $info?) {
throw 'unsupported method Swift.(file).UTF8ExtraInfo.init(isASCII:Bool) in ' + this.constructor.name
}
static /*Swift.(file).UTF8ExtraInfo.==(_:UTF8ExtraInfo,_:UTF8ExtraInfo)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(UTF8ExtraInfo, Equatable$implementation, false)


class UTF8ValidationResult implements Equatable{

static success() {return Object.assign(new UTF8ValidationResult(), {rawValue: "success", ...Array.from(arguments)})}

static error() {return Object.assign(new UTF8ValidationResult(), {rawValue: "error", ...Array.from(arguments)})}
static /*Swift.(file).UTF8ValidationResult.==(_:UTF8ValidationResult,_:UTF8ValidationResult)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(UTF8ValidationResult, Equatable$implementation, false)
_mixin(UTF8ValidationResult, _DefaultEnumImplementation, false)




class UTF8ValidationError implements Error{
static readonly $struct = true
/*Swift.(file).UTF8ValidationError.init()*/
/*Swift.(file).UTF8ValidationError.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UTF8ValidationError.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof Error$implementation != 'undefined') _mixin(UTF8ValidationError, Error$implementation, false)


class _TLSAtomicInt{

/*Swift.(file)._TLSAtomicInt.value*/
value$get() {
throw 'unsupported variable Swift.(file)._TLSAtomicInt.value in ' + this.constructor.name
}
get value() { return this.value$get() };





/*Swift.(file)._TLSAtomicInt.init()*/
/*Swift.(file)._TLSAtomicInt.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._TLSAtomicInt.init() in ' + this.constructor.name
}

/*Swift.(file)._TLSAtomicInt.valuePtr*/
valuePtr$get() {
throw 'unsupported variable Swift.(file)._TLSAtomicInt.valuePtr in ' + this.constructor.name
}
get valuePtr() { return this.valuePtr$get() };



/*Swift.(file)._TLSAtomicInt.increment()*/
/*Swift.(file)._TLSAtomicInt.increment()*/
increment($info?) {
throw 'unsupported method Swift.(file)._TLSAtomicInt.increment() in ' + this.constructor.name
}
/*Swift.(file)._TLSAtomicInt.load()*/
/*Swift.(file)._TLSAtomicInt.load()*/
load($info?) {
throw 'unsupported method Swift.(file)._TLSAtomicInt.load() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class _ThreadLocalStorage{
static readonly $struct = true

/*Swift.(file)._ThreadLocalStorage.uBreakIterator*/
uBreakIterator$get() {
throw 'unsupported variable Swift.(file)._ThreadLocalStorage.uBreakIterator in ' + this.constructor.name
}
get uBreakIterator() { return this.uBreakIterator$get() };






/*Swift.(file)._ThreadLocalStorage.uText*/
uText$get() {
throw 'unsupported variable Swift.(file)._ThreadLocalStorage.uText in ' + this.constructor.name
}
get uText() { return this.uText$get() };





/*Swift.(file)._ThreadLocalStorage.init(_uBreakIterator:OpaquePointer,_uText:OpaquePointer)*/
/*Swift.(file)._ThreadLocalStorage.init(_uBreakIterator:OpaquePointer,_uText:OpaquePointer)*/
init_uBreakIteratorOpaquePointer_uTextOpaquePointer(_uBreakIterator, _uText, $info?) {
throw 'unsupported method Swift.(file)._ThreadLocalStorage.init(_uBreakIterator:OpaquePointer,_uText:OpaquePointer) in ' + this.constructor.name
}
static /*Swift.(file)._ThreadLocalStorage.getPointer()*/
/*Swift.(file)._ThreadLocalStorage.getPointer()*/
getPointer($info?) {
throw 'unsupported method Swift.(file)._ThreadLocalStorage.getPointer() in ' + this.constructor.name
}
static /*Swift.(file)._ThreadLocalStorage.getUBreakIterator(_:UnsafeBufferPointer<UTF16.CodeUnit>)*/
/*Swift.(file)._ThreadLocalStorage.getUBreakIterator(_:UnsafeBufferPointer<UTF16.CodeUnit>)*/
getUBreakIterator(bufPtr, $info?) {
throw 'unsupported method Swift.(file)._ThreadLocalStorage.getUBreakIterator(_:UnsafeBufferPointer<UTF16.CodeUnit>) in ' + this.constructor.name
}
static /*Swift.(file)._ThreadLocalStorage.getUBreakIterator(_:UnsafeBufferPointer<UTF8.CodeUnit>)*/
/*Swift.(file)._ThreadLocalStorage.getUBreakIterator(_:UnsafeBufferPointer<UTF8.CodeUnit>)*/
/*!!!DUPLICATE NAME*/
getUBreakIterator(bufPtr, $info?) {
throw 'unsupported method Swift.(file)._ThreadLocalStorage.getUBreakIterator(_:UnsafeBufferPointer<UTF8.CodeUnit>) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


interface _UnicodeEncoding<CodeUnit, EncodedScalar, ForwardParser, ReverseParser>{



/*Swift.(file)._UnicodeEncoding.encodedReplacementCharacter*/
static encodedReplacementCharacter;



static /*Swift.(file)._UnicodeEncoding.decode(_:Self.EncodedScalar)*/
/*Swift.(file)._UnicodeEncoding.decode(_:Self.EncodedScalar)*/
decode(content, $info?)
static /*Swift.(file)._UnicodeEncoding.encode(_:Unicode.Scalar)*/
/*Swift.(file)._UnicodeEncoding.encode(_:Unicode.Scalar)*/
encode(content, $info?)
static /*Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
/*Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
transcodeFrom<FromEncoding>(content, _, $info?)



}
class _UnicodeEncoding$implementation{

static /*Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
/*Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
transcodeFrom<FromEncoding>(content, _, $info?) {
throw 'unsupported method Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type) in ' + this.constructor.name
}



}




interface _UnicodeParser<Encoding>{

/*Swift.(file)._UnicodeParser.init()*/
/*Swift.(file)._UnicodeParser.init()*/
init($info?)
/*Swift.(file)._UnicodeParser.parseScalar(from:I)*/
/*Swift.(file)._UnicodeParser.parseScalar(from:I)*/
parseScalarFrom<I>(input$inout, $info?)
}
class _UnicodeParser$implementation{
}


class Unmanaged<Instance>{
static readonly $struct = true





/*Swift.(file).Unmanaged.init(_private:Instance)*/
/*Swift.(file).Unmanaged.init(_private:Instance)*/
init_private(_private, $info?) {
let _this = this;
_this._value = _private;
return
}
static /*Swift.(file).Unmanaged.fromOpaque(_:UnsafeRawPointer)*/
/*Swift.(file).Unmanaged.fromOpaque(_:UnsafeRawPointer)*/
fromOpaque(value, $info?) {
let _this = this;
return _create(Unmanaged, 'init_private', unsafeBitCastTo(value, ((function(){throw '!unclarifiedGeneric:Instance'})())), {})
}
/*Swift.(file).Unmanaged.toOpaque()*/
/*Swift.(file).Unmanaged.toOpaque()*/
toOpaque($info?) {
let _this = this;
return unsafeBitCastTo(_this._value, UnsafeMutableRawPointer)
}
static /*Swift.(file).Unmanaged.passRetained(_:Instance)*/
/*Swift.(file).Unmanaged.passRetained(_:Instance)*/
passRetained(value, $info?) {
let _this = this;
return _create(Unmanaged, 'init_private', value, {}).retain( {})
}
static /*Swift.(file).Unmanaged.passUnretained(_:Instance)*/
/*Swift.(file).Unmanaged.passUnretained(_:Instance)*/
passUnretained(value, $info?) {
let _this = this;
return _create(Unmanaged, 'init_private', value, {})
}
/*Swift.(file).Unmanaged.takeUnretainedValue()*/
/*Swift.(file).Unmanaged.takeUnretainedValue()*/
takeUnretainedValue($info?) {
let _this = this;
return _this._value
}
/*Swift.(file).Unmanaged.takeRetainedValue()*/
/*Swift.(file).Unmanaged.takeRetainedValue()*/
takeRetainedValue($info?) {
let _this = this;
const result = _this._value;
_this.release( {});
return result
}

/*Swift.(file).Unmanaged.retain()*/
/*Swift.(file).Unmanaged.retain()*/
retain($info?) {
throw 'unsupported method Swift.(file).Unmanaged.retain() in ' + this.constructor.name
}
/*Swift.(file).Unmanaged.release()*/
/*Swift.(file).Unmanaged.release()*/
release($info?) {
throw 'unsupported method Swift.(file).Unmanaged.release() in ' + this.constructor.name
}
/*Swift.(file).Unmanaged.autorelease()*/
/*Swift.(file).Unmanaged.autorelease()*/
autorelease($info?) {
throw 'unsupported method Swift.(file).Unmanaged.autorelease() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


interface _UTFParser<Encoding>{








}
class _UTFParser$implementation{
/*Swift.(file)._UTFParser.parseScalar(from:I)*/
/*Swift.(file)._UTFParser.parseScalar(from:I)*/
parseScalarFrom<I>(input$inout, $info?) {
throw 'unsupported method Swift.(file)._UTFParser.parseScalar(from:I) in ' + this.constructor.name
}
}




class UnicodeDecodingResult implements Equatable{

static scalarValue() {return Object.assign(new UnicodeDecodingResult(), {rawValue: "scalarValue", ...Array.from(arguments)})}

static get emptyInput() {return Object.assign(new UnicodeDecodingResult(), {rawValue: "emptyInput", ...Array.from(arguments)})}

static get error() {return Object.assign(new UnicodeDecodingResult(), {rawValue: "error", ...Array.from(arguments)})}
static /*Swift.(file).UnicodeDecodingResult.==infix(_:UnicodeDecodingResult,_:UnicodeDecodingResult)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == UnicodeDecodingResult.scalarValue().rawValue && $match[1].rawValue == UnicodeDecodingResult.scalarValue().rawValue))) {
const lhsScalar = $match[0][0]
const rhsScalar = $match[1][0]
return Unicode.Scalar.$equal(lhsScalar, rhsScalar);
}
else if((($match[0].rawValue == UnicodeDecodingResult.emptyInput.rawValue && $match[1].rawValue == UnicodeDecodingResult.emptyInput.rawValue))) {
return true;
}
else if((($match[0].rawValue == UnicodeDecodingResult.error.rawValue && $match[1].rawValue == UnicodeDecodingResult.error.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(UnicodeDecodingResult, Equatable$implementation, false)
_mixin(UnicodeDecodingResult, _DefaultEnumImplementation, false)


interface UnicodeCodec extends Unicode.Encoding{
/*Swift.(file).UnicodeCodec.init()*/
/*Swift.(file).UnicodeCodec.init()*/
init($info?)
/*Swift.(file).UnicodeCodec.decode(_:I)*/
/*Swift.(file).UnicodeCodec.decode(_:I)*/
decode<I>(input$inout, $info?)
static /*Swift.(file).UnicodeCodec.encode(_:Unicode.Scalar,into:(Self.CodeUnit) -> Void)*/
/*Swift.(file).UnicodeCodec.encode(_:Unicode.Scalar,into:(Self.CodeUnit) -> Void)*/
encodeInto(input, processCodeUnit, $info?)

}
class UnicodeCodec$implementation{

}
if(typeof Unicode != 'undefined' && typeof Unicode.Encoding$implementation != 'undefined') _mixin(UnicodeCodec$implementation, Unicode.Encoding$implementation, false)




interface _StringElement{


}
class _StringElement$implementation{
}


class _PlaygroundQuickLook{

static text() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "text", ...Array.from(arguments)})}

static int() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "int", ...Array.from(arguments)})}

static uInt() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "uInt", ...Array.from(arguments)})}

static float() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "float", ...Array.from(arguments)})}

static double() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "double", ...Array.from(arguments)})}

static _image() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "_image", ...Array.from(arguments)})}

static sound() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "sound", ...Array.from(arguments)})}

static color() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "color", ...Array.from(arguments)})}

static bezierPath() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "bezierPath", ...Array.from(arguments)})}

static attributedString() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "attributedString", ...Array.from(arguments)})}

static rectangle() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "rectangle", ...Array.from(arguments)})}

static point() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "point", ...Array.from(arguments)})}

static size() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "size", ...Array.from(arguments)})}

static bool() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "bool", ...Array.from(arguments)})}

static range() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "range", ...Array.from(arguments)})}

static view() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "view", ...Array.from(arguments)})}

static sprite() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "sprite", ...Array.from(arguments)})}

static url() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "url", ...Array.from(arguments)})}

static _raw() {return Object.assign(new _PlaygroundQuickLook(), {rawValue: "_raw", ...Array.from(arguments)})}
/*Swift.(file)._PlaygroundQuickLook.init(reflecting:Any)*/
/*Swift.(file)._PlaygroundQuickLook.init(reflecting:Any)*/
initReflectingprotocol_composition_type(subject, $info?) {
let _this = this;
const $ifLet0, customized_1
if((($ifLet0 = _injectIntoOptional(subject))||true) && $ifLet0.rawValue == 'some' && ((customized_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(customized_1.customPlaygroundQuickLook));
}
else {const $ifLet2, customized_3
if((($ifLet2 = _injectIntoOptional(subject))||true) && $ifLet2.rawValue == 'some' && ((customized_3 = $ifLet2[0])||true)) {
$info.$setThis(_this = _cloneStruct(customized_3._defaultCustomPlaygroundQuickLook));
}
else {
const $ifLet4, q_5
if((($ifLet4 = Mirror.quickLookObject(subject))||true) && $ifLet4.rawValue == 'some' && ((q_5 = $ifLet4[0])||true)) {
$info.$setThis(_this = _cloneStruct(q_5));
}
else {
$info.$setThis(_this = _cloneStruct(_PlaygroundQuickLook.text(_create(String, 'initReflecting', subject, {}))));
};
}
};
return
}
init$vars() {let _this = this;

}
}
_mixin(_PlaygroundQuickLook, _DefaultEnumImplementation, false)




interface _CustomPlaygroundQuickLookable{

/*Swift.(file)._CustomPlaygroundQuickLookable.customPlaygroundQuickLook*/
customPlaygroundQuickLook;



}
class _CustomPlaygroundQuickLookable$implementation{
}


interface __DefaultCustomPlaygroundQuickLookable{



}
class __DefaultCustomPlaygroundQuickLookable$implementation{
}


class _SearchState<SourceIndex, TargetIndex>{
static readonly $struct = true


/*Swift.(file)._SearchState.endpoints*/
endpoints$get() {
throw 'unsupported variable Swift.(file)._SearchState.endpoints in ' + this.constructor.name
}
get endpoints() { return this.endpoints$get() };





/*Swift.(file)._SearchState.init(consuming:[_SearchState<SourceIndex, TargetIndex>.Endpoint])*/
/*Swift.(file)._SearchState.init(consuming:[_SearchState<SourceIndex, TargetIndex>.Endpoint])*/
initConsumingArray(storage$inout, $info?) {
throw 'unsupported method Swift.(file)._SearchState.init(consuming:[_SearchState<SourceIndex, TargetIndex>.Endpoint]) in ' + this.constructor.name
}
/*Swift.(file)._SearchState.subscript(_:Int,_:Int)*/
/*Swift.(file)._SearchState.subscript(_:Int,_:Int)*/
subscript$get(d, k, $info?) {
throw 'unsupported method Swift.(file)._SearchState.subscript(_:Int,_:Int) in ' + this.constructor.name
}/*Swift.(file)._SearchState.subscript(_:Int,_:Int)*/
/*Swift.(file)._SearchState.subscript(_:Int,_:Int)*/
subscript$set(newValue, d, k, $info?) {
throw 'unsupported method Swift.(file)._SearchState.subscript(_:Int,_:Int) in ' + this.constructor.name
}



/*Swift.(file)._SearchState.appendFrontier(repeating:_SearchState<SourceIndex, TargetIndex>.Endpoint)*/
/*Swift.(file)._SearchState.appendFrontier(repeating:_SearchState<SourceIndex, TargetIndex>.Endpoint)*/
appendFrontierRepeating(repeatedValue, $info?) {
throw 'unsupported method Swift.(file)._SearchState.appendFrontier(repeating:_SearchState<SourceIndex, TargetIndex>.Endpoint) in ' + this.constructor.name
}
/*Swift.(file)._SearchState.removeCollectionChanges(a:Source,b:Target,d:Int,delta:Int)*/
/*Swift.(file)._SearchState.removeCollectionChanges(a:Source,b:Target,d:Int,delta:Int)*/
removeCollectionChangesABDDelta<Source, Target>(a, b, d, delta, $info?) {
let _this = this;
const pathStart = {0: a.startIndex, 1: b.startIndex};
const pathEnd = {0: a.endIndex, 1: b.endIndex};
if((Int.$equal(d, 1))) {
_this.endpoints.storage.append(pathEnd, {$setThis: $val => _this.endpoints.storage = $val});
};
let i = Int.$subtract(_this.endpoints.storage.endIndex, 1);
let isInsertion = _injectIntoOptional(null);
let k = delta;
_this.endpoints.storage.subscript$set(pathEnd, i, {$setThis: $val => _this.endpoints.storage = $val});
{
let $d$generator = _cloneStruct(Int.$closedRange(1, d).reversed( {}).makeIterator( {}));
while(true) {
const $ifLet0, d_1;
if(!((($ifLet0 = $d$generator.next( {$setThis: $val => $d$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((d_1 = $ifLet0[0])||true))) break
if((Bool.$logicalOR(Int.$equal(k, Int.$negate(d_1)), () => Bool.$logicalAND(Int.$notEqual(k, d_1), () => (_.arg0 = _this.subscript$get(Int.$subtract(d_1, 1), Int.$subtract(k, 1))["0"]).constructor.$lessThan(_.arg0, _this.subscript$get(Int.$subtract(d_1, 1), Int.$add(k, 1))["0"]))))) {
const $tuple = _this.subscript$get(Int.$subtract(d_1, 1), Int.$add(k, 1)), x = $tuple && $tuple[0], y = $tuple && $tuple[1];
if(((_.arg1 = x).constructor.$notEqual(_.arg1, _this.endpoints.storage.subscript$get(i)["0"]))) {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);
_this.endpoints.storage.subscript$set({0: x, 1: b.indexAfter(y)}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = _injectIntoOptional(null);
};
if((Optional.$notEqual(isInsertion, Optional.some(true)))) {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);
};
_this.endpoints.storage.subscript$set({0: x, 1: y}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = _injectIntoOptional(true);
Int.$addAndAssign({get: () => k, set: $val => k = $val}, 1);
}
else {
const $tuple = _this.subscript$get(Int.$subtract(d_1, 1), Int.$subtract(k, 1)), x = $tuple && $tuple[0], y = $tuple && $tuple[1];
if(((_.arg2 = y).constructor.$notEqual(_.arg2, _this.endpoints.storage.subscript$get(i)["1"]))) {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);
_this.endpoints.storage.subscript$set({0: a.indexAfter(x), 1: y}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = _injectIntoOptional(null);
};
if((Optional.$notEqual(isInsertion, Optional.some(false)))) {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);
};
_this.endpoints.storage.subscript$set({0: x, 1: y}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = _injectIntoOptional(false);
Int.$subtractAndAssign({get: () => k, set: $val => k = $val}, 1);
};
}
};
if(($notEqual(pathStart, _this.endpoints.storage.subscript$get(i)))) {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);
_this.endpoints.storage.subscript$set(pathStart, i, {$setThis: $val => _this.endpoints.storage = $val});
};
const pathStorage = _cloneStruct(_this.endpoints.storage);
_this.endpoints.storage = _create(Array, 'initArrayLiteralArray', [], {});
return _create(_CollectionChanges, 'initPathStorageArrayPathStartIndexInt', pathStorage, i, {})
}
init$vars() {let _this = this;

}
}




interface CustomReflectable{

/*Swift.(file).CustomReflectable.customMirror*/
customMirror;



}
class CustomReflectable$implementation{
}


interface CustomLeafReflectable extends CustomReflectable{
}


interface MirrorPath{
}


interface CustomPlaygroundDisplayConvertible{

/*Swift.(file).CustomPlaygroundDisplayConvertible.playgroundDescription*/
playgroundDescription;



}
class CustomPlaygroundDisplayConvertible$implementation{
}


class CommandLine{











/*Swift.(file).CommandLine.argc*/
static argc$get() {
let _this = this;
_.discardAssignment = _cloneStruct(CommandLine.unsafeArgv);
return _this._argc;
}
static get argc() { return this.argc$get()
}
static get argc() { return this.argc$get() };




/*Swift.(file).CommandLine.unsafeArgv*/
static unsafeArgv$get() {
let _this = this;
return _this._unsafeArgv;
}
static get unsafeArgv() { return this.unsafeArgv$get()
}
static get unsafeArgv() { return this.unsafeArgv$get() };








init$vars() {let _this = this;

}
}
_mixin(CommandLine, _DefaultEnumImplementation, false)


interface SIMDStorage<Scalar>{


/*Swift.(file).SIMDStorage.scalarCount*/
scalarCount;



/*Swift.(file).SIMDStorage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?)
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?)/*Swift.(file).SIMDStorage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?)



}
class SIMDStorage$implementation{

/*Swift.(file).SIMDStorage.scalarCount*/
static scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
static get scalarCount() { return this.scalarCount$get() };



}




interface SIMDScalar<SIMDMaskScalar, SIMD2Storage, SIMD4Storage, SIMD8Storage, SIMD16Storage, SIMD32Storage, SIMD64Storage>{







}
class SIMDScalar$implementation{
}


class UnfoldSequence<Element, State> implements Sequence, IteratorProtocol{
static readonly $struct = true
/*Swift.(file).UnfoldSequence.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if(!((Bool.$not(_this._done)))) {
return _injectIntoOptional(null);
};
const $ifLet0, elt_1
if((($ifLet0 = _this._next({get: () => _this._state, set: $val => _this._state = $val}))||true) && $ifLet0.rawValue == 'some' && ((elt_1 = $ifLet0[0])||true)) {
return _injectIntoOptional(elt_1);
}
else {
_this._done = true;
return _injectIntoOptional(null);
}
}
/*Swift.(file).UnfoldSequence.init(_state:State,_next:(inout State) -> Element?)*/
/*Swift.(file).UnfoldSequence.init(_state:State,_next:(inout State) -> Element?)*/
init_state_nextfunction_type(_state, _next, $info?) {
throw 'unsupported method Swift.(file).UnfoldSequence.init(_state:State,_next:(inout State) -> Element?) in ' + this.constructor.name
}















init$vars() {let _this = this;

}
}
if(typeof Sequence$implementation != 'undefined') _mixin(UnfoldSequence, Sequence$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(UnfoldSequence, IteratorProtocol$implementation, false)


interface CVarArg{



}
class CVarArg$implementation{
}


interface _CVarArgPassedAsDouble extends CVarArg{
}


interface _CVarArgAligned extends CVarArg{



}
class _CVarArgAligned$implementation{
}
if(typeof CVarArg$implementation != 'undefined') _mixin(_CVarArgAligned$implementation, CVarArg$implementation, false)


class __VaListBuilder{
static Header = class{
static readonly $struct = true
/*Swift.(file).__VaListBuilder.Header.init()*/
/*Swift.(file).__VaListBuilder.Header.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__VaListBuilder.Header.init() in ' + this.constructor.name
}

/*Swift.(file).__VaListBuilder.Header.gp_offset*/
gp_offset$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.Header.gp_offset in ' + this.constructor.name
}
get gp_offset() { return this.gp_offset$get() };






/*Swift.(file).__VaListBuilder.Header.fp_offset*/
fp_offset$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.Header.fp_offset in ' + this.constructor.name
}
get fp_offset() { return this.fp_offset$get() };






/*Swift.(file).__VaListBuilder.Header.overflow_arg_area*/
overflow_arg_area$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.Header.overflow_arg_area in ' + this.constructor.name
}
get overflow_arg_area() { return this.overflow_arg_area$get() };






/*Swift.(file).__VaListBuilder.Header.reg_save_area*/
reg_save_area$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.Header.reg_save_area in ' + this.constructor.name
}
get reg_save_area() { return this.reg_save_area$get() };





init$vars() {let _this = this;

}
}

/*Swift.(file).__VaListBuilder.gpRegistersUsed*/
gpRegistersUsed$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.gpRegistersUsed in ' + this.constructor.name
}
get gpRegistersUsed() { return this.gpRegistersUsed$get() };






/*Swift.(file).__VaListBuilder.fpRegistersUsed*/
fpRegistersUsed$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.fpRegistersUsed in ' + this.constructor.name
}
get fpRegistersUsed() { return this.fpRegistersUsed$get() };






/*Swift.(file).__VaListBuilder.header*/
header$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.header in ' + this.constructor.name
}
get header() { return this.header$get() };






/*Swift.(file).__VaListBuilder.storage*/
storage$get() {
throw 'unsupported variable Swift.(file).__VaListBuilder.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };





/*Swift.(file).__VaListBuilder.init()*/
/*Swift.(file).__VaListBuilder.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__VaListBuilder.init() in ' + this.constructor.name
}

/*Swift.(file).__VaListBuilder.append(_:CVarArg)*/
/*Swift.(file).__VaListBuilder.append(_:CVarArg)*/
append(arg, $info?) {
throw 'unsupported method Swift.(file).__VaListBuilder.append(_:CVarArg) in ' + this.constructor.name
}
/*Swift.(file).__VaListBuilder.va_list()*/
/*Swift.(file).__VaListBuilder.va_list()*/
va_list($info?) {
throw 'unsupported method Swift.(file).__VaListBuilder.va_list() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class Zip2Sequence<Sequence1, Sequence2> implements Sequence{
static readonly $struct = true






/*Swift.(file).Zip2Sequence.init(_:Sequence1,_:Sequence2)*/
/*Swift.(file).Zip2Sequence.init(_:Sequence1,_:Sequence2)*/
init(sequence1, sequence2, $info?) {
throw 'unsupported method Swift.(file).Zip2Sequence.init(_:Sequence1,_:Sequence2) in ' + this.constructor.name
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true















/*Swift.(file).Zip2Sequence.Iterator.init(_:Sequence1.Iterator,_:Sequence2.Iterator)*/
/*Swift.(file).Zip2Sequence.Iterator.init(_:Sequence1.Iterator,_:Sequence2.Iterator)*/
init(iterator1, iterator2, $info?) {
let _this = this;
let $tuple = {0: iterator1, 1: iterator2}
_this._baseStream1 = $tuple[0]
_this._baseStream2 = $tuple[1];
return
}

/*Swift.(file).Zip2Sequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if((_this._reachedEnd)) {
return _injectIntoOptional(null);
};
const $ifLet0, element1_1
const $ifLet2, element2_3
if(!((($ifLet0 = _this._baseStream1.next( {$setThis: $val => _this._baseStream1 = $val}))||true) && $ifLet0.rawValue == 'some' && ((element1_1 = $ifLet0[0])||true) && (($ifLet2 = _this._baseStream2.next( {$setThis: $val => _this._baseStream2 = $val}))||true) && $ifLet2.rawValue == 'some' && ((element2_3 = $ifLet2[0])||true))) {
_this._reachedEnd = true;
return _injectIntoOptional(null);
};
return _injectIntoOptional({0: element1_1, 1: element2_3})
}
init$vars() {let _this = this;

}
}



/*Swift.(file).Zip2Sequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(Zip2Sequence.Iterator, 'init', _this._sequence1.makeIterator( {}), _this._sequence2.makeIterator( {}), {})
}

/*Swift.(file).Zip2Sequence.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return 0
}
get underestimatedCount() { return this.underestimatedCount$get() };



init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(Zip2Sequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(Zip2Sequence, Sequence$implementation, false)






class _stdlib_AtomicInt{








/*Swift.(file)._stdlib_AtomicInt.init(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.init(_:Int)*/
initInt(value, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.init(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.store(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.store(_:Int)*/
store(desired, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.store(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.load()*/
/*Swift.(file)._stdlib_AtomicInt.load()*/
load($info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.load() in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.fetchAndAdd(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.fetchAndAdd(_:Int)*/
fetchAndAdd(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.fetchAndAdd(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.addAndFetch(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.addAndFetch(_:Int)*/
addAndFetch(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.addAndFetch(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.fetchAndAnd(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.fetchAndAnd(_:Int)*/
fetchAndAnd(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.fetchAndAnd(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.andAndFetch(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.andAndFetch(_:Int)*/
andAndFetch(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.andAndFetch(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.fetchAndOr(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.fetchAndOr(_:Int)*/
fetchAndOr(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.fetchAndOr(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.orAndFetch(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.orAndFetch(_:Int)*/
orAndFetch(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.orAndFetch(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.fetchAndXor(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.fetchAndXor(_:Int)*/
fetchAndXor(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.fetchAndXor(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.xorAndFetch(_:Int)*/
/*Swift.(file)._stdlib_AtomicInt.xorAndFetch(_:Int)*/
xorAndFetch(operand, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.xorAndFetch(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._stdlib_AtomicInt.compareExchange(expected:Int,desired:Int)*/
/*Swift.(file)._stdlib_AtomicInt.compareExchange(expected:Int,desired:Int)*/
compareExchangeExpectedDesired(expected$inout, desired, $info?) {
throw 'unsupported method Swift.(file)._stdlib_AtomicInt.compareExchange(expected:Int,desired:Int) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


interface Encodable{
/*Swift.(file).Encodable.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?)
}
class Encodable$implementation{
}


interface Decodable{
/*Swift.(file).Decodable.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?)
}
class Decodable$implementation{
}


interface CodingKey extends CustomStringConvertible, CustomDebugStringConvertible{

/*Swift.(file).CodingKey.stringValue*/
stringValue;



/*Swift.(file).CodingKey.init(stringValue:String)*/
/*Swift.(file).CodingKey.init(stringValue:String)*/
initStringValueString(stringValue, $info?)

/*Swift.(file).CodingKey.intValue*/
intValue;



/*Swift.(file).CodingKey.init(intValue:Int)*/
/*Swift.(file).CodingKey.init(intValue:Int)*/
initIntValueInt(intValue, $info?)
}
class CodingKey$implementation{

/*Swift.(file).CodingKey.description*/
description$get() {
throw 'unsupported variable Swift.(file).CodingKey.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).CodingKey.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).CodingKey.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



}
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(CodingKey$implementation, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(CodingKey$implementation, CustomDebugStringConvertible$implementation, false)




interface Encoder{

/*Swift.(file).Encoder.codingPath*/
codingPath;




/*Swift.(file).Encoder.userInfo*/
userInfo;



/*Swift.(file).Encoder.container(keyedBy:Key.Type)*/
/*Swift.(file).Encoder.container(keyedBy:Key.Type)*/
containerKeyedBy<Key>(type, $info?)
/*Swift.(file).Encoder.unkeyedContainer()*/
/*Swift.(file).Encoder.unkeyedContainer()*/
unkeyedContainer($info?)
/*Swift.(file).Encoder.singleValueContainer()*/
/*Swift.(file).Encoder.singleValueContainer()*/
singleValueContainer($info?)
}
class Encoder$implementation{
}


interface Decoder{

/*Swift.(file).Decoder.codingPath*/
codingPath;




/*Swift.(file).Decoder.userInfo*/
userInfo;



/*Swift.(file).Decoder.container(keyedBy:Key.Type)*/
/*Swift.(file).Decoder.container(keyedBy:Key.Type)*/
containerKeyedBy<Key>(type, $info?)
/*Swift.(file).Decoder.unkeyedContainer()*/
/*Swift.(file).Decoder.unkeyedContainer()*/
unkeyedContainer($info?)
/*Swift.(file).Decoder.singleValueContainer()*/
/*Swift.(file).Decoder.singleValueContainer()*/
singleValueContainer($info?)
}
class Decoder$implementation{
}


interface KeyedEncodingContainerProtocol<Key>{


/*Swift.(file).KeyedEncodingContainerProtocol.codingPath*/
codingPath;



/*Swift.(file).KeyedEncodingContainerProtocol.encodeNil(forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeNil(forKey:Self.Key)*/
encodeNilForKey(key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Bool,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Bool,forKey:Self.Key)*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:String,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:String,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Double,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Double,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Float,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Float,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int8,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int8,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int16,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int16,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int32,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int32,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int64,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int64,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt8,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt8,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt16,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt16,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt32,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt32,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt64,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt64,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:T,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:T,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey<T>(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeConditional(_:T,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeConditional(_:T,forKey:Self.Key)*/
encodeConditionalForKey<T>(object, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Bool?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Bool?,forKey:Self.Key)*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:String?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:String?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Double?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Double?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Float?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Float?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int8?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int8?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int16?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int16?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int32?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int32?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int64?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int64?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt8?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt8?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt16?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt16?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt32?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt32?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt64?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt64?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:T?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:T?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey<T>(value, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.nestedContainer(keyedBy:NestedKey.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.nestedContainer(keyedBy:NestedKey.Type,forKey:Self.Key)*/
nestedContainerKeyedByForKey<NestedKey>(keyType, key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.nestedUnkeyedContainer(forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.nestedUnkeyedContainer(forKey:Self.Key)*/
nestedUnkeyedContainerForKey(key, $info?)
/*Swift.(file).KeyedEncodingContainerProtocol.superEncoder()*/
/*Swift.(file).KeyedEncodingContainerProtocol.superEncoder()*/
superEncoder($info?)
/*Swift.(file).KeyedEncodingContainerProtocol.superEncoder(forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.superEncoder(forKey:Self.Key)*/
superEncoderForKey(key, $info?)
}
class KeyedEncodingContainerProtocol$implementation{
/*Swift.(file).KeyedEncodingContainerProtocol.encodeConditional(_:T,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeConditional(_:T,forKey:Self.Key)*/
encodeConditionalForKey<T>(object, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeConditional(_:T,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Bool?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Bool?,forKey:Self.Key)*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Bool?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:String?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:String?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:String?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Double?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Double?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Double?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Float?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Float?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Float?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int8?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int8?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int8?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int16?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int16?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int16?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int32?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int32?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int32?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int64?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int64?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int64?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt8?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt8?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt8?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt16?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt16?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt16?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt32?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt32?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt32?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt64?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt64?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt64?,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:T?,forKey:Self.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:T?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey<T>(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:T?,forKey:Self.Key) in ' + this.constructor.name
}
}






class KeyedEncodingContainer<K> implements KeyedEncodingContainerProtocol{
static readonly $struct = true






/*Swift.(file).KeyedEncodingContainer.init(_:Container)*/
/*Swift.(file).KeyedEncodingContainer.init(_:Container)*/
init<Container>(container, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.init(_:Container) in ' + this.constructor.name
}

/*Swift.(file).KeyedEncodingContainer.codingPath*/
codingPath$get() {
throw 'unsupported variable Swift.(file).KeyedEncodingContainer.codingPath in ' + this.constructor.name
}
get codingPath() { return this.codingPath$get() };



/*Swift.(file).KeyedEncodingContainer.encodeNil(forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeNil(forKey:Self.Key)*/
encodeNilForKey(key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeNil(forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Bool,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Bool,forKey:Self.Key)*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Bool,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:String,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:String,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:String,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Double,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Double,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Double,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Float,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Float,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Float,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Int,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Int,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Int8,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int8,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Int8,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Int16,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int16,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Int16,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Int32,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int32,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Int32,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:Int64,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:Int64,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:Int64,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:UInt,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:UInt,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:UInt8,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt8,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:UInt8,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:UInt16,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt16,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:UInt16,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:UInt32,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt32,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:UInt32,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:UInt64,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:UInt64,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:UInt64,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encode(_:T,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encode(_:T,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey<T>(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encode(_:T,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeConditional(_:T,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeConditional(_:T,forKey:Self.Key)*/
encodeConditionalForKey<T>(object, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeConditional(_:T,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Bool?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Bool?,forKey:Self.Key)*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Bool?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:String?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:String?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:String?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Double?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Double?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Double?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Float?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Float?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Float?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int8?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int8?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int8?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int16?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int16?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int16?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int32?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int32?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int32?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int64?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:Int64?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:Int64?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt8?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt8?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt8?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt16?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt16?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt16?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt32?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt32?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt32?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt64?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:UInt64?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:UInt64?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:T?,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.encodeIfPresent(_:T?,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey<T>(value, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.encodeIfPresent(_:T?,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.nestedContainer(keyedBy:NestedKey.Type,forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.nestedContainer(keyedBy:NestedKey.Type,forKey:Self.Key)*/
nestedContainerKeyedByForKey<NestedKey>(keyType, key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.nestedContainer(keyedBy:NestedKey.Type,forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.nestedUnkeyedContainer(forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.nestedUnkeyedContainer(forKey:Self.Key)*/
nestedUnkeyedContainerForKey(key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.nestedUnkeyedContainer(forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.superEncoder()*/
/*Swift.(file).KeyedEncodingContainerProtocol.superEncoder()*/
superEncoder($info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.superEncoder() in ' + this.constructor.name
}
/*Swift.(file).KeyedEncodingContainer.superEncoder(forKey:KeyedEncodingContainer<K>.Key)*/
/*Swift.(file).KeyedEncodingContainerProtocol.superEncoder(forKey:Self.Key)*/
superEncoderForKey(key, $info?) {
throw 'unsupported method Swift.(file).KeyedEncodingContainer.superEncoder(forKey:KeyedEncodingContainer<K>.Key) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof KeyedEncodingContainerProtocol$implementation != 'undefined') _mixin(KeyedEncodingContainer, KeyedEncodingContainerProtocol$implementation, false)


interface KeyedDecodingContainerProtocol<Key>{


/*Swift.(file).KeyedDecodingContainerProtocol.codingPath*/
codingPath;




/*Swift.(file).KeyedDecodingContainerProtocol.allKeys*/
allKeys;



/*Swift.(file).KeyedDecodingContainerProtocol.contains(_:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.contains(_:Self.Key)*/
contains(key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeNil(forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeNil(forKey:Self.Key)*/
decodeNilForKey(key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Bool.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Bool.Type,forKey:Self.Key)*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:String.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:String.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Double.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Double.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Float.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Float.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int8.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int16.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int32.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int64.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt8.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt16.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt32.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt64.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:T.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:T.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey<T>(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Bool.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Bool.Type,forKey:Self.Key)*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:String.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:String.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Double.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Double.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Float.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Float.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int8.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int16.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int32.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int64.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt8.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt16.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt32.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt64.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:T.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:T.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey<T>(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.nestedContainer(keyedBy:NestedKey.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.nestedContainer(keyedBy:NestedKey.Type,forKey:Self.Key)*/
nestedContainerKeyedByForKey<NestedKey>(type, key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.nestedUnkeyedContainer(forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.nestedUnkeyedContainer(forKey:Self.Key)*/
nestedUnkeyedContainerForKey(key, $info?)
/*Swift.(file).KeyedDecodingContainerProtocol.superDecoder()*/
/*Swift.(file).KeyedDecodingContainerProtocol.superDecoder()*/
superDecoder($info?)
/*Swift.(file).KeyedDecodingContainerProtocol.superDecoder(forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.superDecoder(forKey:Self.Key)*/
superDecoderForKey(key, $info?)
}
class KeyedDecodingContainerProtocol$implementation{
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Bool.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Bool.Type,forKey:Self.Key)*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Bool.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:String.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:String.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:String.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Double.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Double.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Double.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Float.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Float.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Float.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int8.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int8.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int16.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int16.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int32.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int32.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int64.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int64.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt8.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt8.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt16.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt16.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt32.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt32.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt64.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt64.Type,forKey:Self.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:T.Type,forKey:Self.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:T.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey<T>(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:T.Type,forKey:Self.Key) in ' + this.constructor.name
}
}




class KeyedDecodingContainer<K> implements KeyedDecodingContainerProtocol{
static readonly $struct = true






/*Swift.(file).KeyedDecodingContainer.init(_:Container)*/
/*Swift.(file).KeyedDecodingContainer.init(_:Container)*/
init<Container>(container, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.init(_:Container) in ' + this.constructor.name
}

/*Swift.(file).KeyedDecodingContainer.codingPath*/
codingPath$get() {
throw 'unsupported variable Swift.(file).KeyedDecodingContainer.codingPath in ' + this.constructor.name
}
get codingPath() { return this.codingPath$get() };




/*Swift.(file).KeyedDecodingContainer.allKeys*/
allKeys$get() {
throw 'unsupported variable Swift.(file).KeyedDecodingContainer.allKeys in ' + this.constructor.name
}
get allKeys() { return this.allKeys$get() };



/*Swift.(file).KeyedDecodingContainer.contains(_:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.contains(_:Self.Key)*/
contains(key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.contains(_:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeNil(forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeNil(forKey:Self.Key)*/
decodeNilForKey(key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeNil(forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Bool.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Bool.Type,forKey:Self.Key)*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Bool.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:String.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:String.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:String.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Double.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Double.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Double.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Float.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Float.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Float.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Int.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Int.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Int8.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Int8.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Int16.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Int16.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Int32.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Int32.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:Int64.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:Int64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:Int64.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:UInt.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:UInt.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:UInt8.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:UInt8.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:UInt16.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:UInt16.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:UInt32.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:UInt32.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:UInt64.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:UInt64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:UInt64.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decode(_:T.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decode(_:T.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey<T>(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decode(_:T.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Bool.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Bool.Type,forKey:Self.Key)*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Bool.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:String.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:String.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:String.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Double.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Double.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Double.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Float.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Float.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Float.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int8.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int8.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int16.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int16.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int32.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int32.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int64.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:Int64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:Int64.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt8.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt8.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt8.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt16.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt16.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt16.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt32.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt32.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt32.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt64.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:UInt64.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:UInt64.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:T.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.decodeIfPresent(_:T.Type,forKey:Self.Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey<T>(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.decodeIfPresent(_:T.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.nestedContainer(keyedBy:NestedKey.Type,forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.nestedContainer(keyedBy:NestedKey.Type,forKey:Self.Key)*/
nestedContainerKeyedByForKey<NestedKey>(type, key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.nestedContainer(keyedBy:NestedKey.Type,forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.nestedUnkeyedContainer(forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.nestedUnkeyedContainer(forKey:Self.Key)*/
nestedUnkeyedContainerForKey(key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.nestedUnkeyedContainer(forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.superDecoder()*/
/*Swift.(file).KeyedDecodingContainerProtocol.superDecoder()*/
superDecoder($info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.superDecoder() in ' + this.constructor.name
}
/*Swift.(file).KeyedDecodingContainer.superDecoder(forKey:KeyedDecodingContainer<K>.Key)*/
/*Swift.(file).KeyedDecodingContainerProtocol.superDecoder(forKey:Self.Key)*/
superDecoderForKey(key, $info?) {
throw 'unsupported method Swift.(file).KeyedDecodingContainer.superDecoder(forKey:KeyedDecodingContainer<K>.Key) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof KeyedDecodingContainerProtocol$implementation != 'undefined') _mixin(KeyedDecodingContainer, KeyedDecodingContainerProtocol$implementation, false)


interface UnkeyedEncodingContainer{

/*Swift.(file).UnkeyedEncodingContainer.codingPath*/
codingPath;




/*Swift.(file).UnkeyedEncodingContainer.count*/
count;



/*Swift.(file).UnkeyedEncodingContainer.encodeNil()*/
/*Swift.(file).UnkeyedEncodingContainer.encodeNil()*/
encodeNil($info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Bool)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Bool)*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:String)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:String)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Double)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Double)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Float)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Float)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int8)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int8)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int16)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int16)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int32)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int32)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int64)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:Int64)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt8)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt8)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt16)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt16)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt32)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt32)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt64)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:UInt64)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(_:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(_:T)*/
/*!!!DUPLICATE NAME*/
encode<T>(value, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encodeConditional(_:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encodeConditional(_:T)*/
encodeConditional<T>(object, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?)
/*Swift.(file).UnkeyedEncodingContainer.nestedContainer(keyedBy:NestedKey.Type)*/
/*Swift.(file).UnkeyedEncodingContainer.nestedContainer(keyedBy:NestedKey.Type)*/
nestedContainerKeyedBy<NestedKey>(keyType, $info?)
/*Swift.(file).UnkeyedEncodingContainer.nestedUnkeyedContainer()*/
/*Swift.(file).UnkeyedEncodingContainer.nestedUnkeyedContainer()*/
nestedUnkeyedContainer($info?)
/*Swift.(file).UnkeyedEncodingContainer.superEncoder()*/
/*Swift.(file).UnkeyedEncodingContainer.superEncoder()*/
superEncoder($info?)
}
class UnkeyedEncodingContainer$implementation{
/*Swift.(file).UnkeyedEncodingContainer.encodeConditional(_:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encodeConditional(_:T)*/
encodeConditional<T>(object, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encodeConditional(_:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
/*Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T)*/
encodeContentsOf<T>(sequence, $info?) {
throw 'unsupported method Swift.(file).UnkeyedEncodingContainer.encode(contentsOf:T) in ' + this.constructor.name
}
}




interface UnkeyedDecodingContainer{

/*Swift.(file).UnkeyedDecodingContainer.codingPath*/
codingPath;




/*Swift.(file).UnkeyedDecodingContainer.count*/
count;




/*Swift.(file).UnkeyedDecodingContainer.isAtEnd*/
isAtEnd;




/*Swift.(file).UnkeyedDecodingContainer.currentIndex*/
currentIndex;



/*Swift.(file).UnkeyedDecodingContainer.decodeNil()*/
/*Swift.(file).UnkeyedDecodingContainer.decodeNil()*/
decodeNil($info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Bool.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Bool.Type)*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:String.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:String.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Double.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Double.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Float.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Float.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int8.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int8.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int16.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int16.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int32.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int32.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int64.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:Int64.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt8.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt8.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt16.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt16.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt32.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt32.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt64.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:UInt64.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decode(_:T.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decode(_:T.Type)*/
/*!!!DUPLICATE NAME*/
decode<T>(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Bool.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Bool.Type)*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:String.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:String.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Double.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Double.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Float.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Float.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int8.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int8.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int16.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int16.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int32.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int32.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int64.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int64.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt8.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt8.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt16.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt16.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt32.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt32.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt64.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt64.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:T.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:T.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent<T>(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.nestedContainer(keyedBy:NestedKey.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.nestedContainer(keyedBy:NestedKey.Type)*/
nestedContainerKeyedBy<NestedKey>(type, $info?)
/*Swift.(file).UnkeyedDecodingContainer.nestedUnkeyedContainer()*/
/*Swift.(file).UnkeyedDecodingContainer.nestedUnkeyedContainer()*/
nestedUnkeyedContainer($info?)
/*Swift.(file).UnkeyedDecodingContainer.superDecoder()*/
/*Swift.(file).UnkeyedDecodingContainer.superDecoder()*/
superDecoder($info?)
}
class UnkeyedDecodingContainer$implementation{
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Bool.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Bool.Type)*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Bool.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:String.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:String.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:String.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Double.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Double.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Double.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Float.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Float.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Float.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int8.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int8.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int8.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int16.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int16.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int16.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int32.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int32.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int32.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int64.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int64.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:Int64.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt8.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt8.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt8.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt16.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt16.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt16.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt32.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt32.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt32.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt64.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt64.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:UInt64.Type) in ' + this.constructor.name
}
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:T.Type)*/
/*Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:T.Type)*/
/*!!!DUPLICATE NAME*/
decodeIfPresent<T>(type, $info?) {
throw 'unsupported method Swift.(file).UnkeyedDecodingContainer.decodeIfPresent(_:T.Type) in ' + this.constructor.name
}
}




interface SingleValueEncodingContainer{

/*Swift.(file).SingleValueEncodingContainer.codingPath*/
codingPath;



/*Swift.(file).SingleValueEncodingContainer.encodeNil()*/
/*Swift.(file).SingleValueEncodingContainer.encodeNil()*/
encodeNil($info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Bool)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Bool)*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:String)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:String)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Double)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Double)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Float)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Float)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int8)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int8)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int16)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int16)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int32)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int32)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int64)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:Int64)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt8)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt8)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt16)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt16)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt32)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt32)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt64)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:UInt64)*/
/*!!!DUPLICATE NAME*/
encode(value, $info?)
/*Swift.(file).SingleValueEncodingContainer.encode(_:T)*/
/*Swift.(file).SingleValueEncodingContainer.encode(_:T)*/
/*!!!DUPLICATE NAME*/
encode<T>(value, $info?)
}
class SingleValueEncodingContainer$implementation{
}


interface SingleValueDecodingContainer{

/*Swift.(file).SingleValueDecodingContainer.codingPath*/
codingPath;



/*Swift.(file).SingleValueDecodingContainer.decodeNil()*/
/*Swift.(file).SingleValueDecodingContainer.decodeNil()*/
decodeNil($info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Bool.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Bool.Type)*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:String.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:String.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Double.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Double.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Float.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Float.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int8.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int8.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int16.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int16.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int32.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int32.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int64.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:Int64.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt8.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt8.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt16.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt16.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt32.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt32.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt64.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:UInt64.Type)*/
/*!!!DUPLICATE NAME*/
decode(type, $info?)
/*Swift.(file).SingleValueDecodingContainer.decode(_:T.Type)*/
/*Swift.(file).SingleValueDecodingContainer.decode(_:T.Type)*/
/*!!!DUPLICATE NAME*/
decode<T>(type, $info?)
}
class SingleValueDecodingContainer$implementation{
}


class CodingUserInfoKey implements RawRepresentable, Equatable, Hashable{
static readonly $struct = true


/*Swift.(file).CodingUserInfoKey.rawValue*/
readonly rawValue$get() {
throw 'unsupported variable Swift.(file).CodingUserInfoKey.rawValue in ' + this.constructor.name
}
readonly get rawValue() { return this.rawValue$get() };



/*Swift.(file).CodingUserInfoKey.init(rawValue:String)*/
/*Swift.(file).RawRepresentable.init(rawValue:Self.RawValue)*/
initRawValue(rawValue, $info?) {
throw 'unsupported method Swift.(file).CodingUserInfoKey.init(rawValue:String) in ' + this.constructor.name
}
static readonly initRawValue$failable = true
static /*Swift.(file).CodingUserInfoKey.==infix(_:CodingUserInfoKey,_:CodingUserInfoKey)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}

/*Swift.(file).CodingUserInfoKey.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).CodingUserInfoKey.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).CodingUserInfoKey.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).CodingUserInfoKey.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof RawRepresentable$implementation != 'undefined') _mixin(CodingUserInfoKey, RawRepresentable$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(CodingUserInfoKey, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(CodingUserInfoKey, Hashable$implementation, false)


class EncodingError implements Error{
static Context = class{
static readonly $struct = true

/*Swift.(file).EncodingError.Context.codingPath*/
readonly codingPath$get() {
throw 'unsupported variable Swift.(file).EncodingError.Context.codingPath in ' + this.constructor.name
}
readonly get codingPath() { return this.codingPath$get() };




/*Swift.(file).EncodingError.Context.debugDescription*/
readonly debugDescription$get() {
throw 'unsupported variable Swift.(file).EncodingError.Context.debugDescription in ' + this.constructor.name
}
readonly get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).EncodingError.Context.underlyingError*/
readonly underlyingError$get() {
throw 'unsupported variable Swift.(file).EncodingError.Context.underlyingError in ' + this.constructor.name
}
readonly get underlyingError() { return this.underlyingError$get() };



/*Swift.(file).EncodingError.Context.init(codingPath:[CodingKey],debugDescription:String,underlyingError:Error?)*/
/*Swift.(file).EncodingError.Context.init(codingPath:[CodingKey],debugDescription:String,underlyingError:Error?)*/
initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional(codingPath, debugDescription, underlyingError, $info?) {
throw 'unsupported method Swift.(file).EncodingError.Context.init(codingPath:[CodingKey],debugDescription:String,underlyingError:Error?) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}

static invalidValue() {return Object.assign(new EncodingError(), {rawValue: "invalidValue", ...Array.from(arguments)})}









init$vars() {let _this = this;

}
}
if(typeof Error$implementation != 'undefined') _mixin(EncodingError, Error$implementation, false)
_mixin(EncodingError, _DefaultEnumImplementation, false)


class DecodingError implements Error{
static Context = class{
static readonly $struct = true

/*Swift.(file).DecodingError.Context.codingPath*/
readonly codingPath$get() {
throw 'unsupported variable Swift.(file).DecodingError.Context.codingPath in ' + this.constructor.name
}
readonly get codingPath() { return this.codingPath$get() };




/*Swift.(file).DecodingError.Context.debugDescription*/
readonly debugDescription$get() {
throw 'unsupported variable Swift.(file).DecodingError.Context.debugDescription in ' + this.constructor.name
}
readonly get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).DecodingError.Context.underlyingError*/
readonly underlyingError$get() {
throw 'unsupported variable Swift.(file).DecodingError.Context.underlyingError in ' + this.constructor.name
}
readonly get underlyingError() { return this.underlyingError$get() };



/*Swift.(file).DecodingError.Context.init(codingPath:[CodingKey],debugDescription:String,underlyingError:Error?)*/
/*Swift.(file).DecodingError.Context.init(codingPath:[CodingKey],debugDescription:String,underlyingError:Error?)*/
initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional(codingPath, debugDescription, underlyingError, $info?) {
throw 'unsupported method Swift.(file).DecodingError.Context.init(codingPath:[CodingKey],debugDescription:String,underlyingError:Error?) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}

static typeMismatch() {return Object.assign(new DecodingError(), {rawValue: "typeMismatch", ...Array.from(arguments)})}

static valueNotFound() {return Object.assign(new DecodingError(), {rawValue: "valueNotFound", ...Array.from(arguments)})}

static keyNotFound() {return Object.assign(new DecodingError(), {rawValue: "keyNotFound", ...Array.from(arguments)})}

static dataCorrupted() {return Object.assign(new DecodingError(), {rawValue: "dataCorrupted", ...Array.from(arguments)})}









static /*Swift.(file).DecodingError.dataCorruptedError(forKey:C.Key,in:C,debugDescription:String)*/
/*Swift.(file).DecodingError.dataCorruptedError(forKey:C.Key,in:C,debugDescription:String)*/
dataCorruptedErrorForKeyInDebugDescription<C>(key, container, debugDescription, $info?) {
throw 'unsupported method Swift.(file).DecodingError.dataCorruptedError(forKey:C.Key,in:C,debugDescription:String) in ' + this.constructor.name
}
static /*Swift.(file).DecodingError.dataCorruptedError(in:UnkeyedDecodingContainer,debugDescription:String)*/
/*Swift.(file).DecodingError.dataCorruptedError(in:UnkeyedDecodingContainer,debugDescription:String)*/
dataCorruptedErrorInDebugDescription(container, debugDescription, $info?) {
throw 'unsupported method Swift.(file).DecodingError.dataCorruptedError(in:UnkeyedDecodingContainer,debugDescription:String) in ' + this.constructor.name
}
static /*Swift.(file).DecodingError.dataCorruptedError(in:SingleValueDecodingContainer,debugDescription:String)*/
/*Swift.(file).DecodingError.dataCorruptedError(in:SingleValueDecodingContainer,debugDescription:String)*/
/*!!!DUPLICATE NAME*/
dataCorruptedErrorInDebugDescription(container, debugDescription, $info?) {
throw 'unsupported method Swift.(file).DecodingError.dataCorruptedError(in:SingleValueDecodingContainer,debugDescription:String) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof Error$implementation != 'undefined') _mixin(DecodingError, Error$implementation, false)
_mixin(DecodingError, _DefaultEnumImplementation, false)




class _GenericIndexKey implements CodingKey{
static readonly $struct = true

/*Swift.(file)._GenericIndexKey.stringValue*/
stringValue$get() {
throw 'unsupported variable Swift.(file)._GenericIndexKey.stringValue in ' + this.constructor.name
}
get stringValue() { return this.stringValue$get() };






/*Swift.(file)._GenericIndexKey.intValue*/
intValue$get() {
throw 'unsupported variable Swift.(file)._GenericIndexKey.intValue in ' + this.constructor.name
}
get intValue() { return this.intValue$get() };





/*Swift.(file)._GenericIndexKey.init(stringValue:String)*/
/*Swift.(file).CodingKey.init(stringValue:String)*/
initStringValueString(stringValue, $info?) {
throw 'unsupported method Swift.(file)._GenericIndexKey.init(stringValue:String) in ' + this.constructor.name
}
static readonly initStringValueString$failable = true
/*Swift.(file)._GenericIndexKey.init(intValue:Int)*/
/*Swift.(file).CodingKey.init(intValue:Int)*/
initIntValueInt(intValue, $info?) {
throw 'unsupported method Swift.(file)._GenericIndexKey.init(intValue:Int) in ' + this.constructor.name
}
static readonly initIntValueInt$failable = true
init$vars() {let _this = this;

}
}
if(typeof CodingKey$implementation != 'undefined') _mixin(_GenericIndexKey, CodingKey$implementation, false)


class _KeyedEncodingContainerBase<Key>{
/*Swift.(file)._KeyedEncodingContainerBase.init()*/
/*Swift.(file)._KeyedEncodingContainerBase.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.init() in ' + this.constructor.name
}


/*Swift.(file)._KeyedEncodingContainerBase.codingPath*/
codingPath$get() {
throw 'unsupported variable Swift.(file)._KeyedEncodingContainerBase.codingPath in ' + this.constructor.name
}
get codingPath() { return this.codingPath$get() };



/*Swift.(file)._KeyedEncodingContainerBase.encodeNil(forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeNil(forKey:Key)*/
encodeNilForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeNil(forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Bool,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Bool,forKey:Key)*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Bool,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:String,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:String,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:String,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Double,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Double,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Double,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Float,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Float,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Float,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Int,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int8,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int8,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Int8,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int16,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int16,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Int16,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int32,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int32,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Int32,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int64,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int64,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:Int64,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt8,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt8,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt8,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt16,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt16,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt16,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt32,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt32,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt32,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt64,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt64,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt64,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:T,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:T,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey<T>(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encode(_:T,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeConditional(_:T,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeConditional(_:T,forKey:Key)*/
encodeConditionalForKey<T>(object, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeConditional(_:T,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Bool?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Bool?,forKey:Key)*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Bool?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:String?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:String?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:String?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Double?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Double?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Double?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Float?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Float?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Float?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int8?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int8?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int8?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int16?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int16?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int16?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int32?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int32?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int32?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int64?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int64?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int64?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt8?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt8?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt8?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt16?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt16?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt16?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt32?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt32?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt32?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt64?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt64?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt64?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:T?,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:T?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey<T>(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:T?,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key)*/
nestedContainerKeyedByForKey<NestedKey>(keyType, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.nestedUnkeyedContainer(forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.nestedUnkeyedContainer(forKey:Key)*/
nestedUnkeyedContainerForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.nestedUnkeyedContainer(forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.superEncoder()*/
/*Swift.(file)._KeyedEncodingContainerBase.superEncoder()*/
superEncoder($info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.superEncoder() in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBase.superEncoder(forKey:Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.superEncoder(forKey:Key)*/
superEncoderForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBase.superEncoder(forKey:Key) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class _KeyedEncodingContainerBox<Concrete> extends _KeyedEncodingContainerBase{


/*Swift.(file)._KeyedEncodingContainerBox.concrete*/
concrete$get() {
throw 'unsupported variable Swift.(file)._KeyedEncodingContainerBox.concrete in ' + this.constructor.name
}
get concrete() { return this.concrete$get() };





/*Swift.(file)._KeyedEncodingContainerBox.init(_:Concrete)*/
/*Swift.(file)._KeyedEncodingContainerBox.init(_:Concrete)*/
init(container, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.init(_:Concrete) in ' + this.constructor.name
}

/*Swift.(file)._KeyedEncodingContainerBox.codingPath*/
codingPath$get() {
throw 'unsupported variable Swift.(file)._KeyedEncodingContainerBox.codingPath in ' + this.constructor.name
}
get codingPath() { return this.codingPath$get() };



/*Swift.(file)._KeyedEncodingContainerBox.encodeNil(forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeNil(forKey:Key)*/
encodeNilForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeNil(forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Bool,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Bool,forKey:Key)*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Bool,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:String,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:String,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:String,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Double,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Double,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Double,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Float,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Float,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Float,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Int,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Int,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Int8,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int8,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Int8,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Int16,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int16,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Int16,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Int32,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int32,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Int32,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:Int64,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:Int64,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:Int64,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt8,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt8,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt8,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt16,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt16,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt16,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt32,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt32,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt32,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt64,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:UInt64,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:UInt64,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encode(_:T,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encode(_:T,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeForKey<T>(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encode(_:T,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeConditional(_:T,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeConditional(_:T,forKey:Key)*/
encodeConditionalForKey<T>(object, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeConditional(_:T,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Bool?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Bool?,forKey:Key)*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Bool?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:String?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:String?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:String?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Double?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Double?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Double?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Float?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Float?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Float?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int8?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int8?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int8?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int16?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int16?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int16?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int32?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int32?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int32?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int64?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:Int64?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:Int64?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt8?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt8?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt8?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt16?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt16?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt16?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt32?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt32?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt32?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt64?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:UInt64?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:UInt64?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:T?,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.encodeIfPresent(_:T?,forKey:Key)*/
/*!!!DUPLICATE NAME*/
encodeIfPresentForKey<T>(value, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.encodeIfPresent(_:T?,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.nestedContainer(keyedBy:NestedKey.Type,forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key)*/
nestedContainerKeyedByForKey<NestedKey>(keyType, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.nestedContainer(keyedBy:NestedKey.Type,forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.nestedUnkeyedContainer(forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.nestedUnkeyedContainer(forKey:Key)*/
nestedUnkeyedContainerForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.nestedUnkeyedContainer(forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.superEncoder()*/
/*Swift.(file)._KeyedEncodingContainerBase.superEncoder()*/
superEncoder($info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.superEncoder() in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.superEncoder(forKey:_KeyedEncodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedEncodingContainerBase.superEncoder(forKey:Key)*/
superEncoderForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.superEncoder(forKey:_KeyedEncodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedEncodingContainerBox.init()*/
/*Swift.(file)._KeyedEncodingContainerBase.init()*/
/*!!!DUPLICATE NAME*/
init($info?) {
throw 'unsupported method Swift.(file)._KeyedEncodingContainerBox.init() in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _KeyedDecodingContainerBase<Key>{
/*Swift.(file)._KeyedDecodingContainerBase.init()*/
/*Swift.(file)._KeyedDecodingContainerBase.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.init() in ' + this.constructor.name
}


/*Swift.(file)._KeyedDecodingContainerBase.codingPath*/
codingPath$get() {
throw 'unsupported variable Swift.(file)._KeyedDecodingContainerBase.codingPath in ' + this.constructor.name
}
get codingPath() { return this.codingPath$get() };




/*Swift.(file)._KeyedDecodingContainerBase.allKeys*/
allKeys$get() {
throw 'unsupported variable Swift.(file)._KeyedDecodingContainerBase.allKeys in ' + this.constructor.name
}
get allKeys() { return this.allKeys$get() };



/*Swift.(file)._KeyedDecodingContainerBase.contains(_:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.contains(_:Key)*/
contains(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.contains(_:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeNil(forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeNil(forKey:Key)*/
decodeNilForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeNil(forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Bool.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Bool.Type,forKey:Key)*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Bool.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:String.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:String.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:String.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Double.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Double.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Double.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Float.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Float.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Float.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Int.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int8.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Int8.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int16.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Int16.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int32.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Int32.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int64.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:Int64.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt8.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt8.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt16.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt16.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt32.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt32.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt64.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt64.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:T.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:T.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey<T>(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decode(_:T.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Bool.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Bool.Type,forKey:Key)*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Bool.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:String.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:String.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:String.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Double.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Double.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Double.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Float.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Float.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Float.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int8.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int8.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int16.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int16.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int32.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int32.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int64.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int64.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt8.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt8.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt16.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt16.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt32.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt32.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt64.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt64.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:T.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:T.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey<T>(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:T.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key)*/
nestedContainerKeyedByForKey<NestedKey>(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.nestedUnkeyedContainer(forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.nestedUnkeyedContainer(forKey:Key)*/
nestedUnkeyedContainerForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.nestedUnkeyedContainer(forKey:Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.superDecoder()*/
/*Swift.(file)._KeyedDecodingContainerBase.superDecoder()*/
superDecoder($info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.superDecoder() in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBase.superDecoder(forKey:Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.superDecoder(forKey:Key)*/
superDecoderForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBase.superDecoder(forKey:Key) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class _KeyedDecodingContainerBox<Concrete> extends _KeyedDecodingContainerBase{


/*Swift.(file)._KeyedDecodingContainerBox.concrete*/
concrete$get() {
throw 'unsupported variable Swift.(file)._KeyedDecodingContainerBox.concrete in ' + this.constructor.name
}
get concrete() { return this.concrete$get() };





/*Swift.(file)._KeyedDecodingContainerBox.init(_:Concrete)*/
/*Swift.(file)._KeyedDecodingContainerBox.init(_:Concrete)*/
init(container, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.init(_:Concrete) in ' + this.constructor.name
}

/*Swift.(file)._KeyedDecodingContainerBox.codingPath*/
codingPath$get() {
throw 'unsupported variable Swift.(file)._KeyedDecodingContainerBox.codingPath in ' + this.constructor.name
}
get codingPath() { return this.codingPath$get() };




/*Swift.(file)._KeyedDecodingContainerBox.allKeys*/
allKeys$get() {
throw 'unsupported variable Swift.(file)._KeyedDecodingContainerBox.allKeys in ' + this.constructor.name
}
get allKeys() { return this.allKeys$get() };



/*Swift.(file)._KeyedDecodingContainerBox.contains(_:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.contains(_:Key)*/
contains(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.contains(_:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeNil(forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeNil(forKey:Key)*/
decodeNilForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeNil(forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Bool.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Bool.Type,forKey:Key)*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Bool.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:String.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:String.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:String.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Double.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Double.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Double.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Float.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Float.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Float.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Int.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Int.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Int8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Int8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Int16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Int16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Int32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Int32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:Int64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:Int64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:Int64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:UInt64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:UInt64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decode(_:T.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decode(_:T.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeForKey<T>(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decode(_:T.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Bool.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Bool.Type,forKey:Key)*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Bool.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:String.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:String.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:String.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Double.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Double.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Double.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Float.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Float.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Float.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:Int64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:Int64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt8.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt8.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt16.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt16.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt32.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt32.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:UInt64.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:UInt64.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:T.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.decodeIfPresent(_:T.Type,forKey:Key)*/
/*!!!DUPLICATE NAME*/
decodeIfPresentForKey<T>(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.decodeIfPresent(_:T.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.nestedContainer(keyedBy:NestedKey.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.nestedContainer(keyedBy:NestedKey.Type,forKey:Key)*/
nestedContainerKeyedByForKey<NestedKey>(type, key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.nestedContainer(keyedBy:NestedKey.Type,forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.nestedUnkeyedContainer(forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.nestedUnkeyedContainer(forKey:Key)*/
nestedUnkeyedContainerForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.nestedUnkeyedContainer(forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.superDecoder()*/
/*Swift.(file)._KeyedDecodingContainerBase.superDecoder()*/
superDecoder($info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.superDecoder() in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.superDecoder(forKey:_KeyedDecodingContainerBox<Concrete>.Key)*/
/*Swift.(file)._KeyedDecodingContainerBase.superDecoder(forKey:Key)*/
superDecoderForKey(key, $info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.superDecoder(forKey:_KeyedDecodingContainerBox<Concrete>.Key) in ' + this.constructor.name
}
/*Swift.(file)._KeyedDecodingContainerBox.init()*/
/*Swift.(file)._KeyedDecodingContainerBase.init()*/
/*!!!DUPLICATE NAME*/
init($info?) {
throw 'unsupported method Swift.(file)._KeyedDecodingContainerBox.init() in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _DictionaryCodingKey implements CodingKey{
static readonly $struct = true

/*Swift.(file)._DictionaryCodingKey.stringValue*/
readonly stringValue$get() {
throw 'unsupported variable Swift.(file)._DictionaryCodingKey.stringValue in ' + this.constructor.name
}
readonly get stringValue() { return this.stringValue$get() };




/*Swift.(file)._DictionaryCodingKey.intValue*/
readonly intValue$get() {
throw 'unsupported variable Swift.(file)._DictionaryCodingKey.intValue in ' + this.constructor.name
}
readonly get intValue() { return this.intValue$get() };



/*Swift.(file)._DictionaryCodingKey.init(stringValue:String)*/
/*Swift.(file).CodingKey.init(stringValue:String)*/
initStringValueString(stringValue, $info?) {
throw 'unsupported method Swift.(file)._DictionaryCodingKey.init(stringValue:String) in ' + this.constructor.name
}
static readonly initStringValueString$failable = true
/*Swift.(file)._DictionaryCodingKey.init(intValue:Int)*/
/*Swift.(file).CodingKey.init(intValue:Int)*/
initIntValueInt(intValue, $info?) {
throw 'unsupported method Swift.(file)._DictionaryCodingKey.init(intValue:Int) in ' + this.constructor.name
}
static readonly initIntValueInt$failable = true
init$vars() {let _this = this;

}
}
if(typeof CodingKey$implementation != 'undefined') _mixin(_DictionaryCodingKey, CodingKey$implementation, false)


class _FloatAnyHashableBox implements _AnyHashableBox{
static readonly $struct = true




/*Swift.(file)._FloatAnyHashableBox.init(_:_FloatAnyHashableBox.Base)*/
/*Swift.(file)._FloatAnyHashableBox.init(_:_FloatAnyHashableBox.Base)*/
init_FloatAnyHashableBoxBase(value, $info?) {
throw 'unsupported method Swift.(file)._FloatAnyHashableBox.init(_:_FloatAnyHashableBox.Base) in ' + this.constructor.name
}














init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_FloatAnyHashableBox, _AnyHashableBox$implementation, false)


class _DoubleAnyHashableBox implements _AnyHashableBox{
static readonly $struct = true




/*Swift.(file)._DoubleAnyHashableBox.init(_:_DoubleAnyHashableBox.Base)*/
/*Swift.(file)._DoubleAnyHashableBox.init(_:_DoubleAnyHashableBox.Base)*/
init_DoubleAnyHashableBoxBase(value, $info?) {
throw 'unsupported method Swift.(file)._DoubleAnyHashableBox.init(_:_DoubleAnyHashableBox.Base) in ' + this.constructor.name
}














init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_DoubleAnyHashableBox, _AnyHashableBox$implementation, false)


class _Float80AnyHashableBox implements _AnyHashableBox{
static readonly $struct = true




/*Swift.(file)._Float80AnyHashableBox.init(_:_Float80AnyHashableBox.Base)*/
/*Swift.(file)._Float80AnyHashableBox.init(_:_Float80AnyHashableBox.Base)*/
init_Float80AnyHashableBoxBase(value, $info?) {
throw 'unsupported method Swift.(file)._Float80AnyHashableBox.init(_:_Float80AnyHashableBox.Base) in ' + this.constructor.name
}














init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_Float80AnyHashableBox, _AnyHashableBox$implementation, false)


class _IntegerAnyHashableBox<Base> implements _AnyHashableBox{
static readonly $struct = true



/*Swift.(file)._IntegerAnyHashableBox.init(_:Base)*/
/*Swift.(file)._IntegerAnyHashableBox.init(_:Base)*/
init(value, $info?) {
throw 'unsupported method Swift.(file)._IntegerAnyHashableBox.init(_:Base) in ' + this.constructor.name
}














init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_IntegerAnyHashableBox, _AnyHashableBox$implementation, false)


class _Buffer32{
static readonly $struct = true
/*Swift.(file)._Buffer32.init()*/
/*Swift.(file)._Buffer32.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._Buffer32.init() in ' + this.constructor.name
}
































































































































































/*Swift.(file)._Buffer32.withBytes(_:(UnsafeMutablePointer<UInt8>) throws -> Result)*/
/*Swift.(file)._Buffer32.withBytes(_:(UnsafeMutablePointer<UInt8>) throws -> Result)*/
withBytes<Result>(body, $info?) {
throw 'unsupported method Swift.(file)._Buffer32.withBytes(_:(UnsafeMutablePointer<UInt8>) throws -> Result) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class _Buffer72{
static readonly $struct = true
/*Swift.(file)._Buffer72.init()*/
/*Swift.(file)._Buffer72.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._Buffer72.init() in ' + this.constructor.name
}








































































































































































































































































































































































/*Swift.(file)._Buffer72.withBytes(_:(UnsafeMutablePointer<UInt8>) throws -> Result)*/
/*Swift.(file)._Buffer72.withBytes(_:(UnsafeMutablePointer<UInt8>) throws -> Result)*/
withBytes<Result>(body, $info?) {
throw 'unsupported method Swift.(file)._Buffer72.withBytes(_:(UnsafeMutablePointer<UInt8>) throws -> Result) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


class __SwiftNativeNSArray{
/*Swift.(file).__SwiftNativeNSArray.init()*/
/*Swift.(file).__SwiftNativeNSArray.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSArray.init() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class __SwiftNativeNSDictionary{
/*Swift.(file).__SwiftNativeNSDictionary.init()*/
/*Swift.(file).__SwiftNativeNSDictionary.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSDictionary.init() in ' + this.constructor.name
}
/*Swift.(file).__SwiftNativeNSDictionary.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSDictionary.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSDictionary.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class __SwiftNativeNSSet{
/*Swift.(file).__SwiftNativeNSSet.init()*/
/*Swift.(file).__SwiftNativeNSSet.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSSet.init() in ' + this.constructor.name
}
/*Swift.(file).__SwiftNativeNSSet.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSSet.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSSet.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class __SwiftNativeNSEnumerator{
/*Swift.(file).__SwiftNativeNSEnumerator.init()*/
/*Swift.(file).__SwiftNativeNSEnumerator.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSEnumerator.init() in ' + this.constructor.name
}
/*Swift.(file).__SwiftNativeNSEnumerator.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSEnumerator.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSEnumerator.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class __SwiftNativeNSData{
/*Swift.(file).__SwiftNativeNSData.init()*/
/*Swift.(file).__SwiftNativeNSData.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSData.init() in ' + this.constructor.name
}
/*Swift.(file).__SwiftNativeNSData.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSData.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSData.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class __stdlib_ReturnAutoreleasedDummy{
/*Swift.(file).__stdlib_ReturnAutoreleasedDummy.init()*/
/*Swift.(file).__stdlib_ReturnAutoreleasedDummy.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__stdlib_ReturnAutoreleasedDummy.init() in ' + this.constructor.name
}
/*Swift.(file).__stdlib_ReturnAutoreleasedDummy.returnsAutoreleased(_:AnyObject)*/
/*Swift.(file).__stdlib_ReturnAutoreleasedDummy.returnsAutoreleased(_:AnyObject)*/
returnsAutoreleased(x, $info?) {
throw 'unsupported method Swift.(file).__stdlib_ReturnAutoreleasedDummy.returnsAutoreleased(_:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}


class AnyIterator<Element> implements IteratorProtocol, Sequence{
static readonly $struct = true



/*Swift.(file).AnyIterator.init(_:I)*/
/*Swift.(file).AnyIterator.init(_:I)*/
init<I>(base, $info?) {
throw 'unsupported method Swift.(file).AnyIterator.init(_:I) in ' + this.constructor.name
}
/*Swift.(file).AnyIterator.init(_:() -> Element?)*/
/*Swift.(file).AnyIterator.init(_:() -> Element?)*/
initfunction_type(body, $info?) {
//slightly bodgy; in principle, the passed function becomes the next, so that's exactly what we're doing here
this.next = body
}
/*Swift.(file).AnyIterator.init(_box:_AnyIteratorBoxBase<Element>)*/
/*Swift.(file).AnyIterator.init(_box:_AnyIteratorBoxBase<Element>)*/
init_box_AnyIteratorBoxBase(_box, $info?) {
throw 'unsupported method Swift.(file).AnyIterator.init(_box:_AnyIteratorBoxBase<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyIterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).AnyIterator.next() in ' + this.constructor.name
}


init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(AnyIterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(AnyIterator, Sequence$implementation, false)






class _ClosureBasedIterator<Element> implements IteratorProtocol{
static readonly $struct = true
/*Swift.(file)._ClosureBasedIterator.init(_:() -> Element?)*/
/*Swift.(file)._ClosureBasedIterator.init(_:() -> Element?)*/
initfunction_type(body, $info?) {
throw 'unsupported method Swift.(file)._ClosureBasedIterator.init(_:() -> Element?) in ' + this.constructor.name
}
/*Swift.(file)._ClosureBasedIterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file)._ClosureBasedIterator.next() in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_ClosureBasedIterator, IteratorProtocol$implementation, false)


class _AnyIteratorBoxBase<Element> implements IteratorProtocol{
/*Swift.(file)._AnyIteratorBoxBase.init()*/
/*Swift.(file)._AnyIteratorBoxBase.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._AnyIteratorBoxBase.init() in ' + this.constructor.name
}

/*Swift.(file)._AnyIteratorBoxBase.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file)._AnyIteratorBoxBase.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_AnyIteratorBoxBase, IteratorProtocol$implementation, false)


class _IteratorBox<Base> extends _AnyIteratorBoxBase{
/*Swift.(file)._IteratorBox.init(_:Base)*/
/*Swift.(file)._IteratorBox.init(_:Base)*/
init(base, $info?) {
throw 'unsupported method Swift.(file)._IteratorBox.init(_:Base) in ' + this.constructor.name
}

/*Swift.(file)._IteratorBox.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file)._IteratorBox.next() in ' + this.constructor.name
}





/*Swift.(file)._IteratorBox.init()*/
/*Swift.(file)._AnyIteratorBoxBase.init()*/
/*!!!DUPLICATE NAME*/
init($info?) {
throw 'unsupported method Swift.(file)._IteratorBox.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _AnySequenceBox<Element>{
/*Swift.(file)._AnySequenceBox.init()*/
/*Swift.(file)._AnySequenceBox.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._AnySequenceBox.init() in ' + this.constructor.name
}

















init$vars() {let _this = this;

}
}


class _AnyCollectionBox<Element> extends _AnySequenceBox{







/*Swift.(file)._AnyCollectionBox.subscript(_:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(_:_AnyIndexBox)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._AnyCollectionBox.subscript(_:_AnyIndexBox) in ' + this.constructor.name
}











/*Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
init_startIndex_AnyIndexBoxEndIndex_AnyIndexBox(_startIndex, endIndex, $info?) {
throw 'unsupported method Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox) in ' + this.constructor.name
}






/*Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
subscriptStartEnd$get(start, end, $info?) {
throw 'unsupported method Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox) in ' + this.constructor.name
}

/*Swift.(file)._AnyCollectionBox.init()*/
/*Swift.(file)._AnySequenceBox.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._AnyCollectionBox.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _AnyBidirectionalCollectionBox<Element> extends _AnyCollectionBox{







/*Swift.(file)._AnyBidirectionalCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
subscriptStartEnd$get(start, end, $info?) {
throw 'unsupported method Swift.(file)._AnyBidirectionalCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox) in ' + this.constructor.name
}



/*Swift.(file)._AnyBidirectionalCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
init_startIndex_AnyIndexBoxEndIndex_AnyIndexBox(_startIndex, endIndex, $info?) {
throw 'unsupported method Swift.(file)._AnyBidirectionalCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _AnyRandomAccessCollectionBox<Element> extends _AnyBidirectionalCollectionBox{







/*Swift.(file)._AnyRandomAccessCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
subscriptStartEnd$get(start, end, $info?) {
throw 'unsupported method Swift.(file)._AnyRandomAccessCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox) in ' + this.constructor.name
}

/*Swift.(file)._AnyRandomAccessCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
init_startIndex_AnyIndexBoxEndIndex_AnyIndexBox(_startIndex, endIndex, $info?) {
throw 'unsupported method Swift.(file)._AnyRandomAccessCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _SequenceBox<S> extends _AnySequenceBox{


















/*Swift.(file)._SequenceBox.init(_base:S)*/
/*Swift.(file)._SequenceBox.init(_base:S)*/
init_base(_base, $info?) {
throw 'unsupported method Swift.(file)._SequenceBox.init(_base:S) in ' + this.constructor.name
}





/*Swift.(file)._SequenceBox.init()*/
/*Swift.(file)._AnySequenceBox.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SequenceBox.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _CollectionBox<S> extends _AnyCollectionBox{


















/*Swift.(file)._CollectionBox.init(_base:S)*/
/*Swift.(file)._CollectionBox.init(_base:S)*/
init_base(_base, $info?) {
throw 'unsupported method Swift.(file)._CollectionBox.init(_base:S) in ' + this.constructor.name
}

/*Swift.(file)._CollectionBox.subscript(_:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(_:_AnyIndexBox)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file)._CollectionBox.subscript(_:_AnyIndexBox) in ' + this.constructor.name
}

/*Swift.(file)._CollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
subscriptStartEnd$get(start, end, $info?) {
throw 'unsupported method Swift.(file)._CollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox) in ' + this.constructor.name
}
















/*Swift.(file)._CollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
init_startIndex_AnyIndexBoxEndIndex_AnyIndexBox(_startIndex, endIndex, $info?) {
throw 'unsupported method Swift.(file)._CollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _BidirectionalCollectionBox<S> extends _AnyBidirectionalCollectionBox{


















/*Swift.(file)._BidirectionalCollectionBox.init(_base:S)*/
/*Swift.(file)._BidirectionalCollectionBox.init(_base:S)*/
init_base(_base, $info?) {
throw 'unsupported method Swift.(file)._BidirectionalCollectionBox.init(_base:S) in ' + this.constructor.name
}

/*Swift.(file)._BidirectionalCollectionBox.subscript(_:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(_:_AnyIndexBox)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file)._BidirectionalCollectionBox.subscript(_:_AnyIndexBox) in ' + this.constructor.name
}

/*Swift.(file)._BidirectionalCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
subscriptStartEnd$get(start, end, $info?) {
throw 'unsupported method Swift.(file)._BidirectionalCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox) in ' + this.constructor.name
}


















/*Swift.(file)._BidirectionalCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
init_startIndex_AnyIndexBoxEndIndex_AnyIndexBox(_startIndex, endIndex, $info?) {
throw 'unsupported method Swift.(file)._BidirectionalCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _RandomAccessCollectionBox<S> extends _AnyRandomAccessCollectionBox{


















/*Swift.(file)._RandomAccessCollectionBox.init(_base:S)*/
/*Swift.(file)._RandomAccessCollectionBox.init(_base:S)*/
init_base(_base, $info?) {
throw 'unsupported method Swift.(file)._RandomAccessCollectionBox.init(_base:S) in ' + this.constructor.name
}

/*Swift.(file)._RandomAccessCollectionBox.subscript(_:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(_:_AnyIndexBox)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file)._RandomAccessCollectionBox.subscript(_:_AnyIndexBox) in ' + this.constructor.name
}

/*Swift.(file)._RandomAccessCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox)*/
subscriptStartEnd$get(start, end, $info?) {
throw 'unsupported method Swift.(file)._RandomAccessCollectionBox.subscript(start:_AnyIndexBox,end:_AnyIndexBox) in ' + this.constructor.name
}


















/*Swift.(file)._RandomAccessCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
/*Swift.(file)._AnyCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox)*/
init_startIndex_AnyIndexBoxEndIndex_AnyIndexBox(_startIndex, endIndex, $info?) {
throw 'unsupported method Swift.(file)._RandomAccessCollectionBox.init(_startIndex:_AnyIndexBox,endIndex:_AnyIndexBox) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _ClosureBasedSequence<Iterator> implements Sequence{
static readonly $struct = true





/*Swift.(file)._ClosureBasedSequence.init(_:() -> Iterator)*/
/*Swift.(file)._ClosureBasedSequence.init(_:() -> Iterator)*/
initfunction_type(makeUnderlyingIterator, $info?) {
throw 'unsupported method Swift.(file)._ClosureBasedSequence.init(_:() -> Iterator) in ' + this.constructor.name
}
/*Swift.(file)._ClosureBasedSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}


init$vars() {let _this = this;

}
}
if(typeof Sequence$implementation != 'undefined') _mixin(_ClosureBasedSequence, Sequence$implementation, false)




class AnySequence<Element> implements Sequence{
static readonly $struct = true



/*Swift.(file).AnySequence.init(_:() -> I)*/
/*Swift.(file).AnySequence.init(_:() -> I)*/
initfunction_type<I>(makeUnderlyingIterator, $info?) {
throw 'unsupported method Swift.(file).AnySequence.init(_:() -> I) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.init(_box:_AnySequenceBox<Element>)*/
/*Swift.(file).AnySequence.init(_box:_AnySequenceBox<Element>)*/
init_box_AnySequenceBox(_box, $info?) {
throw 'unsupported method Swift.(file).AnySequence.init(_box:_AnySequenceBox<Element>) in ' + this.constructor.name
}

/*Swift.(file).AnySequence.init(_:S)*/
/*Swift.(file).AnySequence.init(_:S)*/
init<S>(base, $info?) {
throw 'unsupported method Swift.(file).AnySequence.init(_:S) in ' + this.constructor.name
}

/*Swift.(file).AnySequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}
/*Swift.(file).AnySequence.dropLast(_:Int)*/
/*Swift.(file).AnySequence.dropLast(_:Int)*/
dropLast(n, $info?) {
throw 'unsupported method Swift.(file).AnySequence.dropLast(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.prefix(while:(Element) throws -> Bool)*/
/*Swift.(file).AnySequence.prefix(while:(Element) throws -> Bool)*/
prefixWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnySequence.prefix(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.suffix(_:Int)*/
/*Swift.(file).AnySequence.suffix(_:Int)*/
suffix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnySequence.suffix(_:Int) in ' + this.constructor.name
}

/*Swift.(file).AnySequence.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return 0
}
get underestimatedCount() { return this.underestimatedCount$get() };



/*Swift.(file).AnySequence.map(_:(Element) throws -> T)*/
/*Swift.(file).AnySequence.map(_:(Element) throws -> T)*/
mapSwift<T>(transform, $info?) {
throw 'unsupported method Swift.(file).AnySequence.map(_:(Element) throws -> T) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.filter(_:(Element) throws -> Bool)*/
/*Swift.(file).AnySequence.filter(_:(Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
throw 'unsupported method Swift.(file).AnySequence.filter(_:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.forEach(_:(Element) throws -> Void)*/
/*Swift.(file).AnySequence.forEach(_:(Element) throws -> Void)*/
forEachSwift(body, $info?) {
throw 'unsupported method Swift.(file).AnySequence.forEach(_:(Element) throws -> Void) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.drop(while:(Element) throws -> Bool)*/
/*Swift.(file).AnySequence.drop(while:(Element) throws -> Bool)*/
dropWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnySequence.drop(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.dropFirst(_:Int)*/
/*Swift.(file).AnySequence.dropFirst(_:Int)*/
dropFirst(n, $info?) {
throw 'unsupported method Swift.(file).AnySequence.dropFirst(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnySequence.prefix(_:Int)*/
/*Swift.(file).AnySequence.prefix(_:Int)*/
prefix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnySequence.prefix(_:Int) in ' + this.constructor.name
}



init$vars() {let _this = this;

}
}
if(typeof Sequence$implementation != 'undefined') _mixin(AnySequence, Sequence$implementation, false)






interface _AnyIndexBox extends AnyObject{






}
class _AnyIndexBox$implementation{
}
if(typeof AnyObject$implementation != 'undefined') _mixin(_AnyIndexBox$implementation, AnyObject$implementation, false)


class _IndexBox<BaseIndex> implements _AnyIndexBox{





/*Swift.(file)._IndexBox.init(_base:BaseIndex)*/
/*Swift.(file)._IndexBox.init(_base:BaseIndex)*/
init_base(_base, $info?) {
throw 'unsupported method Swift.(file)._IndexBox.init(_base:BaseIndex) in ' + this.constructor.name
}








init$vars() {let _this = this;

}
}
if(typeof _AnyIndexBox$implementation != 'undefined') _mixin(_IndexBox, _AnyIndexBox$implementation, false)


interface ElementaryFunctions{
static /*Swift.(file).ElementaryFunctions.sqrt(_:Self)*/
/*Swift.(file).ElementaryFunctions.sqrt(_:Self)*/
sqrt(x, $info?)
static /*Swift.(file).ElementaryFunctions.cos(_:Self)*/
/*Swift.(file).ElementaryFunctions.cos(_:Self)*/
cos(x, $info?)
static /*Swift.(file).ElementaryFunctions.sin(_:Self)*/
/*Swift.(file).ElementaryFunctions.sin(_:Self)*/
sin(x, $info?)
static /*Swift.(file).ElementaryFunctions.tan(_:Self)*/
/*Swift.(file).ElementaryFunctions.tan(_:Self)*/
tan(x, $info?)
static /*Swift.(file).ElementaryFunctions.acos(_:Self)*/
/*Swift.(file).ElementaryFunctions.acos(_:Self)*/
acos(x, $info?)
static /*Swift.(file).ElementaryFunctions.asin(_:Self)*/
/*Swift.(file).ElementaryFunctions.asin(_:Self)*/
asin(x, $info?)
static /*Swift.(file).ElementaryFunctions.atan(_:Self)*/
/*Swift.(file).ElementaryFunctions.atan(_:Self)*/
atan(x, $info?)
static /*Swift.(file).ElementaryFunctions.cosh(_:Self)*/
/*Swift.(file).ElementaryFunctions.cosh(_:Self)*/
cosh(x, $info?)
static /*Swift.(file).ElementaryFunctions.sinh(_:Self)*/
/*Swift.(file).ElementaryFunctions.sinh(_:Self)*/
sinh(x, $info?)
static /*Swift.(file).ElementaryFunctions.tanh(_:Self)*/
/*Swift.(file).ElementaryFunctions.tanh(_:Self)*/
tanh(x, $info?)
static /*Swift.(file).ElementaryFunctions.acosh(_:Self)*/
/*Swift.(file).ElementaryFunctions.acosh(_:Self)*/
acosh(x, $info?)
static /*Swift.(file).ElementaryFunctions.asinh(_:Self)*/
/*Swift.(file).ElementaryFunctions.asinh(_:Self)*/
asinh(x, $info?)
static /*Swift.(file).ElementaryFunctions.atanh(_:Self)*/
/*Swift.(file).ElementaryFunctions.atanh(_:Self)*/
atanh(x, $info?)
static /*Swift.(file).ElementaryFunctions.exp(_:Self)*/
/*Swift.(file).ElementaryFunctions.exp(_:Self)*/
exp(x, $info?)
static /*Swift.(file).ElementaryFunctions.exp2(_:Self)*/
/*Swift.(file).ElementaryFunctions.exp2(_:Self)*/
exp2(x, $info?)
static /*Swift.(file).ElementaryFunctions.exp10(_:Self)*/
/*Swift.(file).ElementaryFunctions.exp10(_:Self)*/
exp10(x, $info?)
static /*Swift.(file).ElementaryFunctions.expm1(_:Self)*/
/*Swift.(file).ElementaryFunctions.expm1(_:Self)*/
expm1(x, $info?)
static /*Swift.(file).ElementaryFunctions.log(_:Self)*/
/*Swift.(file).ElementaryFunctions.log(_:Self)*/
log(x, $info?)
static /*Swift.(file).ElementaryFunctions.log2(_:Self)*/
/*Swift.(file).ElementaryFunctions.log2(_:Self)*/
log2(x, $info?)
static /*Swift.(file).ElementaryFunctions.log10(_:Self)*/
/*Swift.(file).ElementaryFunctions.log10(_:Self)*/
log10(x, $info?)
static /*Swift.(file).ElementaryFunctions.log1p(_:Self)*/
/*Swift.(file).ElementaryFunctions.log1p(_:Self)*/
log1p(x, $info?)
static /*Swift.(file).ElementaryFunctions.pow(_:Self,_:Self)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Self)*/
pow(x, y, $info?)
static /*Swift.(file).ElementaryFunctions.pow(_:Self,_:Int)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Int)*/
/*!!!DUPLICATE NAME*/
pow(x, n, $info?)
static /*Swift.(file).ElementaryFunctions.root(_:Self,_:Int)*/
/*Swift.(file).ElementaryFunctions.root(_:Self,_:Int)*/
root(x, n, $info?)
}
class ElementaryFunctions$implementation{
}


class EnumeratedSequence<Base> implements Sequence{
static readonly $struct = true





/*Swift.(file).EnumeratedSequence.init(_base:Base)*/
/*Swift.(file).EnumeratedSequence.init(_base:Base)*/
init_base(_base, $info?) {
let _this = this;
_this._base = _base;
return
}
static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true










/*Swift.(file).EnumeratedSequence.Iterator.init(_base:Base.Iterator)*/
/*Swift.(file).EnumeratedSequence.Iterator.init(_base:Base.Iterator)*/
init_base(_base, $info?) {
let _this = this;
_this._base = _base;
_this._count = 0;
return
}

/*Swift.(file).EnumeratedSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const $ifLet0, b_1
if(!((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((b_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
const result = {0: _this._count, 1: b_1};
Int.$addAndAssign({get: () => _this._count, set: $val => _this._count = $val}, 1);
return _injectIntoOptional(result)
}

init$vars() {let _this = this;

}
}
/*Swift.(file).EnumeratedSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(EnumeratedSequence.Iterator, 'init_base', _this._base.makeIterator( {}), {})
}

init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(EnumeratedSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(EnumeratedSequence.Iterator, Sequence$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(EnumeratedSequence, Sequence$implementation, false)






interface _ArrayAnyHashableProtocol extends _AnyHashableBox{

/*Swift.(file)._ArrayAnyHashableProtocol.count*/
count;



/*Swift.(file)._ArrayAnyHashableProtocol.subscript(_:Int)*/
/*Swift.(file)._ArrayAnyHashableProtocol.subscript(_:Int)*/
subscript$get(index, $info?)

}
class _ArrayAnyHashableProtocol$implementation{
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_ArrayAnyHashableProtocol$implementation, _AnyHashableBox$implementation, false)


class _ArrayAnyHashableBox<Element> implements _ArrayAnyHashableProtocol{
static readonly $struct = true



/*Swift.(file)._ArrayAnyHashableBox.init(_:[Element])*/
/*Swift.(file)._ArrayAnyHashableBox.init(_:[Element])*/
initArray(value, $info?) {
throw 'unsupported method Swift.(file)._ArrayAnyHashableBox.init(_:[Element]) in ' + this.constructor.name
}




/*Swift.(file)._ArrayAnyHashableBox.count*/
count$get() {
throw 'unsupported variable Swift.(file)._ArrayAnyHashableBox.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file)._ArrayAnyHashableBox.subscript(_:Int)*/
/*Swift.(file)._ArrayAnyHashableProtocol.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file)._ArrayAnyHashableBox.subscript(_:Int) in ' + this.constructor.name
}









init$vars() {let _this = this;

}
}
if(typeof _ArrayAnyHashableProtocol$implementation != 'undefined') _mixin(_ArrayAnyHashableBox, _ArrayAnyHashableProtocol$implementation, false)


class _UnsafeBitset implements Sequence{
static readonly $struct = true

/*Swift.(file)._UnsafeBitset.words*/
readonly words$get() {
throw 'unsupported variable Swift.(file)._UnsafeBitset.words in ' + this.constructor.name
}
readonly get words() { return this.words$get() };




/*Swift.(file)._UnsafeBitset.wordCount*/
readonly wordCount$get() {
throw 'unsupported variable Swift.(file)._UnsafeBitset.wordCount in ' + this.constructor.name
}
readonly get wordCount() { return this.wordCount$get() };



/*Swift.(file)._UnsafeBitset.init(words:UnsafeMutablePointer<_UnsafeBitset.Word>,wordCount:Int)*/
/*Swift.(file)._UnsafeBitset.init(words:UnsafeMutablePointer<_UnsafeBitset.Word>,wordCount:Int)*/
initWordsUnsafeMutablePointerWordCountInt(words, wordCount, $info?) {
throw 'unsupported method Swift.(file)._UnsafeBitset.init(words:UnsafeMutablePointer<_UnsafeBitset.Word>,wordCount:Int) in ' + this.constructor.name
}
static /*Swift.(file)._UnsafeBitset.word(for:Int)*/
/*Swift.(file)._UnsafeBitset.word(for:Int)*/
wordFor(_element, $info?) {
let _this = this;
const _element = _create(UInt, 'initBitPatternInt', _element, {});
const capacity = _create(UInt, 'initBitPatternInt', _UnsafeBitset.Word.capacity, {});
return _create(Int, 'initBitPatternUInt', UInt.$divide(_element, capacity), {})
}
static /*Swift.(file)._UnsafeBitset.bit(for:Int)*/
/*Swift.(file)._UnsafeBitset.bit(for:Int)*/
bitFor(_element, $info?) {
let _this = this;
const _element = _create(UInt, 'initBitPatternInt', _element, {});
const capacity = _create(UInt, 'initBitPatternInt', _UnsafeBitset.Word.capacity, {});
return _create(Int, 'initBitPatternUInt', UInt.$remainder(_element, capacity), {})
}
static /*Swift.(file)._UnsafeBitset.split(_:Int)*/
/*Swift.(file)._UnsafeBitset.split(_:Int)*/
split(_element, $info?) {
let _this = this;
return {0: _this.wordFor(_element), 1: _this.bitFor(_element)}
}
static /*Swift.(file)._UnsafeBitset.join(word:Int,bit:Int)*/
/*Swift.(file)._UnsafeBitset.join(word:Int,bit:Int)*/
joinWordBit(word, bit, $info?) {
let _this = this;
return Int.$addWithOverflow(Int.$multiplyIgnoringOverflow(word, _UnsafeBitset.Word.capacity), bit)
}
static /*Swift.(file)._UnsafeBitset.wordCount(forCapacity:Int)*/
/*Swift.(file)._UnsafeBitset.wordCount(forCapacity:Int)*/
wordCountForCapacity(capacity, $info?) {
let _this = this;
return _this.wordFor(Int.$subtractWithOverflow(Int.$addWithOverflow(capacity, _UnsafeBitset.Word.capacity), 1))
}

/*Swift.(file)._UnsafeBitset.capacity*/
capacity$get() {
let _this = this;
return Int.$multiplyIgnoringOverflow(_this.wordCount, _UnsafeBitset.Word.capacity)
}
get capacity() { return this.capacity$get() };



/*Swift.(file)._UnsafeBitset.isValid(_:Int)*/
/*Swift.(file)._UnsafeBitset.isValid(_:Int)*/
isValid(_element, $info?) {
let _this = this;
return Bool.$logicalAND(Int.$greaterThanOrEqual(_element, 0), () => Int.$lessThanOrEqual(_element, _this.capacity))
}
/*Swift.(file)._UnsafeBitset.uncheckedContains(_:Int)*/
/*Swift.(file)._UnsafeBitset.uncheckedContains(_:Int)*/
uncheckedContains(_element, $info?) {
let _this = this;
const $tuple = _UnsafeBitset.split(_element), word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return _this.words.subscript$get(word).uncheckedContains(bit)
}
/*Swift.(file)._UnsafeBitset.uncheckedInsert(_:Int)*/
/*Swift.(file)._UnsafeBitset.uncheckedInsert(_:Int)*/
uncheckedInsert(_element, $info?) {
let _this = this;
const $tuple = _UnsafeBitset.split(_element), word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return _this.words.subscript$get(word).uncheckedInsert(bit, {$setThis: $val => _this.words.subscript$set($val, word, {$setThis: $val => _this.words = _cloneStruct($val)})})
}
/*Swift.(file)._UnsafeBitset.uncheckedRemove(_:Int)*/
/*Swift.(file)._UnsafeBitset.uncheckedRemove(_:Int)*/
uncheckedRemove(_element, $info?) {
let _this = this;
const $tuple = _UnsafeBitset.split(_element), word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return _this.words.subscript$get(word).uncheckedRemove(bit, {$setThis: $val => _this.words.subscript$set($val, word, {$setThis: $val => _this.words = _cloneStruct($val)})})
}
/*Swift.(file)._UnsafeBitset.clear()*/
/*Swift.(file)._UnsafeBitset.clear()*/
clear($info?) {
let _this = this;
_this.words.assignRepeatingCount(_UnsafeBitset.Word.empty, _this.wordCount)
}


/*Swift.(file)._UnsafeBitset.count*/
count$get() {
let _this = this;
let count = 0;
{
let $w$generator = _cloneStruct(Int.$halfOpenRange(0, _this.wordCount).makeIterator( {}));
while(true) {
const $ifLet0, w_1;
if(!((($ifLet0 = $w$generator.next( {$setThis: $val => $w$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((w_1 = $ifLet0[0])||true))) break
Int.$addAndAssign({get: () => count, set: $val => count = $val}, _this.words.subscript$get(w_1).count);
}
};
return count
}
get count() { return this.count$get() };




/*Swift.(file)._UnsafeBitset.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return _this.count
}
get underestimatedCount() { return this.underestimatedCount$get() };



/*Swift.(file)._UnsafeBitset.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(_UnsafeBitset.Iterator, 'init_UnsafeBitset', _this, {})
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true

/*Swift.(file)._UnsafeBitset.Iterator.bitset*/
readonly bitset$get() {
throw 'unsupported variable Swift.(file)._UnsafeBitset.Iterator.bitset in ' + this.constructor.name
}
readonly get bitset() { return this.bitset$get() };




/*Swift.(file)._UnsafeBitset.Iterator.index*/
index$get() {
throw 'unsupported variable Swift.(file)._UnsafeBitset.Iterator.index in ' + this.constructor.name
}
get index() { return this.index$get() };






/*Swift.(file)._UnsafeBitset.Iterator.word*/
word$get() {
throw 'unsupported variable Swift.(file)._UnsafeBitset.Iterator.word in ' + this.constructor.name
}
get word() { return this.word$get() };





/*Swift.(file)._UnsafeBitset.Iterator.init(_:_UnsafeBitset)*/
/*Swift.(file)._UnsafeBitset.Iterator.init(_:_UnsafeBitset)*/
init_UnsafeBitset(bitset, $info?) {
throw 'unsupported method Swift.(file)._UnsafeBitset.Iterator.init(_:_UnsafeBitset) in ' + this.constructor.name
}
/*Swift.(file)._UnsafeBitset.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file)._UnsafeBitset.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
static Word = class implements Sequence, IteratorProtocol{
static readonly $struct = true

/*Swift.(file)._UnsafeBitset.Word.value*/
value$get() {
throw 'unsupported variable Swift.(file)._UnsafeBitset.Word.value in ' + this.constructor.name
}
get value() { return this.value$get() };





/*Swift.(file)._UnsafeBitset.Word.init(_:UInt)*/
/*Swift.(file)._UnsafeBitset.Word.init(_:UInt)*/
initUInt(value, $info?) {
throw 'unsupported method Swift.(file)._UnsafeBitset.Word.init(_:UInt) in ' + this.constructor.name
}

/*Swift.(file)._UnsafeBitset.Word.capacity*/
static capacity$get() {
let _this = this;
return UInt.bitWidth;
}
static get capacity() { return this.capacity$get()
}
static get capacity() { return this.capacity$get() };



/*Swift.(file)._UnsafeBitset.Word.uncheckedContains(_:Int)*/
/*Swift.(file)._UnsafeBitset.Word.uncheckedContains(_:Int)*/
uncheckedContains(bit, $info?) {
let _this = this;
return UInt.$notEqual(UInt.$bitwiseAND(_this.value, UInt.infix_38_60_60(1, bit)), 0)
}
/*Swift.(file)._UnsafeBitset.Word.uncheckedInsert(_:Int)*/
/*Swift.(file)._UnsafeBitset.Word.uncheckedInsert(_:Int)*/
uncheckedInsert(bit, $info?) {
let _this = this;
const mask = UInt.infix_38_60_60(1, bit);
const inserted = UInt.$equal(UInt.$bitwiseAND(_this.value, mask), 0);
UInt.$bitwiseORAndAssign({get: () => _this.value, set: $val => _this.value = $val}, mask);
return inserted
}
/*Swift.(file)._UnsafeBitset.Word.uncheckedRemove(_:Int)*/
/*Swift.(file)._UnsafeBitset.Word.uncheckedRemove(_:Int)*/
uncheckedRemove(bit, $info?) {
let _this = this;
const mask = UInt.infix_38_60_60(1, bit);
const removed = UInt.$notEqual(UInt.$bitwiseAND(_this.value, mask), 0);
UInt.$bitwiseANDAndAssign({get: () => _this.value, set: $val => _this.value = $val}, UInt.$bitwiseNot(mask));
return removed
}

/*Swift.(file)._UnsafeBitset.Word.minimum*/
minimum$get() {
let _this = this;
if(!((UInt.$notEqual(_this.value, 0)))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(UInt.prototype.trailingZeroBitCount$get.call(_this.value))
}
get minimum() { return this.minimum$get() };




/*Swift.(file)._UnsafeBitset.Word.maximum*/
maximum$get() {
let _this = this;
if(!((UInt.$notEqual(_this.value, 0)))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(Int.$subtractWithOverflow(Int.$subtractWithOverflow(_UnsafeBitset.Word.capacity, 1), UInt.prototype.leadingZeroBitCount$get.call(_this.value)))
}
get maximum() { return this.maximum$get() };




/*Swift.(file)._UnsafeBitset.Word.complement*/
complement$get() {
let _this = this;
return _create(_UnsafeBitset.Word, 'initUInt', UInt.$bitwiseNot(_this.value), {})
}
get complement() { return this.complement$get() };



/*Swift.(file)._UnsafeBitset.Word.subtracting(elementsBelow:Int)*/
/*Swift.(file)._UnsafeBitset.Word.subtracting(elementsBelow:Int)*/
subtractingElementsBelow(bit, $info?) {
let _this = this;
const mask = UInt.infix_38_60_60(UInt.max, bit);
return _create(_UnsafeBitset.Word, 'initUInt', UInt.$bitwiseAND(_this.value, mask), {})
}
/*Swift.(file)._UnsafeBitset.Word.intersecting(elementsBelow:Int)*/
/*Swift.(file)._UnsafeBitset.Word.intersecting(elementsBelow:Int)*/
intersectingElementsBelow(bit, $info?) {
let _this = this;
const mask = UInt.$subtractWithOverflow(UInt.infix_38_60_60(1, bit), 1);
return _create(_UnsafeBitset.Word, 'initUInt', UInt.$bitwiseAND(_this.value, mask), {})
}
/*Swift.(file)._UnsafeBitset.Word.intersecting(elementsAbove:Int)*/
/*Swift.(file)._UnsafeBitset.Word.intersecting(elementsAbove:Int)*/
intersectingElementsAbove(bit, $info?) {
let _this = this;
const mask = UInt.infix_38_60_60(UInt.infix_38_60_60(UInt.max, bit), 1);
return _create(_UnsafeBitset.Word, 'initUInt', UInt.$bitwiseAND(_this.value, mask), {})
}

/*Swift.(file)._UnsafeBitset.Word.empty*/
static empty$get() {
let _this = this;
return _create(_UnsafeBitset.Word, 'initUInt', 0, {});
}
static get empty() { return this.empty$get()
}
static get empty() { return this.empty$get() };




/*Swift.(file)._UnsafeBitset.Word.allBits*/
static allBits$get() {
let _this = this;
return _create(_UnsafeBitset.Word, 'initUInt', UInt.max, {});
}
static get allBits() { return this.allBits$get()
}
static get allBits() { return this.allBits$get() };




/*Swift.(file)._UnsafeBitset.Word.count*/
count$get() {
let _this = this;
return UInt.prototype.nonzeroBitCount$get.call(_this.value)
}
get count() { return this.count$get() };




/*Swift.(file)._UnsafeBitset.Word.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return _this.count
}
get underestimatedCount() { return this.underestimatedCount$get() };




/*Swift.(file)._UnsafeBitset.Word.isEmpty*/
isEmpty$get() {
let _this = this;
return UInt.$equal(_this.value, 0)
}
get isEmpty() { return this.isEmpty$get() };



/*Swift.(file)._UnsafeBitset.Word.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if(!((UInt.$notEqual(_this.value, 0)))) {
return _injectIntoOptional(null);
};
const bit = UInt.prototype.trailingZeroBitCount$get.call(_this.value);
UInt.$bitwiseANDAndAssign({get: () => _this.value, set: $val => _this.value = $val}, UInt.$subtractWithOverflow(_this.value, 1));
return _injectIntoOptional(bit)
}


init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_UnsafeBitset.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_UnsafeBitset.Word, Sequence$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_UnsafeBitset.Word, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_UnsafeBitset, Sequence$implementation, false)










class MIO_Mixin_Bool implements _ExpressibleByBuiltinBooleanLiteral, ExpressibleByBooleanLiteral, CustomStringConvertible, Equatable, Hashable, LosslessStringConvertible, CVarArg, Codable, CustomReflectable, _CustomPlaygroundQuickLookable{
static readonly $struct = true
static readonly $mixin = true





/*Swift.(file).Bool.init()*/
/*Swift.(file).Bool.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Bool.init() in ' + this.constructor.name
}
/*Swift.(file).Bool.init(_:Int1)*/
/*Swift.(file).Bool.init(_:Int1)*/
initInt1(v, $info?) {
throw 'unsupported method Swift.(file).Bool.init(_:Int1) in ' + this.constructor.name
}
/*Swift.(file).Bool.init(_:Bool)*/
/*Swift.(file).Bool.init(_:Bool)*/
initBool(value, $info?) {
let _this = this;
return _cloneStruct(value);
return
}
static /*Swift.(file).Bool.random(using:T)*/
/*Swift.(file).Bool.random(using:T)*/
randomUsing<T>(generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
return UInt64.$equal(UInt64.$bitwiseAND(UInt64.$bitwiseRightShift(generator.next( {$setThis: $val => generator = $val}), 17), 1), 0);})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).Bool.random()*/
/*Swift.(file).Bool.random()*/
random($info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return Bool.randomUsing({get: () => g, set: $val => g = $val})
}
/*Swift.(file).Bool.init(_builtinBooleanLiteral:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinBooleanLiteral.init(_builtinBooleanLiteral:Int1)*/
init_builtinBooleanLiteralInt1(value, $info?) {
throw 'unsupported method Swift.(file).Bool.init(_builtinBooleanLiteral:Int1) in ' + this.constructor.name
}
/*Swift.(file).Bool.init(booleanLiteral:Bool)*/
/*Swift.(file).ExpressibleByBooleanLiteral.init(booleanLiteral:Self.BooleanLiteralType)*/
initBooleanLiteral(value, $info?) {
let _this = this;
return _cloneStruct(value);
return
}


/*Swift.(file).Bool.description*/
description$get() {
let _this = this;
return (_this ? "true" : "false")
}
get description() { return this.description$get() };



static /*Swift.(file).Bool.==infix(_:Bool,_:Bool)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
/*Swift.(file).Bool.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine((_this ? 1 : 0), {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).Bool.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Bool.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Bool.init(_:String)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString(description, $info?) {
let _this = this;
if((String.$equal(description, "true"))) {
return _cloneStruct(true);
}
else {
if((String.$equal(description, "false"))) {
return _cloneStruct(false);
}
else {
return (this.$failed = true);
}
};
return
}
static readonly initString$failable = true
static /*Swift.(file).Bool.!prefix(_:Bool)*/
/*Swift.(file).Bool.!prefix(_:Bool)*/
$not(a, $info?) {
return !a
}
static /*Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)*/
/*Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)*/
$logicalAND(lhs, rhs, $info?) {
let _this = this;
return (lhs ? rhs( {}) : false)
}
static /*Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)*/
/*Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)*/
$logicalOR(lhs, rhs, $info?) {
let _this = this;
return (lhs ? true : rhs( {}))
}
/*Swift.(file).Bool.toggle()*/
/*Swift.(file).Bool.toggle()*/
toggle($info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(Bool.$not(_this)))
}



/*Swift.(file).Bool.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Bool.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Bool.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Bool.encode(to:Encoder) in ' + this.constructor.name
}

/*Swift.(file).Bool.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Bool.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Bool.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Bool.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}
if(typeof _ExpressibleByBuiltinBooleanLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Bool, _ExpressibleByBuiltinBooleanLiteral$implementation, false)
if(typeof ExpressibleByBooleanLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Bool, ExpressibleByBooleanLiteral$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Bool, CustomStringConvertible$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_Bool, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Bool, Hashable$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Bool, LosslessStringConvertible$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_Bool, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Bool, Codable$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Bool, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Bool, _CustomPlaygroundQuickLookable$implementation, false)
_mixin(Boolean, MIO_Mixin_Bool, true)
class Bool{}
_mixin(Bool, MIO_Mixin_Bool, true)


























class __BridgingBufferStorage extends ManagedBuffer{
/*Swift.(file).__BridgingBufferStorage.init(_doNotCallMe:())*/
/*Swift.(file).ManagedBuffer.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__BridgingBufferStorage.init(_doNotCallMe:()) in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class IndexingIterator<Elements> implements IteratorProtocol, Sequence{
static readonly $struct = true








/*Swift.(file).IndexingIterator.init(_elements:Elements)*/
/*Swift.(file).IndexingIterator.init(_elements:Elements)*/
init_elements(_elements, $info?) {
let _this = this;
_this._elements = _elements;
_this._position = _elements.startIndex;
return
}
/*Swift.(file).IndexingIterator.init(_elements:Elements,_position:Elements.Index)*/
/*Swift.(file).IndexingIterator.init(_elements:Elements,_position:Elements.Index)*/
init_elements_position(_elements, _position, $info?) {
let _this = this;
_this._elements = _elements;
_this._position = _position;
return
}



/*Swift.(file).IndexingIterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if(((_.arg0 = _this._position).constructor.$equal(_.arg0, _this._elements.endIndex))) {
return _injectIntoOptional(null);
};
const _element = _this._elements.subscript$get(_this._position);
_this._elements.formIndexAfter({get: () => _this._position, set: $val => _this._position = $val});
return _injectIntoOptional(_element)
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(IndexingIterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(IndexingIterator, Sequence$implementation, false)




interface Collection<Element, Index, Iterator, SubSequence, Indices> extends Sequence{




/*Swift.(file).Collection.startIndex*/
startIndex;




/*Swift.(file).Collection.endIndex*/
endIndex;




/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?)

/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?)


/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?)



/*Swift.(file).Collection.indices*/
indices;




/*Swift.(file).Collection.isEmpty*/
isEmpty;




/*Swift.(file).Collection.count*/
count;





/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?)
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?)
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?)



/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?)
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?)
}
class Collection$implementation{

/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}



/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)*/
formIndexOffsetBy(i$inout, distance, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexOffsetBy(i, distance);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
formIndexOffsetByLimitedBy(i$inout, distance, limit, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
const $ifLet0, advancedIndex_1
if((($ifLet0 = _this.indexOffsetByLimitedBy(i, distance, limit))||true) && $ifLet0.rawValue == 'some' && ((advancedIndex_1 = $ifLet0[0])||true)) {
i = advancedIndex_1;
return true;
};
i = limit;
return false;})()
i$inout.set(i)
return $result
}
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}
/*Swift.(file).Collection.randomElement(using:T)*/
/*Swift.(file).Collection.randomElement(using:T)*/
randomElementUsing<T>(generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
if(!((Bool.$not(_this.isEmpty)))) {
return _injectIntoOptional(null);
};
const random = Int.randomInUsing(Int.$halfOpenRange(0, _this.count), {get: () => generator, set: $val => generator = $val});
const idx = _this.indexOffsetBy(_this.startIndex, random);
return _injectIntoOptional(_this.subscript$get(idx));})()
generator$inout.set(generator)
return $result
}
/*Swift.(file).Collection.randomElement()*/
/*Swift.(file).Collection.randomElement()*/
randomElement($info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomElementUsing({get: () => g, set: $val => g = $val})
}


/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*!!!DUPLICATE NAME*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}

/*Swift.(file).Collection.popFirst()*/
/*Swift.(file).Collection.popFirst()*/
popFirst($info?) {
let _this = this;
if(!((Bool.$not(_this.isEmpty)))) {
return _injectIntoOptional(null);
};
const _element = _this.first[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexAfter(_this.startIndex)).constructor.$halfOpenRange(_.arg0, _this.endIndex))));
return _injectIntoOptional(_element)
}

/*Swift.(file).Collection.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };




/*Swift.(file).Collection.first*/
first$get() {
let _this = this;
const start = _this.startIndex;
if(((_.arg0 = start).constructor.$notEqual(_.arg0, _this.endIndex))) {
return _injectIntoOptional(_this.subscript$get(start));
}
else {
return _injectIntoOptional(null);
}
}
get first() { return this.first$get() };




/*Swift.(file).Collection.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return _this.count
}
get underestimatedCount() { return this.underestimatedCount$get() };




/*Swift.(file).Collection.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };





/*Swift.(file).Collection.map(_:(Self.Element) throws -> T)*/
/*Swift.(file).Collection.map(_:(Self.Element) throws -> T)*/
mapSwift<T>(transform, $info?) {
let _this = this;
const n = _this.count;
if((Int.$equal(n, 0))) {
return _create(Array, 'initArrayLiteralArray', [], {});
};
let result = _create(Array, 'init', {});
let i = _this.startIndex;
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, n).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
result.append(transform(_this.subscript$get(i)), {$setThis: $val => result = $val});
_this.formIndexAfter({get: () => i, set: $val => i = $val});
}
};
return result
}
/*Swift.(file).Collection.dropFirst(_:Int)*/
/*Swift.(file).Collection.dropFirst(_:Int)*/
dropFirst(k, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Can't drop a negative number of elements from a collection", null, null);
const start = $nilCoalescing(_this.indexOffsetByLimitedBy(_this.startIndex, k, _this.endIndex), () => _this.endIndex);
return _this.subscriptRange$get((_.arg0 = start).constructor.$halfOpenRange(_.arg0, _this.endIndex))
}
/*Swift.(file).Collection.dropLast(_:Int)*/
/*Swift.(file).Collection.dropLast(_:Int)*/
dropLast(k, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Can't drop a negative number of elements from a collection", null, null);
const amount = max(0, Int.$subtract(_this.count, k));
const end = $nilCoalescing(_this.indexOffsetByLimitedBy(_this.startIndex, amount, _this.endIndex), () => _this.endIndex);
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, end))
}
/*Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)*/
/*Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)*/
dropWhile(predicate, $info?) {
let _this = this;
let start = _this.startIndex;
while(true){
if(!((Bool.$logicalAND((_.arg0 = start).constructor.$notEqual(_.arg0, _this.endIndex), () => predicate(_this.subscript$get(start)))))) break
_this.formIndexAfter({get: () => start, set: $val => start = $val});
};
return _this.subscriptRange$get((_.arg1 = start).constructor.$halfOpenRange(_.arg1, _this.endIndex))
}
/*Swift.(file).Collection.prefix(_:Int)*/
/*Swift.(file).Collection.prefix(_:Int)*/
prefix(maxLength, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(maxLength, 0), () => "Can't take a prefix of negative length from a collection", null, null);
const end = $nilCoalescing(_this.indexOffsetByLimitedBy(_this.startIndex, maxLength, _this.endIndex), () => _this.endIndex);
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, end))
}
/*Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)*/
/*Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)*/
prefixWhile(predicate, $info?) {
let _this = this;
let end = _this.startIndex;
while(true){
if(!((Bool.$logicalAND((_.arg0 = end).constructor.$notEqual(_.arg0, _this.endIndex), () => predicate(_this.subscript$get(end)))))) break
_this.formIndexAfter({get: () => end, set: $val => end = $val});
};
return _this.subscriptRange$get((_.arg1 = _this.startIndex).constructor.$halfOpenRange(_.arg1, end))
}
/*Swift.(file).Collection.suffix(_:Int)*/
/*Swift.(file).Collection.suffix(_:Int)*/
suffix(maxLength, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(maxLength, 0), () => "Can't take a suffix of negative length from a collection", null, null);
const amount = max(0, Int.$subtract(_this.count, maxLength));
const start = $nilCoalescing(_this.indexOffsetByLimitedBy(_this.startIndex, amount, _this.endIndex), () => _this.endIndex);
return _this.subscriptRange$get((_.arg0 = start).constructor.$halfOpenRange(_.arg0, _this.endIndex))
}
/*Swift.(file).Collection.prefix(upTo:Self.Index)*/
/*Swift.(file).Collection.prefix(upTo:Self.Index)*/
prefixUpTo(end, $info?) {
let _this = this;
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, end))
}
/*Swift.(file).Collection.suffix(from:Self.Index)*/
/*Swift.(file).Collection.suffix(from:Self.Index)*/
suffixFrom(start, $info?) {
let _this = this;
return _this.subscriptRange$get((_.arg0 = start).constructor.$halfOpenRange(_.arg0, _this.endIndex))
}
/*Swift.(file).Collection.prefix(through:Self.Index)*/
/*Swift.(file).Collection.prefix(through:Self.Index)*/
prefixThrough(position, $info?) {
let _this = this;
return _this.prefixUpTo(_this.indexAfter(position))
}
/*Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)*/
/*Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)*/
splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, isSeparator, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(maxSplits, 0), () => "Must take zero or more splits", null, null);
let result = _create(Array, 'initArrayLiteralArray', [], {});
let subSequenceStart = _this.startIndex;
function appendSubsequenceEnd(end, $info?){
if((Bool.$logicalAND((_.arg0 = subSequenceStart).constructor.$equal(_.arg0, end), () => omittingEmptySubsequences))) {
return false;
};
result.append(_this.subscriptRange$get((_.arg1 = subSequenceStart).constructor.$halfOpenRange(_.arg1, end)), {$setThis: $val => result = $val});
return true;
}
if((Bool.$logicalOR(Int.$equal(maxSplits, 0), () => _this.isEmpty))) {
_.discardAssignment = appendSubsequenceEnd(_this.endIndex);
return result;
};
let subSequenceEnd = subSequenceStart;
const cachedEndIndex = _this.endIndex;
while(true){
if(!(((_.arg2 = subSequenceEnd).constructor.$notEqual(_.arg2, cachedEndIndex)))) break
if((isSeparator(_this.subscript$get(subSequenceEnd)))) {
const didAppend = appendSubsequenceEnd(subSequenceEnd);
_this.formIndexAfter({get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});
subSequenceStart = subSequenceEnd;
if((Bool.$logicalAND(didAppend, () => Int.$equal(result.count, maxSplits)))) {
break;
};
continue;
};
_this.formIndexAfter({get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});
};
if((Bool.$logicalOR((_.arg3 = subSequenceStart).constructor.$notEqual(_.arg3, cachedEndIndex), () => Bool.$not(omittingEmptySubsequences)))) {
result.append(_this.subscriptRange$get((_.arg4 = subSequenceStart).constructor.$halfOpenRange(_.arg4, cachedEndIndex)), {$setThis: $val => result = $val});
};
return result
}
/*Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)*/
/*Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)*/
splitSeparatorMaxSplitsOmittingEmptySubsequences(separator, maxSplits, omittingEmptySubsequences, $info?) {
let _this = this;
return _this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, (($0, $info?) => (_.arg0 = $0).constructor.$equal(_.arg0, separator)))
}
/*Swift.(file).Collection.removeFirst()*/
/*Swift.(file).Collection.removeFirst()*/
removeFirst($info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove items from an empty collection", null, null);
const _element = _this.first[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexAfter(_this.startIndex)).constructor.$halfOpenRange(_.arg0, _this.endIndex))));
return _element
}
/*Swift.(file).Collection.removeFirst(_:Int)*/
/*Swift.(file).Collection.removeFirst(_:Int)*/
/*!!!DUPLICATE NAME*/
removeFirst(k, $info?) {
let _this = this;
if((Int.$equal(k, 0))) {
return ;
};
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Number of elements to remove should be non-negative", null, null);
preconditionFileLine(() => Int.$greaterThanOrEqual(_this.count, k), () => "Can't remove more items from a collection than it contains", null, null);
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexOffsetBy(_this.startIndex, k)).constructor.$halfOpenRange(_.arg0, _this.endIndex))))
}
/*Swift.(file).Collection.firstIndex(of:Self.Element)*/
/*Swift.(file).Collection.firstIndex(of:Self.Element)*/
firstIndexOf(_element, $info?) {
let _this = this;
const $ifLet0, result_1
if((($ifLet0 = _this._customIndexOfEquatableElement(_element))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return result_1;
};
let i = _this.startIndex;
while(true){
if(!(((_.arg0 = i).constructor.$notEqual(_.arg0, _this.endIndex)))) break
if(((_.arg1 = _this.subscript$get(i)).constructor.$equal(_.arg1, _element))) {
return _injectIntoOptional(i);
};
_this.formIndexAfter({get: () => i, set: $val => i = $val});
};
return _injectIntoOptional(null)
}
/*Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)*/
firstIndexWhere(predicate, $info?) {
let _this = this;
let i = _this.startIndex;
while(true){
if(!(((_.arg0 = i).constructor.$notEqual(_.arg0, _this.endIndex)))) break
if((predicate(_this.subscript$get(i)))) {
return _injectIntoOptional(i);
};
_this.formIndexAfter({get: () => i, set: $val => i = $val});
};
return _injectIntoOptional(null)
}



/*Swift.(file).Collection.indices*/
indices$get() {
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this, _this.startIndex, _this.endIndex, {})
}
get indices() { return this.indices$get() };



/*Swift.(file).Collection.subscript(_:R)*/
/*Swift.(file).Collection.subscript(_:R)*/
/*!!!DUPLICATE NAME*/
subscript$get<R>(r, $info?) {
let _this = this;
return _this.subscriptRange$get(r.relativeTo(_this))
}

/*Swift.(file).Collection.subscript(_:(UnboundedRange_) -> ())*/
/*Swift.(file).Collection.subscript(_:(UnboundedRange_) -> ())*/
subscriptUnboundedRange$get(x, $info?) {
let _this = this;
return _this.subscript$get(((function(){throw '!unclarifiedGeneric:Self.Index'})()).$openEndedRange(_this.startIndex))
}



/*Swift.(file).Collection.index(_:Self.Index,offsetBy:T)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:T)*/
indexOffsetByT<T>(i, n, $info?) {
let _this = this;
return _this.indexOffsetBy(i, _create(Int, 'initT', n, {}))
}
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)*/
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)*/
/*!!!DUPLICATE NAME*/
formIndexOffsetBy<T>(i$inout, n, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
return _this.formIndexOffsetBy({get: () => i, set: $val => i = $val}, _create(Int, 'initT', n, {}));})()
i$inout.set(i)
return $result
}
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)*/
indexOffsetByTLimitedBy<T>(i, n, limit, $info?) {
let _this = this;
return _this.indexOffsetByLimitedBy(i, _create(Int, 'initT', n, {}), limit)
}
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)*/
/*Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)*/
/*!!!DUPLICATE NAME*/
formIndexOffsetByLimitedBy<T>(i$inout, n, limit, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
return _this.formIndexOffsetByLimitedBy({get: () => i, set: $val => i = $val}, _create(Int, 'initT', n, {}), limit);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo<T>(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}
/*Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)*/
/*Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)*/
flatMap(transform, $info?) {
let _this = this;
return _this._compactMap(transform)
}
/*Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)*/
indexWhere(_predicate, $info?) {
let _this = this;
return _this.firstIndexWhere(_predicate)
}
/*Swift.(file).Collection.index(of:Self.Element)*/
/*Swift.(file).Collection.index(of:Self.Element)*/
indexOfSwift(_element, $info?) {
let _this = this;
return _this.firstIndexOf(_element)
}
}
if(typeof Sequence$implementation != 'undefined') _mixin(Collection$implementation, Sequence$implementation, false)






































interface Comparable extends Equatable{
static /*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?)
static /*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?)
static /*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?)
static /*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?)
}
class Comparable$implementation{
static /*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}
static /*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).Comparable....infix(_:Self,_:Self)*/
/*Swift.(file).Comparable....infix(_:Self,_:Self)*/
$closedRange(minimum, maximum, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = minimum).constructor.$lessThanOrEqual(_.arg0, maximum), () => "Can't form Range with upperBound < lowerBound", null, null);
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {0: minimum, 1: maximum}, {})
}
static /*Swift.(file).Comparable...<infix(_:Self,_:Self)*/
/*Swift.(file).Comparable...<infix(_:Self,_:Self)*/
$halfOpenRange(minimum, maximum, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = minimum).constructor.$lessThanOrEqual(_.arg0, maximum), () => "Can't form Range with upperBound < lowerBound", null, null);
return _create(Range, 'initUncheckedBoundstuple_type', {0: minimum, 1: maximum}, {})
}
static /*Swift.(file).Comparable...<prefix(_:Self)*/
/*Swift.(file).Comparable...<prefix(_:Self)*/
prefix_46_46_60(maximum, $info?) {
let _this = this;
return _create(PartialRangeUpTo, 'init', maximum, {})
}
static /*Swift.(file).Comparable....prefix(_:Self)*/
/*Swift.(file).Comparable....prefix(_:Self)*/
prefix_46_46_46(maximum, $info?) {
let _this = this;
return _create(PartialRangeThrough, 'init', maximum, {})
}
static /*Swift.(file).Comparable....postfix(_:Self)*/
/*Swift.(file).Comparable....postfix(_:Self)*/
$openEndedRange(minimum, $info?) {
let _this = this;
return _create(PartialRangeFrom, 'init', minimum, {})
}
}
if(typeof Equatable$implementation != 'undefined') _mixin(Comparable$implementation, Equatable$implementation, false)








class OpaquePointer implements Equatable, Hashable, CustomDebugStringConvertible, CVarArg{
static readonly $struct = true





/*Swift.(file).OpaquePointer.init(_:RawPointer)*/
/*Swift.(file).OpaquePointer.init(_:RawPointer)*/
initRawPointer(v, $info?) {
throw 'unsupported method Swift.(file).OpaquePointer.init(_:RawPointer) in ' + this.constructor.name
}
/*Swift.(file).OpaquePointer.init(bitPattern:Int)*/
/*Swift.(file).OpaquePointer.init(bitPattern:Int)*/
initBitPatternInt(bitPattern, $info?) {
throw 'unsupported method Swift.(file).OpaquePointer.init(bitPattern:Int) in ' + this.constructor.name
}
static readonly initBitPatternInt$failable = true
/*Swift.(file).OpaquePointer.init(bitPattern:UInt)*/
/*Swift.(file).OpaquePointer.init(bitPattern:UInt)*/
initBitPatternUInt(bitPattern, $info?) {
throw 'unsupported method Swift.(file).OpaquePointer.init(bitPattern:UInt) in ' + this.constructor.name
}
static readonly initBitPatternUInt$failable = true
/*Swift.(file).OpaquePointer.init(_:UnsafePointer<T>)*/
/*Swift.(file).OpaquePointer.init(_:UnsafePointer<T>)*/
initUnsafePointer<T>(from, $info?) {
let _this = this;
_this._rawValue = from._rawValue;
return
}
/*Swift.(file).OpaquePointer.init(_:UnsafePointer<T>?)*/
/*Swift.(file).OpaquePointer.init(_:UnsafePointer<T>?)*/
initOptional<T>(from, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeRawPointer(unwrapped_1);
return
}
static readonly initOptional$failable = true
/*Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>)*/
/*Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>)*/
initUnsafeMutablePointer<T>(from, $info?) {
let _this = this;
_this._rawValue = from._rawValue;
return
}
/*Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>?)*/
/*Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>?)*/
/*!!!DUPLICATE NAME*/
initOptional<T>(from, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeMutablePointer(unwrapped_1);
return
}
static readonly initOptional$failable = true
static /*Swift.(file).OpaquePointer.==infix(_:OpaquePointer,_:OpaquePointer)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
/*Swift.(file).OpaquePointer.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).OpaquePointer.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).OpaquePointer.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).OpaquePointer.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


/*Swift.(file).OpaquePointer.debugDescription*/
debugDescription$get() {
let _this = this;
return _rawPointerToString(_this._rawValue)
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer)*/
/*Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer)*/
initUnsafeMutableRawPointer(from, $info?) {
let _this = this;
_this._rawValue = from._rawValue;
return
}
/*Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer?)*/
/*Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer?)*/
/*!!!DUPLICATE NAME*/
initOptional(from, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this._rawValue = unwrapped_1._rawValue;
return
}
static readonly initOptional$failable = true
/*Swift.(file).OpaquePointer.init(_:UnsafeRawPointer)*/
/*Swift.(file).OpaquePointer.init(_:UnsafeRawPointer)*/
initUnsafeRawPointer(from, $info?) {
let _this = this;
_this._rawValue = from._rawValue;
return
}
/*Swift.(file).OpaquePointer.init(_:UnsafeRawPointer?)*/
/*Swift.(file).OpaquePointer.init(_:UnsafeRawPointer?)*/
/*!!!DUPLICATE NAME*/
initOptional(from, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this._rawValue = unwrapped_1._rawValue;
return
}
static readonly initOptional$failable = true



init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(OpaquePointer, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(OpaquePointer, Hashable$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(OpaquePointer, CustomDebugStringConvertible$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(OpaquePointer, CVarArg$implementation, false)












class CVaListPointer implements CustomDebugStringConvertible{
static readonly $struct = true





/*Swift.(file).CVaListPointer.init(_fromUnsafeMutablePointer:UnsafeMutableRawPointer)*/
/*Swift.(file).CVaListPointer.init(_fromUnsafeMutablePointer:UnsafeMutableRawPointer)*/
init_fromUnsafeMutablePointerUnsafeMutableRawPointer(from, $info?) {
let _this = this;
_this._value = _cloneStruct(from);
return
}

/*Swift.(file).CVaListPointer.debugDescription*/
debugDescription$get() {
let _this = this;
return _this._value.debugDescription
}
get debugDescription() { return this.debugDescription$get() };



init$vars() {let _this = this;

}
}
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(CVaListPointer, CustomDebugStringConvertible$implementation, false)




class _DictionaryAnyHashableBox<Key, Value> implements _AnyHashableBox{
static readonly $struct = true






/*Swift.(file)._DictionaryAnyHashableBox.init(_:Dictionary<Key, Value>)*/
/*Swift.(file)._DictionaryAnyHashableBox.init(_:Dictionary<Key, Value>)*/
initDictionary(value, $info?) {
throw 'unsupported method Swift.(file)._DictionaryAnyHashableBox.init(_:Dictionary<Key, Value>) in ' + this.constructor.name
}














init$vars() {let _this = this;

}
}
if(typeof _AnyHashableBox$implementation != 'undefined') _mixin(_DictionaryAnyHashableBox, _AnyHashableBox$implementation, false)


class _MergeError implements Error{

static get keyCollision() {return Object.assign(new _MergeError(), {rawValue: "keyCollision", ...Array.from(arguments)})}
static /*Swift.(file)._MergeError.==(_:_MergeError,_:_MergeError)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file)._MergeError.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file)._MergeError.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file)._MergeError.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file)._MergeError.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof Error$implementation != 'undefined') _mixin(_MergeError, Error$implementation, false)
_mixin(_MergeError, _DefaultEnumImplementation, false)


class _SwiftDictionaryNSEnumerator<Key, Value> extends __SwiftNativeNSEnumerator implements _NSEnumerator{

/*Swift.(file)._SwiftDictionaryNSEnumerator.base*/
base$get() {
throw 'unsupported variable Swift.(file)._SwiftDictionaryNSEnumerator.base in ' + this.constructor.name
}
get base() { return this.base$get() };






/*Swift.(file)._SwiftDictionaryNSEnumerator.bridgedKeys*/
bridgedKeys$get() {
throw 'unsupported variable Swift.(file)._SwiftDictionaryNSEnumerator.bridgedKeys in ' + this.constructor.name
}
get bridgedKeys() { return this.bridgedKeys$get() };






/*Swift.(file)._SwiftDictionaryNSEnumerator.nextBucket*/
nextBucket$get() {
throw 'unsupported variable Swift.(file)._SwiftDictionaryNSEnumerator.nextBucket in ' + this.constructor.name
}
get nextBucket() { return this.nextBucket$get() };






/*Swift.(file)._SwiftDictionaryNSEnumerator.endBucket*/
endBucket$get() {
throw 'unsupported variable Swift.(file)._SwiftDictionaryNSEnumerator.endBucket in ' + this.constructor.name
}
get endBucket() { return this.endBucket$get() };





/*Swift.(file)._SwiftDictionaryNSEnumerator.init()*/
/*Swift.(file).__SwiftNativeNSEnumerator.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SwiftDictionaryNSEnumerator.init() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDictionaryNSEnumerator.init(_:_NativeDictionary<Key, Value>)*/
/*Swift.(file)._SwiftDictionaryNSEnumerator.init(_:_NativeDictionary<Key, Value>)*/
init_NativeDictionary(base, $info?) {
throw 'unsupported method Swift.(file)._SwiftDictionaryNSEnumerator.init(_:_NativeDictionary<Key, Value>) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDictionaryNSEnumerator.init(_:_SwiftDeferredNSDictionary<Key, Value>)*/
/*Swift.(file)._SwiftDictionaryNSEnumerator.init(_:_SwiftDeferredNSDictionary<Key, Value>)*/
init_SwiftDeferredNSDictionary(deferred, $info?) {
throw 'unsupported method Swift.(file)._SwiftDictionaryNSEnumerator.init(_:_SwiftDeferredNSDictionary<Key, Value>) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDictionaryNSEnumerator.bridgedKey(at:_HashTable.Bucket)*/
/*Swift.(file)._SwiftDictionaryNSEnumerator.bridgedKey(at:_HashTable.Bucket)*/
bridgedKeyAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._SwiftDictionaryNSEnumerator.bridgedKey(at:_HashTable.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDictionaryNSEnumerator.nextObject()*/
/*Swift.(file)._NSEnumerator.nextObject()*/
nextObject($info?) {
throw 'unsupported method Swift.(file)._SwiftDictionaryNSEnumerator.nextObject() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDictionaryNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int)*/
/*Swift.(file)._SwiftDictionaryNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file)._SwiftDictionaryNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDictionaryNSEnumerator.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSEnumerator.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file)._SwiftDictionaryNSEnumerator.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSEnumerator$implementation != 'undefined') _mixin(_SwiftDictionaryNSEnumerator, _NSEnumerator$implementation, false)


class _SwiftDeferredNSDictionary<Key, Value> extends __SwiftNativeNSDictionary implements _NSDictionaryCore{
















/*Swift.(file)._SwiftDeferredNSDictionary.init(_:_NativeDictionary<Key, Value>)*/
/*Swift.(file)._SwiftDeferredNSDictionary.init(_:_NativeDictionary<Key, Value>)*/
init_NativeDictionary(_native, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.init(_:_NativeDictionary<Key, Value>) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
/*Swift.(file)._NSDictionaryCore.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
initObjectsUnsafePointerForKeysUnsafeRawPointerCountInt(objects, forKeys, count, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int) in ' + this.constructor.name
}














/*Swift.(file)._SwiftDeferredNSDictionary.bridgeKeys()*/
/*Swift.(file)._SwiftDeferredNSDictionary.bridgeKeys()*/
bridgeKeys($info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.bridgeKeys() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.bridgeValues()*/
/*Swift.(file)._SwiftDeferredNSDictionary.bridgeValues()*/
bridgeValues($info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.bridgeValues() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSDictionaryCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}


/*Swift.(file)._SwiftDeferredNSDictionary.object(forKey:AnyObject)*/
/*Swift.(file)._NSDictionaryCore.object(forKey:AnyObject)*/
objectForKey(aKey, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.object(forKey:AnyObject) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.keyEnumerator()*/
/*Swift.(file)._NSDictionaryCore.keyEnumerator()*/
keyEnumerator($info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.keyEnumerator() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
getObjectsAndKeysCount(objects, keys, count, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:Int,using:@convention(block) (Unmanaged<AnyObject>, Unmanaged<AnyObject>, UnsafeMutablePointer<UInt8>) -> Void)*/
/*Swift.(file)._SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:Int,using:@convention(block) (Unmanaged<AnyObject>, Unmanaged<AnyObject>, UnsafeMutablePointer<UInt8>) -> Void)*/
enumerateKeysAndObjectsOptionsUsing(options, block, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:Int,using:@convention(block) (Unmanaged<AnyObject>, Unmanaged<AnyObject>, UnsafeMutablePointer<UInt8>) -> Void) in ' + this.constructor.name
}

/*Swift.(file)._SwiftDeferredNSDictionary.count*/
count$get() {
throw 'unsupported variable Swift.(file)._SwiftDeferredNSDictionary.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file)._SwiftDeferredNSDictionary.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.init()*/
/*Swift.(file).__SwiftNativeNSDictionary.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.init() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSDictionary.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSDictionary.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSDictionary.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSDictionaryCore$implementation != 'undefined') _mixin(_SwiftDeferredNSDictionary, _NSDictionaryCore$implementation, false)


class __CocoaDictionary implements _DictionaryBuffer, Sequence{
static readonly $struct = true

/*Swift.(file).__CocoaDictionary.object*/
readonly object$get() {
throw 'unsupported variable Swift.(file).__CocoaDictionary.object in ' + this.constructor.name
}
readonly get object() { return this.object$get() };



/*Swift.(file).__CocoaDictionary.init(_:AnyObject)*/
/*Swift.(file).__CocoaDictionary.init(_:AnyObject)*/
initAnyObject(object, $info?) {
throw 'unsupported method Swift.(file).__CocoaDictionary.init(_:AnyObject) in ' + this.constructor.name
}
/*Swift.(file).__CocoaDictionary.isEqual(to:__CocoaDictionary)*/
/*Swift.(file).__CocoaDictionary.isEqual(to:__CocoaDictionary)*/
isEqualTo(other, $info?) {
let _this = this;
return _stdlib_NSObject_isEqual(_this.object, other.object)
}



/*Swift.(file).__CocoaDictionary.startIndex*/
startIndex$get() {
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSDictionary_allKeys(_this.object));
return _create(__CocoaDictionary.Index, 'init__CocoaDictionaryIndexStorageOffsetInt', _create(__CocoaDictionary.Index.Storage, 'init__CocoaDictionary_BridgingBuffer', _this, allKeys, {}), 0, {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).__CocoaDictionary.endIndex*/
endIndex$get() {
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSDictionary_allKeys(_this.object));
return _create(__CocoaDictionary.Index, 'init__CocoaDictionaryIndexStorageOffsetInt', _create(__CocoaDictionary.Index.Storage, 'init__CocoaDictionary_BridgingBuffer', _this, allKeys, {}), allKeys.count, {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).__CocoaDictionary.index(after:__CocoaDictionary.Index)*/
/*Swift.(file)._DictionaryBuffer.index(after:Self.Index)*/
indexAfter(index, $info?) {
let _this = this;
_this.validate(index);
let result = _cloneStruct(index);
Int.$addAndAssign({get: () => result._offset, set: $val => result._offset = $val}, 1);
return result
}
/*Swift.(file).__CocoaDictionary.validate(_:__CocoaDictionary.Index)*/
/*Swift.(file).__CocoaDictionary.validate(_:__CocoaDictionary.Index)*/
validate(index, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object)), () => "Invalid index", null, null);
preconditionFileLine(() => Int.$lessThan(index._offset, index.storage.allKeys.count), () => "Attempt to access endIndex", null, null)
}
/*Swift.(file).__CocoaDictionary.formIndex(after:__CocoaDictionary.Index,isUnique:Bool)*/
/*Swift.(file).__CocoaDictionary.formIndex(after:__CocoaDictionary.Index,isUnique:Bool)*/
formIndexAfterIsUnique(index$inout, isUnique, $info?) {
let _this = this;
let index = index$inout.get()
const $result = (() => {
_this.validate(index);
Int.$addAndAssign({get: () => index._offset, set: $val => index._offset = $val}, 1);})()
index$inout.set(index)
return $result
}
/*Swift.(file).__CocoaDictionary.index(forKey:__CocoaDictionary.Key)*/
/*Swift.(file)._DictionaryBuffer.index(forKey:Self.Key)*/
indexForKey(key, $info?) {
throw 'unsupported method Swift.(file).__CocoaDictionary.index(forKey:__CocoaDictionary.Key) in ' + this.constructor.name
}

/*Swift.(file).__CocoaDictionary.count*/
count$get() {
let _this = this;
const nsd = _cloneStruct(unsafeBitCastTo(_this.object, _NSDictionary));
return nsd.count
}
get count() { return this.count$get() };



/*Swift.(file).__CocoaDictionary.contains(_:__CocoaDictionary.Key)*/
/*Swift.(file)._DictionaryBuffer.contains(_:Self.Key)*/
contains(key, $info?) {
let _this = this;
const nsd = _cloneStruct(unsafeBitCastTo(_this.object, _NSDictionary));
return Optional.wrappedNotEqualsOptionalNilComparisonType(nsd.objectForKey(key), _injectIntoOptional(null))
}
/*Swift.(file).__CocoaDictionary.lookup(_:__CocoaDictionary.Key)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Key)*/
lookup(key, $info?) {
let _this = this;
const nsd = _cloneStruct(unsafeBitCastTo(_this.object, _NSDictionary));
return nsd.objectForKey(key)
}
/*Swift.(file).__CocoaDictionary.lookup(_:__CocoaDictionary.Index)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Index)*/
/*!!!DUPLICATE NAME*/
lookup(index, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object)), () => "Invalid index", null, null);
const key = _cloneStruct(index.storage.allKeys.subscript$get(index._offset));
const value = _cloneStruct(index.storage.base.object[0](key)[0]);
return {0: key, 1: value}
}
/*Swift.(file).__CocoaDictionary.key(at:__CocoaDictionary.Index)*/
/*Swift.(file)._DictionaryBuffer.key(at:Self.Index)*/
keyAt(index, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object)), () => "Invalid index", null, null);
return index.key
}
/*Swift.(file).__CocoaDictionary.value(at:__CocoaDictionary.Index)*/
/*Swift.(file)._DictionaryBuffer.value(at:Self.Index)*/
valueAt(index, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object)), () => "Invalid index", null, null);
const key = _cloneStruct(index.storage.allKeys.subscript$get(index._offset));
return index.storage.base.object[0](key)[0]
}
/*Swift.(file).__CocoaDictionary.mapValues(_:(Value) throws -> T)*/
/*Swift.(file).__CocoaDictionary.mapValues(_:(Value) throws -> T)*/
mapValues<Key, Value, T>(transform, $info?) {
let _this = this;
let result = _create(_NativeDictionary, 'initCapacityInt', _this.count, {});
{
let $generator = _this.makeIterator( {});
while(true) {
const $ifLet0, cocoaKey_1, cocoaValue_2;
if(!((($ifLet0 = _injectIntoOptional(((_.tmp0 = $generator.next( {})).rawValue === 'some') ? (_.tmp0[0]) : null))||true) && $ifLet0.rawValue == 'some' && ((cocoaKey_1 = $ifLet0[0][0])||true) && ((cocoaValue_2 = $ifLet0[0][1])||true))) break
const key = _forceBridgeFromObjectiveC(cocoaKey_1, ((function(){throw '!unclarifiedGeneric:Key'})()));
const value = _forceBridgeFromObjectiveC(cocoaValue_2, ((function(){throw '!unclarifiedGeneric:Value'})()));
result.insertNewKeyValue(key, transform(value), {$setThis: $val => result = $val});
}
};
return result
}
static Index = class implements Equatable, Comparable{
static readonly $struct = true











/*Swift.(file).__CocoaDictionary.Index.storage*/
storage$get() {
throw 'unsupported variable Swift.(file).__CocoaDictionary.Index.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };



/*Swift.(file).__CocoaDictionary.Index.init(_:__CocoaDictionary.Index.Storage,offset:Int)*/
/*Swift.(file).__CocoaDictionary.Index.init(_:__CocoaDictionary.Index.Storage,offset:Int)*/
init__CocoaDictionaryIndexStorageOffsetInt(storage, offset, $info?) {
throw 'unsupported method Swift.(file).__CocoaDictionary.Index.init(_:__CocoaDictionary.Index.Storage,offset:Int) in ' + this.constructor.name
}
static Storage = class{

/*Swift.(file).__CocoaDictionary.Index.Storage.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file).__CocoaDictionary.Index.Storage.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };




/*Swift.(file).__CocoaDictionary.Index.Storage.allKeys*/
allKeys$get() {
throw 'unsupported variable Swift.(file).__CocoaDictionary.Index.Storage.allKeys in ' + this.constructor.name
}
get allKeys() { return this.allKeys$get() };





/*Swift.(file).__CocoaDictionary.Index.Storage.init(_:__CocoaDictionary,_:_BridgingBuffer)*/
/*Swift.(file).__CocoaDictionary.Index.Storage.init(_:__CocoaDictionary,_:_BridgingBuffer)*/
init__CocoaDictionary_BridgingBuffer(base, allKeys, $info?) {
throw 'unsupported method Swift.(file).__CocoaDictionary.Index.Storage.init(_:__CocoaDictionary,_:_BridgingBuffer) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}

/*Swift.(file).__CocoaDictionary.Index.handleBitPattern*/
handleBitPattern$get() {
let _this = this;
return unsafeBitCastTo(_this.storage, UInt)
}
get handleBitPattern() { return this.handleBitPattern$get() };




/*Swift.(file).__CocoaDictionary.Index.dictionary*/
dictionary$get() {
let _this = this;
return _this.storage.base
}
get dictionary() { return this.dictionary$get() };




/*Swift.(file).__CocoaDictionary.Index.key*/
key$get() {
let _this = this;
preconditionFileLine(() => Int.$lessThan(_this._offset, _this.storage.allKeys.count), () => "Attempting to access Dictionary elements using an invalid index", null, null);
return _this.storage.allKeys.subscript$get(_this._offset)
}
get key() { return this.key$get() };




/*Swift.(file).__CocoaDictionary.Index.age*/
age$get() {
let _this = this;
return _HashTable.ageFor(_this.storage.base.object)
}
get age() { return this.age$get() };



static /*Swift.(file).__CocoaDictionary.Index.==infix(_:__CocoaDictionary.Index,_:__CocoaDictionary.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different dictionaries", null, null);
return Int.$equal(lhs._offset, rhs._offset)
}
static /*Swift.(file).__CocoaDictionary.Index.<infix(_:__CocoaDictionary.Index,_:__CocoaDictionary.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different dictionaries", null, null);
return Int.$lessThan(lhs._offset, rhs._offset)
}
init$vars() {let _this = this;

}
}
static Iterator = class implements IteratorProtocol{











/*Swift.(file).__CocoaDictionary.Iterator.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file).__CocoaDictionary.Iterator.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };










/*Swift.(file).__CocoaDictionary.Iterator.itemIndex*/
itemIndex$get() {
throw 'unsupported variable Swift.(file).__CocoaDictionary.Iterator.itemIndex in ' + this.constructor.name
}
get itemIndex() { return this.itemIndex$get() };






/*Swift.(file).__CocoaDictionary.Iterator.itemCount*/
itemCount$get() {
throw 'unsupported variable Swift.(file).__CocoaDictionary.Iterator.itemCount in ' + this.constructor.name
}
get itemCount() { return this.itemCount$get() };





/*Swift.(file).__CocoaDictionary.Iterator.init(_:__CocoaDictionary)*/
/*Swift.(file).__CocoaDictionary.Iterator.init(_:__CocoaDictionary)*/
init__CocoaDictionary(base, $info?) {
throw 'unsupported method Swift.(file).__CocoaDictionary.Iterator.init(_:__CocoaDictionary) in ' + this.constructor.name
}


/*Swift.(file).__CocoaDictionary.Iterator.nextKey()*/
/*Swift.(file).__CocoaDictionary.Iterator.nextKey()*/
nextKey($info?) {
let _this = this;
if((Int.$lessThan(_this.itemIndex, 0))) {
return _injectIntoOptional(null);
};
const base = _cloneStruct(_this.base);
if((Int.$equal(_this.itemIndex, _this.itemCount))) {
const stackBufCount = _this._fastEnumerationStackBuf.count;
_this.itemCount = base.object[0](_this._fastEnumerationStatePtr, _create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', _this._fastEnumerationStackBufPtr, {}).assumingMemoryBoundTo(AnyObject), stackBufCount);
if((Int.$equal(_this.itemCount, 0))) {
_this.itemIndex = -1;
return _injectIntoOptional(null);
};
_this.itemIndex = 0;
};
const itemsPtrUP = _cloneStruct(_create(UnsafeMutableRawPointer, 'initAutoreleasingUnsafeMutablePointer', _this._fastEnumerationState.itemsPtr[0], {}).assumingMemoryBoundTo(AnyObject));
const itemsPtr = _create(_UnmanagedAnyObjectArray, 'initUnsafeMutablePointer', itemsPtrUP, {});
const key = _cloneStruct(itemsPtr.subscript$get(_this.itemIndex));
Int.$addAndAssign({get: () => _this.itemIndex, set: $val => _this.itemIndex = $val}, 1);
return _injectIntoOptional(key)
}
/*Swift.(file).__CocoaDictionary.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const $ifLet0, key_1
if(!((($ifLet0 = _this.nextKey( {}))||true) && $ifLet0.rawValue == 'some' && ((key_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
const value = _cloneStruct(_this.base.object[0](key_1)[0]);
return _injectIntoOptional({0: key_1, 1: value})
}
init$vars() {let _this = this;

}
}
/*Swift.(file).__CocoaDictionary.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(__CocoaDictionary.Iterator, 'init__CocoaDictionary', _this, {})
}

init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(__CocoaDictionary.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(__CocoaDictionary.Index, Comparable$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(__CocoaDictionary.Iterator, IteratorProtocol$implementation, false)
if(typeof _DictionaryBuffer$implementation != 'undefined') _mixin(__CocoaDictionary, _DictionaryBuffer$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(__CocoaDictionary, Sequence$implementation, false)












class __RawDictionaryStorage extends __SwiftNativeNSDictionary{













































/*Swift.(file).__RawDictionaryStorage.init(_doNotCallMe:())*/
/*Swift.(file).__RawDictionaryStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__RawDictionaryStorage.init(_doNotCallMe:()) in ' + this.constructor.name
}









/*Swift.(file).__RawDictionaryStorage.init()*/
/*Swift.(file).__SwiftNativeNSDictionary.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__RawDictionaryStorage.init() in ' + this.constructor.name
}
/*Swift.(file).__RawDictionaryStorage.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSDictionary.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file).__RawDictionaryStorage.init(coder:AnyObject) in ' + this.constructor.name
}


/*Swift.(file).__RawDictionaryStorage.empty*/
static empty$get() {
throw 'unsupported variable Swift.(file).__RawDictionaryStorage.empty in ' + this.constructor.name
}
static get empty() { return this.empty$get() };



init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}




class __EmptyDictionarySingleton extends __RawDictionaryStorage implements _NSDictionaryCore{
/*Swift.(file).__EmptyDictionarySingleton.init(_doNotCallMe:())*/
/*Swift.(file).__RawDictionaryStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__EmptyDictionarySingleton.init(_doNotCallMe:()) in ' + this.constructor.name
}
/*Swift.(file).__EmptyDictionarySingleton.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
/*Swift.(file)._NSDictionaryCore.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
initObjectsUnsafePointerForKeysUnsafeRawPointerCountInt(objects, forKeys, count, $info?) {
throw 'unsupported method Swift.(file).__EmptyDictionarySingleton.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int) in ' + this.constructor.name
}

/*Swift.(file).__EmptyDictionarySingleton.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSDictionaryCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file).__EmptyDictionarySingleton.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}

/*Swift.(file).__EmptyDictionarySingleton.count*/
count$get() {
let _this = this;
return 0
}
get count() { return this.count$get() };



/*Swift.(file).__EmptyDictionarySingleton.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file).__EmptyDictionarySingleton.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).__EmptyDictionarySingleton.object(forKey:AnyObject)*/
/*Swift.(file)._NSDictionaryCore.object(forKey:AnyObject)*/
objectForKey(aKey, $info?) {
let _this = this;
return _injectIntoOptional(null)
}
/*Swift.(file).__EmptyDictionarySingleton.keyEnumerator()*/
/*Swift.(file)._NSDictionaryCore.keyEnumerator()*/
keyEnumerator($info?) {
let _this = this;
return _create(__SwiftEmptyNSEnumerator, 'init', {})
}
/*Swift.(file).__EmptyDictionarySingleton.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
getObjectsAndKeysCount(objects, keys, count, $info?) {
let _this = this
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSDictionaryCore$implementation != 'undefined') _mixin(__EmptyDictionarySingleton, _NSDictionaryCore$implementation, false)




class _DictionaryStorage<Key, Value> extends __RawDictionaryStorage implements _NSDictionaryCore{
/*Swift.(file)._DictionaryStorage.init(_doNotCallMe:())*/
/*Swift.(file).__RawDictionaryStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.init(_doNotCallMe:()) in ' + this.constructor.name
}








/*Swift.(file)._DictionaryStorage.asNative*/
asNative$get() {
throw 'unsupported variable Swift.(file)._DictionaryStorage.asNative in ' + this.constructor.name
}
get asNative() { return this.asNative$get() };



/*Swift.(file)._DictionaryStorage.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
/*Swift.(file)._NSDictionaryCore.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int)*/
initObjectsUnsafePointerForKeysUnsafeRawPointerCountInt(objects, forKeys, count, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.init(objects:UnsafePointer<AnyObject?>,forKeys:UnsafeRawPointer,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._DictionaryStorage.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSDictionaryCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}

/*Swift.(file)._DictionaryStorage.count*/
count$get() {
throw 'unsupported variable Swift.(file)._DictionaryStorage.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file)._DictionaryStorage.keyEnumerator()*/
/*Swift.(file)._NSDictionaryCore.keyEnumerator()*/
keyEnumerator($info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.keyEnumerator() in ' + this.constructor.name
}
/*Swift.(file)._DictionaryStorage.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._DictionaryStorage.object(forKey:AnyObject)*/
/*Swift.(file)._NSDictionaryCore.object(forKey:AnyObject)*/
objectForKey(aKey, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.object(forKey:AnyObject) in ' + this.constructor.name
}
/*Swift.(file)._DictionaryStorage.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSDictionaryCore.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)*/
getObjectsAndKeysCount(objects, keys, count, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
static /*Swift.(file)._DictionaryStorage.copy(original:__RawDictionaryStorage)*/
/*Swift.(file)._DictionaryStorage.copy(original:__RawDictionaryStorage)*/
copyOriginal(original, $info?) {
let _this = this;
return _this.allocateScaleAgeSeed(original._scale, _injectIntoOptional(original._age), _injectIntoOptional(original._seed))
}
static /*Swift.(file)._DictionaryStorage.resize(original:__RawDictionaryStorage,capacity:Int,move:Bool)*/
/*Swift.(file)._DictionaryStorage.resize(original:__RawDictionaryStorage,capacity:Int,move:Bool)*/
resizeOriginalCapacityMove(original, capacity, move, $info?) {
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity);
return _this.allocateScaleAgeSeed(scale, _injectIntoOptional(null), _injectIntoOptional(null))
}
static /*Swift.(file)._DictionaryStorage.allocate(capacity:Int)*/
/*Swift.(file)._DictionaryStorage.allocate(capacity:Int)*/
allocateCapacity(capacity, $info?) {
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity);
return _this.allocateScaleAgeSeed(scale, _injectIntoOptional(null), _injectIntoOptional(null))
}
static /*Swift.(file)._DictionaryStorage.convert(_:__CocoaDictionary,capacity:Int)*/
/*Swift.(file)._DictionaryStorage.convert(_:__CocoaDictionary,capacity:Int)*/
convertCapacity(cocoa, capacity, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.convert(_:__CocoaDictionary,capacity:Int) in ' + this.constructor.name
}
static /*Swift.(file)._DictionaryStorage.allocate(scale:Int8,age:Int32?,seed:Int?)*/
/*Swift.(file)._DictionaryStorage.allocate(scale:Int8,age:Int32?,seed:Int?)*/
allocateScaleAgeSeed(scale, age, seed, $info?) {
throw 'unsupported method Swift.(file)._DictionaryStorage.allocate(scale:Int8,age:Int32?,seed:Int?) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSDictionaryCore$implementation != 'undefined') _mixin(_DictionaryStorage, _NSDictionaryCore$implementation, false)




class AnyHashable implements Equatable, Hashable, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable{
static readonly $struct = true





/*Swift.(file).AnyHashable.init(_box:_AnyHashableBox)*/
/*Swift.(file).AnyHashable.init(_box:_AnyHashableBox)*/
init_box_AnyHashableBox(box, $info?) {
let _this = this;
_this._box = _cloneStruct(box);
return
}
/*Swift.(file).AnyHashable.init(_:H)*/
/*Swift.(file).AnyHashable.init(_:H)*/
init<H>(base, $info?) {
let _this = this;
const $ifLet0, custom_1
if((($ifLet0 = (((_.tmp0 = _injectIntoOptional(base)).rawValue === 'some') ? (_.tmp0[0]._toCustomAnyHashable( {})) : Optional.none))||true) && $ifLet0.rawValue == 'some' && ((custom_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(custom_1)));
return ;
};
_this.init_box_AnyHashableBox(_create(_ConcreteHashableBox, 'init', false, {}));
_makeAnyHashableUpcastingToHashableBaseTypeStoringResultInto(base, {get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))});
return
}
/*Swift.(file).AnyHashable.init(_usingDefaultRepresentationOf:H)*/
/*Swift.(file).AnyHashable.init(_usingDefaultRepresentationOf:H)*/
init_usingDefaultRepresentationOf<H>(base, $info?) {
let _this = this;
_this._box = _cloneStruct(_create(_ConcreteHashableBox, 'init', base, {}));
return
}

/*Swift.(file).AnyHashable.base*/
base$get() {
let _this = this;
return _this._box._base
}
get base() { return this.base$get() };




static /*Swift.(file).AnyHashable.==infix(_:AnyHashable,_:AnyHashable)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return $nilCoalescing(lhs._box._canonicalBox._isEqualTo(rhs._box._canonicalBox), () => false)
}

/*Swift.(file).AnyHashable.hashValue*/
hashValue$get() {
let _this = this;
return _this._box._canonicalBox._hashValue
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).AnyHashable.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
_this._box._canonicalBox._hashInto({get: () => hasher, set: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}


/*Swift.(file).AnyHashable.description*/
description$get() {
let _this = this;
return _create(String, 'initDescribing', _this.base, {})
}
get description() { return this.description$get() };




/*Swift.(file).AnyHashable.debugDescription*/
debugDescription$get() {
let _this = this;
return String.$add(String.$add("AnyHashable(", _create(String, 'initReflecting', _this.base, {})), ")")
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).AnyHashable.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["value", _this.base]]), , , {})
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(AnyHashable, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(AnyHashable, Hashable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(AnyHashable, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(AnyHashable, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(AnyHashable, CustomReflectable$implementation, false)












class __SwiftEmptyNSEnumerator extends __SwiftNativeNSEnumerator implements _NSEnumerator{
/*Swift.(file).__SwiftEmptyNSEnumerator.init()*/
/*Swift.(file).__SwiftNativeNSEnumerator.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftEmptyNSEnumerator.init() in ' + this.constructor.name
}
/*Swift.(file).__SwiftEmptyNSEnumerator.nextObject()*/
/*Swift.(file)._NSEnumerator.nextObject()*/
nextObject($info?) {
throw 'unsupported method Swift.(file).__SwiftEmptyNSEnumerator.nextObject() in ' + this.constructor.name
}
/*Swift.(file).__SwiftEmptyNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int)*/
/*Swift.(file).__SwiftEmptyNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file).__SwiftEmptyNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int) in ' + this.constructor.name
}
/*Swift.(file).__SwiftEmptyNSEnumerator.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSEnumerator.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file).__SwiftEmptyNSEnumerator.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSEnumerator$implementation != 'undefined') _mixin(__SwiftEmptyNSEnumerator, _NSEnumerator$implementation, false)


class __BridgingHashBuffer extends ManagedBuffer{
static Header = class{
static readonly $struct = true

/*Swift.(file).__BridgingHashBuffer.Header.owner*/
owner$get() {
throw 'unsupported variable Swift.(file).__BridgingHashBuffer.Header.owner in ' + this.constructor.name
}
get owner() { return this.owner$get() };






/*Swift.(file).__BridgingHashBuffer.Header.hashTable*/
hashTable$get() {
throw 'unsupported variable Swift.(file).__BridgingHashBuffer.Header.hashTable in ' + this.constructor.name
}
get hashTable() { return this.hashTable$get() };





/*Swift.(file).__BridgingHashBuffer.Header.init(owner:AnyObject,hashTable:_HashTable)*/
/*Swift.(file).__BridgingHashBuffer.Header.init(owner:AnyObject,hashTable:_HashTable)*/
initOwnerAnyObjectHashTable_HashTable(owner, hashTable, $info?) {
throw 'unsupported method Swift.(file).__BridgingHashBuffer.Header.init(owner:AnyObject,hashTable:_HashTable) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
static /*Swift.(file).__BridgingHashBuffer.allocate(owner:AnyObject,hashTable:_HashTable)*/
/*Swift.(file).__BridgingHashBuffer.allocate(owner:AnyObject,hashTable:_HashTable)*/
allocateOwnerHashTable(owner, hashTable, $info?) {
throw 'unsupported method Swift.(file).__BridgingHashBuffer.allocate(owner:AnyObject,hashTable:_HashTable) in ' + this.constructor.name
}

/*Swift.(file).__BridgingHashBuffer.subscript(_:_HashTable.Bucket)*/
/*Swift.(file).__BridgingHashBuffer.subscript(_:_HashTable.Bucket)*/
subscript$get(bucket, $info?) {
throw 'unsupported method Swift.(file).__BridgingHashBuffer.subscript(_:_HashTable.Bucket) in ' + this.constructor.name
}

/*Swift.(file).__BridgingHashBuffer.initialize(at:_HashTable.Bucket,to:AnyObject)*/
/*Swift.(file).__BridgingHashBuffer.initialize(at:_HashTable.Bucket,to:AnyObject)*/
initializeAtTo(bucket, object, $info?) {
throw 'unsupported method Swift.(file).__BridgingHashBuffer.initialize(at:_HashTable.Bucket,to:AnyObject) in ' + this.constructor.name
}
/*Swift.(file).__BridgingHashBuffer.init(_doNotCallMe:())*/
/*Swift.(file).ManagedBuffer.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__BridgingHashBuffer.init(_doNotCallMe:()) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _HashTable implements Sequence{
static readonly $struct = true


/*Swift.(file)._HashTable.words*/
words$get() {
throw 'unsupported variable Swift.(file)._HashTable.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file)._HashTable.bucketMask*/
readonly bucketMask$get() {
throw 'unsupported variable Swift.(file)._HashTable.bucketMask in ' + this.constructor.name
}
readonly get bucketMask() { return this.bucketMask$get() };



/*Swift.(file)._HashTable.init(words:UnsafeMutablePointer<_HashTable.Word>,bucketCount:Int)*/
/*Swift.(file)._HashTable.init(words:UnsafeMutablePointer<_HashTable.Word>,bucketCount:Int)*/
initWordsUnsafeMutablePointerBucketCountInt(words, bucketCount, $info?) {
throw 'unsupported method Swift.(file)._HashTable.init(words:UnsafeMutablePointer<_HashTable.Word>,bucketCount:Int) in ' + this.constructor.name
}

/*Swift.(file)._HashTable.bucketCount*/
bucketCount$get() {
throw 'unsupported variable Swift.(file)._HashTable.bucketCount in ' + this.constructor.name
}
get bucketCount() { return this.bucketCount$get() };




/*Swift.(file)._HashTable.wordCount*/
wordCount$get() {
throw 'unsupported variable Swift.(file)._HashTable.wordCount in ' + this.constructor.name
}
get wordCount() { return this.wordCount$get() };




/*Swift.(file)._HashTable.maxLoadFactor*/
static maxLoadFactor$get() {
let _this = this;
return Double.$divide(3, 4);
}
static get maxLoadFactor() { return this.maxLoadFactor$get()
}
static get maxLoadFactor() { return this.maxLoadFactor$get() };



static /*Swift.(file)._HashTable.capacity(forScale:Int8)*/
/*Swift.(file)._HashTable.capacity(forScale:Int8)*/
capacityForScale(scale, $info?) {
let _this = this;
const bucketCount = Int.infix_38_60_60(1, scale);
return _create(Int, 'initDouble', Double.$multiply(_create(Double, 'initInt', bucketCount, {}), _this.maxLoadFactor), {})
}
static /*Swift.(file)._HashTable.scale(forCapacity:Int)*/
/*Swift.(file)._HashTable.scale(forCapacity:Int)*/
scaleForCapacity(capacity, $info?) {
let _this = this;
const capacity = max(capacity, 1);
const minimumEntries = max(_create(Int, 'initDouble', Double.prototype.rounded.call(Double.$divide(_create(Double, 'initInt', capacity, {}), _this.maxLoadFactor), FloatingPointRoundingRule.up), {}), Int.$add(capacity, 1));
const exponent = Int.$add(Int.prototype._binaryLogarithm.call(Int.$subtract(max(minimumEntries, 2), 1), ), 1);
const scale = _create(Int8, 'initTruncatingIfNeeded', exponent, {});
return scale
}
static /*Swift.(file)._HashTable.age(for:AnyObject)*/
/*Swift.(file)._HashTable.age(for:AnyObject)*/
ageFor(cocoa, $info?) {
let _this = this;
const hash = _create(ObjectIdentifier, 'initAnyObject', cocoa, {}).hashValue;
return _create(Int32, 'initTruncatingIfNeeded', hash, {})
}
static /*Swift.(file)._HashTable.hashSeed(for:AnyObject,scale:Int8)*/
/*Swift.(file)._HashTable.hashSeed(for:AnyObject,scale:Int8)*/
hashSeedForScale(object, scale, $info?) {
let _this = this;
if((Hasher._isDeterministic)) {
return _create(Int, 'initT', scale, {});
};
return unsafeBitCastTo(object, Int)
}
static Bucket = class implements Equatable, Comparable{
static readonly $struct = true

/*Swift.(file)._HashTable.Bucket.offset*/
offset$get() {
throw 'unsupported variable Swift.(file)._HashTable.Bucket.offset in ' + this.constructor.name
}
get offset() { return this.offset$get() };





/*Swift.(file)._HashTable.Bucket.init(offset:Int)*/
/*Swift.(file)._HashTable.Bucket.init(offset:Int)*/
initOffsetInt(offset, $info?) {
throw 'unsupported method Swift.(file)._HashTable.Bucket.init(offset:Int) in ' + this.constructor.name
}
/*Swift.(file)._HashTable.Bucket.init(word:Int,bit:Int)*/
/*Swift.(file)._HashTable.Bucket.init(word:Int,bit:Int)*/
initWordIntBitInt(word, bit, $info?) {
throw 'unsupported method Swift.(file)._HashTable.Bucket.init(word:Int,bit:Int) in ' + this.constructor.name
}

/*Swift.(file)._HashTable.Bucket.word*/
word$get() {
throw 'unsupported variable Swift.(file)._HashTable.Bucket.word in ' + this.constructor.name
}
get word() { return this.word$get() };




/*Swift.(file)._HashTable.Bucket.bit*/
bit$get() {
throw 'unsupported variable Swift.(file)._HashTable.Bucket.bit in ' + this.constructor.name
}
get bit() { return this.bit$get() };



static /*Swift.(file)._HashTable.Bucket.==infix(_:_HashTable.Bucket,_:_HashTable.Bucket)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return Int.$equal(lhs.offset, rhs.offset)
}
static /*Swift.(file)._HashTable.Bucket.<infix(_:_HashTable.Bucket,_:_HashTable.Bucket)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
return Int.$lessThan(lhs.offset, rhs.offset)
}
init$vars() {let _this = this;

}
}
static Index = class implements Equatable, Comparable{
static readonly $struct = true

/*Swift.(file)._HashTable.Index.bucket*/
readonly bucket$get() {
throw 'unsupported variable Swift.(file)._HashTable.Index.bucket in ' + this.constructor.name
}
readonly get bucket() { return this.bucket$get() };




/*Swift.(file)._HashTable.Index.age*/
readonly age$get() {
throw 'unsupported variable Swift.(file)._HashTable.Index.age in ' + this.constructor.name
}
readonly get age() { return this.age$get() };



/*Swift.(file)._HashTable.Index.init(bucket:_HashTable.Bucket,age:Int32)*/
/*Swift.(file)._HashTable.Index.init(bucket:_HashTable.Bucket,age:Int32)*/
initBucket_HashTableBucketAgeInt32(bucket, age, $info?) {
throw 'unsupported method Swift.(file)._HashTable.Index.init(bucket:_HashTable.Bucket,age:Int32) in ' + this.constructor.name
}
static /*Swift.(file)._HashTable.Index.==infix(_:_HashTable.Index,_:_HashTable.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
preconditionFileLine(() => Int32.$equal(lhs.age, rhs.age), () => "Can't compare indices belonging to different collections", null, null);
return _HashTable.Bucket.$equal(lhs.bucket, rhs.bucket)
}
static /*Swift.(file)._HashTable.Index.<infix(_:_HashTable.Index,_:_HashTable.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
preconditionFileLine(() => Int32.$equal(lhs.age, rhs.age), () => "Can't compare indices belonging to different collections", null, null);
return _HashTable.Bucket.$lessThan(lhs.bucket, rhs.bucket)
}
init$vars() {let _this = this;

}
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true

/*Swift.(file)._HashTable.Iterator.hashTable*/
readonly hashTable$get() {
throw 'unsupported variable Swift.(file)._HashTable.Iterator.hashTable in ' + this.constructor.name
}
readonly get hashTable() { return this.hashTable$get() };




/*Swift.(file)._HashTable.Iterator.wordIndex*/
wordIndex$get() {
throw 'unsupported variable Swift.(file)._HashTable.Iterator.wordIndex in ' + this.constructor.name
}
get wordIndex() { return this.wordIndex$get() };






/*Swift.(file)._HashTable.Iterator.word*/
word$get() {
throw 'unsupported variable Swift.(file)._HashTable.Iterator.word in ' + this.constructor.name
}
get word() { return this.word$get() };





/*Swift.(file)._HashTable.Iterator.init(_:_HashTable)*/
/*Swift.(file)._HashTable.Iterator.init(_:_HashTable)*/
init_HashTable(hashTable, $info?) {
throw 'unsupported method Swift.(file)._HashTable.Iterator.init(_:_HashTable) in ' + this.constructor.name
}
/*Swift.(file)._HashTable.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file)._HashTable.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
/*Swift.(file)._HashTable.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(_HashTable.Iterator, 'init_HashTable', _this, {})
}

/*Swift.(file)._HashTable.isValid(_:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.isValid(_:_HashTable.Bucket)*/
isValid(bucket, $info?) {
let _this = this;
return Bool.$logicalAND(Int.$greaterThanOrEqual(bucket.offset, 0), () => Int.$lessThan(bucket.offset, _this.bucketCount))
}

/*Swift.(file)._HashTable.isOccupied(_:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.isOccupied(_:_HashTable.Bucket)*/
isOccupied(bucket, $info?) {
let _this = this;
return Bool.$logicalAND(_this.isValid(bucket), () => _this._isOccupied(bucket))
}
/*Swift.(file)._HashTable.checkOccupied(_:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.checkOccupied(_:_HashTable.Bucket)*/
checkOccupied(bucket, $info?) {
let _this = this;
preconditionFileLine(() => _this.isOccupied(bucket), () => "Attempting to access Collection elements using an invalid Index", null, null)
}

/*Swift.(file)._HashTable.occupiedBucket(after:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.occupiedBucket(after:_HashTable.Bucket)*/
occupiedBucketAfter(bucket, $info?) {
let _this = this;
const word = bucket.word;
const $ifLet0, bit_1
if((($ifLet0 = _this.words.subscript$get(word).intersectingElementsAbove(bucket.bit).minimum)||true) && $ifLet0.rawValue == 'some' && ((bit_1 = $ifLet0[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_1, {});
};
return _this._firstOccupiedBucketFromWord(Int.$add(word, 1))
}

/*Swift.(file)._HashTable.startBucket*/
startBucket$get() {
let _this = this;
return _this._firstOccupiedBucketFromWord(0)
}
get startBucket() { return this.startBucket$get() };




/*Swift.(file)._HashTable.endBucket*/
endBucket$get() {
let _this = this;
return _create(_HashTable.Bucket, 'initOffsetInt', _this.bucketCount, {})
}
get endBucket() { return this.endBucket$get() };



/*Swift.(file)._HashTable.idealBucket(forHashValue:Int)*/
/*Swift.(file)._HashTable.idealBucket(forHashValue:Int)*/
idealBucketForHashValue(hashValue, $info?) {
let _this = this;
return _create(_HashTable.Bucket, 'initOffsetInt', Int.$bitwiseAND(hashValue, _this.bucketMask), {})
}
/*Swift.(file)._HashTable.bucket(wrappedAfter:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.bucket(wrappedAfter:_HashTable.Bucket)*/
bucketWrappedAfter(bucket, $info?) {
let _this = this;
return _create(_HashTable.Bucket, 'initOffsetInt', Int.$bitwiseAND(Int.$addWithOverflow(bucket.offset, 1), _this.bucketMask), {})
}
/*Swift.(file)._HashTable.previousHole(before:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.previousHole(before:_HashTable.Bucket)*/
previousHoleBefore(bucket, $info?) {
let _this = this;
let word = bucket.word;
const $ifLet0, bit_1
if((($ifLet0 = _this.words.subscript$get(word).complement.intersectingElementsBelow(bucket.bit).maximum)||true) && $ifLet0.rawValue == 'some' && ((bit_1 = $ifLet0[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_1, {});
};
let wrap = false;
while(true){
if(!((true))) break
Int.$subtractAndAssign({get: () => word, set: $val => word = $val}, 1);
if((Int.$lessThan(word, 0))) {
preconditionFileLine(() => Bool.$not(wrap), () => "Hash table has no holes", null, null);
wrap = true;
word = Int.$subtract(_this.wordCount, 1);
};
const $ifLet2, bit_3
if((($ifLet2 = _this.words.subscript$get(word).complement.maximum)||true) && $ifLet2.rawValue == 'some' && ((bit_3 = $ifLet2[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_3, {});
};
}
}
/*Swift.(file)._HashTable.nextHole(atOrAfter:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.nextHole(atOrAfter:_HashTable.Bucket)*/
nextHoleAtOrAfter(bucket, $info?) {
let _this = this;
let word = bucket.word;
const $ifLet0, bit_1
if((($ifLet0 = _this.words.subscript$get(word).complement.subtractingElementsBelow(bucket.bit).minimum)||true) && $ifLet0.rawValue == 'some' && ((bit_1 = $ifLet0[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_1, {});
};
let wrap = false;
while(true){
if(!((true))) break
Int.infix_38_43_61({get: () => word, set: $val => word = $val}, 1);
if((Int.$equal(word, _this.wordCount))) {
preconditionFileLine(() => Bool.$not(wrap), () => "Hash table has no holes", null, null);
wrap = true;
word = 0;
};
const $ifLet2, bit_3
if((($ifLet2 = _this.words.subscript$get(word).complement.minimum)||true) && $ifLet2.rawValue == 'some' && ((bit_3 = $ifLet2[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_3, {});
};
}
}
/*Swift.(file)._HashTable.copyContents(of:_HashTable)*/
/*Swift.(file)._HashTable.copyContents(of:_HashTable)*/
copyContentsOf(other, $info?) {
let _this = this;
_this.words.assignFromCount(other.words, _this.wordCount)
}
/*Swift.(file)._HashTable.insertNew(hashValue:Int)*/
/*Swift.(file)._HashTable.insertNew(hashValue:Int)*/
insertNewHashValue(hashValue, $info?) {
let _this = this;
const hole = _cloneStruct(_this.nextHoleAtOrAfter(_this.idealBucketForHashValue(hashValue)));
_this.insert(hole);
return hole
}
/*Swift.(file)._HashTable.insert(_:_HashTable.Bucket)*/
/*Swift.(file)._HashTable.insert(_:_HashTable.Bucket)*/
insert(bucket, $info?) {
let _this = this;
_this.words.subscript$get(bucket.word).uncheckedInsert(bucket.bit, {$setThis: $val => _this.words.subscript$set($val, bucket.word, {$setThis: $val => _this.words = _cloneStruct($val)})})
}
/*Swift.(file)._HashTable.clear()*/
/*Swift.(file)._HashTable.clear()*/
clear($info?) {
let _this = this;
if((Int.$lessThan(_this.bucketCount, _HashTable.Word.capacity))) {
_this.words.subscript$set(_cloneStruct(_HashTable.Word.allBits.subtractingElementsBelow(_this.bucketCount)), 0, {$setThis: $val => _this.words = _cloneStruct($val)});
}
else {
_this.words.assignRepeatingCount(_HashTable.Word.empty, _this.wordCount);
}
}
/*Swift.(file)._HashTable.delete(at:_HashTable.Bucket,with:D)*/
/*Swift.(file)._HashTable.delete(at:_HashTable.Bucket,with:D)*/
deleteAtWith<D>(bucket, delegate, $info?) {
let _this = this;
let hole = _cloneStruct(bucket);
let candidate = _cloneStruct(_this.bucketWrappedAfter(hole));
if(!((_this._isOccupied(candidate)))) {
_this.words.subscript$get(hole.word).uncheckedRemove(hole.bit, {$setThis: $val => _this.words.subscript$set($val, hole.word, {$setThis: $val => _this.words = _cloneStruct($val)})});
return ;
};
const start = _cloneStruct(_this.bucketWrappedAfter(_this.previousHoleBefore(bucket)));
while(true){
if(!((_this._isOccupied(candidate)))) break
const candidateHash = delegate.hashValueAt(candidate);
const ideal = _cloneStruct(_this.idealBucketForHashValue(candidateHash));
const c0 = _HashTable.Bucket.$greaterThanOrEqual(ideal, start);
const c1 = _HashTable.Bucket.$lessThanOrEqual(ideal, hole);
if(((_HashTable.Bucket.$lessThanOrEqual(start, hole) ? Bool.$logicalAND(c0, () => c1) : Bool.$logicalOR(c0, () => c1)))) {
delegate.moveEntryFromTo(candidate, hole);
hole = _cloneStruct(candidate);
};
candidate = _cloneStruct(_this.bucketWrappedAfter(candidate));
};
_this.words.subscript$get(hole.word).uncheckedRemove(hole.bit, {$setThis: $val => _this.words.subscript$set($val, hole.word, {$setThis: $val => _this.words = _cloneStruct($val)})})
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(_HashTable.Bucket, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(_HashTable.Bucket, Comparable$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(_HashTable.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(_HashTable.Index, Comparable$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_HashTable.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_HashTable, Sequence$implementation, false)


















class JoinedSequence<Base> implements Sequence{
static readonly $struct = true











/*Swift.(file).JoinedSequence.init(base:Base,separator:Separator)*/
/*Swift.(file).JoinedSequence.init(base:Base,separator:Separator)*/
initBaseSeparator<Separator>(base, separator, $info?) {
let _this = this;
_this._base = base;
_this._separator = _create(ContiguousArray, 'initBuffer', separator, {});
return
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true




















static _JoinIteratorState = class{

static get start() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: "start", ...Array.from(arguments)})}

static get generatingElements() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: "generatingElements", ...Array.from(arguments)})}

static get generatingSeparator() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: "generatingSeparator", ...Array.from(arguments)})}

static get end() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: "end", ...Array.from(arguments)})}
static /*Swift.(file).JoinedSequence.Iterator._JoinIteratorState.==(_:JoinedSequence<Base>.Iterator._JoinIteratorState,_:JoinedSequence<Base>.Iterator._JoinIteratorState)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).JoinedSequence.Iterator._JoinIteratorState.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).JoinedSequence.Iterator._JoinIteratorState.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).JoinedSequence.Iterator._JoinIteratorState.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).JoinedSequence.Iterator._JoinIteratorState.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}





/*Swift.(file).JoinedSequence.Iterator.init(base:Base.Iterator,separator:Separator)*/
/*Swift.(file).JoinedSequence.Iterator.init(base:Base.Iterator,separator:Separator)*/
initBaseSeparator<Separator>(base, separator, $info?) {
let _this = this;
_this._base = base;
_this._separatorData = _create(ContiguousArray, 'initBuffer', separator, {});
return
}

/*Swift.(file).JoinedSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
while(true){
if(!((true))) break
const $match = _this._state
if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.start.rawValue))) {
const $ifLet0, nextSubSequence_1
if((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((nextSubSequence_1 = $ifLet0[0])||true)) {
_this._inner = _injectIntoOptional(nextSubSequence_1.makeIterator( {}));
_this._state = JoinedSequence.Iterator._JoinIteratorState.generatingElements;
}
else {
_this._state = JoinedSequence.Iterator._JoinIteratorState.end;
return _injectIntoOptional(null);
};
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.generatingElements.rawValue))) {
const result = _this._inner[0].next( {$setThis: $val => _this._inner[0] = $val});
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(result, _injectIntoOptional(null))))) {
return result;
};
_this._inner = _injectIntoOptional(((_.tmp0 = _this._base.next( {$setThis: $val => _this._base = $val})).rawValue === 'some') ? (_.tmp0[0].makeIterator( {})) : null);
if((Optional.wrappedEqualsOptionalNilComparisonType(_this._inner, _injectIntoOptional(null)))) {
_this._state = JoinedSequence.Iterator._JoinIteratorState.end;
return _injectIntoOptional(null);
};
if((Bool.$not(_this._separatorData.isEmpty))) {
_this._separator = _injectIntoOptional(_this._separatorData.makeIterator( {}));
_this._state = JoinedSequence.Iterator._JoinIteratorState.generatingSeparator;
};
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.generatingSeparator.rawValue))) {
const result = _this._separator[0].next( {$setThis: $val => _this._separator[0] = $val});
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(result, _injectIntoOptional(null))))) {
return result;
};
_this._state = JoinedSequence.Iterator._JoinIteratorState.generatingElements;
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.end.rawValue))) {
return _injectIntoOptional(null);
};
}
}
init$vars() {let _this = this;

}
}
/*Swift.(file).JoinedSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(JoinedSequence.Iterator, 'initBaseSeparator', _this._base.makeIterator( {}), _this._separator, {})
}

init$vars() {let _this = this;

}
}
_mixin(JoinedSequence.Iterator._JoinIteratorState, _DefaultEnumImplementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(JoinedSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(JoinedSequence, Sequence$implementation, false)






class AnyKeyPath implements Hashable, _AppendKeyPath{

/*Swift.(file).AnyKeyPath.rootType*/
static rootType$get() {
let _this = this;
return _this._rootAndValueType["0"];
}
static get rootType() { return this.rootType$get()
}
static get rootType() { return this.rootType$get() };




/*Swift.(file).AnyKeyPath.valueType*/
static valueType$get() {
let _this = this;
return _this._rootAndValueType["1"];
}
static get valueType() { return this.valueType$get()
}
static get valueType() { return this.valueType$get() };









/*Swift.(file).AnyKeyPath.hashValue*/
hashValue$get() {
let _this = this;
return _hashValueFor(_this)
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).AnyKeyPath.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
_create(ObjectIdentifier, 'initprotocol_composition_type', AnyKeyPath, {}).hashInto({get: () => hasher, set: $val => hasher = $val});
return _this.withBuffer((($0, $info?) => { 
let buffer = _cloneStruct($0);
if((buffer.data.isEmpty)) {
return ;
};
while(true){
if(!((true))) break
const $tuple = buffer.next( {$setThis: $val => buffer = $val}), component = $tuple && $tuple[0], type = $tuple && $tuple[1];
hasher.combine(component.value, {$setThis: $val => hasher = $val});
const $ifLet0, type_1
if((($ifLet0 = type)||true) && $ifLet0.rawValue == 'some' && ((type_1 = $ifLet0[0])||true)) {
hasher.combine(unsafeBitCastTo(type_1, Int), {$setThis: $val => hasher = $val});
}
else {
break;
};
}; }));})()
hasher$inout.set(hasher)
return $result
}
static /*Swift.(file).AnyKeyPath.==infix(_:AnyKeyPath,_:AnyKeyPath)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
let _this = this;
if(($identical(_injectIntoOptional(a), _injectIntoOptional(b)))) {
return true;
};
if(($notEqual(_injectIntoOptional(AnyKeyPath), _injectIntoOptional(AnyKeyPath)))) {
return false;
};
return a.withBuffer((($0, $info?) => { 
let aBuffer = _cloneStruct($0);
return b.withBuffer((($0, $info?) => { 
let bBuffer = _cloneStruct($0);
if((Bool.$notEqual(aBuffer.hasReferencePrefix, bBuffer.hasReferencePrefix))) {
return false;
};
if((aBuffer.data.isEmpty)) {
return bBuffer.data.isEmpty;
};
while(true){
if(!((true))) break
const $tuple = aBuffer.next( {$setThis: $val => aBuffer = $val}), aComponent = $tuple && $tuple[0], aType = $tuple && $tuple[1];
const $tuple = bBuffer.next( {$setThis: $val => bBuffer = $val}), bComponent = $tuple && $tuple[0], bType = $tuple && $tuple[1];
if((Bool.$logicalOR(Bool.$logicalOR(Bool.$notEqual(aComponent.header.endOfReferencePrefix, bComponent.header.endOfReferencePrefix), () => KeyPathComponent.$notEqual(aComponent.value, bComponent.value)), () => $notEqual(aType, bType)))) {
return false;
};
if(($equal(aType, _injectIntoOptional(null)))) {
return true;
};
}; })); }))
}



/*Swift.(file).AnyKeyPath.init()*/
/*Swift.(file).AnyKeyPath.init()*/
init($info?) {
throw 'unsupported method Swift.(file).AnyKeyPath.init() in ' + this.constructor.name
}




/*Swift.(file).AnyKeyPath.withBuffer(_:(KeyPathBuffer) throws -> T)*/
/*Swift.(file).AnyKeyPath.withBuffer(_:(KeyPathBuffer) throws -> T)*/
withBuffer<T>(f, $info?) {
throw 'unsupported method Swift.(file).AnyKeyPath.withBuffer(_:(KeyPathBuffer) throws -> T) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
if(typeof Hashable$implementation != 'undefined') _mixin(AnyKeyPath, Hashable$implementation, false)
if(typeof _AppendKeyPath$implementation != 'undefined') _mixin(AnyKeyPath, _AppendKeyPath$implementation, false)


class PartialKeyPath<Root> extends AnyKeyPath{
/*Swift.(file).PartialKeyPath.init()*/
/*Swift.(file).AnyKeyPath.init()*/
init($info?) {
throw 'unsupported method Swift.(file).PartialKeyPath.init() in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class KeyPath<Root, Value> extends PartialKeyPath{





/*Swift.(file).KeyPath.kind*/
static kind$get() {
let _this = this;
return KeyPath.Kind.readOnly;
}
static get kind() { return this.kind$get()
}
static get kind() { return this.kind$get() };



static /*Swift.(file).KeyPath.appendedType(with:KeyPath<Value, AppendedValue>.Type)*/
/*Swift.(file).KeyPath.appendedType(with:KeyPath<Value, AppendedValue>.Type)*/
appendedTypeWith<AppendedValue>(t, $info?) {
let _this = this;
const resultKind;
const $match = {0: _this.kind, 1: t.kind}
if((($match[1].rawValue == KeyPath.Kind.reference.rawValue))) {
resultKind = KeyPath.Kind.reference;
}
else if((($match[1].rawValue == KeyPath.Kind.value.rawValue))) {
const x = $match[0]
resultKind = x;
}
else if(((true))) {
resultKind = KeyPath.Kind.readOnly;
};
const $match = resultKind
if((($match.rawValue == KeyPath.Kind.readOnly.rawValue))) {
return KeyPath;
}
else if((($match.rawValue == KeyPath.Kind.value.rawValue))) {
return WritableKeyPath;
}
else if((($match.rawValue == KeyPath.Kind.reference.rawValue))) {
return ReferenceWritableKeyPath;
}
}


/*Swift.(file).KeyPath.init()*/
/*Swift.(file).AnyKeyPath.init()*/
init($info?) {
throw 'unsupported method Swift.(file).KeyPath.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class WritableKeyPath<Root, Value> extends KeyPath{

/*Swift.(file).WritableKeyPath.kind*/
static kind$get() {
let _this = this;
return KeyPath.Kind.readOnly;
}
static get kind() { return this.kind$get()
}
static get kind() { return this.kind$get() };




/*Swift.(file).WritableKeyPath.init()*/
/*Swift.(file).AnyKeyPath.init()*/
init($info?) {
throw 'unsupported method Swift.(file).WritableKeyPath.init() in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class ReferenceWritableKeyPath<Root, Value> extends WritableKeyPath{

/*Swift.(file).ReferenceWritableKeyPath.kind*/
static kind$get() {
let _this = this;
return KeyPath.Kind.readOnly;
}
static get kind() { return this.kind$get()
}
static get kind() { return this.kind$get() };





/*Swift.(file).ReferenceWritableKeyPath.init()*/
/*Swift.(file).AnyKeyPath.init()*/
init($info?) {
throw 'unsupported method Swift.(file).ReferenceWritableKeyPath.init() in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


interface LazySequenceProtocol<Elements> extends Sequence{




}
class LazySequenceProtocol$implementation{
/*Swift.(file).LazySequenceProtocol.drop(while:(Self.Elements.Element) -> Bool)*/
/*Swift.(file).LazySequenceProtocol.drop(while:(Self.Elements.Element) -> Bool)*/
dropWhile(predicate, $info?) {
let _this = this;
return _create(LazyDropWhileSequence, 'init_basePredicatefunction_type', _this._elements, predicate, {})
}
/*Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)*/
/*Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)*/
filterSwift(isIncluded, $info?) {
let _this = this;
return _create(LazyFilterSequence, 'init_basefunction_type', _this._elements, isIncluded, {})
}
/*Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)*/
/*Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)*/
flatMap<SegmentOfResult>(transform, $info?) {
let _this = this;
return _this.mapSwift(transform).joined( {})
}
/*Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)*/
/*Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)*/
compactMap<ElementOfResult>(transform, $info?) {
let _this = this;
return _this.mapSwift(transform).filterSwift((($0, $info?) => Optional.wrappedNotEqualsOptionalNilComparisonType($0, _injectIntoOptional(null)))).mapSwift((($0, $info?) => $0[0]))
}
/*Swift.(file).LazySequenceProtocol.joined()*/
/*Swift.(file).LazySequenceProtocol.joined()*/
joined($info?) {
let _this = this;
return _create(FlattenSequence, 'init_base', _this._elements, {}).lazy
}




/*Swift.(file).LazySequenceProtocol.lazy*/
lazy$get() {
let _this = this;
return _this._elements.lazy
}
get lazy() { return this.lazy$get() };




/*Swift.(file).LazySequenceProtocol.lazy*/
lazy$get() {
let _this = this;
return _this._elements.lazy
}
get lazy() { return this.lazy$get() };



/*Swift.(file).LazySequenceProtocol.map(_:(Self.Element) -> U)*/
/*Swift.(file).LazySequenceProtocol.map(_:(Self.Element) -> U)*/
mapSwift<U>(transform, $info?) {
let _this = this;
return _create(LazyMapSequence, 'init_baseTransformfunction_type', _this._elements, transform, {})
}
/*Swift.(file).LazySequenceProtocol.prefix(while:(Self.Elements.Element) -> Bool)*/
/*Swift.(file).LazySequenceProtocol.prefix(while:(Self.Elements.Element) -> Bool)*/
prefixWhile(predicate, $info?) {
let _this = this;
return _create(LazyPrefixWhileSequence, 'init_basePredicatefunction_type', _this._elements, predicate, {})
}
/*Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)*/
/*Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)*/
/*!!!DUPLICATE NAME*/
flatMap<ElementOfResult>(transform, $info?) {
let _this = this;
return _this.compactMap(transform)
}
}
if(typeof Sequence$implementation != 'undefined') _mixin(LazySequenceProtocol$implementation, Sequence$implementation, false)














interface MutableCollection<Element, Index, SubSequence> extends Collection{



/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?)/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, position, $info?)




/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?)/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(newValue, bounds, $info?)



/*Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)*/
/*Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)*/
partitionBy(belongsInSecondPartition, $info?)
/*Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)*/
/*Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)*/
swapAt(i, j, $info?)

/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withContiguousMutableStorageIfAvailable<R>(body, $info?)
}
class MutableCollection$implementation{
/*Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)*/
/*Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)*/
partitionBy(belongsInSecondPartition, $info?) {
let _this = this;
return _this._halfStablePartitionIsSuffixElement(belongsInSecondPartition, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}

/*Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)*/
/*Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)*/
partitionBy(belongsInSecondPartition, $info?) {
let _this = this;
return _this._halfStablePartitionIsSuffixElement(belongsInSecondPartition, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}

/*Swift.(file).MutableCollection.shuffle(using:T)*/
/*Swift.(file).MutableCollection.shuffle(using:T)*/
shuffleUsing<T>(generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
if(!((Int.$greaterThan(_this.count, 1)))) {
return ;
};
let amount = _this.count;
let currentIndex = _this.startIndex;
while(true){
if(!((Int.$greaterThan(amount, 1)))) break
const random = Int.randomInUsing(Int.$halfOpenRange(0, amount), {get: () => generator, set: $val => generator = $val});
Int.$subtractAndAssign({get: () => amount, set: $val => amount = $val}, 1);
_this.swapAt(currentIndex, _this.indexOffsetBy(currentIndex, random), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.formIndexAfter({get: () => currentIndex, set: $val => currentIndex = $val});
};})()
generator$inout.set(generator)
return $result
}
/*Swift.(file).MutableCollection.shuffle()*/
/*Swift.(file).MutableCollection.shuffle()*/
shuffle($info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
_this.shuffleUsing({get: () => g, set: $val => g = $val}, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}

/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withContiguousMutableStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(null)
}
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*!!!DUPLICATE NAME*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*!!!DUPLICATE NAME*/
subscriptRange$set(newValue, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}



/*Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)*/
/*Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)*/
swapAt(i, j, $info?) {
let _this = this;
if(!(((_.arg0 = i).constructor.$notEqual(_.arg0, j)))) {
return ;
};
const tmp = _this.subscript$get(i);
_this.subscript$set(_this.subscript$get(j), i, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.subscript$set(tmp, j, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).MutableCollection.subscript(_:R)*/
/*Swift.(file).MutableCollection.subscript(_:R)*/
/*!!!DUPLICATE NAME*/
subscriptRange$get<R>(r, $info?) {
let _this = this;
return _this.subscriptRange$get(r.relativeTo(_this));

}/*Swift.(file).MutableCollection.subscript(_:R)*/
/*Swift.(file).MutableCollection.subscript(_:R)*/
/*!!!DUPLICATE NAME*/
subscriptRange$set<R>(newValue, r, $info?) {
let _this = this;
_this.subscriptRange$set(newValue, r.relativeTo(_this), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}



/*Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())*/
/*Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())*/
subscriptUnboundedRange$get(x, $info?) {
let _this = this;
return _this.subscriptRange$get(((function(){throw '!unclarifiedGeneric:Self.Index'})()).$openEndedRange(_this.startIndex));

}/*Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())*/
/*Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())*/
subscriptUnboundedRange$set(newValue, x, $info?) {
let _this = this;
_this.subscriptRange$set(newValue, ((function(){throw '!unclarifiedGeneric:Self.Index'})()).$openEndedRange(_this.startIndex), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}



/*Swift.(file).MutableCollection.reverse()*/
/*Swift.(file).MutableCollection.reverse()*/
reverse($info?) {
let _this = this;
if((_this.isEmpty)) {
return ;
};
let f = _this.startIndex;
let l = _this.indexBefore(_this.endIndex);
while(true){
if(!(((_.arg0 = f).constructor.$lessThan(_.arg0, l)))) break
_this.swapAt(f, l, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.formIndexAfter({get: () => f, set: $val => f = $val});
_this.formIndexBefore({get: () => l, set: $val => l = $val});
}
}
/*Swift.(file).MutableCollection.sort()*/
/*Swift.(file).MutableCollection.sort()*/
sortSwift($info?) {
let _this = this;
_this.sortBy(this.first[0].constructor.$lessThan, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)*/
/*Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)*/
sortBy(areInIncreasingOrder, $info?) {
//TODO move to swift
return this.sort((a, b) => areInIncreasingOrder(a, b, {}) ? -1 : 1)
}



}
if(typeof Collection$implementation != 'undefined') _mixin(MutableCollection$implementation, Collection$implementation, false)














class _NativeDictionary<Key, Value> implements _DictionaryBuffer, _HashTableDelegate, Sequence{
static readonly $struct = true






/*Swift.(file)._NativeDictionary.init()*/
/*Swift.(file)._NativeDictionary.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.init() in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.init(_:__RawDictionaryStorage)*/
/*Swift.(file)._NativeDictionary.init(_:__RawDictionaryStorage)*/
init__RawDictionaryStorage(storage, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.init(_:__RawDictionaryStorage) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.init(capacity:Int)*/
/*Swift.(file)._NativeDictionary.init(capacity:Int)*/
initCapacityInt(capacity, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.init(capacity:Int) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.init(_:__CocoaDictionary)*/
/*Swift.(file)._NativeDictionary.init(_:__CocoaDictionary)*/
init__CocoaDictionary(cocoa, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.init(_:__CocoaDictionary) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.init(_:__CocoaDictionary,capacity:Int)*/
/*Swift.(file)._NativeDictionary.init(_:__CocoaDictionary,capacity:Int)*/
init__CocoaDictionaryCapacityInt(cocoa, capacity, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.init(_:__CocoaDictionary,capacity:Int) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.bridged()*/
/*Swift.(file)._NativeDictionary.bridged()*/
bridged($info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.bridged() in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>) -> Int)*/
/*Swift.(file)._NativeDictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>) -> Int)*/
init_unsafeUninitializedCapacityIntAllowingDuplicatesBoolInitializingWithfunction_type(capacity, allowingDuplicates, initializer, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>) -> Int) in ' + this.constructor.name
}


/*Swift.(file)._NativeDictionary.capacity*/
capacity$get() {
let _this = this;
return _assumeNonNegative(_this._storage._capacity)
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._NativeDictionary.hashTable*/
hashTable$get() {
let _this = this;
return _this._storage._hashTable
}
get hashTable() { return this.hashTable$get() };




/*Swift.(file)._NativeDictionary.age*/
age$get() {
let _this = this;
return _this._storage._age
}
get age() { return this.age$get() };









/*Swift.(file)._NativeDictionary.invalidateIndices()*/
/*Swift.(file)._NativeDictionary.invalidateIndices()*/
invalidateIndices($info?) {
let _this = this;
Int32.infix_38_43_61({get: () => _this._storage._age, set: $val => _this._storage._age = $val}, 1)
}
/*Swift.(file)._NativeDictionary.uncheckedKey(at:_NativeDictionary<Key, Value>.Bucket)*/
/*Swift.(file)._NativeDictionary.uncheckedKey(at:_NativeDictionary<Key, Value>.Bucket)*/
uncheckedKeyAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.uncheckedKey(at:_NativeDictionary<Key, Value>.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.uncheckedValue(at:_NativeDictionary<Key, Value>.Bucket)*/
/*Swift.(file)._NativeDictionary.uncheckedValue(at:_NativeDictionary<Key, Value>.Bucket)*/
uncheckedValueAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.uncheckedValue(at:_NativeDictionary<Key, Value>.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.uncheckedInitialize(at:_NativeDictionary<Key, Value>.Bucket,toKey:Key,value:Value)*/
/*Swift.(file)._NativeDictionary.uncheckedInitialize(at:_NativeDictionary<Key, Value>.Bucket,toKey:Key,value:Value)*/
uncheckedInitializeAtToKeyValue(bucket, key, value, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.uncheckedInitialize(at:_NativeDictionary<Key, Value>.Bucket,toKey:Key,value:Value) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.uncheckedDestroy(at:_NativeDictionary<Key, Value>.Bucket)*/
/*Swift.(file)._NativeDictionary.uncheckedDestroy(at:_NativeDictionary<Key, Value>.Bucket)*/
uncheckedDestroyAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.uncheckedDestroy(at:_NativeDictionary<Key, Value>.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.hashValue(for:Key)*/
/*Swift.(file)._NativeDictionary.hashValue(for:Key)*/
hashValueFor(key, $info?) {
let _this = this;
return key._rawHashValueSeed(_this._storage._seed)
}
/*Swift.(file)._NativeDictionary.find(_:Key)*/
/*Swift.(file)._NativeDictionary.find(_:Key)*/
find(key, $info?) {
let _this = this;
return _this.findHashValue(key, _this.hashValueFor(key))
}
/*Swift.(file)._NativeDictionary.find(_:Key,hashValue:Int)*/
/*Swift.(file)._NativeDictionary.find(_:Key,hashValue:Int)*/
findHashValue(key, hashValue, $info?) {
let _this = this;
const hashTable = _cloneStruct(_this.hashTable);
let bucket = _cloneStruct(hashTable.idealBucketForHashValue(hashValue));
while(true){
if(!((hashTable._isOccupied(bucket)))) break
if(((_.arg0 = _this.uncheckedKeyAt(bucket)).constructor.$equal(_.arg0, key))) {
return {0: bucket, 1: true};
};
bucket = _cloneStruct(hashTable.bucketWrappedAfter(bucket));
};
return {0: bucket, 1: false}
}
/*Swift.(file)._NativeDictionary.resize(capacity:Int)*/
/*Swift.(file)._NativeDictionary.resize(capacity:Int)*/
resizeCapacity(capacity, $info?) {
let _this = this;
const capacity = max(capacity, _this.capacity);
const newStorage = _DictionaryStorage.resizeOriginalCapacityMove(_this._storage, capacity, true);
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', newStorage, {});
if((Int.$greaterThan(_this.count, 0))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = UnsafeMutablePointer.$add(_this._keys, bucket_1.offset).move( {});
const value = UnsafeMutablePointer.$add(_this._values, bucket_1.offset).move( {});
result._unsafeInsertNewKeyValue(key, value);
}
};
_this._storage._hashTable.clear( {});
_this._storage._count = 0;
};
_this._storage = result._storage
}
/*Swift.(file)._NativeDictionary.copyAndResize(capacity:Int)*/
/*Swift.(file)._NativeDictionary.copyAndResize(capacity:Int)*/
copyAndResizeCapacity(capacity, $info?) {
let _this = this;
const capacity = max(capacity, _this.capacity);
const newStorage = _DictionaryStorage.resizeOriginalCapacityMove(_this._storage, capacity, false);
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', newStorage, {});
if((Int.$greaterThan(_this.count, 0))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
result._unsafeInsertNewKeyValue(_this.uncheckedKeyAt(bucket_1), _this.uncheckedValueAt(bucket_1));
}
};
};
_this._storage = result._storage
}
/*Swift.(file)._NativeDictionary.copy()*/
/*Swift.(file)._NativeDictionary.copy()*/
copy($info?) {
let _this = this;
const newStorage = _DictionaryStorage.copyOriginal(_this._storage);
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', newStorage, {});
if((Int.$greaterThan(_this.count, 0))) {
result.hashTable.copyContentsOf(_this.hashTable);
result._storage._count = _this.count;
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = _this.uncheckedKeyAt(bucket_1);
const value = _this.uncheckedValueAt(bucket_1);
result.uncheckedInitializeAtToKeyValue(bucket_1, key, value);
}
};
};
_this._storage = result._storage
}
/*Swift.(file)._NativeDictionary.ensureUnique(isUnique:Bool,capacity:Int)*/
/*Swift.(file)._NativeDictionary.ensureUnique(isUnique:Bool,capacity:Int)*/
ensureUniqueIsUniqueCapacity(isUnique, capacity, $info?) {
let _this = this;
if((_fastPath(Bool.$logicalAND(Int.$lessThanOrEqual(capacity, _this.capacity), () => isUnique)))) {
return false;
};
if((isUnique)) {
_this.resizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true;
};
if((Int.$lessThanOrEqual(capacity, _this.capacity))) {
_this.copy( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return false;
};
_this.copyAndResizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true
}
/*Swift.(file)._NativeDictionary.reserveCapacity(_:Int,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.reserveCapacity(_:Int,isUnique:Bool)*/
reserveCapacityIsUnique(capacity, isUnique, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.reserveCapacity(_:Int,isUnique:Bool) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.validatedBucket(for:_HashTable.Index)*/
/*Swift.(file)._NativeDictionary.validatedBucket(for:_HashTable.Index)*/
validatedBucketFor(index, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.validatedBucket(for:_HashTable.Index) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.validatedBucket(for:Dictionary<Key, Value>.Index)*/
/*Swift.(file)._NativeDictionary.validatedBucket(for:Dictionary<Key, Value>.Index)*/
/*!!!DUPLICATE NAME*/
validatedBucketFor(index, $info?) {
let _this = this;
if(!((index._isNative))) {
index._cocoaPath( {});
const cocoa = _cloneStruct(index._asCocoa);
if((Int32.$equal(cocoa.age, _this.age))) {
const key = _forceBridgeFromObjectiveC(cocoa.key, ((function(){throw '!unclarifiedGeneric:Key'})()));
const $tuple = _this.find(key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
return bucket;
};
};
preconditionFailureFileLine(() => "Attempting to access Dictionary elements using an invalid index", null, null);
};
return _this.validatedBucketFor(index._asNative)
}


/*Swift.(file)._NativeDictionary.startIndex*/
startIndex$get() {
let _this = this;
const bucket = _cloneStruct(_this.hashTable.startBucket);
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._NativeDictionary.endIndex*/
endIndex$get() {
let _this = this;
const bucket = _cloneStruct(_this.hashTable.endBucket);
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._NativeDictionary.index(after:_NativeDictionary<Key, Value>.Index)*/
/*Swift.(file)._DictionaryBuffer.index(after:Self.Index)*/
indexAfter(index, $info?) {
let _this = this;
if(!((_fastPath(index._isNative)))) {
 const _ = _cloneStruct(_this.validatedBucketFor(index));
const i = _cloneStruct(index._asCocoa);
return _create(_NativeDictionary.Index, 'init_cocoa__CocoaDictionaryIndex', i.dictionary.indexAfter(i), {});
};
const bucket = _cloneStruct(_this.validatedBucketFor(index._asNative));
const next = _cloneStruct(_this.hashTable.occupiedBucketAfter(bucket));
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', next, _this.age, {}), {})
}
/*Swift.(file)._NativeDictionary.index(forKey:Key)*/
/*Swift.(file)._DictionaryBuffer.index(forKey:Self.Key)*/
indexForKey(key, $info?) {
let _this = this;
if((Int.$equal(_this.count, 0))) {
return _injectIntoOptional(null);
};
const $tuple = _this.find(key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {}))
}

/*Swift.(file)._NativeDictionary.count*/
count$get() {
let _this = this;
return _assumeNonNegative(_this._storage._count)
}
get count() { return this.count$get() };



/*Swift.(file)._NativeDictionary.contains(_:Key)*/
/*Swift.(file)._DictionaryBuffer.contains(_:Self.Key)*/
contains(key, $info?) {
let _this = this;
return _this.find(key)["1"]
}
/*Swift.(file)._NativeDictionary.lookup(_:Key)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Key)*/
lookup(key, $info?) {
let _this = this;
if((Int.$equal(_this.count, 0))) {
return _injectIntoOptional(null);
};
const $tuple = _this.find(key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.uncheckedValueAt(bucket))
}
/*Swift.(file)._NativeDictionary.lookup(_:_NativeDictionary<Key, Value>.Index)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Index)*/
/*!!!DUPLICATE NAME*/
lookup(index, $info?) {
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index));
const key = _this.uncheckedKeyAt(bucket);
const value = _this.uncheckedValueAt(bucket);
return {0: key, 1: value}
}
/*Swift.(file)._NativeDictionary.key(at:_NativeDictionary<Key, Value>.Index)*/
/*Swift.(file)._DictionaryBuffer.key(at:Self.Index)*/
keyAt(index, $info?) {
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index));
return _this.uncheckedKeyAt(bucket)
}
/*Swift.(file)._NativeDictionary.value(at:_NativeDictionary<Key, Value>.Index)*/
/*Swift.(file)._DictionaryBuffer.value(at:Self.Index)*/
valueAt(index, $info?) {
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index));
return _this.uncheckedValueAt(bucket)
}


/*Swift.(file)._NativeDictionary.subscript(_:Key,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.subscript(_:Key,isUnique:Bool)*/
subscriptIsUnique$get(key, isUnique, $info?) {
let _this = this;
return _this.lookup(key);
}subscriptIsUnique$_modify(key, isUnique, $info?){
let _this = this;
const $tuple = _this.mutatingFindIsUnique(key, isUnique, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
let value = _injectIntoOptional(UnsafeMutablePointer.$add(_this._values, bucket.offset).move( {}));
let $defer = () => {
const $ifLet0, value_1
if((($ifLet0 = value)||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true)) {
UnsafeMutablePointer.$add(_this._values, bucket.offset).initializeTo(value_1);
}
else {
UnsafeMutablePointer.$add(_this._keys, bucket.offset).deinitializeCount(1);
_this._deleteAt(bucket);
};
}
const $result = (() => {
try {;
/*yield*/;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
}
else {
let value = _injectIntoOptional(null);
let $defer = () => {
const $ifLet2, value_3
if((($ifLet2 = value)||true) && $ifLet2.rawValue == 'some' && ((value_3 = $ifLet2[0])||true)) {
_this._insertAtKeyValue(bucket, key, value_3);
};
}
const $result = (() => {
try {;
/*yield*/;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
}
}/*Swift.(file)._NativeDictionary.subscript(_:Key,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.subscript(_:Key,isUnique:Bool)*/
subscriptIsUnique$_modify(key, isUnique, $info?) {
let _this = this;
return _this.lookup(key);
}subscriptIsUnique$_modify(key, isUnique, $info?){
let _this = this;
const $tuple = _this.mutatingFindIsUnique(key, isUnique, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
let value = _injectIntoOptional(UnsafeMutablePointer.$add(_this._values, bucket.offset).move( {}));
let $defer = () => {
const $ifLet0, value_1
if((($ifLet0 = value)||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true)) {
UnsafeMutablePointer.$add(_this._values, bucket.offset).initializeTo(value_1);
}
else {
UnsafeMutablePointer.$add(_this._keys, bucket.offset).deinitializeCount(1);
_this._deleteAt(bucket);
};
}
const $result = (() => {
try {;
/*yield*/;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
}
else {
let value = _injectIntoOptional(null);
let $defer = () => {
const $ifLet2, value_3
if((($ifLet2 = value)||true) && $ifLet2.rawValue == 'some' && ((value_3 = $ifLet2[0])||true)) {
_this._insertAtKeyValue(bucket, key, value_3);
};
}
const $result = (() => {
try {;
/*yield*/;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
}
}





/*Swift.(file)._NativeDictionary.insertNew(key:Key,value:Value)*/
/*Swift.(file)._NativeDictionary.insertNew(key:Key,value:Value)*/
insertNewKeyValue(key, value, $info?) {
let _this = this;
_.discardAssignment = _this.ensureUniqueIsUniqueCapacity(true, Int.$add(_this.count, 1), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this._unsafeInsertNewKeyValue(key, value)
}
/*Swift.(file)._NativeDictionary.mutatingFind(_:Key,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.mutatingFind(_:Key,isUnique:Bool)*/
mutatingFindIsUnique(key, isUnique, $info?) {
let _this = this;
const $tuple = _this.find(key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, Int.$add(_this.count, (found ? 0 : 1)), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
if(!((rehashed))) {
return {0: bucket, 1: found};
};
const $tuple = _this.find(key), b = $tuple && $tuple[0], f = $tuple && $tuple[1];
if((Bool.$notEqual(f, found))) {
KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(((function(){throw '!unclarifiedGeneric:Key'})()));
};
return {0: b, 1: found}
}

/*Swift.(file)._NativeDictionary.updateValue(_:Value,forKey:Key,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.updateValue(_:Value,forKey:Key,isUnique:Bool)*/
updateValueForKeyIsUnique(value, key, isUnique, $info?) {
let _this = this;
const $tuple = _this.mutatingFindIsUnique(key, isUnique, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
const oldValue = UnsafeMutablePointer.$add(_this._values, bucket.offset).move( {});
UnsafeMutablePointer.$add(_this._values, bucket.offset).initializeTo(value);
return _injectIntoOptional(oldValue);
};
_this._insertAtKeyValue(bucket, key, value);
return _injectIntoOptional(null)
}
/*Swift.(file)._NativeDictionary.setValue(_:Value,forKey:Key,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.setValue(_:Value,forKey:Key,isUnique:Bool)*/
setValueForKeyIsUnique(value, key, isUnique, $info?) {
let _this = this;
const $tuple = _this.mutatingFindIsUnique(key, isUnique, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
UnsafeMutablePointer.$add(_this._values, bucket.offset).pointee = value;
}
else {
_this._insertAtKeyValue(bucket, key, value);
}
}
/*Swift.(file)._NativeDictionary.swapValuesAt(_:_NativeDictionary<Key, Value>.Bucket,_:_NativeDictionary<Key, Value>.Bucket,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.swapValuesAt(_:_NativeDictionary<Key, Value>.Bucket,_:_NativeDictionary<Key, Value>.Bucket,isUnique:Bool)*/
swapValuesAtIsUnique(a, b, isUnique, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.swapValuesAt(_:_NativeDictionary<Key, Value>.Bucket,_:_NativeDictionary<Key, Value>.Bucket,isUnique:Bool) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.isEqual(to:_NativeDictionary<Key, Value>)*/
/*Swift.(file)._NativeDictionary.isEqual(to:_NativeDictionary<Key, Value>)*/
isEqualTo(other, $info?) {
let _this = this;
if(($identical(_injectIntoOptional(_this._storage), _injectIntoOptional(other._storage)))) {
return true;
};
if((Int.$notEqual(_this.count, other.count))) {
return false;
};
{
let $generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, key_1, value_2;
if(!((($ifLet0 = _injectIntoOptional(((_.tmp0 = $generator.next( {$setThis: $val => $generator = $val})).rawValue === 'some') ? (_.tmp0[0]) : null))||true) && $ifLet0.rawValue == 'some' && ((key_1 = $ifLet0[0][0])||true) && ((value_2 = $ifLet0[0][1])||true))) break
const $tuple = other.find(key_1), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found) && ((_.arg0 = other.uncheckedValueAt(bucket)).constructor.$equal(_.arg0, value_2)))) {
return false;
};
}
};
return true
}
/*Swift.(file)._NativeDictionary.isEqual(to:__CocoaDictionary)*/
/*Swift.(file)._NativeDictionary.isEqual(to:__CocoaDictionary)*/
/*!!!DUPLICATE NAME*/
isEqualTo(other, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.isEqual(to:__CocoaDictionary) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.hashValue(at:_NativeDictionary<Key, Value>.Bucket)*/
/*Swift.(file)._HashTableDelegate.hashValue(at:_HashTable.Bucket)*/
hashValueAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.hashValue(at:_NativeDictionary<Key, Value>.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.moveEntry(from:_NativeDictionary<Key, Value>.Bucket,to:_NativeDictionary<Key, Value>.Bucket)*/
/*Swift.(file)._HashTableDelegate.moveEntry(from:_HashTable.Bucket,to:_HashTable.Bucket)*/
moveEntryFromTo(source, target, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.moveEntry(from:_NativeDictionary<Key, Value>.Bucket,to:_NativeDictionary<Key, Value>.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.swapEntry(_:_NativeDictionary<Key, Value>.Bucket,with:_NativeDictionary<Key, Value>.Bucket)*/
/*Swift.(file)._NativeDictionary.swapEntry(_:_NativeDictionary<Key, Value>.Bucket,with:_NativeDictionary<Key, Value>.Bucket)*/
swapEntryWith(left, right, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.swapEntry(_:_NativeDictionary<Key, Value>.Bucket,with:_NativeDictionary<Key, Value>.Bucket) in ' + this.constructor.name
}

/*Swift.(file)._NativeDictionary.uncheckedRemove(at:_NativeDictionary<Key, Value>.Bucket,isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.uncheckedRemove(at:_NativeDictionary<Key, Value>.Bucket,isUnique:Bool)*/
uncheckedRemoveAtIsUnique(bucket, isUnique, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.uncheckedRemove(at:_NativeDictionary<Key, Value>.Bucket,isUnique:Bool) in ' + this.constructor.name
}
/*Swift.(file)._NativeDictionary.removeAll(isUnique:Bool)*/
/*Swift.(file)._NativeDictionary.removeAll(isUnique:Bool)*/
removeAllIsUnique(isUnique, $info?) {
let _this = this;
if(!((isUnique))) {
const scale = _this._storage._scale;
_this._storage = _DictionaryStorage.allocateScaleAgeSeed(scale, _injectIntoOptional(null), _injectIntoOptional(null));
return ;
};
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
UnsafeMutablePointer.$add(_this._keys, bucket_1.offset).deinitializeCount(1);
UnsafeMutablePointer.$add(_this._values, bucket_1.offset).deinitializeCount(1);
}
};
_this.hashTable.clear( {});
_this._storage._count = 0;
_this.invalidateIndices( {})
}
/*Swift.(file)._NativeDictionary.mapValues(_:(Value) throws -> T)*/
/*Swift.(file)._NativeDictionary.mapValues(_:(Value) throws -> T)*/
mapValues<T>(transform, $info?) {
let _this = this;
const resultStorage = _DictionaryStorage.copyOriginal(_this._storage);
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', resultStorage, {});
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = _this.uncheckedKeyAt(bucket_1);
const value = _this.uncheckedValueAt(bucket_1);
result._insertAtKeyValue(bucket_1, key, transform(value));
}
};
return result
}
/*Swift.(file)._NativeDictionary.merge(_:S,isUnique:Bool,uniquingKeysWith:(Value, Value) throws -> Value)*/
/*Swift.(file)._NativeDictionary.merge(_:S,isUnique:Bool,uniquingKeysWith:(Value, Value) throws -> Value)*/
mergeIsUniqueUniquingKeysWith<S>(keysAndValues, isUnique, combine, $info?) {
let _this = this;
let isUnique_dupl = isUnique;
{
let $generator = keysAndValues.makeIterator( {});
while(true) {
const $ifLet0, key_1, value_2;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((key_1 = $ifLet0[0][0])||true) && ((value_2 = $ifLet0[0][1])||true))) break
const $tuple = _this.mutatingFindIsUnique(key_1, isUnique_dupl, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
isUnique_dupl = true;
if((found)) {
try {
const newValue = combine(_this.uncheckedValueAt(bucket), value_2);
_this._values.subscript$set(newValue, bucket.offset, {$setThis: $val => _this._values = _cloneStruct($val)});
} catch(error) {
if((error instanceof _MergeError && error.rawValue == _MergeError.keyCollision.rawValue)) {
fatalErrorFileLine(() => (("Duplicate values for key: '") + (key_1) + ("'")), null, null);
}
else throw error
};
}
else {
_this._insertAtKeyValue(bucket, key_1, value_2);
};
}
}
}
/*Swift.(file)._NativeDictionary.init(grouping:S,by:(S.Element) throws -> Key)*/
/*Swift.(file)._NativeDictionary.init(grouping:S,by:(S.Element) throws -> Key)*/
initGroupingByfunction_type<S>(values, keyForValue, $info?) {
let _this = this;
_this.init( {});
{
let $value$generator = values.makeIterator( {});
while(true) {
const $ifLet0, value_1;
if(!((($ifLet0 = $value$generator.next( {$setThis: $val => $value$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) break
const key = keyForValue(value_1);
const $tuple = _this.mutatingFindIsUnique(key, true, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
_this._values.subscript$get(bucket.offset).append(value_1, {$setThis: $val => _this._values.subscript$set($val, bucket.offset, {$setThis: $val => _this._values = _cloneStruct($val)})});
}
else {
_this._insertAtKeyValue(bucket, key, _create(Array, 'initArrayLiteralArray', [value_1], {}));
};
}
};
return
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true

/*Swift.(file)._NativeDictionary.Iterator.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file)._NativeDictionary.Iterator.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };




/*Swift.(file)._NativeDictionary.Iterator.iterator*/
iterator$get() {
throw 'unsupported variable Swift.(file)._NativeDictionary.Iterator.iterator in ' + this.constructor.name
}
get iterator() { return this.iterator$get() };





/*Swift.(file)._NativeDictionary.Iterator.init(_:_NativeDictionary<Key, Value>)*/
/*Swift.(file)._NativeDictionary.Iterator.init(_:_NativeDictionary<Key, Value>)*/
init_NativeDictionary(base, $info?) {
throw 'unsupported method Swift.(file)._NativeDictionary.Iterator.init(_:_NativeDictionary<Key, Value>) in ' + this.constructor.name
}

/*Swift.(file)._NativeDictionary.Iterator.nextKey()*/
/*Swift.(file)._NativeDictionary.Iterator.nextKey()*/
nextKey($info?) {
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.base.uncheckedKeyAt(index_1))
}
/*Swift.(file)._NativeDictionary.Iterator.nextValue()*/
/*Swift.(file)._NativeDictionary.Iterator.nextValue()*/
nextValue($info?) {
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.base.uncheckedValueAt(index_1))
}
/*Swift.(file)._NativeDictionary.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
const key = _this.base.uncheckedKeyAt(index_1);
const value = _this.base.uncheckedValueAt(index_1);
return _injectIntoOptional({0: key, 1: value})
}
init$vars() {let _this = this;

}
}
/*Swift.(file)._NativeDictionary.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(_NativeDictionary.Iterator, 'init_NativeDictionary', _this, {})
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_NativeDictionary.Iterator, IteratorProtocol$implementation, false)
if(typeof _DictionaryBuffer$implementation != 'undefined') _mixin(_NativeDictionary, _DictionaryBuffer$implementation, false)
if(typeof _HashTableDelegate$implementation != 'undefined') _mixin(_NativeDictionary, _HashTableDelegate$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_NativeDictionary, Sequence$implementation, false)






























class _NativeSet<Element> implements _SetBuffer, _HashTableDelegate, Sequence{
static readonly $struct = true





/*Swift.(file)._NativeSet.init()*/
/*Swift.(file)._NativeSet.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._NativeSet.init() in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.init(_:__RawSetStorage)*/
/*Swift.(file)._NativeSet.init(_:__RawSetStorage)*/
init__RawSetStorage(storage, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.init(_:__RawSetStorage) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.init(capacity:Int)*/
/*Swift.(file)._NativeSet.init(capacity:Int)*/
initCapacityInt(capacity, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.init(capacity:Int) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.init(_:__CocoaSet)*/
/*Swift.(file)._NativeSet.init(_:__CocoaSet)*/
init__CocoaSet(cocoa, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.init(_:__CocoaSet) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.init(_:__CocoaSet,capacity:Int)*/
/*Swift.(file)._NativeSet.init(_:__CocoaSet,capacity:Int)*/
init__CocoaSetCapacityInt(cocoa, capacity, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.init(_:__CocoaSet,capacity:Int) in ' + this.constructor.name
}


/*Swift.(file)._NativeSet.capacity*/
capacity$get() {
let _this = this;
return _assumeNonNegative(_this._storage._capacity)
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._NativeSet.hashTable*/
hashTable$get() {
let _this = this;
return _this._storage._hashTable
}
get hashTable() { return this.hashTable$get() };




/*Swift.(file)._NativeSet.age*/
age$get() {
let _this = this;
return _this._storage._age
}
get age() { return this.age$get() };






/*Swift.(file)._NativeSet.invalidateIndices()*/
/*Swift.(file)._NativeSet.invalidateIndices()*/
invalidateIndices($info?) {
let _this = this;
Int32.infix_38_43_61({get: () => _this._storage._age, set: $val => _this._storage._age = $val}, 1)
}
/*Swift.(file)._NativeSet.uncheckedElement(at:_NativeSet<Element>.Bucket)*/
/*Swift.(file)._NativeSet.uncheckedElement(at:_NativeSet<Element>.Bucket)*/
uncheckedElementAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.uncheckedElement(at:_NativeSet<Element>.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.uncheckedInitialize(at:_NativeSet<Element>.Bucket,to:Element)*/
/*Swift.(file)._NativeSet.uncheckedInitialize(at:_NativeSet<Element>.Bucket,to:Element)*/
uncheckedInitializeAtTo(bucket, _element, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.uncheckedInitialize(at:_NativeSet<Element>.Bucket,to:Element) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.uncheckedAssign(at:_NativeSet<Element>.Bucket,to:Element)*/
/*Swift.(file)._NativeSet.uncheckedAssign(at:_NativeSet<Element>.Bucket,to:Element)*/
uncheckedAssignAtTo(bucket, _element, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.uncheckedAssign(at:_NativeSet<Element>.Bucket,to:Element) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.hashValue(for:Element)*/
/*Swift.(file)._NativeSet.hashValue(for:Element)*/
hashValueFor(_element, $info?) {
let _this = this;
return _element._rawHashValueSeed(_this._storage._seed)
}
/*Swift.(file)._NativeSet.find(_:Element)*/
/*Swift.(file)._NativeSet.find(_:Element)*/
find(_element, $info?) {
let _this = this;
return _this.findHashValue(_element, _this.hashValueFor(_element))
}
/*Swift.(file)._NativeSet.find(_:Element,hashValue:Int)*/
/*Swift.(file)._NativeSet.find(_:Element,hashValue:Int)*/
findHashValue(_element, hashValue, $info?) {
let _this = this;
const hashTable = _cloneStruct(_this.hashTable);
let bucket = _cloneStruct(hashTable.idealBucketForHashValue(hashValue));
while(true){
if(!((hashTable._isOccupied(bucket)))) break
if(((_.arg0 = _this.uncheckedElementAt(bucket)).constructor.$equal(_.arg0, _element))) {
return {0: bucket, 1: true};
};
bucket = _cloneStruct(hashTable.bucketWrappedAfter(bucket));
};
return {0: bucket, 1: false}
}
/*Swift.(file)._NativeSet.resize(capacity:Int)*/
/*Swift.(file)._NativeSet.resize(capacity:Int)*/
resizeCapacity(capacity, $info?) {
let _this = this;
const capacity = max(capacity, _this.capacity);
const result = _create(_NativeSet, 'init__RawSetStorage', _SetStorage.resizeOriginalCapacityMove(_this._storage, capacity, true), {});
if((Int.$greaterThan(_this.count, 0))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const _element = UnsafeMutablePointer.$add(_this._elements, bucket_1.offset).move( {});
result._unsafeInsertNew(_element);
}
};
_this._storage._hashTable.clear( {});
_this._storage._count = 0;
};
_this._storage = result._storage
}
/*Swift.(file)._NativeSet.copyAndResize(capacity:Int)*/
/*Swift.(file)._NativeSet.copyAndResize(capacity:Int)*/
copyAndResizeCapacity(capacity, $info?) {
let _this = this;
const capacity = max(capacity, _this.capacity);
const result = _create(_NativeSet, 'init__RawSetStorage', _SetStorage.resizeOriginalCapacityMove(_this._storage, capacity, false), {});
if((Int.$greaterThan(_this.count, 0))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
result._unsafeInsertNew(_this.uncheckedElementAt(bucket_1));
}
};
};
_this._storage = result._storage
}
/*Swift.(file)._NativeSet.copy()*/
/*Swift.(file)._NativeSet.copy()*/
copy($info?) {
let _this = this;
const newStorage = _SetStorage.copyOriginal(_this._storage);
const result = _create(_NativeSet, 'init__RawSetStorage', newStorage, {});
if((Int.$greaterThan(_this.count, 0))) {
result.hashTable.copyContentsOf(_this.hashTable);
result._storage._count = _this.count;
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const _element = _this.uncheckedElementAt(bucket_1);
result.uncheckedInitializeAtTo(bucket_1, _element);
}
};
};
_this._storage = result._storage
}
/*Swift.(file)._NativeSet.ensureUnique(isUnique:Bool,capacity:Int)*/
/*Swift.(file)._NativeSet.ensureUnique(isUnique:Bool,capacity:Int)*/
ensureUniqueIsUniqueCapacity(isUnique, capacity, $info?) {
let _this = this;
if((_fastPath(Bool.$logicalAND(Int.$lessThanOrEqual(capacity, _this.capacity), () => isUnique)))) {
return false;
};
if((isUnique)) {
_this.resizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true;
};
if((Int.$lessThanOrEqual(capacity, _this.capacity))) {
_this.copy( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return false;
};
_this.copyAndResizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true
}
/*Swift.(file)._NativeSet.reserveCapacity(_:Int,isUnique:Bool)*/
/*Swift.(file)._NativeSet.reserveCapacity(_:Int,isUnique:Bool)*/
reserveCapacityIsUnique(capacity, isUnique, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.reserveCapacity(_:Int,isUnique:Bool) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.validatedBucket(for:_HashTable.Index)*/
/*Swift.(file)._NativeSet.validatedBucket(for:_HashTable.Index)*/
validatedBucketFor(index, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.validatedBucket(for:_HashTable.Index) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.validatedBucket(for:Set<Element>.Index)*/
/*Swift.(file)._NativeSet.validatedBucket(for:Set<Element>.Index)*/
/*!!!DUPLICATE NAME*/
validatedBucketFor(index, $info?) {
let _this = this;
if(!((index._isNative))) {
index._cocoaPath( {});
const cocoa = _cloneStruct(index._asCocoa);
if((Int32.$equal(cocoa.age, _this.age))) {
const _element = _forceBridgeFromObjectiveC(cocoa._element, ((function(){throw '!unclarifiedGeneric:Element'})()));
const $tuple = _this.find(_element), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
return bucket;
};
};
preconditionFailureFileLine(() => "Attempting to access Set elements using an invalid index", null, null);
};
return _this.validatedBucketFor(index._asNative)
}


/*Swift.(file)._NativeSet.startIndex*/
startIndex$get() {
let _this = this;
const bucket = _cloneStruct(_this.hashTable.startBucket);
return _create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._NativeSet.endIndex*/
endIndex$get() {
let _this = this;
const bucket = _cloneStruct(_this.hashTable.endBucket);
return _create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._NativeSet.index(after:_NativeSet<Element>.Index)*/
/*Swift.(file)._SetBuffer.index(after:Self.Index)*/
indexAfter(index, $info?) {
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index._asNative));
const next = _cloneStruct(_this.hashTable.occupiedBucketAfter(bucket));
return _create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', next, _this.age, {}), {})
}
/*Swift.(file)._NativeSet.index(for:Element)*/
/*Swift.(file)._SetBuffer.index(for:Self.Element)*/
indexFor(_element, $info?) {
let _this = this;
if((Int.$equal(_this.count, 0))) {
return _injectIntoOptional(null);
};
const $tuple = _this.find(_element), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {}))
}

/*Swift.(file)._NativeSet.count*/
count$get() {
let _this = this;
return _assumeNonNegative(_this._storage._count)
}
get count() { return this.count$get() };



/*Swift.(file)._NativeSet.contains(_:Element)*/
/*Swift.(file)._SetBuffer.contains(_:Self.Element)*/
contains(member, $info?) {
let _this = this;
if((Int.$equal(_this.count, 0))) {
return false;
};
return _this.find(member)["1"]
}
/*Swift.(file)._NativeSet.element(at:_NativeSet<Element>.Index)*/
/*Swift.(file)._SetBuffer.element(at:Self.Index)*/
elementAt(index, $info?) {
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index));
return _this.uncheckedElementAt(bucket)
}

/*Swift.(file)._NativeSet.insertNew(_:Element,isUnique:Bool)*/
/*Swift.(file)._NativeSet.insertNew(_:Element,isUnique:Bool)*/
insertNewIsUnique(_element, isUnique, $info?) {
let _this = this;
_.discardAssignment = _this.ensureUniqueIsUniqueCapacity(isUnique, Int.$add(_this.count, 1), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this._unsafeInsertNew(_element)
}

/*Swift.(file)._NativeSet.insertNew(_:Element,at:_NativeSet<Element>.Bucket,isUnique:Bool)*/
/*Swift.(file)._NativeSet.insertNew(_:Element,at:_NativeSet<Element>.Bucket,isUnique:Bool)*/
insertNewAtIsUnique(_element, bucket, isUnique, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.insertNew(_:Element,at:_NativeSet<Element>.Bucket,isUnique:Bool) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.update(with:Element,isUnique:Bool)*/
/*Swift.(file)._NativeSet.update(with:Element,isUnique:Bool)*/
updateWithIsUnique(_element, isUnique, $info?) {
let _this = this;
let $tuple = _this.find(_element), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, Int.$add(_this.count, (found ? 0 : 1)), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
if((rehashed)) {
const $tuple = _this.find(_element), b = $tuple && $tuple[0], f = $tuple && $tuple[1];
if((Bool.$notEqual(f, found))) {
ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(((function(){throw '!unclarifiedGeneric:Element'})()));
};
bucket = _cloneStruct(b);
};
if((found)) {
const old = UnsafeMutablePointer.$add(_this._elements, bucket.offset).move( {});
_this.uncheckedInitializeAtTo(bucket, _element);
return _injectIntoOptional(old);
};
_this._unsafeInsertNewAt(_element, bucket);
return _injectIntoOptional(null)
}

/*Swift.(file)._NativeSet.isEqual(to:_NativeSet<Element>)*/
/*Swift.(file)._NativeSet.isEqual(to:_NativeSet<Element>)*/
isEqualTo(other, $info?) {
let _this = this;
if(($identical(_injectIntoOptional(_this._storage), _injectIntoOptional(other._storage)))) {
return true;
};
if((Int.$notEqual(_this.count, other.count))) {
return false;
};
{
let $member$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, member_1;
if(!((($ifLet0 = $member$generator.next( {$setThis: $val => $member$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((member_1 = $ifLet0[0])||true))) break
if(!((other.find(member_1)["1"]))) {
return false;
};
}
};
return true
}
/*Swift.(file)._NativeSet.isEqual(to:__CocoaSet)*/
/*Swift.(file)._NativeSet.isEqual(to:__CocoaSet)*/
/*!!!DUPLICATE NAME*/
isEqualTo(other, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.isEqual(to:__CocoaSet) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.hashValue(at:_NativeSet<Element>.Bucket)*/
/*Swift.(file)._HashTableDelegate.hashValue(at:_HashTable.Bucket)*/
hashValueAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.hashValue(at:_NativeSet<Element>.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.moveEntry(from:_NativeSet<Element>.Bucket,to:_NativeSet<Element>.Bucket)*/
/*Swift.(file)._HashTableDelegate.moveEntry(from:_HashTable.Bucket,to:_HashTable.Bucket)*/
moveEntryFromTo(source, target, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.moveEntry(from:_NativeSet<Element>.Bucket,to:_NativeSet<Element>.Bucket) in ' + this.constructor.name
}

/*Swift.(file)._NativeSet.uncheckedRemove(at:_NativeSet<Element>.Bucket,isUnique:Bool)*/
/*Swift.(file)._NativeSet.uncheckedRemove(at:_NativeSet<Element>.Bucket,isUnique:Bool)*/
uncheckedRemoveAtIsUnique(bucket, isUnique, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.uncheckedRemove(at:_NativeSet<Element>.Bucket,isUnique:Bool) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.removeAll(isUnique:Bool)*/
/*Swift.(file)._NativeSet.removeAll(isUnique:Bool)*/
removeAllIsUnique(isUnique, $info?) {
let _this = this;
if(!((isUnique))) {
const scale = _this._storage._scale;
_this._storage = _SetStorage.allocateScaleAgeSeed(scale, _injectIntoOptional(null), _injectIntoOptional(null));
return ;
};
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
UnsafeMutablePointer.$add(_this._elements, bucket_1.offset).deinitializeCount(1);
}
};
_this.hashTable.clear( {});
_this._storage._count = 0;
_this.invalidateIndices( {})
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true

/*Swift.(file)._NativeSet.Iterator.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file)._NativeSet.Iterator.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };




/*Swift.(file)._NativeSet.Iterator.iterator*/
iterator$get() {
throw 'unsupported variable Swift.(file)._NativeSet.Iterator.iterator in ' + this.constructor.name
}
get iterator() { return this.iterator$get() };





/*Swift.(file)._NativeSet.Iterator.init(_:_NativeSet<Element>)*/
/*Swift.(file)._NativeSet.Iterator.init(_:_NativeSet<Element>)*/
init_NativeSet(base, $info?) {
throw 'unsupported method Swift.(file)._NativeSet.Iterator.init(_:_NativeSet<Element>) in ' + this.constructor.name
}
/*Swift.(file)._NativeSet.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.base.uncheckedElementAt(index_1))
}

init$vars() {let _this = this;

}
}
/*Swift.(file)._NativeSet.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(_NativeSet.Iterator, 'init_NativeSet', _this, {})
}

/*Swift.(file)._NativeSet.bridged()*/
/*Swift.(file)._NativeSet.bridged()*/
bridged($info?) {
throw 'unsupported method Swift.(file)._NativeSet.bridged() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_NativeSet.Iterator, IteratorProtocol$implementation, false)
if(typeof _SetBuffer$implementation != 'undefined') _mixin(_NativeSet, _SetBuffer$implementation, false)
if(typeof _HashTableDelegate$implementation != 'undefined') _mixin(_NativeSet, _HashTableDelegate$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_NativeSet, Sequence$implementation, false)


























class ObjectIdentifier implements CustomDebugStringConvertible, Equatable, Comparable, Hashable{
static readonly $struct = true



/*Swift.(file).ObjectIdentifier.init(_:AnyObject)*/
/*Swift.(file).ObjectIdentifier.init(_:AnyObject)*/
initAnyObject(x, $info?) {
this._value = x
}
/*Swift.(file).ObjectIdentifier.init(_:Any.Type)*/
/*Swift.(file).ObjectIdentifier.init(_:Any.Type)*/
initprotocol_composition_type(x, $info?) {
throw 'unsupported method Swift.(file).ObjectIdentifier.init(_:Any.Type) in ' + this.constructor.name
}

/*Swift.(file).ObjectIdentifier.debugDescription*/
debugDescription$get() {
let _this = this;
return (("ObjectIdentifier(") + (_rawPointerToString(_this._value)) + (")"))
}
get debugDescription() { return this.debugDescription$get() };



static /*Swift.(file).ObjectIdentifier.==infix(_:ObjectIdentifier,_:ObjectIdentifier)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(x, y, $info?) {
return x._value === y._value
}
static /*Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
return UInt.$lessThan(_create(UInt, 'initBitPatternObjectIdentifier', lhs, {}), _create(UInt, 'initBitPatternObjectIdentifier', rhs, {}))
}
/*Swift.(file).ObjectIdentifier.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).ObjectIdentifier.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).ObjectIdentifier.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).ObjectIdentifier.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(ObjectIdentifier, CustomDebugStringConvertible$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(ObjectIdentifier, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(ObjectIdentifier, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(ObjectIdentifier, Hashable$implementation, false)










class Optional<Wrapped> implements ExpressibleByNilLiteral, CustomDebugStringConvertible, CustomReflectable, Equatable, Hashable, _ObjectiveCBridgeable, Encodable, Decodable{

static get none() {return Object.assign(new Optional(), {rawValue: "none", ...Array.from(arguments)})}

static some() {return Object.assign(new Optional(), {rawValue: "some", ...Array.from(arguments)})}
/*Swift.(file).Optional.init(_:Wrapped)*/
/*Swift.(file).Optional.init(_:Wrapped)*/
init(some, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(Optional.some(some)));
return
}
/*Swift.(file).Optional.map(_:(Wrapped) throws -> U)*/
/*Swift.(file).Optional.map(_:(Wrapped) throws -> U)*/
mapSwift<U>(transform, $info?) {
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return Optional.some(transform(y));
}
else if((($match.rawValue == Optional.none.rawValue))) {
return Optional.none;
}
}
/*Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)*/
/*Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)*/
flatMap<U>(transform, $info?) {
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return transform(y);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return Optional.none;
}
}
/*Swift.(file).Optional.init(nilLiteral:())*/
/*Swift.(file).ExpressibleByNilLiteral.init(nilLiteral:())*/
initNilLiteraltuple_type(nilLiteral, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(Optional.none));
return
}

/*Swift.(file).Optional.unsafelyUnwrapped*/
unsafelyUnwrapped$get() {
let _this = this;
const $ifLet0, x_1
if((($ifLet0 = _this)||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true)) {
return x_1;
};
preconditionFailureFileLine(() => "unsafelyUnwrapped of nil optional", null, null)
}
get unsafelyUnwrapped() { return this.unsafelyUnwrapped$get() };







/*Swift.(file).Optional.debugDescription*/
debugDescription$get() {
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
let result = "Optional(";
debugPrintSeparatorTerminatorTo(_create(Array, 'initArrayLiteralArray', [value], {}), null, "", {get: () => result, set: $val => result = $val});
String.$addAndAssign({get: () => result, set: $val => result = $val}, ")");
return result;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return "nil";
}
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).Optional.customMirror*/
customMirror$get() {
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["some", value]]), _injectIntoOptional(Mirror.DisplayStyle.optional), , {});
}
else if((($match.rawValue == Optional.none.rawValue))) {
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([]), _injectIntoOptional(Mirror.DisplayStyle.optional), , {});
}
}
get customMirror() { return this.customMirror$get() };



static /*Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const l = $match[0][0]
const r = $match[1][0]
return (_.arg0 = l).constructor.$equal(_.arg0, r);
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
}
/*Swift.(file).Optional.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
const $match = _this
if((($match.rawValue == Optional.none.rawValue))) {
hasher.combine(0, {$setThis: $val => hasher = $val});
}
else if((($match.rawValue == Optional.some().rawValue))) {
const wrapped = $match[0]
hasher.combine(1, {$setThis: $val => hasher = $val});
hasher.combine(wrapped, {$setThis: $val => hasher = $val});
};})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).Optional.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Optional.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

static /*Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)*/
/*Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)*/
$patternMatch(lhs, rhs, $info?) {
let _this = this;
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
}
static /*Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)*/
/*Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)*/
wrappedEqualsOptionalNilComparisonType(lhs, rhs, $info?) {
let _this = this;
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
}
static /*Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)*/
/*Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)*/
wrappedNotEqualsOptionalNilComparisonType(lhs, rhs, $info?) {
let _this = this;
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
}
static /*Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)*/
/*Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)*/
optionalNilComparisonTypeEqualsWrapped(lhs, rhs, $info?) {
let _this = this;
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
}
static /*Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)*/
/*Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)*/
optionalNilComparisonTypeNotEqualsWrapped(lhs, rhs, $info?) {
let _this = this;
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
}








/*Swift.(file).Optional.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Optional.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Optional.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Optional.init(from:Decoder) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof ExpressibleByNilLiteral$implementation != 'undefined') _mixin(Optional, ExpressibleByNilLiteral$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(Optional, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(Optional, CustomReflectable$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(Optional, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(Optional, Hashable$implementation, false)
if(typeof _ObjectiveCBridgeable$implementation != 'undefined') _mixin(Optional, _ObjectiveCBridgeable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(Optional, Encodable$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(Optional, Decodable$implementation, false)
_mixin(Optional, _DefaultEnumImplementation, false)


















interface OptionSet<Element> extends SetAlgebra, RawRepresentable{

/*Swift.(file).OptionSet.init(rawValue:Self.RawValue)*/
/*Swift.(file).OptionSet.init(rawValue:Self.RawValue)*/
initRawValue(rawValue, $info?)
}
class OptionSet$implementation{
/*Swift.(file).OptionSet.union(_:Self)*/
/*Swift.(file).OptionSet.union(_:Self)*/
union(other, $info?) {
let _this = this;
let r = _create(_this.constructor, 'initRawValue', _this.rawValue, {});
r.formUnion(other, {$setThis: $val => r = $val});
return r
}
/*Swift.(file).OptionSet.intersection(_:Self)*/
/*Swift.(file).OptionSet.intersection(_:Self)*/
intersection(other, $info?) {
let _this = this;
let r = _create(_this.constructor, 'initRawValue', _this.rawValue, {});
r.formIntersection(other, {$setThis: $val => r = $val});
return r
}
/*Swift.(file).OptionSet.symmetricDifference(_:Self)*/
/*Swift.(file).OptionSet.symmetricDifference(_:Self)*/
symmetricDifference(other, $info?) {
let _this = this;
let r = _create(_this.constructor, 'initRawValue', _this.rawValue, {});
r.formSymmetricDifference(other, {$setThis: $val => r = $val});
return r
}
/*Swift.(file).OptionSet.contains(_:Self)*/
/*Swift.(file).OptionSet.contains(_:Self)*/
contains(member, $info?) {
let _this = this;
return _this.isSupersetOf(member)
}
/*Swift.(file).OptionSet.insert(_:Self.Element)*/
/*Swift.(file).OptionSet.insert(_:Self.Element)*/
insert(newMember, $info?) {
let _this = this;
const oldMember = _this.intersection(newMember);
const shouldInsert = (_.arg0 = oldMember).constructor.$notEqual(_.arg0, newMember);
const result = {0: shouldInsert, 1: (shouldInsert ? newMember : oldMember)};
if((shouldInsert)) {
_this.formUnion(newMember, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
};
return result
}
/*Swift.(file).OptionSet.remove(_:Self.Element)*/
/*Swift.(file).OptionSet.remove(_:Self.Element)*/
remove(member, $info?) {
let _this = this;
const r = (_this.isSupersetOf(member) ? _create(Optional, 'init', member, {}) : _injectIntoOptional(null));
_this.subtract(member, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return r
}
/*Swift.(file).OptionSet.update(with:Self.Element)*/
/*Swift.(file).OptionSet.update(with:Self.Element)*/
updateWith(newMember, $info?) {
let _this = this;
const r = _this.intersection(newMember);
_this.formUnion(newMember, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return (r.isEmpty ? _injectIntoOptional(null) : _injectIntoOptional(r))
}
/*Swift.(file).OptionSet.init()*/
/*Swift.(file).OptionSet.init()*/
init($info?) {
let _this = this;
_this.initRawValue(0);
return
}
/*Swift.(file).OptionSet.formUnion(_:Self)*/
/*Swift.(file).OptionSet.formUnion(_:Self)*/
formUnion(other, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'initRawValue', ((function(){throw '!unclarifiedGeneric:Self.RawValue'})()).$bitwiseOR(_this.rawValue, other.rawValue), {})))
}
/*Swift.(file).OptionSet.formIntersection(_:Self)*/
/*Swift.(file).OptionSet.formIntersection(_:Self)*/
formIntersection(other, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'initRawValue', ((function(){throw '!unclarifiedGeneric:Self.RawValue'})()).$bitwiseAND(_this.rawValue, other.rawValue), {})))
}
/*Swift.(file).OptionSet.formSymmetricDifference(_:Self)*/
/*Swift.(file).OptionSet.formSymmetricDifference(_:Self)*/
formSymmetricDifference(other, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'initRawValue', ((function(){throw '!unclarifiedGeneric:Self.RawValue'})()).$bitwiseXOR(_this.rawValue, other.rawValue), {})))
}
}
if(typeof SetAlgebra$implementation != 'undefined') _mixin(OptionSet$implementation, SetAlgebra$implementation, false)
if(typeof RawRepresentable$implementation != 'undefined') _mixin(OptionSet$implementation, RawRepresentable$implementation, false)








class Never implements Error, Equatable, Comparable, Hashable{
static /*Swift.(file).Never.==(_:Never,_:Never)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}
static /*Swift.(file).Never.<infix(_:Never,_:Never)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this
}



/*Swift.(file).Never.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Never.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Never.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Never.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof Error$implementation != 'undefined') _mixin(Never, Error$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(Never, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(Never, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(Never, Hashable$implementation, false)
_mixin(Never, _DefaultEnumImplementation, false)










class PartialRangeUpTo<Bound> implements RangeExpression, Decodable, Encodable{
static readonly $struct = true

/*Swift.(file).PartialRangeUpTo.upperBound*/
readonly upperBound$get() {
throw 'unsupported variable Swift.(file).PartialRangeUpTo.upperBound in ' + this.constructor.name
}
readonly get upperBound() { return this.upperBound$get() };



/*Swift.(file).PartialRangeUpTo.init(_:Bound)*/
/*Swift.(file).PartialRangeUpTo.init(_:Bound)*/
init(upperBound, $info?) {
throw 'unsupported method Swift.(file).PartialRangeUpTo.init(_:Bound) in ' + this.constructor.name
}
/*Swift.(file).PartialRangeUpTo.relative(to:C)*/
/*Swift.(file).RangeExpression.relative(to:C)*/
relativeTo<C>(collection, $info?) {
let _this = this;
return (_.arg0 = collection.startIndex).constructor.$halfOpenRange(_.arg0, _this.upperBound)
}
/*Swift.(file).PartialRangeUpTo.contains(_:Bound)*/
/*Swift.(file).RangeExpression.contains(_:Self.Bound)*/
contains(_element, $info?) {
let _this = this;
return (_.arg0 = _element).constructor.$lessThan(_.arg0, _this.upperBound)
}

/*Swift.(file).PartialRangeUpTo.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
_this.init(container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val}));
return
}
/*Swift.(file).PartialRangeUpTo.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.upperBound, {$setThis: $val => container = $val})
}
init$vars() {let _this = this;

}
}
if(typeof RangeExpression$implementation != 'undefined') _mixin(PartialRangeUpTo, RangeExpression$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(PartialRangeUpTo, Decodable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(PartialRangeUpTo, Encodable$implementation, false)








class PartialRangeThrough<Bound> implements RangeExpression, Decodable, Encodable{
static readonly $struct = true

/*Swift.(file).PartialRangeThrough.upperBound*/
readonly upperBound$get() {
throw 'unsupported variable Swift.(file).PartialRangeThrough.upperBound in ' + this.constructor.name
}
readonly get upperBound() { return this.upperBound$get() };



/*Swift.(file).PartialRangeThrough.init(_:Bound)*/
/*Swift.(file).PartialRangeThrough.init(_:Bound)*/
init(upperBound, $info?) {
throw 'unsupported method Swift.(file).PartialRangeThrough.init(_:Bound) in ' + this.constructor.name
}
/*Swift.(file).PartialRangeThrough.relative(to:C)*/
/*Swift.(file).RangeExpression.relative(to:C)*/
relativeTo<C>(collection, $info?) {
let _this = this;
return (_.arg0 = collection.startIndex).constructor.$halfOpenRange(_.arg0, collection.indexAfter(_this.upperBound))
}
/*Swift.(file).PartialRangeThrough.contains(_:Bound)*/
/*Swift.(file).RangeExpression.contains(_:Self.Bound)*/
contains(_element, $info?) {
let _this = this;
return (_.arg0 = _element).constructor.$lessThanOrEqual(_.arg0, _this.upperBound)
}

/*Swift.(file).PartialRangeThrough.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
_this.init(container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val}));
return
}
/*Swift.(file).PartialRangeThrough.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.upperBound, {$setThis: $val => container = $val})
}
init$vars() {let _this = this;

}
}
if(typeof RangeExpression$implementation != 'undefined') _mixin(PartialRangeThrough, RangeExpression$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(PartialRangeThrough, Decodable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(PartialRangeThrough, Encodable$implementation, false)








class PartialRangeFrom<Bound> implements RangeExpression, Sequence, Decodable, Encodable{
static readonly $struct = true

/*Swift.(file).PartialRangeFrom.lowerBound*/
readonly lowerBound$get() {
throw 'unsupported variable Swift.(file).PartialRangeFrom.lowerBound in ' + this.constructor.name
}
readonly get lowerBound() { return this.lowerBound$get() };



/*Swift.(file).PartialRangeFrom.init(_:Bound)*/
/*Swift.(file).PartialRangeFrom.init(_:Bound)*/
init(lowerBound, $info?) {
throw 'unsupported method Swift.(file).PartialRangeFrom.init(_:Bound) in ' + this.constructor.name
}
/*Swift.(file).PartialRangeFrom.relative(to:C)*/
/*Swift.(file).RangeExpression.relative(to:C)*/
relativeTo<C>(collection, $info?) {
let _this = this;
return (_.arg0 = _this.lowerBound).constructor.$halfOpenRange(_.arg0, collection.endIndex)
}
/*Swift.(file).PartialRangeFrom.contains(_:Bound)*/
/*Swift.(file).RangeExpression.contains(_:Self.Bound)*/
contains(_element, $info?) {
let _this = this;
return (_.arg0 = _this.lowerBound).constructor.$lessThanOrEqual(_.arg0, _element)
}


static Iterator = class implements IteratorProtocol{
static readonly $struct = true





/*Swift.(file).PartialRangeFrom.Iterator.init(_current:Bound)*/
/*Swift.(file).PartialRangeFrom.Iterator.init(_current:Bound)*/
init_current(_current, $info?) {
let _this = this;
_this._current = _current;
return
}
/*Swift.(file).PartialRangeFrom.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
let $defer = () => {
_this._current = _this._current.advancedBy(1);
}
const $result = (() => {
try {;
return _injectIntoOptional(_this._current);}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}

init$vars() {let _this = this;

}
}
/*Swift.(file).PartialRangeFrom.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(PartialRangeFrom.Iterator, 'init_current', _this.lowerBound, {})
}
/*Swift.(file).PartialRangeFrom.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
_this.init(container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val}));
return
}
/*Swift.(file).PartialRangeFrom.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.lowerBound, {$setThis: $val => container = $val})
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(PartialRangeFrom.Iterator, IteratorProtocol$implementation, false)
if(typeof RangeExpression$implementation != 'undefined') _mixin(PartialRangeFrom, RangeExpression$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(PartialRangeFrom, Sequence$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(PartialRangeFrom, Decodable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(PartialRangeFrom, Encodable$implementation, false)










interface RangeReplaceableCollection<SubSequence> extends Collection{

/*Swift.(file).RangeReplaceableCollection.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?)
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(subrange, newElements, $info?)
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
reserveCapacity(n, $info?)
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
initRepeatingCountInt(repeatedValue, count, $info?)
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
initBuffer<S>(_elements, $info?)
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(newElement, $info?)
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
appendContentsOf<S>(newElements, $info?)
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
insertAt(newElement, i, $info?)
/*Swift.(file).RangeReplaceableCollection.insert(contentsOf:S,at:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(contentsOf:S,at:Self.Index)*/
insertContentsOfAt<S>(newElements, i, $info?)
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
removeAt(i, $info?)
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)*/
removeSubrangeRange(bounds, $info?)


/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
removeFirst($info?)
/*Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)*/
removeFirstMultiple(k, $info?)
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?)
/*Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)*/
removeAllWhere(shouldBeRemoved, $info?)
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(bounds, $info?)


/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?)

}
class RangeReplaceableCollection$implementation{
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
initRepeatingCountInt(repeatedValue, count, $info?) {
let _this = this;
_this.init( {});
if((Int.$notEqual(count, 0))) {
const _elements = _create(Repeated, 'init_repeatingCountInt', repeatedValue, count, {});
_this.appendContentsOf(_elements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
};
return
}
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
initBuffer<S>(_elements, $info?) {
let _this = this;
_this.init( {});
_this.appendContentsOf(_elements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return
}
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(newElement, $info?) {
let _this = this;
_this.insertAt(newElement, _this.endIndex, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
appendContentsOf<S>(newElements, $info?) {
let _this = this;
const approximateCapacity = Int.$add(_this.count, numericCast(newElements.underestimatedCount, {T: Int, U: Int}));
{
let $element$generator = newElements.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
_this.append(_element_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
insertAt(newElement, i, $info?) {
let _this = this;
_this.replaceSubrangeWith((_.arg0 = i).constructor.$halfOpenRange(_.arg0, i), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)*/
/*!!!DUPLICATE NAME*/
insertContentsOfAt<C>(newElements, i, $info?) {
let _this = this;
_this.replaceSubrangeWith((_.arg0 = i).constructor.$halfOpenRange(_.arg0, i), newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
removeAt(position, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove from an empty collection", null, null);
const result = _this.subscript$get(position);
_this.replaceSubrangeWith((_.arg0 = position).constructor.$halfOpenRange(_.arg0, _this.indexAfter(position)), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return result
}
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)*/
removeSubrangeRange(bounds, $info?) {
let _this = this;
_this.replaceSubrangeWith(bounds, _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)*/
removeFirstMultiple(k, $info?) {
let _this = this;
if((Int.$equal(k, 0))) {
return ;
};
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Number of elements to remove should be non-negative", null, null);
preconditionFileLine(() => Int.$greaterThanOrEqual(_this.count, k), () => "Can't remove more items from a collection than it has", null, null);
const end = _this.indexOffsetBy(_this.startIndex, k);
_this.removeSubrangeRange((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, end), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
removeFirst($info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove first element from an empty collection", null, null);
const firstElement = _this.first[0];
_this.removeFirstMultiple(1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return firstElement
}
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
let _this = this;
if((Bool.$not(keepCapacity))) {
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'init', {})));
}
else {
_this.replaceSubrangeWith((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
reserveCapacity(n, $info?) {

}
/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
removeFirst($info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove first element from an empty collection", null, null);
const firstElement = _this.first[0];
_this.removeFirstMultiple(1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return firstElement
}
/*Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)*/
removeFirstMultiple(k, $info?) {
let _this = this;
if((Int.$equal(k, 0))) {
return ;
};
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Number of elements to remove should be non-negative", null, null);
preconditionFileLine(() => Int.$greaterThanOrEqual(_this.count, k), () => "Can't remove more items from a collection than it has", null, null);
const end = _this.indexOffsetBy(_this.startIndex, k);
_this.removeSubrangeRange((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, end), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)*/
/*!!!DUPLICATE NAME*/
replaceSubrangeWith<C, R>(subrange, newElements, $info?) {
let _this = this;
_this.replaceSubrangeWith(subrange.relativeTo(_this), newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)*/
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)*/
removeSubrange<R>(bounds, $info?) {
let _this = this;
_this.removeSubrangeRange(bounds.relativeTo(_this), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}




/*Swift.(file).RangeReplaceableCollection.popLast()*/
/*Swift.(file).RangeReplaceableCollection.popLast()*/
popLast($info?) {
let _this = this;
if((_this.isEmpty)) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.removeAt(_this.indexBefore(_this.endIndex), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
}
/*Swift.(file).RangeReplaceableCollection.removeLast()*/
/*Swift.(file).RangeReplaceableCollection.removeLast()*/
removeLast($info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove last element from an empty collection", null, null);
return _this.removeAt(_this.indexBefore(_this.endIndex), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.removeLast(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.removeLast(_:Int)*/
removeLastMultiple(k, $info?) {
throw 'unsupported method Swift.(file).RangeReplaceableCollection.removeLast(_:Int) in ' + this.constructor.name
}
/*Swift.(file).RangeReplaceableCollection.popLast()*/
/*Swift.(file).RangeReplaceableCollection.popLast()*/
popLast($info?) {
let _this = this;
if((_this.isEmpty)) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.removeAt(_this.indexBefore(_this.endIndex), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
}
/*Swift.(file).RangeReplaceableCollection.removeLast()*/
/*Swift.(file).RangeReplaceableCollection.removeLast()*/
removeLast($info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove last element from an empty collection", null, null);
return _this.removeAt(_this.indexBefore(_this.endIndex), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.removeLast(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.removeLast(_:Int)*/
removeLastMultiple(k, $info?) {
throw 'unsupported method Swift.(file).RangeReplaceableCollection.removeLast(_:Int) in ' + this.constructor.name
}
static /*Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)*/
/*Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)*/
$add<Other>(lhs, rhs, $info?) {
let _this = this;
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf(rhs, {$setThis: $val => lhs_dupl = $val});
return lhs_dupl
}
static /*Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)*/
/*Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)*/
/*!!!DUPLICATE NAME*/
$add<Other>(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
result.appendContentsOf(lhs, {$setThis: $val => result = $val});
result.appendContentsOf(rhs, {$setThis: $val => result = $val});
return result
}
static /*Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)*/
/*Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)*/
$addAndAssign<Other>(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf(rhs, {$setThis: $val => lhs = $val});})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)*/
/*Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)*/
$add<Other>(lhs, rhs, $info?) {
let _this = this;
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf(rhs, {$setThis: $val => lhs_dupl = $val});
return lhs_dupl
}
/*Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)*/
/*Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
let _this = this;
return _create(_this.constructor, 'initBuffer', _this.lazy.filterSwift(isIncluded), {})
}
/*Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)*/
removeAllWhere(shouldBeRemoved, $info?) {
let _this = this;
const suffixStart = _this._halfStablePartitionIsSuffixElement(shouldBeRemoved, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.removeSubrange(((function(){throw '!unclarifiedGeneric:Self.Index'})()).$openEndedRange(suffixStart), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)*/
removeAllWhere(shouldBeRemoved, $info?) {
let _this = this;
const suffixStart = _this._halfStablePartitionIsSuffixElement(shouldBeRemoved, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.removeSubrange(((function(){throw '!unclarifiedGeneric:Self.Index'})()).$openEndedRange(suffixStart), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).RangeReplaceableCollection.applying(_:CollectionDifference<Self.Element>)*/
/*Swift.(file).RangeReplaceableCollection.applying(_:CollectionDifference<Self.Element>)*/
applying(difference, $info?) {
throw 'unsupported method Swift.(file).RangeReplaceableCollection.applying(_:CollectionDifference<Self.Element>) in ' + this.constructor.name
}
}
if(typeof Collection$implementation != 'undefined') _mixin(RangeReplaceableCollection$implementation, Collection$implementation, false)


























class MIO_Mixin_Set<Element> implements ExpressibleByArrayLiteral, Sequence, Collection, Equatable, Hashable, _HasCustomAnyHashableRepresentation, SetAlgebra, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable, Encodable, Decodable{
static readonly $struct = true
static readonly $mixin = true





/*Swift.(file).Set.init(minimumCapacity:Int)*/
/*Swift.(file).Set.init(minimumCapacity:Int)*/
initMinimumCapacityInt(minimumCapacity, $info?) {
throw 'unsupported method Swift.(file).Set.init(minimumCapacity:Int) in ' + this.constructor.name
}
/*Swift.(file).Set.init(_native:_NativeSet<Element>)*/
/*Swift.(file).Set.init(_native:_NativeSet<Element>)*/
init_native_NativeSet(_native, $info?) {
throw 'unsupported method Swift.(file).Set.init(_native:_NativeSet<Element>) in ' + this.constructor.name
}
/*Swift.(file).Set.init(_cocoa:__CocoaSet)*/
/*Swift.(file).Set.init(_cocoa:__CocoaSet)*/
init_cocoa__CocoaSet(_cocoa, $info?) {
throw 'unsupported method Swift.(file).Set.init(_cocoa:__CocoaSet) in ' + this.constructor.name
}
/*Swift.(file).Set.init(_immutableCocoaSet:AnyObject)*/
/*Swift.(file).Set.init(_immutableCocoaSet:AnyObject)*/
init_immutableCocoaSetAnyObject(_immutableCocoaSet, $info?) {
throw 'unsupported method Swift.(file).Set.init(_immutableCocoaSet:AnyObject) in ' + this.constructor.name
}
/*Swift.(file).Set.init(arrayLiteral:[Element])*/
/*Swift.(file).ExpressibleByArrayLiteral.init(arrayLiteral:[Self.ArrayLiteralElement])*/
initArrayLiteralArray(_elements, $info?) {
return new Set(_elements)
}

/*Swift.(file).Set.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}
/*Swift.(file).Set.contains(_:Element)*/
/*Swift.(file).SetAlgebra.contains(_:Self.Element)*/
contains(member, $info?) {
throw 'unsupported method Swift.(file).Set.contains(_:Element) in ' + this.constructor.name
}


/*Swift.(file).Set.filter(_:(Element) throws -> Bool)*/
/*Swift.(file).Set.filter(_:(Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
throw 'unsupported method Swift.(file).Set.filter(_:(Element) throws -> Bool) in ' + this.constructor.name
}

/*Swift.(file).Set.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Set.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Set.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Set.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Set.subscript(_:Set<Element>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Set.subscript(_:Set<Element>.Index) in ' + this.constructor.name
}


/*Swift.(file).Set.index(after:Set<Element>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Set.index(after:Set<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).Set.formIndex(after:Set<Element>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Set.firstIndex(of:Element)*/
/*Swift.(file).Set.firstIndex(of:Element)*/
firstIndexOf(member, $info?) {
throw 'unsupported method Swift.(file).Set.firstIndex(of:Element) in ' + this.constructor.name
}



/*Swift.(file).Set.count*/
count$get() {
return this.size
}
get count() { return this.count$get() };




/*Swift.(file).Set.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };





static /*Swift.(file).Set.==infix(_:Set<Element>,_:Set<Element>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
/*Swift.(file).Set.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Set.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).Set.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Set.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


/*Swift.(file).Set.insert(_:Element)*/
/*Swift.(file).SetAlgebra.insert(_:Self.Element)*/
insert(newMember, $info?) {
this.add(_cloneStruct(newMember))
}
/*Swift.(file).Set.update(with:Element)*/
/*Swift.(file).SetAlgebra.update(with:Self.Element)*/
updateWith(newMember, $info?) {
throw 'unsupported method Swift.(file).Set.update(with:Element) in ' + this.constructor.name
}
/*Swift.(file).Set.remove(_:Element)*/
/*Swift.(file).SetAlgebra.remove(_:Self.Element)*/
remove(member, $info?) {
throw 'unsupported method Swift.(file).Set.remove(_:Element) in ' + this.constructor.name
}
/*Swift.(file).Set.remove(at:Set<Element>.Index)*/
/*Swift.(file).Set.remove(at:Set<Element>.Index)*/
removeAt(position, $info?) {
throw 'unsupported method Swift.(file).Set.remove(at:Set<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).Set.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).Set.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
throw 'unsupported method Swift.(file).Set.removeAll(keepingCapacity:Bool) in ' + this.constructor.name
}
/*Swift.(file).Set.removeFirst()*/
/*Swift.(file).Set.removeFirst()*/
removeFirst($info?) {
throw 'unsupported method Swift.(file).Set.removeFirst() in ' + this.constructor.name
}
/*Swift.(file).Set.init()*/
/*Swift.(file).SetAlgebra.init()*/
init($info?) {
return new Set()
}
/*Swift.(file).Set.init(_:Source)*/
/*Swift.(file).SetAlgebra.init(_:S)*/
initSource<Source>(sequence, $info?) {
return new Set(sequence)
}
/*Swift.(file).Set.isSubset(of:S)*/
/*Swift.(file).Set.isSubset(of:S)*/
isSubsetOf<S>(possibleSuperset, $info?) {
throw 'unsupported method Swift.(file).Set.isSubset(of:S) in ' + this.constructor.name
}
/*Swift.(file).Set.isStrictSubset(of:S)*/
/*Swift.(file).Set.isStrictSubset(of:S)*/
isStrictSubsetOf<S>(possibleStrictSuperset, $info?) {
throw 'unsupported method Swift.(file).Set.isStrictSubset(of:S) in ' + this.constructor.name
}
/*Swift.(file).Set.isSuperset(of:S)*/
/*Swift.(file).Set.isSuperset(of:S)*/
isSupersetOf<S>(possibleSubset, $info?) {
throw 'unsupported method Swift.(file).Set.isSuperset(of:S) in ' + this.constructor.name
}
/*Swift.(file).Set.isStrictSuperset(of:S)*/
/*Swift.(file).Set.isStrictSuperset(of:S)*/
isStrictSupersetOf<S>(possibleStrictSubset, $info?) {
throw 'unsupported method Swift.(file).Set.isStrictSuperset(of:S) in ' + this.constructor.name
}
/*Swift.(file).Set.isDisjoint(with:S)*/
/*Swift.(file).Set.isDisjoint(with:S)*/
isDisjointWith<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.isDisjoint(with:S) in ' + this.constructor.name
}
/*Swift.(file).Set.union(_:S)*/
/*Swift.(file).SetAlgebra.union(_:Self)*/
union<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.union(_:S) in ' + this.constructor.name
}
/*Swift.(file).Set.formUnion(_:S)*/
/*Swift.(file).SetAlgebra.formUnion(_:Self)*/
formUnion<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.formUnion(_:S) in ' + this.constructor.name
}
/*Swift.(file).Set.subtracting(_:S)*/
/*Swift.(file).Set.subtracting(_:S)*/
subtracting<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.subtracting(_:S) in ' + this.constructor.name
}

/*Swift.(file).Set.subtract(_:S)*/
/*Swift.(file).Set.subtract(_:S)*/
subtract<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.subtract(_:S) in ' + this.constructor.name
}

/*Swift.(file).Set.intersection(_:S)*/
/*Swift.(file).Set.intersection(_:S)*/
intersection<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.intersection(_:S) in ' + this.constructor.name
}
/*Swift.(file).Set.formIntersection(_:S)*/
/*Swift.(file).SetAlgebra.formIntersection(_:Self)*/
formIntersection<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.formIntersection(_:S) in ' + this.constructor.name
}
/*Swift.(file).Set.symmetricDifference(_:S)*/
/*Swift.(file).SetAlgebra.symmetricDifference(_:Self)*/
symmetricDifference<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.symmetricDifference(_:S) in ' + this.constructor.name
}
/*Swift.(file).Set.formSymmetricDifference(_:S)*/
/*Swift.(file).Set.formSymmetricDifference(_:S)*/
formSymmetricDifference<S>(other, $info?) {
throw 'unsupported method Swift.(file).Set.formSymmetricDifference(_:S) in ' + this.constructor.name
}

/*Swift.(file).Set.description*/
description$get() {
throw 'unsupported variable Swift.(file).Set.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).Set.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Set.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).Set.subtract(_:Set<Element>)*/
/*Swift.(file).SetAlgebra.subtract(_:Self)*/
/*!!!DUPLICATE NAME*/
subtract(other, $info?) {
let _this = this;
_this.formIntersection(_this.symmetricDifference(other), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).Set.isSubset(of:Set<Element>)*/
/*Swift.(file).SetAlgebra.isSubset(of:Self)*/
/*!!!DUPLICATE NAME*/
isSubsetOf(other, $info?) {
let _this = this;
return (_.arg0 = _this.intersection(other)).constructor.$equal(_.arg0, _this)
}
/*Swift.(file).Set.isSuperset(of:Set<Element>)*/
/*Swift.(file).SetAlgebra.isSuperset(of:Self)*/
/*!!!DUPLICATE NAME*/
isSupersetOf(other, $info?) {
let _this = this;
return other.isSubsetOf(_this)
}
/*Swift.(file).Set.isDisjoint(with:Set<Element>)*/
/*Swift.(file).SetAlgebra.isDisjoint(with:Self)*/
/*!!!DUPLICATE NAME*/
isDisjointWith(other, $info?) {
let _this = this;
return _this.intersection(other).isEmpty
}

/*Swift.(file).Set.subtracting(_:Set<Element>)*/
/*Swift.(file).SetAlgebra.subtracting(_:Self)*/
/*!!!DUPLICATE NAME*/
subtracting(other, $info?) {
let _this = this;
return _this.intersection(_this.symmetricDifference(other))
}
/*Swift.(file).Set.isStrictSuperset(of:Set<Element>)*/
/*Swift.(file).Set.isStrictSuperset(of:Set<Element>)*/
/*!!!DUPLICATE NAME*/
isStrictSupersetOf(other, $info?) {
throw 'unsupported method Swift.(file).Set.isStrictSuperset(of:Set<Element>) in ' + this.constructor.name
}
/*Swift.(file).Set.isStrictSubset(of:Set<Element>)*/
/*Swift.(file).Set.isStrictSubset(of:Set<Element>)*/
/*!!!DUPLICATE NAME*/
isStrictSubsetOf(other, $info?) {
throw 'unsupported method Swift.(file).Set.isStrictSubset(of:Set<Element>) in ' + this.constructor.name
}
/*Swift.(file).Set.intersection(_:Set<Element>)*/
/*Swift.(file).SetAlgebra.intersection(_:Self)*/
/*!!!DUPLICATE NAME*/
intersection(other, $info?) {
throw 'unsupported method Swift.(file).Set.intersection(_:Set<Element>) in ' + this.constructor.name
}
/*Swift.(file).Set.formSymmetricDifference(_:Set<Element>)*/
/*Swift.(file).SetAlgebra.formSymmetricDifference(_:Self)*/
/*!!!DUPLICATE NAME*/
formSymmetricDifference(other, $info?) {
throw 'unsupported method Swift.(file).Set.formSymmetricDifference(_:Set<Element>) in ' + this.constructor.name
}
static Index = class implements Equatable, Comparable, Hashable{
static readonly $struct = true
static _Variant = class{

static _native() {return Object.assign(new MIO_Mixin_Set.Index._Variant(), {rawValue: "_native", ...Array.from(arguments)})}

static cocoa() {return Object.assign(new MIO_Mixin_Set.Index._Variant(), {rawValue: "cocoa", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}





/*Swift.(file).Set.Index.init(_variant:Set<Element>.Index._Variant)*/
/*Swift.(file).Set.Index.init(_variant:Set<Element>.Index._Variant)*/
init_variantSetIndex_Variant(_variant, $info?) {
throw 'unsupported method Swift.(file).Set.Index.init(_variant:Set<Element>.Index._Variant) in ' + this.constructor.name
}
/*Swift.(file).Set.Index.init(_native:_HashTable.Index)*/
/*Swift.(file).Set.Index.init(_native:_HashTable.Index)*/
init_native_HashTableIndex(index, $info?) {
throw 'unsupported method Swift.(file).Set.Index.init(_native:_HashTable.Index) in ' + this.constructor.name
}
/*Swift.(file).Set.Index.init(_cocoa:__CocoaSet.Index)*/
/*Swift.(file).Set.Index.init(_cocoa:__CocoaSet.Index)*/
init_cocoa__CocoaSetIndex(index, $info?) {
throw 'unsupported method Swift.(file).Set.Index.init(_cocoa:__CocoaSet.Index) in ' + this.constructor.name
}
















static /*Swift.(file).Set.Index.==infix(_:Set<Element>.Index,_:Set<Element>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Set.Index.<infix(_:Set<Element>.Index,_:Set<Element>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
/*Swift.(file).Set.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Set.Index.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).Set.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Set.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}
static Iterator = class implements IteratorProtocol, CustomReflectable{
static readonly $struct = true
static _Variant = class{

static _native() {return Object.assign(new MIO_Mixin_Set.Iterator._Variant(), {rawValue: "_native", ...Array.from(arguments)})}

static cocoa() {return Object.assign(new MIO_Mixin_Set.Iterator._Variant(), {rawValue: "cocoa", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}





/*Swift.(file).Set.Iterator.init(_variant:Set<Element>.Iterator._Variant)*/
/*Swift.(file).Set.Iterator.init(_variant:Set<Element>.Iterator._Variant)*/
init_variantSetIterator_Variant(_variant, $info?) {
throw 'unsupported method Swift.(file).Set.Iterator.init(_variant:Set<Element>.Iterator._Variant) in ' + this.constructor.name
}
/*Swift.(file).Set.Iterator.init(_native:_NativeSet<Set<Element>.Iterator.Element>.Iterator)*/
/*Swift.(file).Set.Iterator.init(_native:_NativeSet<Set<Element>.Iterator.Element>.Iterator)*/
init_native_NativeSetIterator(_native, $info?) {
throw 'unsupported method Swift.(file).Set.Iterator.init(_native:_NativeSet<Set<Element>.Iterator.Element>.Iterator) in ' + this.constructor.name
}
/*Swift.(file).Set.Iterator.init(_cocoa:__CocoaSet.Iterator)*/
/*Swift.(file).Set.Iterator.init(_cocoa:__CocoaSet.Iterator)*/
init_cocoa__CocoaSetIterator(_cocoa, $info?) {
throw 'unsupported method Swift.(file).Set.Iterator.init(_cocoa:__CocoaSet.Iterator) in ' + this.constructor.name
}















/*Swift.(file).Set.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).Set.Iterator.next() in ' + this.constructor.name
}


/*Swift.(file).Set.Iterator.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Set.Iterator.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}

/*Swift.(file).Set.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Set.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };



/*Swift.(file).Set.popFirst()*/
/*Swift.(file).Set.popFirst()*/
popFirst($info?) {
throw 'unsupported method Swift.(file).Set.popFirst() in ' + this.constructor.name
}

/*Swift.(file).Set.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file).Set.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };



/*Swift.(file).Set.reserveCapacity(_:Int)*/
/*Swift.(file).Set.reserveCapacity(_:Int)*/
reserveCapacity(minimumCapacity, $info?) {
throw 'unsupported method Swift.(file).Set.reserveCapacity(_:Int) in ' + this.constructor.name
}
/*Swift.(file).Set.insert(_:ConcreteElement)*/
/*Swift.(file).Set.insert(_:ConcreteElement)*/
insertConcreteElement<ConcreteElement>(newMember, $info?) {
let _this = this;
const $tuple = _this.insert(_create(AnyHashable, 'init', newMember, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), inserted = $tuple && $tuple[0], memberAfterInsert = $tuple && $tuple[1];
return {0: inserted, 1: memberAfterInsert.base}
}
/*Swift.(file).Set.update(with:ConcreteElement)*/
/*Swift.(file).Set.update(with:ConcreteElement)*/
/*!!!DUPLICATE NAME*/
updateWith<ConcreteElement>(newMember, $info?) {
let _this = this;
return _this.updateWith(_create(AnyHashable, 'init', newMember, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}).mapSwift((($0, $info?) => $0.base))
}
/*Swift.(file).Set.remove(_:ConcreteElement)*/
/*Swift.(file).Set.remove(_:ConcreteElement)*/
/*!!!DUPLICATE NAME*/
remove<ConcreteElement>(member, $info?) {
let _this = this;
return _this.remove(_create(AnyHashable, 'init', member, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}).mapSwift((($0, $info?) => $0.base))
}


/*Swift.(file).Set.init(_mapping:C,allowingDuplicates:Bool,transform:(C.Element) -> Element?)*/
/*Swift.(file).Set.init(_mapping:C,allowingDuplicates:Bool,transform:(C.Element) -> Element?)*/
init_mappingAllowingDuplicatesBoolTransformfunction_type<C>(source, allowingDuplicates, transform, $info?) {
let _this = this;
let target = _create(_NativeSet, 'initCapacityInt', source.count, {});
if((allowingDuplicates)) {
{
let $m$generator = source.makeIterator( {});
while(true) {
const $ifLet0, m_1;
if(!((($ifLet0 = $m$generator.next( {$setThis: $val => $m$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((m_1 = $ifLet0[0])||true))) break
const $ifLet2, member_3
if(!((($ifLet2 = transform(m_1))||true) && $ifLet2.rawValue == 'some' && ((member_3 = $ifLet2[0])||true))) {
return (this.$failed = true);
};
target._unsafeUpdateWith(member_3, {$setThis: $val => target = $val});
}
};
}
else {
{
let $m$generator = source.makeIterator( {});
while(true) {
const $ifLet4, m_5;
if(!((($ifLet4 = $m$generator.next( {$setThis: $val => $m$generator = $val}))||true) && $ifLet4.rawValue == 'some' && ((m_5 = $ifLet4[0])||true))) break
const $ifLet6, member_7
if(!((($ifLet6 = transform(m_5))||true) && $ifLet6.rawValue == 'some' && ((member_7 = $ifLet6[0])||true))) {
return (this.$failed = true);
};
target._unsafeInsertNew(member_7);
}
};
};
_this.init_native_NativeSet(target);
return
}
static readonly init_mappingAllowingDuplicatesBoolTransformfunction_type$failable = true
static _Variant = class implements _SetBuffer{
static readonly $struct = true

/*Swift.(file).Set._Variant.object*/
object$get() {
throw 'unsupported variable Swift.(file).Set._Variant.object in ' + this.constructor.name
}
get object() { return this.object$get() };





/*Swift.(file).Set._Variant.init(dummy:())*/
/*Swift.(file).Set._Variant.init(dummy:())*/
initDummytuple_type(dummy, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.init(dummy:()) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.init(native:_NativeSet<Element>)*/
/*Swift.(file).Set._Variant.init(native:_NativeSet<Element>)*/
initNative_NativeSet(_native, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.init(native:_NativeSet<Element>) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.init(cocoa:__CocoaSet)*/
/*Swift.(file).Set._Variant.init(cocoa:__CocoaSet)*/
initCocoa__CocoaSet(cocoa, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.init(cocoa:__CocoaSet) in ' + this.constructor.name
}

/*Swift.(file).Set._Variant.guaranteedNative*/
guaranteedNative$get() {
throw 'unsupported variable Swift.(file).Set._Variant.guaranteedNative in ' + this.constructor.name
}
get guaranteedNative() { return this.guaranteedNative$get() };



/*Swift.(file).Set._Variant.isUniquelyReferenced()*/
/*Swift.(file).Set._Variant.isUniquelyReferenced()*/
isUniquelyReferenced($info?) {
throw 'unsupported method Swift.(file).Set._Variant.isUniquelyReferenced() in ' + this.constructor.name
}

/*Swift.(file).Set._Variant.isNative*/
isNative$get() {
throw 'unsupported variable Swift.(file).Set._Variant.isNative in ' + this.constructor.name
}
get isNative() { return this.isNative$get() };




/*Swift.(file).Set._Variant.asNative*/
asNative$get() {
throw 'unsupported variable Swift.(file).Set._Variant.asNative in ' + this.constructor.name
}
get asNative() { return this.asNative$get() };






/*Swift.(file).Set._Variant.asCocoa*/
asCocoa$get() {
throw 'unsupported variable Swift.(file).Set._Variant.asCocoa in ' + this.constructor.name
}
get asCocoa() { return this.asCocoa$get() };



/*Swift.(file).Set._Variant.reserveCapacity(_:Int)*/
/*Swift.(file).Set._Variant.reserveCapacity(_:Int)*/
reserveCapacity(capacity, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.reserveCapacity(_:Int) in ' + this.constructor.name
}

/*Swift.(file).Set._Variant.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file).Set._Variant.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };





/*Swift.(file).Set._Variant.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Set._Variant.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Set._Variant.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Set._Variant.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Set._Variant.index(after:Set<Element>._Variant.Index)*/
/*Swift.(file)._SetBuffer.index(after:Self.Index)*/
indexAfter(index, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.index(after:Set<Element>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.formIndex(after:Set<Element>._Variant.Index)*/
/*Swift.(file).Set._Variant.formIndex(after:Set<Element>._Variant.Index)*/
formIndexAfter(index$inout, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.formIndex(after:Set<Element>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.index(for:Element)*/
/*Swift.(file)._SetBuffer.index(for:Self.Element)*/
indexFor(_element, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.index(for:Element) in ' + this.constructor.name
}

/*Swift.(file).Set._Variant.count*/
count$get() {
throw 'unsupported variable Swift.(file).Set._Variant.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file).Set._Variant.contains(_:Element)*/
/*Swift.(file)._SetBuffer.contains(_:Self.Element)*/
contains(member, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.contains(_:Element) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.element(at:Set<Element>._Variant.Index)*/
/*Swift.(file)._SetBuffer.element(at:Self.Index)*/
elementAt(index, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.element(at:Set<Element>._Variant.Index) in ' + this.constructor.name
}

/*Swift.(file).Set._Variant.update(with:Element)*/
/*Swift.(file).Set._Variant.update(with:Element)*/
updateWith(value, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.update(with:Element) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.insert(_:Element)*/
/*Swift.(file).Set._Variant.insert(_:Element)*/
insert(_element, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.insert(_:Element) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.remove(at:Set<Element>._Variant.Index)*/
/*Swift.(file).Set._Variant.remove(at:Set<Element>._Variant.Index)*/
removeAt(index, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.remove(at:Set<Element>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.remove(_:Element)*/
/*Swift.(file).Set._Variant.remove(_:Element)*/
remove(member, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.remove(_:Element) in ' + this.constructor.name
}

/*Swift.(file).Set._Variant.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).Set._Variant.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
throw 'unsupported method Swift.(file).Set._Variant.removeAll(keepingCapacity:Bool) in ' + this.constructor.name
}
/*Swift.(file).Set._Variant.makeIterator()*/
/*Swift.(file).Set._Variant.makeIterator()*/
makeIterator($info?) {
throw 'unsupported method Swift.(file).Set._Variant.makeIterator() in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
/*Swift.(file).Set.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Set.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Set.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Set.init(from:Decoder) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
_mixin(MIO_Mixin_Set.Index._Variant, _DefaultEnumImplementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_Set.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(MIO_Mixin_Set.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Set.Index, Hashable$implementation, false)
_mixin(MIO_Mixin_Set.Iterator._Variant, _DefaultEnumImplementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(MIO_Mixin_Set.Iterator, IteratorProtocol$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Set.Iterator, CustomReflectable$implementation, false)
if(typeof _SetBuffer$implementation != 'undefined') _mixin(MIO_Mixin_Set._Variant, _SetBuffer$implementation, false)
if(typeof ExpressibleByArrayLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Set, ExpressibleByArrayLiteral$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(MIO_Mixin_Set, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(MIO_Mixin_Set, Collection$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_Set, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Set, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Set, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof SetAlgebra$implementation != 'undefined') _mixin(MIO_Mixin_Set, SetAlgebra$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Set, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Set, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Set, CustomReflectable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(MIO_Mixin_Set, Encodable$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(MIO_Mixin_Set, Decodable$implementation, false)
_mixin(Set, MIO_Mixin_Set, true)










































class _SwiftSetNSEnumerator<Element> extends __SwiftNativeNSEnumerator implements _NSEnumerator{

/*Swift.(file)._SwiftSetNSEnumerator.base*/
base$get() {
throw 'unsupported variable Swift.(file)._SwiftSetNSEnumerator.base in ' + this.constructor.name
}
get base() { return this.base$get() };






/*Swift.(file)._SwiftSetNSEnumerator.bridgedElements*/
bridgedElements$get() {
throw 'unsupported variable Swift.(file)._SwiftSetNSEnumerator.bridgedElements in ' + this.constructor.name
}
get bridgedElements() { return this.bridgedElements$get() };






/*Swift.(file)._SwiftSetNSEnumerator.nextBucket*/
nextBucket$get() {
throw 'unsupported variable Swift.(file)._SwiftSetNSEnumerator.nextBucket in ' + this.constructor.name
}
get nextBucket() { return this.nextBucket$get() };






/*Swift.(file)._SwiftSetNSEnumerator.endBucket*/
endBucket$get() {
throw 'unsupported variable Swift.(file)._SwiftSetNSEnumerator.endBucket in ' + this.constructor.name
}
get endBucket() { return this.endBucket$get() };





/*Swift.(file)._SwiftSetNSEnumerator.init()*/
/*Swift.(file).__SwiftNativeNSEnumerator.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SwiftSetNSEnumerator.init() in ' + this.constructor.name
}
/*Swift.(file)._SwiftSetNSEnumerator.init(_:_NativeSet<Element>)*/
/*Swift.(file)._SwiftSetNSEnumerator.init(_:_NativeSet<Element>)*/
init_NativeSet(base, $info?) {
throw 'unsupported method Swift.(file)._SwiftSetNSEnumerator.init(_:_NativeSet<Element>) in ' + this.constructor.name
}
/*Swift.(file)._SwiftSetNSEnumerator.init(_:_SwiftDeferredNSSet<Element>)*/
/*Swift.(file)._SwiftSetNSEnumerator.init(_:_SwiftDeferredNSSet<Element>)*/
init_SwiftDeferredNSSet(deferred, $info?) {
throw 'unsupported method Swift.(file)._SwiftSetNSEnumerator.init(_:_SwiftDeferredNSSet<Element>) in ' + this.constructor.name
}
/*Swift.(file)._SwiftSetNSEnumerator.bridgedElement(at:_HashTable.Bucket)*/
/*Swift.(file)._SwiftSetNSEnumerator.bridgedElement(at:_HashTable.Bucket)*/
bridgedElementAt(bucket, $info?) {
throw 'unsupported method Swift.(file)._SwiftSetNSEnumerator.bridgedElement(at:_HashTable.Bucket) in ' + this.constructor.name
}
/*Swift.(file)._SwiftSetNSEnumerator.nextObject()*/
/*Swift.(file)._NSEnumerator.nextObject()*/
nextObject($info?) {
throw 'unsupported method Swift.(file)._SwiftSetNSEnumerator.nextObject() in ' + this.constructor.name
}
/*Swift.(file)._SwiftSetNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int)*/
/*Swift.(file)._SwiftSetNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file)._SwiftSetNSEnumerator.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SwiftSetNSEnumerator.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSEnumerator.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file)._SwiftSetNSEnumerator.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSEnumerator$implementation != 'undefined') _mixin(_SwiftSetNSEnumerator, _NSEnumerator$implementation, false)


class _SwiftDeferredNSSet<Element> extends __SwiftNativeNSSet implements _NSSetCore{










/*Swift.(file)._SwiftDeferredNSSet.init(_:_NativeSet<Element>)*/
/*Swift.(file)._SwiftDeferredNSSet.init(_:_NativeSet<Element>)*/
init_NativeSet(_native, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.init(_:_NativeSet<Element>) in ' + this.constructor.name
}







/*Swift.(file)._SwiftDeferredNSSet.bridgeElements()*/
/*Swift.(file)._SwiftDeferredNSSet.bridgeElements()*/
bridgeElements($info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.bridgeElements() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSSet.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
/*Swift.(file)._NSSetCore.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
initObjectsUnsafePointerCountInt(objects, count, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.init(objects:UnsafePointer<AnyObject?>,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSSet.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSSetCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSSet.member(_:AnyObject)*/
/*Swift.(file)._NSSetCore.member(_:AnyObject)*/
member(object, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.member(_:AnyObject) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSSet.objectEnumerator()*/
/*Swift.(file)._NSSetCore.objectEnumerator()*/
objectEnumerator($info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.objectEnumerator() in ' + this.constructor.name
}

/*Swift.(file)._SwiftDeferredNSSet.count*/
count$get() {
throw 'unsupported variable Swift.(file)._SwiftDeferredNSSet.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file)._SwiftDeferredNSSet.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSSetCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSSet.init()*/
/*Swift.(file).__SwiftNativeNSSet.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.init() in ' + this.constructor.name
}
/*Swift.(file)._SwiftDeferredNSSet.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSSet.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file)._SwiftDeferredNSSet.init(coder:AnyObject) in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSSetCore$implementation != 'undefined') _mixin(_SwiftDeferredNSSet, _NSSetCore$implementation, false)


class __CocoaSet implements _SetBuffer, Sequence{
static readonly $struct = true

/*Swift.(file).__CocoaSet.object*/
readonly object$get() {
throw 'unsupported variable Swift.(file).__CocoaSet.object in ' + this.constructor.name
}
readonly get object() { return this.object$get() };



/*Swift.(file).__CocoaSet.init(_:AnyObject)*/
/*Swift.(file).__CocoaSet.init(_:AnyObject)*/
initAnyObject(object, $info?) {
throw 'unsupported method Swift.(file).__CocoaSet.init(_:AnyObject) in ' + this.constructor.name
}
/*Swift.(file).__CocoaSet.member(for:__CocoaSet.Index)*/
/*Swift.(file).__CocoaSet.member(for:__CocoaSet.Index)*/
memberFor(index, $info?) {
let _this = this;
return index._element
}
/*Swift.(file).__CocoaSet.member(for:AnyObject)*/
/*Swift.(file).__CocoaSet.member(for:AnyObject)*/
/*!!!DUPLICATE NAME*/
memberFor(_element, $info?) {
let _this = this;
const nss = _cloneStruct(unsafeBitCastTo(_this.object, _NSSet));
return nss.member(_element)
}
/*Swift.(file).__CocoaSet.isEqual(to:__CocoaSet)*/
/*Swift.(file).__CocoaSet.isEqual(to:__CocoaSet)*/
isEqualTo(other, $info?) {
let _this = this;
return _stdlib_NSObject_isEqual(_this.object, other.object)
}


/*Swift.(file).__CocoaSet.startIndex*/
startIndex$get() {
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSSet_allObjects(_this.object));
return _create(__CocoaSet.Index, 'init__CocoaSetIndexStorageOffsetInt', _create(__CocoaSet.Index.Storage, 'init__CocoaSet_BridgingBuffer', _this, allKeys, {}), 0, {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).__CocoaSet.endIndex*/
endIndex$get() {
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSSet_allObjects(_this.object));
return _create(__CocoaSet.Index, 'init__CocoaSetIndexStorageOffsetInt', _create(__CocoaSet.Index.Storage, 'init__CocoaSet_BridgingBuffer', _this, allKeys, {}), allKeys.count, {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).__CocoaSet.index(after:__CocoaSet.Index)*/
/*Swift.(file)._SetBuffer.index(after:Self.Index)*/
indexAfter(index, $info?) {
let _this = this;
_this.validate(index);
let result = _cloneStruct(index);
Int.$addAndAssign({get: () => result._offset, set: $val => result._offset = $val}, 1);
return result
}
/*Swift.(file).__CocoaSet.validate(_:__CocoaSet.Index)*/
/*Swift.(file).__CocoaSet.validate(_:__CocoaSet.Index)*/
validate(index, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object)), () => "Invalid index", null, null);
preconditionFileLine(() => Int.$lessThan(index._offset, index.storage.allKeys.count), () => "Attempt to access endIndex", null, null)
}
/*Swift.(file).__CocoaSet.formIndex(after:__CocoaSet.Index,isUnique:Bool)*/
/*Swift.(file).__CocoaSet.formIndex(after:__CocoaSet.Index,isUnique:Bool)*/
formIndexAfterIsUnique(index$inout, isUnique, $info?) {
let _this = this;
let index = index$inout.get()
const $result = (() => {
_this.validate(index);
Int.$addAndAssign({get: () => index._offset, set: $val => index._offset = $val}, 1);})()
index$inout.set(index)
return $result
}
/*Swift.(file).__CocoaSet.index(for:AnyObject)*/
/*Swift.(file)._SetBuffer.index(for:Self.Element)*/
indexFor(_element, $info?) {
throw 'unsupported method Swift.(file).__CocoaSet.index(for:AnyObject) in ' + this.constructor.name
}

/*Swift.(file).__CocoaSet.count*/
count$get() {
let _this = this;
const nss = _cloneStruct(unsafeBitCastTo(_this.object, _NSSet));
return nss.count
}
get count() { return this.count$get() };



/*Swift.(file).__CocoaSet.contains(_:AnyObject)*/
/*Swift.(file)._SetBuffer.contains(_:Self.Element)*/
contains(_element, $info?) {
let _this = this;
const nss = _cloneStruct(unsafeBitCastTo(_this.object, _NSSet));
return Optional.wrappedNotEqualsOptionalNilComparisonType(nss.member(_element), _injectIntoOptional(null))
}
/*Swift.(file).__CocoaSet.element(at:__CocoaSet.Index)*/
/*Swift.(file)._SetBuffer.element(at:Self.Index)*/
elementAt(i, $info?) {
let _this = this;
const _element = _injectIntoOptional(i._element);
return _element[0]
}
static Index = class implements Equatable, Comparable{
static readonly $struct = true











/*Swift.(file).__CocoaSet.Index.storage*/
storage$get() {
throw 'unsupported variable Swift.(file).__CocoaSet.Index.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };



/*Swift.(file).__CocoaSet.Index.init(_:__CocoaSet.Index.Storage,offset:Int)*/
/*Swift.(file).__CocoaSet.Index.init(_:__CocoaSet.Index.Storage,offset:Int)*/
init__CocoaSetIndexStorageOffsetInt(storage, offset, $info?) {
throw 'unsupported method Swift.(file).__CocoaSet.Index.init(_:__CocoaSet.Index.Storage,offset:Int) in ' + this.constructor.name
}
static Storage = class{

/*Swift.(file).__CocoaSet.Index.Storage.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file).__CocoaSet.Index.Storage.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };




/*Swift.(file).__CocoaSet.Index.Storage.allKeys*/
allKeys$get() {
throw 'unsupported variable Swift.(file).__CocoaSet.Index.Storage.allKeys in ' + this.constructor.name
}
get allKeys() { return this.allKeys$get() };





/*Swift.(file).__CocoaSet.Index.Storage.init(_:__CocoaSet,_:_BridgingBuffer)*/
/*Swift.(file).__CocoaSet.Index.Storage.init(_:__CocoaSet,_:_BridgingBuffer)*/
init__CocoaSet_BridgingBuffer(base, allKeys, $info?) {
throw 'unsupported method Swift.(file).__CocoaSet.Index.Storage.init(_:__CocoaSet,_:_BridgingBuffer) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}

/*Swift.(file).__CocoaSet.Index.handleBitPattern*/
handleBitPattern$get() {
let _this = this;
return unsafeBitCastTo(_this.storage, UInt)
}
get handleBitPattern() { return this.handleBitPattern$get() };







/*Swift.(file).__CocoaSet.Index.age*/
age$get() {
let _this = this;
return _HashTable.ageFor(_this.storage.base.object)
}
get age() { return this.age$get() };



static /*Swift.(file).__CocoaSet.Index.==infix(_:__CocoaSet.Index,_:__CocoaSet.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different sets", null, null);
return Int.$equal(lhs._offset, rhs._offset)
}
static /*Swift.(file).__CocoaSet.Index.<infix(_:__CocoaSet.Index,_:__CocoaSet.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
preconditionFileLine(() => $identical(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different sets", null, null);
return Int.$lessThan(lhs._offset, rhs._offset)
}
init$vars() {let _this = this;

}
}
static Iterator = class implements IteratorProtocol{











/*Swift.(file).__CocoaSet.Iterator.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file).__CocoaSet.Iterator.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };










/*Swift.(file).__CocoaSet.Iterator.itemIndex*/
itemIndex$get() {
throw 'unsupported variable Swift.(file).__CocoaSet.Iterator.itemIndex in ' + this.constructor.name
}
get itemIndex() { return this.itemIndex$get() };






/*Swift.(file).__CocoaSet.Iterator.itemCount*/
itemCount$get() {
throw 'unsupported variable Swift.(file).__CocoaSet.Iterator.itemCount in ' + this.constructor.name
}
get itemCount() { return this.itemCount$get() };





/*Swift.(file).__CocoaSet.Iterator.init(_:__CocoaSet)*/
/*Swift.(file).__CocoaSet.Iterator.init(_:__CocoaSet)*/
init__CocoaSet(base, $info?) {
throw 'unsupported method Swift.(file).__CocoaSet.Iterator.init(_:__CocoaSet) in ' + this.constructor.name
}


/*Swift.(file).__CocoaSet.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if((Int.$lessThan(_this.itemIndex, 0))) {
return _injectIntoOptional(null);
};
const base = _cloneStruct(_this.base);
if((Int.$equal(_this.itemIndex, _this.itemCount))) {
const stackBufCount = _this._fastEnumerationStackBuf.count;
_this.itemCount = base.object[0](_this._fastEnumerationStatePtr, _create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', _this._fastEnumerationStackBufPtr, {}).assumingMemoryBoundTo(AnyObject), stackBufCount);
if((Int.$equal(_this.itemCount, 0))) {
_this.itemIndex = -1;
return _injectIntoOptional(null);
};
_this.itemIndex = 0;
};
const itemsPtrUP = _cloneStruct(_create(UnsafeMutableRawPointer, 'initAutoreleasingUnsafeMutablePointer', _this._fastEnumerationState.itemsPtr[0], {}).assumingMemoryBoundTo(AnyObject));
const itemsPtr = _create(_UnmanagedAnyObjectArray, 'initUnsafeMutablePointer', itemsPtrUP, {});
const key = _cloneStruct(itemsPtr.subscript$get(_this.itemIndex));
Int.$addAndAssign({get: () => _this.itemIndex, set: $val => _this.itemIndex = $val}, 1);
return _injectIntoOptional(key)
}
init$vars() {let _this = this;

}
}
/*Swift.(file).__CocoaSet.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(__CocoaSet.Iterator, 'init__CocoaSet', _this, {})
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(__CocoaSet.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(__CocoaSet.Index, Comparable$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(__CocoaSet.Iterator, IteratorProtocol$implementation, false)
if(typeof _SetBuffer$implementation != 'undefined') _mixin(__CocoaSet, _SetBuffer$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(__CocoaSet, Sequence$implementation, false)












class __RawSetStorage extends __SwiftNativeNSSet{








































/*Swift.(file).__RawSetStorage.init(_doNotCallMe:())*/
/*Swift.(file).__RawSetStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__RawSetStorage.init(_doNotCallMe:()) in ' + this.constructor.name
}









/*Swift.(file).__RawSetStorage.init()*/
/*Swift.(file).__SwiftNativeNSSet.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__RawSetStorage.init() in ' + this.constructor.name
}
/*Swift.(file).__RawSetStorage.init(coder:AnyObject)*/
/*Swift.(file).__SwiftNativeNSSet.init(coder:AnyObject)*/
initCoderAnyObject(coder, $info?) {
throw 'unsupported method Swift.(file).__RawSetStorage.init(coder:AnyObject) in ' + this.constructor.name
}


/*Swift.(file).__RawSetStorage.empty*/
static empty$get() {
throw 'unsupported variable Swift.(file).__RawSetStorage.empty in ' + this.constructor.name
}
static get empty() { return this.empty$get() };



init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}




class __EmptySetSingleton extends __RawSetStorage implements _NSSetCore{
/*Swift.(file).__EmptySetSingleton.init(_doNotCallMe:())*/
/*Swift.(file).__RawSetStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__EmptySetSingleton.init(_doNotCallMe:()) in ' + this.constructor.name
}
/*Swift.(file).__EmptySetSingleton.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
/*Swift.(file)._NSSetCore.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
initObjectsUnsafePointerCountInt(objects, count, $info?) {
throw 'unsupported method Swift.(file).__EmptySetSingleton.init(objects:UnsafePointer<AnyObject?>,count:Int) in ' + this.constructor.name
}

/*Swift.(file).__EmptySetSingleton.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSSetCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file).__EmptySetSingleton.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}

/*Swift.(file).__EmptySetSingleton.count*/
count$get() {
let _this = this;
return 0
}
get count() { return this.count$get() };



/*Swift.(file).__EmptySetSingleton.member(_:AnyObject)*/
/*Swift.(file)._NSSetCore.member(_:AnyObject)*/
member(object, $info?) {
let _this = this;
return _injectIntoOptional(null)
}
/*Swift.(file).__EmptySetSingleton.objectEnumerator()*/
/*Swift.(file)._NSSetCore.objectEnumerator()*/
objectEnumerator($info?) {
let _this = this;
return _create(__SwiftEmptyNSEnumerator, 'init', {})
}
/*Swift.(file).__EmptySetSingleton.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSSetCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file).__EmptySetSingleton.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSSetCore$implementation != 'undefined') _mixin(__EmptySetSingleton, _NSSetCore$implementation, false)




class _SetStorage<Element> extends __RawSetStorage implements _NSSetCore{
/*Swift.(file)._SetStorage.init(_doNotCallMe:())*/
/*Swift.(file).__RawSetStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file)._SetStorage.init(_doNotCallMe:()) in ' + this.constructor.name
}





/*Swift.(file)._SetStorage.asNative*/
asNative$get() {
throw 'unsupported variable Swift.(file)._SetStorage.asNative in ' + this.constructor.name
}
get asNative() { return this.asNative$get() };



/*Swift.(file)._SetStorage.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
/*Swift.(file)._NSSetCore.init(objects:UnsafePointer<AnyObject?>,count:Int)*/
initObjectsUnsafePointerCountInt(objects, count, $info?) {
throw 'unsupported method Swift.(file)._SetStorage.init(objects:UnsafePointer<AnyObject?>,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SetStorage.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSSetCore.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Swift.(file)._SetStorage.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}

/*Swift.(file)._SetStorage.count*/
count$get() {
throw 'unsupported variable Swift.(file)._SetStorage.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file)._SetStorage.objectEnumerator()*/
/*Swift.(file)._NSSetCore.objectEnumerator()*/
objectEnumerator($info?) {
throw 'unsupported method Swift.(file)._SetStorage.objectEnumerator() in ' + this.constructor.name
}
/*Swift.(file)._SetStorage.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSSetCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file)._SetStorage.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file)._SetStorage.member(_:AnyObject)*/
/*Swift.(file)._NSSetCore.member(_:AnyObject)*/
member(object, $info?) {
throw 'unsupported method Swift.(file)._SetStorage.member(_:AnyObject) in ' + this.constructor.name
}
static /*Swift.(file)._SetStorage.copy(original:__RawSetStorage)*/
/*Swift.(file)._SetStorage.copy(original:__RawSetStorage)*/
copyOriginal(original, $info?) {
let _this = this;
return _SetStorage.allocateScaleAgeSeed(original._scale, _injectIntoOptional(original._age), _injectIntoOptional(original._seed))
}
static /*Swift.(file)._SetStorage.resize(original:__RawSetStorage,capacity:Int,move:Bool)*/
/*Swift.(file)._SetStorage.resize(original:__RawSetStorage,capacity:Int,move:Bool)*/
resizeOriginalCapacityMove(original, capacity, move, $info?) {
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity);
return _this.allocateScaleAgeSeed(scale, _injectIntoOptional(null), _injectIntoOptional(null))
}
static /*Swift.(file)._SetStorage.allocate(capacity:Int)*/
/*Swift.(file)._SetStorage.allocate(capacity:Int)*/
allocateCapacity(capacity, $info?) {
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity);
return _this.allocateScaleAgeSeed(scale, _injectIntoOptional(null), _injectIntoOptional(null))
}
static /*Swift.(file)._SetStorage.convert(_:__CocoaSet,capacity:Int)*/
/*Swift.(file)._SetStorage.convert(_:__CocoaSet,capacity:Int)*/
convertCapacity(cocoa, capacity, $info?) {
throw 'unsupported method Swift.(file)._SetStorage.convert(_:__CocoaSet,capacity:Int) in ' + this.constructor.name
}
static /*Swift.(file)._SetStorage.allocate(scale:Int8,age:Int32?,seed:Int?)*/
/*Swift.(file)._SetStorage.allocate(scale:Int8,age:Int32?,seed:Int?)*/
allocateScaleAgeSeed(scale, age, seed, $info?) {
throw 'unsupported method Swift.(file)._SetStorage.allocate(scale:Int8,age:Int32?,seed:Int?) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSSetCore$implementation != 'undefined') _mixin(_SetStorage, _NSSetCore$implementation, false)




class StaticString implements _ExpressibleByBuiltinUnicodeScalarLiteral, _ExpressibleByBuiltinExtendedGraphemeClusterLiteral, _ExpressibleByBuiltinStringLiteral, ExpressibleByUnicodeScalarLiteral, ExpressibleByExtendedGraphemeClusterLiteral, ExpressibleByStringLiteral, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable{
static readonly $struct = true
















/*Swift.(file).StaticString.utf8Start*/
utf8Start$get() {
let _this = this;
preconditionFileLine(() => _this.hasPointerRepresentation, () => "StaticString should have pointer representation", null, null);
return _create(UnsafePointer, 'initBitPatternUInt', _create(UInt, 'initWord', _this._startPtrOrData, {}), {})[0]
}
get utf8Start() { return this.utf8Start$get() };




/*Swift.(file).StaticString.unicodeScalar*/
unicodeScalar$get() {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.hasPointerRepresentation), () => "StaticString should have Unicode scalar representation", null, null);
return _create(Unicode.Scalar, 'initUInt32', _create(UInt32, 'initT', _create(UInt, 'initWord', _this._startPtrOrData, {}), {}), {})[0]
}
get unicodeScalar() { return this.unicodeScalar$get() };




/*Swift.(file).StaticString.utf8CodeUnitCount*/
utf8CodeUnitCount$get() {
let _this = this;
preconditionFileLine(() => _this.hasPointerRepresentation, () => "StaticString should have pointer representation", null, null);
return _create(Int, 'initWord', _this._utf8CodeUnitCount, {})
}
get utf8CodeUnitCount() { return this.utf8CodeUnitCount$get() };




/*Swift.(file).StaticString.hasPointerRepresentation*/
hasPointerRepresentation$get() {
let _this = this;
return UInt8.$equal(UInt8.$bitwiseAND(_create(UInt8, 'initInt8', _this._flags, {}), 0x1), 0)
}
get hasPointerRepresentation() { return this.hasPointerRepresentation$get() };




/*Swift.(file).StaticString.isASCII*/
isASCII$get() {
let _this = this;
return UInt8.$notEqual(UInt8.$bitwiseAND(_create(UInt8, 'initInt8', _this._flags, {}), 0x2), 0)
}
get isASCII() { return this.isASCII$get() };



/*Swift.(file).StaticString.withUTF8Buffer(_:(UnsafeBufferPointer<UInt8>) -> R)*/
/*Swift.(file).StaticString.withUTF8Buffer(_:(UnsafeBufferPointer<UInt8>) -> R)*/
withUTF8Buffer<R>(body, $info?) {
throw 'unsupported method Swift.(file).StaticString.withUTF8Buffer(_:(UnsafeBufferPointer<UInt8>) -> R) in ' + this.constructor.name
}
/*Swift.(file).StaticString.init()*/
/*Swift.(file).StaticString.init()*/
init($info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct("")));
return
}
/*Swift.(file).StaticString.init(_start:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file).StaticString.init(_start:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_startRawPointerUtf8CodeUnitCountWordIsASCIIInt1(_start, utf8CodeUnitCount, isASCII, $info?) {
throw 'unsupported method Swift.(file).StaticString.init(_start:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1) in ' + this.constructor.name
}
/*Swift.(file).StaticString.init(unicodeScalar:Int32)*/
/*Swift.(file).StaticString.init(unicodeScalar:Int32)*/
initUnicodeScalarInt32(unicodeScalar, $info?) {
throw 'unsupported method Swift.(file).StaticString.init(unicodeScalar:Int32) in ' + this.constructor.name
}
/*Swift.(file).StaticString.init(_builtinUnicodeScalarLiteral:Int32)*/
/*Swift.(file)._ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:Int32)*/
init_builtinUnicodeScalarLiteralInt32(value, $info?) {
throw 'unsupported method Swift.(file).StaticString.init(_builtinUnicodeScalarLiteral:Int32) in ' + this.constructor.name
}
/*Swift.(file).StaticString.init(unicodeScalarLiteral:StaticString)*/
/*Swift.(file).ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:Self.UnicodeScalarLiteralType)*/
initUnicodeScalarLiteral(value, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(value)));
return
}
/*Swift.(file).StaticString.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinExtendedGraphemeClusterLiteral.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_builtinExtendedGraphemeClusterLiteralRawPointerUtf8CodeUnitCountWordIsASCIIInt1(start, utf8CodeUnitCount, isASCII, $info?) {
throw 'unsupported method Swift.(file).StaticString.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1) in ' + this.constructor.name
}
/*Swift.(file).StaticString.init(extendedGraphemeClusterLiteral:StaticString)*/
/*Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(extendedGraphemeClusterLiteral:Self.ExtendedGraphemeClusterLiteralType)*/
initExtendedGraphemeClusterLiteral(value, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(value)));
return
}
/*Swift.(file).StaticString.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_builtinStringLiteralRawPointerUtf8CodeUnitCountWordIsASCIIInt1(start, utf8CodeUnitCount, isASCII, $info?) {
throw 'unsupported method Swift.(file).StaticString.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1) in ' + this.constructor.name
}
/*Swift.(file).StaticString.init(stringLiteral:StaticString)*/
/*Swift.(file).ExpressibleByStringLiteral.init(stringLiteral:Self.StringLiteralType)*/
initStringLiteral(value, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(value)));
return
}

/*Swift.(file).StaticString.description*/
description$get() {
let _this = this;
return _this.withUTF8Buffer((($0, $info?) => String._uncheckedFromUTF8($0)))
}
get description() { return this.description$get() };




/*Swift.(file).StaticString.debugDescription*/
debugDescription$get() {
let _this = this;
return _this.description.debugDescription
}
get debugDescription() { return this.debugDescription$get() };







/*Swift.(file).StaticString.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initReflectingprotocol_composition_type', _this.description, {})
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}
if(typeof _ExpressibleByBuiltinUnicodeScalarLiteral$implementation != 'undefined') _mixin(StaticString, _ExpressibleByBuiltinUnicodeScalarLiteral$implementation, false)
if(typeof _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(StaticString, _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation, false)
if(typeof _ExpressibleByBuiltinStringLiteral$implementation != 'undefined') _mixin(StaticString, _ExpressibleByBuiltinStringLiteral$implementation, false)
if(typeof ExpressibleByUnicodeScalarLiteral$implementation != 'undefined') _mixin(StaticString, ExpressibleByUnicodeScalarLiteral$implementation, false)
if(typeof ExpressibleByExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(StaticString, ExpressibleByExtendedGraphemeClusterLiteral$implementation, false)
if(typeof ExpressibleByStringLiteral$implementation != 'undefined') _mixin(StaticString, ExpressibleByStringLiteral$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(StaticString, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(StaticString, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(StaticString, CustomReflectable$implementation, false)




interface Strideable<Stride> extends Comparable{

/*Swift.(file).Strideable.distance(to:Self)*/
/*Swift.(file).Strideable.distance(to:Self)*/
distanceTo(other, $info?)
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
advancedBy(n, $info?)

}
class Strideable$implementation{
static /*Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)*/
/*Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)*/
$add(lhs, rhs, $info?) {
let _this = this;
return lhs.advancedBy(rhs)
}
static /*Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)*/
/*Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)*/
/*!!!DUPLICATE NAME*/
$add(lhs, rhs, $info?) {
let _this = this;
return rhs.advancedBy(lhs)
}
static /*Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)*/
/*Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)*/
$subtract(lhs, rhs, $info?) {
let _this = this;
return lhs.advancedBy(((function(){throw '!unclarifiedGeneric:Self.Stride'})()).$negate(rhs))
}
static /*Swift.(file).Strideable.-infix(_:Self,_:Self)*/
/*Swift.(file).Strideable.-infix(_:Self,_:Self)*/
/*!!!DUPLICATE NAME*/
$subtract(lhs, rhs, $info?) {
let _this = this;
return rhs.distanceTo(lhs)
}
static /*Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)*/
/*Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)*/
$addAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy(rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)*/
/*Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy(((function(){throw '!unclarifiedGeneric:Self.Stride'})()).$negate(rhs));})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).Strideable.<infix(_:Self,_:Self)*/
/*Swift.(file).Strideable.<infix(_:Self,_:Self)*/
$lessThan(x, y, $info?) {
let _this = this;
return ((function(){throw '!unclarifiedGeneric:Self.Stride'})()).$greaterThan(x.distanceTo(y), 0)
}
static /*Swift.(file).Strideable.==infix(_:Self,_:Self)*/
/*Swift.(file).Strideable.==infix(_:Self,_:Self)*/
$equal(x, y, $info?) {
let _this = this;
return ((function(){throw '!unclarifiedGeneric:Self.Stride'})()).$equal(x.distanceTo(y), 0)
}



}
if(typeof Comparable$implementation != 'undefined') _mixin(Strideable$implementation, Comparable$implementation, false)










class StrideTo<Element> implements Sequence, CustomReflectable{
static readonly $struct = true









/*Swift.(file).StrideTo.init(_start:Element,end:Element,stride:Element.Stride)*/
/*Swift.(file).StrideTo.init(_start:Element,end:Element,stride:Element.Stride)*/
init_startEndStride(_start, end, stride, $info?) {
throw 'unsupported method Swift.(file).StrideTo.init(_start:Element,end:Element,stride:Element.Stride) in ' + this.constructor.name
}
/*Swift.(file).StrideTo.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(StrideToIterator, 'init_startEndStride', _this._start, _this._end, _this._stride, {})
}

/*Swift.(file).StrideTo.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
let it = _cloneStruct(_this.makeIterator( {}));
let count = 0;
while(true){
if(!((Optional.wrappedNotEqualsOptionalNilComparisonType(it.next( {$setThis: $val => it = $val}), _injectIntoOptional(null))))) break
Int.$addAndAssign({get: () => count, set: $val => count = $val}, 1);
};
return count
}
get underestimatedCount() { return this.underestimatedCount$get() };







/*Swift.(file).StrideTo.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["from", _this._start], ["to", _this._end], ["by", _this._stride]]), , , {})
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}
if(typeof Sequence$implementation != 'undefined') _mixin(StrideTo, Sequence$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(StrideTo, CustomReflectable$implementation, false)






class StrideThrough<Element> implements Sequence, CustomReflectable{
static readonly $struct = true









/*Swift.(file).StrideThrough.init(_start:Element,end:Element,stride:Element.Stride)*/
/*Swift.(file).StrideThrough.init(_start:Element,end:Element,stride:Element.Stride)*/
init_startEndStride(_start, end, stride, $info?) {

}
/*Swift.(file).StrideThrough.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(StrideThroughIterator, 'init_startEndStride', _this._start, _this._end, _this._stride, {})
}

/*Swift.(file).StrideThrough.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
let it = _cloneStruct(_this.makeIterator( {}));
let count = 0;
while(true){
if(!((Optional.wrappedNotEqualsOptionalNilComparisonType(it.next( {$setThis: $val => it = $val}), _injectIntoOptional(null))))) break
Int.$addAndAssign({get: () => count, set: $val => count = $val}, 1);
};
return count
}
get underestimatedCount() { return this.underestimatedCount$get() };







/*Swift.(file).StrideThrough.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["from", _this._start], ["through", _this._end], ["by", _this._stride]]), , , {})
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}
if(typeof Sequence$implementation != 'undefined') _mixin(StrideThrough, Sequence$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(StrideThrough, CustomReflectable$implementation, false)






class __SwiftNativeNSArrayWithContiguousStorage extends __SwiftNativeNSArray implements _NSArrayCore{
/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.init()*/
/*Swift.(file).__SwiftNativeNSArray.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.init() in ' + this.constructor.name
}

/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R)*/
/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R)*/
withUnsafeBufferOfObjects<R>(body, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R) in ' + this.constructor.name
}

/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.count*/
count$get() {
throw 'unsupported variable Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.objectAt(_:Int)*/
/*Swift.(file)._NSArrayCore.objectAt(_:Int)*/
objectAt(index, $info?) {
let _this = this;
return _this.withUnsafeBufferOfObjects(((objects, $info?) => { 
preconditionFileLine(() => _isValidArraySubscriptCount(index, objects.count), () => "Array index out of range", null, null);
return objects.subscript$get(index); }))
}
/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.getObjects(_:UnsafeMutablePointer<AnyObject>,range:_SwiftNSRange)*/
/*Swift.(file)._NSArrayCore.getObjects(_:UnsafeMutablePointer<AnyObject>,range:_SwiftNSRange)*/
getObjectsRange(aBuffer, range, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.getObjects(_:UnsafeMutablePointer<AnyObject>,range:_SwiftNSRange) in ' + this.constructor.name
}
/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSArrayCore.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
/*Swift.(file)._NSFastEnumeration.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)*/
countByEnumeratingWithObjectsCount(state, objects, count, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.copy(with:_SwiftNSZone?)*/
/*Swift.(file)._NSCopying.copy(with:_SwiftNSZone?)*/
copyWith(_, $info?) {
throw 'unsupported method Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.copy(with:_SwiftNSZone?) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof _NSArrayCore$implementation != 'undefined') _mixin(__SwiftNativeNSArrayWithContiguousStorage, _NSArrayCore$implementation, false)




class __SwiftDeferredNSArray extends __SwiftNativeNSArrayWithContiguousStorage{














/*Swift.(file).__SwiftDeferredNSArray.init(_nativeStorage:__ContiguousArrayStorageBase)*/
/*Swift.(file).__SwiftDeferredNSArray.init(_nativeStorage:__ContiguousArrayStorageBase)*/
init_nativeStorage__ContiguousArrayStorageBase(_nativeStorage, $info?) {
throw 'unsupported method Swift.(file).__SwiftDeferredNSArray.init(_nativeStorage:__ContiguousArrayStorageBase) in ' + this.constructor.name
}


/*Swift.(file).__SwiftDeferredNSArray.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R)*/
/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R)*/
withUnsafeBufferOfObjects<R>(body, $info?) {
throw 'unsupported method Swift.(file).__SwiftDeferredNSArray.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R) in ' + this.constructor.name
}

/*Swift.(file).__SwiftDeferredNSArray.count*/
count$get() {
throw 'unsupported variable Swift.(file).__SwiftDeferredNSArray.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file).__SwiftDeferredNSArray.init()*/
/*Swift.(file).__SwiftNativeNSArray.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__SwiftDeferredNSArray.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class __ContiguousArrayStorageBase extends __SwiftNativeNSArrayWithContiguousStorage{

/*Swift.(file).__ContiguousArrayStorageBase.countAndCapacity*/
countAndCapacity$get() {
throw 'unsupported variable Swift.(file).__ContiguousArrayStorageBase.countAndCapacity in ' + this.constructor.name
}
get countAndCapacity() { return this.countAndCapacity$get() };





/*Swift.(file).__ContiguousArrayStorageBase.init(_doNotCallMeBase:())*/
/*Swift.(file).__ContiguousArrayStorageBase.init(_doNotCallMeBase:())*/
init_doNotCallMeBasetuple_type(_doNotCallMeBase, $info?) {
throw 'unsupported method Swift.(file).__ContiguousArrayStorageBase.init(_doNotCallMeBase:()) in ' + this.constructor.name
}
/*Swift.(file).__ContiguousArrayStorageBase.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R)*/
/*Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R)*/
withUnsafeBufferOfObjects<R>(body, $info?) {
throw 'unsupported method Swift.(file).__ContiguousArrayStorageBase.withUnsafeBufferOfObjects(_:(UnsafeBufferPointer<AnyObject>) throws -> R) in ' + this.constructor.name
}



/*Swift.(file).__ContiguousArrayStorageBase.canStoreElements(ofDynamicType:Any.Type)*/
/*Swift.(file).__ContiguousArrayStorageBase.canStoreElements(ofDynamicType:Any.Type)*/
canStoreElementsOfDynamicType(_, $info?) {
throw 'unsupported method Swift.(file).__ContiguousArrayStorageBase.canStoreElements(ofDynamicType:Any.Type) in ' + this.constructor.name
}

/*Swift.(file).__ContiguousArrayStorageBase.staticElementType*/
staticElementType$get() {
throw 'unsupported variable Swift.(file).__ContiguousArrayStorageBase.staticElementType in ' + this.constructor.name
}
get staticElementType() { return this.staticElementType$get() };




/*Swift.(file).__ContiguousArrayStorageBase.init()*/
/*Swift.(file).__SwiftNativeNSArray.init()*/
init($info?) {
throw 'unsupported method Swift.(file).__ContiguousArrayStorageBase.init() in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _CountingIndex<Base> implements Equatable, Comparable{
static readonly $struct = true

/*Swift.(file)._CountingIndex.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file)._CountingIndex.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };




/*Swift.(file)._CountingIndex.offset*/
readonly offset$get() {
throw 'unsupported variable Swift.(file)._CountingIndex.offset in ' + this.constructor.name
}
readonly get offset() { return this.offset$get() };



/*Swift.(file)._CountingIndex.init(base:Base,offset:Int?)*/
/*Swift.(file)._CountingIndex.init(base:Base,offset:Int?)*/
initBaseOffsetOptional(base, offset, $info?) {
throw 'unsupported method Swift.(file)._CountingIndex.init(base:Base,offset:Int?) in ' + this.constructor.name
}
static /*Swift.(file)._CountingIndex.==(_:_CountingIndex<Base>,_:_CountingIndex<Base>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}
static /*Swift.(file)._CountingIndex.<infix(_:_CountingIndex<Base>,_:_CountingIndex<Base>)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
return $lessThan({0: lhs.base, 1: $nilCoalescing(lhs.offset, () => Int.max)}, {0: rhs.base, 1: $nilCoalescing(rhs.offset, () => Int.max)})
}
init$vars() {let _this = this;

}
}
if(typeof Equatable$implementation != 'undefined') _mixin(_CountingIndex, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(_CountingIndex, Comparable$implementation, false)




class Mirror implements CustomStringConvertible, CustomReflectable{
static readonly $struct = true
static _DefaultDescendantRepresentation = class{

static get generated() {return Object.assign(new Mirror._DefaultDescendantRepresentation(), {rawValue: "generated", ...Array.from(arguments)})}

static get suppressed() {return Object.assign(new Mirror._DefaultDescendantRepresentation(), {rawValue: "suppressed", ...Array.from(arguments)})}
static /*Swift.(file).Mirror._DefaultDescendantRepresentation.==(_:Mirror._DefaultDescendantRepresentation,_:Mirror._DefaultDescendantRepresentation)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).Mirror._DefaultDescendantRepresentation.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Mirror._DefaultDescendantRepresentation.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Mirror._DefaultDescendantRepresentation.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Mirror._DefaultDescendantRepresentation.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
static AncestorRepresentation = class{

static get generated() {return Object.assign(new Mirror.AncestorRepresentation(), {rawValue: "generated", ...Array.from(arguments)})}

static customized() {return Object.assign(new Mirror.AncestorRepresentation(), {rawValue: "customized", ...Array.from(arguments)})}

static get suppressed() {return Object.assign(new Mirror.AncestorRepresentation(), {rawValue: "suppressed", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}
/*Swift.(file).Mirror.init(reflecting:Any)*/
/*Swift.(file).Mirror.init(reflecting:Any)*/
initReflectingprotocol_composition_type(subject, $info?) {
let _this = this;
const $ifLet0, customized_1
if((($ifLet0 = subject)||true) && $ifLet0 instanceof CustomReflectable && ((customized_1 = $ifLet0)||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(customized_1.customMirror)));
}
else {
$info.$setThis(_this = _cloneStruct(_create(Mirror, 'initInternalReflectingprotocol_composition_typeSubjectTypeOptionalCustomAncestorOptional', subject, , , {})));
};
return
}


static DisplayStyle = class{

static get struct() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "struct", ...Array.from(arguments)})}

static get _class() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "_class", ...Array.from(arguments)})}

static get enum() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "enum", ...Array.from(arguments)})}

static get tuple() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "tuple", ...Array.from(arguments)})}

static get optional() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "optional", ...Array.from(arguments)})}

static get collection() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "collection", ...Array.from(arguments)})}

static get dictionary() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "dictionary", ...Array.from(arguments)})}

static get set() {return Object.assign(new Mirror.DisplayStyle(), {rawValue: "set", ...Array.from(arguments)})}
static /*Swift.(file).Mirror.DisplayStyle.==(_:Mirror.DisplayStyle,_:Mirror.DisplayStyle)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).Mirror.DisplayStyle.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Mirror.DisplayStyle.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Mirror.DisplayStyle.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Mirror.DisplayStyle.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


/*Swift.(file).Mirror.init(_:Subject,children:C,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation)*/
/*Swift.(file).Mirror.init(_:Subject,children:C,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation)*/
initChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation<Subject, C>(subject, children, displayStyle, ancestorRepresentation, $info?) {
throw 'unsupported method Swift.(file).Mirror.init(_:Subject,children:C,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation) in ' + this.constructor.name
}
/*Swift.(file).Mirror.init(_:Subject,unlabeledChildren:C,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation)*/
/*Swift.(file).Mirror.init(_:Subject,unlabeledChildren:C,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation)*/
initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation<Subject, C>(subject, unlabeledChildren, displayStyle, ancestorRepresentation, $info?) {
throw 'unsupported method Swift.(file).Mirror.init(_:Subject,unlabeledChildren:C,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation) in ' + this.constructor.name
}
/*Swift.(file).Mirror.init(_:Subject,children:KeyValuePairs<String, Any>,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation)*/
/*Swift.(file).Mirror.init(_:Subject,children:KeyValuePairs<String, Any>,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation)*/
initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation<Subject>(subject, children, displayStyle, ancestorRepresentation, $info?) {
throw 'unsupported method Swift.(file).Mirror.init(_:Subject,children:KeyValuePairs<String, Any>,displayStyle:Mirror.DisplayStyle?,ancestorRepresentation:Mirror.AncestorRepresentation) in ' + this.constructor.name
}

/*Swift.(file).Mirror.subjectType*/
readonly subjectType$get() {
throw 'unsupported variable Swift.(file).Mirror.subjectType in ' + this.constructor.name
}
readonly get subjectType() { return this.subjectType$get() };




/*Swift.(file).Mirror.children*/
readonly children$get() {
throw 'unsupported variable Swift.(file).Mirror.children in ' + this.constructor.name
}
readonly get children() { return this.children$get() };




/*Swift.(file).Mirror.displayStyle*/
readonly displayStyle$get() {
throw 'unsupported variable Swift.(file).Mirror.displayStyle in ' + this.constructor.name
}
readonly get displayStyle() { return this.displayStyle$get() };




/*Swift.(file).Mirror.superclassMirror*/
superclassMirror$get() {
let _this = this;
return _this._makeSuperclassMirror( {})
}
get superclassMirror() { return this.superclassMirror$get() };









/*Swift.(file).Mirror.init(internalReflecting:Any,subjectType:Any.Type?,customAncestor:Mirror?)*/
/*Swift.(file).Mirror.init(internalReflecting:Any,subjectType:Any.Type?,customAncestor:Mirror?)*/
initInternalReflectingprotocol_composition_typeSubjectTypeOptionalCustomAncestorOptional(subject, subjectType, customAncestor, $info?) {
throw 'unsupported method Swift.(file).Mirror.init(internalReflecting:Any,subjectType:Any.Type?,customAncestor:Mirror?) in ' + this.constructor.name
}
static /*Swift.(file).Mirror.quickLookObject(_:Any)*/
/*Swift.(file).Mirror.quickLookObject(_:Any)*/
quickLookObject(subject, $info?) {
let _this = this;
const object = _getQuickLookObject(subject);
return object.flatMap(_getClassPlaygroundQuickLook)
}
static _Dummy = class implements CustomReflectable{
static readonly $struct = true
/*Swift.(file).Mirror._Dummy.init(mirror:Mirror)*/
/*Swift.(file).Mirror._Dummy.init(mirror:Mirror)*/
initMirrorMirror(mirror, $info?) {
throw 'unsupported method Swift.(file).Mirror._Dummy.init(mirror:Mirror) in ' + this.constructor.name
}

/*Swift.(file).Mirror._Dummy.mirror*/
mirror$get() {
throw 'unsupported variable Swift.(file).Mirror._Dummy.mirror in ' + this.constructor.name
}
get mirror() { return this.mirror$get() };






/*Swift.(file).Mirror._Dummy.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Mirror._Dummy.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}
/*Swift.(file).Mirror.descendant(_:MirrorPath,_:[MirrorPath])*/
/*Swift.(file).Mirror.descendant(_:MirrorPath,_:[MirrorPath])*/
descendant(first, rest, $info?) {
let _this = this;
let result = _cloneStruct(_create(Mirror._Dummy, 'initMirrorMirror', _this, {}));
{
let $e$generator = _cloneStruct(Array.$add(_create(Array, 'initArrayLiteralArray', [first], {}), rest).makeIterator( {}));
while(true) {
const $ifLet0, e_1;
if(!((($ifLet0 = $e$generator.next( {$setThis: $val => $e$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e_1 = $ifLet0[0])||true))) break
const children = _cloneStruct(_create(Mirror, 'initReflectingprotocol_composition_type', result, {}).children);
const position;
const $ifLet2, label_3
if((($ifLet2 = e_1)||true) && $ifLet2 instanceof String && ((label_3 = $ifLet2)||true)) {
position = _cloneStruct($nilCoalescing(children.firstIndexWhere((($0, $info?) => Optional.$equal($0["0"], _injectIntoOptional(label_3)))), () => children.endIndex));
}
else {const $ifLet4, offset_5
if((($ifLet4 = _injectIntoOptional(e_1))||true) && $ifLet4.rawValue == 'some' && ((offset_5 = $ifLet4[0])||true)) {
position = _cloneStruct($nilCoalescing(children.indexOffsetByLimitedBy(children.startIndex, offset_5, children.endIndex), () => children.endIndex));
}
else {
preconditionFailureFileLine(() => "Someone added a conformance to MirrorPath; that privilege is reserved to the standard library", null, null);
}
};
if((AnyIndex.$equal(position, children.endIndex))) {
return _injectIntoOptional(null);
};
result = _cloneStruct(children.subscript$get(position)["1"]);
}
};
return _injectIntoOptional(result)
}

/*Swift.(file).Mirror.description*/
description$get() {
let _this = this;
return (("Mirror for ") + (_this.subjectType) + (""))
}
get description() { return this.description$get() };




/*Swift.(file).Mirror.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([]), , , {})
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}
_mixin(Mirror._DefaultDescendantRepresentation, _DefaultEnumImplementation, false)
_mixin(Mirror.AncestorRepresentation, _DefaultEnumImplementation, false)
_mixin(Mirror.DisplayStyle, _DefaultEnumImplementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(Mirror._Dummy, CustomReflectable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(Mirror, CustomStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(Mirror, CustomReflectable$implementation, false)








interface SIMD<MaskStorage> extends SIMDStorage, Codable, Hashable, CustomStringConvertible, ExpressibleByArrayLiteral{

}
class SIMD$implementation{

/*Swift.(file).SIMD.indices*/
indices$get() {
let _this = this;
return Int.$halfOpenRange(0, _this.scalarCount)
}
get indices() { return this.indices$get() };



/*Swift.(file).SIMD.init(repeating:Self.Scalar)*/
/*Swift.(file).SIMD.init(repeating:Self.Scalar)*/
initRepeating(value, $info?) {
let _this = this;
_this.init( {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set(value, i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return
}
static /*Swift.(file).SIMD.==infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
let result = true;
{
let $i$generator = _cloneStruct(lhs.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result = Bool.$logicalAND(result, () => (_.arg0 = lhs.subscript$get(i_1)).constructor.$equal(_.arg0, rhs.subscript$get(i_1)));
}
};
return result
}
/*Swift.(file).SIMD.hash(into:Hasher)*/
/*Swift.(file).SIMD.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
hasher.combine(_this.subscript$get(i_1), {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
}
/*Swift.(file).SIMD.encode(to:Encoder)*/
/*Swift.(file).SIMD.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
container.encode(_this.subscript$get(i_1), {$setThis: $val => container = $val});
}
}
}
/*Swift.(file).SIMD.init(from:Decoder)*/
/*Swift.(file).SIMD.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
let _this = this;
_this.init( {});
let container = _cloneStruct(decoder.unkeyedContainer( {}));
if(!((Optional.$equal(container.count, _injectIntoOptional(_this.scalarCount))))) {
throw DecodingError.dataCorrupted(_create(DecodingError.Context, 'initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional', decoder.codingPath, (("Expected vector with exactly ") + (Int.prototype.description$get.call(_this.scalarCount)) + (" elements.")), , {}));
};
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set(container.decode(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), {$setThis: $val => container = $val}), i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return
}

/*Swift.(file).SIMD.description*/
description$get() {
let _this = this;
return String.$add(String.$add((("") + (_this.constructor) + ("(")), _this.indices.mapSwift((($0, $info?) => (("") + (_this.subscript$get($0)) + ("")))).joinedSeparator(", ")), ")")
}
get description() { return this.description$get() };



static /*Swift.(file).SIMD..==infix(_:Self,_:Self)*/
/*Swift.(file).SIMD..==infix(_:Self,_:Self)*/
infix_46_61_61(lhs, rhs, $info?) {
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1)).constructor.$equal(_.arg0, rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD..!=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD..!=infix(_:Self,_:Self)*/
infix_46_33_61(lhs, rhs, $info?) {
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1)).constructor.$notEqual(_.arg0, rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).SIMD.replace(with:Self,where:SIMDMask<Self.MaskStorage>)*/
/*Swift.(file).SIMD.replace(with:Self,where:SIMDMask<Self.MaskStorage>)*/
replaceWithWhere(other, mask, $info?) {
let _this = this;
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set((mask.subscript$get(i_1) ? other.subscript$get(i_1) : _this.subscript$get(i_1)), i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file).SIMD.init(arrayLiteral:[Self.Scalar])*/
/*Swift.(file).SIMD.init(arrayLiteral:[Self.Scalar])*/
initArrayLiteralArray(scalars, $info?) {
let _this = this;
_this.init(scalars);
return
}
/*Swift.(file).SIMD.init(_:S)*/
/*Swift.(file).SIMD.init(_:S)*/
init<S>(scalars, $info?) {
let _this = this;
_this.init( {});
let index = 0;
{
let $scalar$generator = scalars.makeIterator( {});
while(true) {
const $ifLet0, scalar_1;
if(!((($ifLet0 = $scalar$generator.next( {$setThis: $val => $scalar$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((scalar_1 = $ifLet0[0])||true))) break
if((Int.$equal(index, _this.scalarCount))) {
preconditionFailureFileLine(() => "Too many elements in sequence.", null, null);
};
_this.subscript$set(scalar_1, index, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
Int.$addAndAssign({get: () => index, set: $val => index = $val}, 1);
}
};
if((Int.$lessThan(index, _this.scalarCount))) {
preconditionFailureFileLine(() => "Not enough elements in sequence.", null, null);
};
return
}
/*Swift.(file).SIMD.subscript(_:SIMD2<Index>)*/
/*Swift.(file).SIMD.subscript(_:SIMD2<Index>)*/
subscript$get<Index>(index, $info?) {
let _this = this;
let result = _create(SIMD2, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_this.subscript$get(Int.$remainder(_create(Int, 'initT', index.subscript$get(i_1), {}), _this.scalarCount)), i_1, {$setThis: $val => result = $val});
}
};
return result
}

/*Swift.(file).SIMD.subscript(_:SIMD3<Index>)*/
/*Swift.(file).SIMD.subscript(_:SIMD3<Index>)*/
/*!!!DUPLICATE NAME*/
subscript$get<Index>(index, $info?) {
let _this = this;
let result = _create(SIMD3, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_this.subscript$get(Int.$remainder(_create(Int, 'initT', index.subscript$get(i_1), {}), _this.scalarCount)), i_1, {$setThis: $val => result = $val});
}
};
return result
}

/*Swift.(file).SIMD.subscript(_:SIMD4<Index>)*/
/*Swift.(file).SIMD.subscript(_:SIMD4<Index>)*/
/*!!!DUPLICATE NAME*/
subscript$get<Index>(index, $info?) {
let _this = this;
let result = _create(SIMD4, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_this.subscript$get(Int.$remainder(_create(Int, 'initT', index.subscript$get(i_1), {}), _this.scalarCount)), i_1, {$setThis: $val => result = $val});
}
};
return result
}

/*Swift.(file).SIMD.subscript(_:SIMD8<Index>)*/
/*Swift.(file).SIMD.subscript(_:SIMD8<Index>)*/
/*!!!DUPLICATE NAME*/
subscript$get<Index>(index, $info?) {
let _this = this;
let result = _create(SIMD8, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_this.subscript$get(Int.$remainder(_create(Int, 'initT', index.subscript$get(i_1), {}), _this.scalarCount)), i_1, {$setThis: $val => result = $val});
}
};
return result
}

/*Swift.(file).SIMD.subscript(_:SIMD16<Index>)*/
/*Swift.(file).SIMD.subscript(_:SIMD16<Index>)*/
/*!!!DUPLICATE NAME*/
subscript$get<Index>(index, $info?) {
let _this = this;
let result = _create(SIMD16, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_this.subscript$get(Int.$remainder(_create(Int, 'initT', index.subscript$get(i_1), {}), _this.scalarCount)), i_1, {$setThis: $val => result = $val});
}
};
return result
}

/*Swift.(file).SIMD.subscript(_:SIMD32<Index>)*/
/*Swift.(file).SIMD.subscript(_:SIMD32<Index>)*/
/*!!!DUPLICATE NAME*/
subscript$get<Index>(index, $info?) {
let _this = this;
let result = _create(SIMD32, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_this.subscript$get(Int.$remainder(_create(Int, 'initT', index.subscript$get(i_1), {}), _this.scalarCount)), i_1, {$setThis: $val => result = $val});
}
};
return result
}

/*Swift.(file).SIMD.subscript(_:SIMD64<Index>)*/
/*Swift.(file).SIMD.subscript(_:SIMD64<Index>)*/
/*!!!DUPLICATE NAME*/
subscript$get<Index>(index, $info?) {
let _this = this;
let result = _create(SIMD64, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_this.subscript$get(Int.$remainder(_create(Int, 'initT', index.subscript$get(i_1), {}), _this.scalarCount)), i_1, {$setThis: $val => result = $val});
}
};
return result
}

static /*Swift.(file).SIMD..<infix(_:Self,_:Self)*/
/*Swift.(file).SIMD..<infix(_:Self,_:Self)*/
infix_46_60(lhs, rhs, $info?) {
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1)).constructor.$lessThan(_.arg0, rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD..<=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD..<=infix(_:Self,_:Self)*/
infix_46_60_61(lhs, rhs, $info?) {
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1)).constructor.$lessThanOrEqual(_.arg0, rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).SIMD.min()*/
/*Swift.(file).SIMD.min()*/
min($info?) {
let _this = this;
return _this.indices.reduceInto(_this.subscript$get(0), (($0$inout, $1, $info?) => $0 = min($0, _this.subscript$get($1))))
}
/*Swift.(file).SIMD.max()*/
/*Swift.(file).SIMD.max()*/
max($info?) {
let _this = this;
return _this.indices.reduceInto(_this.subscript$get(0), (($0$inout, $1, $info?) => $0 = max($0, _this.subscript$get($1))))
}
static /*Swift.(file).SIMD..==infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD..==infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_46_61_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_61_61(_.arg0, rhs)
}
static /*Swift.(file).SIMD..!=infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD..!=infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_46_33_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_33_61(_.arg0, rhs)
}
static /*Swift.(file).SIMD..==infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD..==infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_46_61_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_61_61(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD..!=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD..!=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_46_33_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_33_61(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
/*Swift.(file).SIMD.replace(with:Self.Scalar,where:SIMDMask<Self.MaskStorage>)*/
/*Swift.(file).SIMD.replace(with:Self.Scalar,where:SIMDMask<Self.MaskStorage>)*/
/*!!!DUPLICATE NAME*/
replaceWithWhere(other, mask, $info?) {
let _this = this;
_this.replaceWithWhere(_create(_this.constructor, 'initRepeating', other, {}), mask, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).SIMD.replacing(with:Self,where:SIMDMask<Self.MaskStorage>)*/
/*Swift.(file).SIMD.replacing(with:Self,where:SIMDMask<Self.MaskStorage>)*/
replacingWithWhere(other, mask, $info?) {
let _this = this;
let result = _this;
result.replaceWithWhere(other, mask, {$setThis: $val => result = $val});
return result
}
/*Swift.(file).SIMD.replacing(with:Self.Scalar,where:SIMDMask<Self.MaskStorage>)*/
/*Swift.(file).SIMD.replacing(with:Self.Scalar,where:SIMDMask<Self.MaskStorage>)*/
/*!!!DUPLICATE NAME*/
replacingWithWhere(other, mask, $info?) {
let _this = this;
return _this.replacingWithWhere(_create(_this.constructor, 'initRepeating', other, {}), mask)
}
static /*Swift.(file).SIMD..>=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD..>=infix(_:Self,_:Self)*/
infix_46_62_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.infix_46_60_61(_.arg0, lhs)
}
static /*Swift.(file).SIMD..>infix(_:Self,_:Self)*/
/*Swift.(file).SIMD..>infix(_:Self,_:Self)*/
infix_46_62(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.infix_46_60(_.arg0, lhs)
}
static /*Swift.(file).SIMD..<infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD..<infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_46_60(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_60(_.arg0, rhs)
}
static /*Swift.(file).SIMD..<=infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD..<=infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_46_60_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_60_61(_.arg0, rhs)
}
static /*Swift.(file).SIMD..>=infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD..>=infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_46_62_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_62_61(_.arg0, rhs)
}
static /*Swift.(file).SIMD..>infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD..>infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_46_62(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_62(_.arg0, rhs)
}
static /*Swift.(file).SIMD..<infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD..<infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_46_60(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_60(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD..<=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD..<=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_46_60_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_60_61(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD..>=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD..>=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_46_62_61(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_62_61(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD..>infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD..>infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_46_62(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_62(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
/*Swift.(file).SIMD.clamp(lowerBound:Self,upperBound:Self)*/
/*Swift.(file).SIMD.clamp(lowerBound:Self,upperBound:Self)*/
clampLowerBoundUpperBound(lowerBound, upperBound, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.clampedLowerBoundUpperBound(lowerBound, upperBound)))
}
/*Swift.(file).SIMD.clamped(lowerBound:Self,upperBound:Self)*/
/*Swift.(file).SIMD.clamped(lowerBound:Self,upperBound:Self)*/
clampedLowerBoundUpperBound(lowerBound, upperBound, $info?) {
let _this = this;
return pointwiseMin(upperBound, pointwiseMax(lowerBound, _this))
}

/*Swift.(file).SIMD.zero*/
static zero$get() {
let _this = this;
return _create(_this, 'init', {});
}
static get zero() { return this.zero$get()
}
static get zero() { return this.zero$get() };




/*Swift.(file).SIMD.one*/
static one$get() {
let _this = this;
return _create(_this, 'initRepeating', 1, {});
}
static get one() { return this.one$get()
}
static get one() { return this.one$get() };



static /*Swift.(file).SIMD.random(in:Range<Self.Scalar>,using:T)*/
/*Swift.(file).SIMD.random(in:Range<Self.Scalar>,using:T)*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).SIMD.random(in:Range<Self.Scalar>)*/
/*Swift.(file).SIMD.random(in:Range<Self.Scalar>)*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}
static /*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>,using:T)*/
/*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>,using:T)*/
/*!!!DUPLICATE NAME*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>)*/
/*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>)*/
/*!!!DUPLICATE NAME*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}

/*Swift.(file).SIMD.zero*/
static zero$get() {
let _this = this;
return _create(_this, 'init', {});
}
static get zero() { return this.zero$get()
}
static get zero() { return this.zero$get() };




/*Swift.(file).SIMD.one*/
static one$get() {
let _this = this;
return _create(_this, 'initRepeating', 1, {});
}
static get one() { return this.one$get()
}
static get one() { return this.one$get() };



/*Swift.(file).SIMD.clamp(lowerBound:Self,upperBound:Self)*/
/*Swift.(file).SIMD.clamp(lowerBound:Self,upperBound:Self)*/
clampLowerBoundUpperBound(lowerBound, upperBound, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.clampedLowerBoundUpperBound(lowerBound, upperBound)))
}
/*Swift.(file).SIMD.clamped(lowerBound:Self,upperBound:Self)*/
/*Swift.(file).SIMD.clamped(lowerBound:Self,upperBound:Self)*/
clampedLowerBoundUpperBound(lowerBound, upperBound, $info?) {
let _this = this;
return pointwiseMin(upperBound, pointwiseMax(lowerBound, _this))
}
static /*Swift.(file).SIMD.random(in:Range<Self.Scalar>,using:T)*/
/*Swift.(file).SIMD.random(in:Range<Self.Scalar>,using:T)*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).SIMD.random(in:Range<Self.Scalar>)*/
/*Swift.(file).SIMD.random(in:Range<Self.Scalar>)*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}
static /*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>,using:T)*/
/*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>,using:T)*/
/*!!!DUPLICATE NAME*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>)*/
/*Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>)*/
/*!!!DUPLICATE NAME*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}

/*Swift.(file).SIMD.leadingZeroBitCount*/
leadingZeroBitCount$get() {
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_create(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), 'initT', ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.leadingZeroBitCount$get.call(_this.subscript$get(i_1)), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).SIMD.trailingZeroBitCount*/
trailingZeroBitCount$get() {
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_create(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), 'initT', ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.trailingZeroBitCount$get.call(_this.subscript$get(i_1)), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).SIMD.nonzeroBitCount*/
nonzeroBitCount$get() {
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_create(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), 'initT', ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.nonzeroBitCount$get.call(_this.subscript$get(i_1)), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static /*Swift.(file).SIMD.~prefix(_:Self)*/
/*Swift.(file).SIMD.~prefix(_:Self)*/
$bitwiseNot(rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$bitwiseNot(rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.&infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$bitwiseAND(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.^infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$bitwiseXOR(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.|infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$bitwiseOR(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.&<<infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_60_60(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.&>>infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_62_62(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.&+infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&+infix(_:Self,_:Self)*/
$addWithOverflow(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$addWithOverflow(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.&-infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&-infix(_:Self,_:Self)*/
$subtractWithOverflow(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$subtractWithOverflow(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.&*infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&*infix(_:Self,_:Self)*/
$multiplyIgnoringOverflow(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$multiplyIgnoringOverflow(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD./infix(_:Self,_:Self)*/
/*Swift.(file).SIMD./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$divide(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.%infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$remainder(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).SIMD.wrappedSum()*/
/*Swift.(file).SIMD.wrappedSum()*/
wrappedSum($info?) {
let _this = this;
return _this.indices.reduceInto(0, (($0$inout, $1, $info?) => ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_43_61({get: () => $0, set: $val => $0 = $val}, _this.subscript$get($1))))
}
static /*Swift.(file).SIMD.+infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$add(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.-infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$subtract(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.*infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$multiply(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD./infix(_:Self,_:Self)*/
/*Swift.(file).SIMD./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$divide(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).SIMD.addingProduct(_:Self,_:Self)*/
/*Swift.(file).SIMD.addingProduct(_:Self,_:Self)*/
addingProduct(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.addingProduct.call(_this.subscript$get(i_1), lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).SIMD.squareRoot()*/
/*Swift.(file).SIMD.squareRoot()*/
squareRoot($info?) {
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.squareRoot.call(_this.subscript$get(i_1), ), i_1, {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).SIMD.rounded(_:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD.rounded(_:FloatingPointRoundingRule)*/
rounded(rule, $info?) {
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.rounded.call(_this.subscript$get(i_1), rule), i_1, {$setThis: $val => result = $val});
}
};
return result
}
/*Swift.(file).SIMD.min()*/
/*Swift.(file).SIMD.min()*/
min($info?) {
let _this = this;
return _this.indices.reduceInto(_this.subscript$get(0), (($0$inout, $1, $info?) => $0 = min($0, _this.subscript$get($1))))
}
/*Swift.(file).SIMD.max()*/
/*Swift.(file).SIMD.max()*/
max($info?) {
let _this = this;
return _this.indices.reduceInto(_this.subscript$get(0), (($0$inout, $1, $info?) => $0 = max($0, _this.subscript$get($1))))
}
/*Swift.(file).SIMD.sum()*/
/*Swift.(file).SIMD.sum()*/
sum($info?) {
let _this = this;
return _this.indices.reduceInto(0, (($0$inout, $1, $info?) => ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$addAndAssign({get: () => $0, set: $val => $0 = $val}, _this.subscript$get($1))))
}
static /*Swift.(file).SIMD.&infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.&infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$bitwiseAND(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$bitwiseAND(_.arg0, rhs)
}
static /*Swift.(file).SIMD.^infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.^infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$bitwiseXOR(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$bitwiseXOR(_.arg0, rhs)
}
static /*Swift.(file).SIMD.|infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.|infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$bitwiseOR(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$bitwiseOR(_.arg0, rhs)
}
static /*Swift.(file).SIMD.&<<infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.&<<infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_38_60_60(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38_60_60(_.arg0, rhs)
}
static /*Swift.(file).SIMD.&>>infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.&>>infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
infix_38_62_62(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38_62_62(_.arg0, rhs)
}
static /*Swift.(file).SIMD.&+infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.&+infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$addWithOverflow(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$addWithOverflow(_.arg0, rhs)
}
static /*Swift.(file).SIMD.&-infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.&-infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$subtractWithOverflow(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$subtractWithOverflow(_.arg0, rhs)
}
static /*Swift.(file).SIMD.&*infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.&*infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$multiplyIgnoringOverflow(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$multiplyIgnoringOverflow(_.arg0, rhs)
}
static /*Swift.(file).SIMD./infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD./infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$divide(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$divide(_.arg0, rhs)
}
static /*Swift.(file).SIMD.%infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.%infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$remainder(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$remainder(_.arg0, rhs)
}
static /*Swift.(file).SIMD.&infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$bitwiseAND(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$bitwiseAND(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.^infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.^infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$bitwiseXOR(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$bitwiseXOR(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.|infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.|infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$bitwiseOR(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$bitwiseOR(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.&<<infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&<<infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_38_60_60(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_38_60_60(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.&>>infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&>>infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_38_62_62(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.infix_38_62_62(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.&+infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&+infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$addWithOverflow(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$addWithOverflow(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.&-infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&-infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$subtractWithOverflow(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$subtractWithOverflow(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.&*infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&*infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$multiplyIgnoringOverflow(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$multiplyIgnoringOverflow(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD./infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD./infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$divide(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$divide(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.%infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.%infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$remainder(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$remainder(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.&=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$bitwiseAND(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.^=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$bitwiseXOR(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.|=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$bitwiseOR(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&<<=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_60_60(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&>>=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_62_62(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&+=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&+=infix(_:Self,_:Self)*/
infix_38_43_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$addWithOverflow(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&-=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&-=infix(_:Self,_:Self)*/
infix_38_45_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$subtractWithOverflow(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&*=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.&*=infix(_:Self,_:Self)*/
infix_38_42_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$multiplyIgnoringOverflow(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD./=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$divide(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.%=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$remainder(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$bitwiseAND(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.^=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.^=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$bitwiseXOR(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.|=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.|=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$bitwiseOR(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&<<=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&<<=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_60_60(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&>>=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&>>=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_62_62(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&+=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&+=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_38_43_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$addWithOverflow(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&-=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&-=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_38_45_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$subtractWithOverflow(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.&*=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.&*=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
infix_38_42_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$multiplyIgnoringOverflow(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD./=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD./=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$divideAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$divide(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.%=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.%=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$remainder(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.+infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$add(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.-infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$subtract(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.*infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).$multiply(lhs.subscript$get(i_1), rhs.subscript$get(i_1)), i_1, {$setThis: $val => result = $val});
}
};
return result
}
static /*Swift.(file).SIMD.+infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.+infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$add(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.-infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.-infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$subtract(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.*infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.*infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$multiply(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.+infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.+infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$add(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.-infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.-infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$subtract(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.*infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.*infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$multiply(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.+=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.-=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.*=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.+=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.+=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$addAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.-=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.-=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.*=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.*=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.-prefix(_:Self)*/
/*Swift.(file).SIMD.-prefix(_:Self)*/
$negate(rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$subtract(0, _.arg0)
}
static /*Swift.(file).SIMD.+infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.+infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$add(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.-infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.-infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$subtract(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.*infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.*infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$multiply(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD./infix(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD./infix(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
$divide(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.$divide(_.arg0, rhs)
}
static /*Swift.(file).SIMD.+infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.+infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$add(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.-infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.-infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$subtract(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD.*infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.*infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$multiply(lhs, rhs, $info?) {
let _this = this;
fatalErrorFileLine( null, null, null)
}
static /*Swift.(file).SIMD./infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD./infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$divide(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs).constructor.$divide(_.arg0, _create(_this, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMD.+=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.-=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.*=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD./=infix(_:Self,_:Self)*/
/*Swift.(file).SIMD./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$divide(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.+=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.+=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$addAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.-=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.-=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD.*=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.*=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine( null, null, null);})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMD./=infix(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD./=infix(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
$divideAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.$divide(_.arg0, rhs);})()
lhs$inout.set(lhs)
return $result
}
/*Swift.(file).SIMD.addingProduct(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.addingProduct(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
addingProduct(lhs, rhs, $info?) {
let _this = this;
return _this.addingProduct(_create(_this.constructor, 'initRepeating', lhs, {}), rhs)
}
/*Swift.(file).SIMD.addingProduct(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.addingProduct(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
addingProduct(lhs, rhs, $info?) {
let _this = this;
return _this.addingProduct(lhs, _create(_this.constructor, 'initRepeating', rhs, {}))
}
/*Swift.(file).SIMD.addProduct(_:Self,_:Self)*/
/*Swift.(file).SIMD.addProduct(_:Self,_:Self)*/
addProduct(lhs, rhs, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.addingProduct(lhs, rhs)))
}
/*Swift.(file).SIMD.addProduct(_:Self.Scalar,_:Self)*/
/*Swift.(file).SIMD.addProduct(_:Self.Scalar,_:Self)*/
/*!!!DUPLICATE NAME*/
addProduct(lhs, rhs, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.addingProduct(lhs, rhs)))
}
/*Swift.(file).SIMD.addProduct(_:Self,_:Self.Scalar)*/
/*Swift.(file).SIMD.addProduct(_:Self,_:Self.Scalar)*/
/*!!!DUPLICATE NAME*/
addProduct(lhs, rhs, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.addingProduct(lhs, rhs)))
}
/*Swift.(file).SIMD.formSquareRoot()*/
/*Swift.(file).SIMD.formSquareRoot()*/
formSquareRoot($info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.squareRoot( {})))
}
/*Swift.(file).SIMD.round(_:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD.round(_:FloatingPointRoundingRule)*/
round(rule, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.rounded(rule)))
}
static /*Swift.(file).SIMD.sqrt(_:Self)*/
/*Swift.(file).SIMD.sqrt(_:Self)*/
sqrt(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.sqrt(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.cos(_:Self)*/
/*Swift.(file).SIMD.cos(_:Self)*/
cos(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.cos(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.sin(_:Self)*/
/*Swift.(file).SIMD.sin(_:Self)*/
sin(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.sin(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.tan(_:Self)*/
/*Swift.(file).SIMD.tan(_:Self)*/
tan(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.tan(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.acos(_:Self)*/
/*Swift.(file).SIMD.acos(_:Self)*/
acos(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.acos(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.asin(_:Self)*/
/*Swift.(file).SIMD.asin(_:Self)*/
asin(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.asin(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.atan(_:Self)*/
/*Swift.(file).SIMD.atan(_:Self)*/
atan(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.atan(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.cosh(_:Self)*/
/*Swift.(file).SIMD.cosh(_:Self)*/
cosh(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.cosh(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.sinh(_:Self)*/
/*Swift.(file).SIMD.sinh(_:Self)*/
sinh(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.sinh(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.tanh(_:Self)*/
/*Swift.(file).SIMD.tanh(_:Self)*/
tanh(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.tanh(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.acosh(_:Self)*/
/*Swift.(file).SIMD.acosh(_:Self)*/
acosh(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.acosh(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.asinh(_:Self)*/
/*Swift.(file).SIMD.asinh(_:Self)*/
asinh(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.asinh(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.atanh(_:Self)*/
/*Swift.(file).SIMD.atanh(_:Self)*/
atanh(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.atanh(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.exp(_:Self)*/
/*Swift.(file).SIMD.exp(_:Self)*/
exp(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.exp(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.exp2(_:Self)*/
/*Swift.(file).SIMD.exp2(_:Self)*/
exp2(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.exp2(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.exp10(_:Self)*/
/*Swift.(file).SIMD.exp10(_:Self)*/
exp10(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.exp10(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.expm1(_:Self)*/
/*Swift.(file).SIMD.expm1(_:Self)*/
expm1(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.expm1(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.log(_:Self)*/
/*Swift.(file).SIMD.log(_:Self)*/
log(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.log(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.log2(_:Self)*/
/*Swift.(file).SIMD.log2(_:Self)*/
log2(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.log2(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.log10(_:Self)*/
/*Swift.(file).SIMD.log10(_:Self)*/
log10(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.log10(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.log1p(_:Self)*/
/*Swift.(file).SIMD.log1p(_:Self)*/
log1p(x, $info?) {
throw 'unsupported method Swift.(file).SIMD.log1p(_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.pow(_:Self,_:Self)*/
/*Swift.(file).SIMD.pow(_:Self,_:Self)*/
pow(x, y, $info?) {
throw 'unsupported method Swift.(file).SIMD.pow(_:Self,_:Self) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.pow(_:Self,_:Int)*/
/*Swift.(file).SIMD.pow(_:Self,_:Int)*/
/*!!!DUPLICATE NAME*/
pow(x, n, $info?) {
throw 'unsupported method Swift.(file).SIMD.pow(_:Self,_:Int) in ' + this.constructor.name
}
static /*Swift.(file).SIMD.root(_:Self,_:Int)*/
/*Swift.(file).SIMD.root(_:Self,_:Int)*/
root(x, n, $info?) {
throw 'unsupported method Swift.(file).SIMD.root(_:Self,_:Int) in ' + this.constructor.name
}
}
if(typeof SIMDStorage$implementation != 'undefined') _mixin(SIMD$implementation, SIMDStorage$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(SIMD$implementation, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(SIMD$implementation, Hashable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(SIMD$implementation, CustomStringConvertible$implementation, false)
if(typeof ExpressibleByArrayLiteral$implementation != 'undefined') _mixin(SIMD$implementation, ExpressibleByArrayLiteral$implementation, false)


























class SIMDMask<Storage> implements SIMD{
static readonly $struct = true








/*Swift.(file).SIMDMask.scalarCount*/
scalarCount$get() {
let _this = this;
return _this._storage.scalarCount
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMDMask.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
let _this = this;
_this._storage = _create(((function(){throw '!unclarifiedGeneric:Storage'})()), 'init', {});
return
}
/*Swift.(file).SIMDMask.init(_:Storage)*/
/*Swift.(file).SIMDMask.init(_:Storage)*/
/*!!!DUPLICATE NAME*/
init(_storage, $info?) {
let _this = this;
_this._storage = _storage;
return
}
/*Swift.(file).SIMDMask.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
let _this = this;
preconditionFileLine(() => _this.indices.contains(index), null, null, null);
return ((function(){throw '!unclarifiedGeneric:Storage.Scalar'})()).$lessThan(_this._storage.subscript$get(index), 0);

}/*Swift.(file).SIMDMask.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
let _this = this;
preconditionFileLine(() => _this.indices.contains(index), null, null, null);
_this._storage.subscript$set((newValue ? -1 : 0), index, {$setThis: $val => _this._storage = $val})
}






/*Swift.(file).SIMDMask.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMDMask.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).SIMDMask.random(using:T)*/
/*Swift.(file).SIMDMask.random(using:T)*/
randomUsing<T>(generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(Bool.randomUsing({get: () => generator, set: $val => generator = $val}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).SIMDMask.random()*/
/*Swift.(file).SIMDMask.random()*/
random($info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return SIMDMask.randomUsing({get: () => g, set: $val => g = $val})
}
static /*Swift.(file).SIMDMask..!prefix(_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..!prefix(_:SIMDMask<Storage>)*/
prefix_46_33(rhs, $info?) {
let _this = this;
return _create(SIMDMask, 'init', ((function(){throw '!unclarifiedGeneric:Storage'})()).$bitwiseNot(rhs._storage), {})
}
static /*Swift.(file).SIMDMask..&infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..&infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
infix_46_38(lhs, rhs, $info?) {
let _this = this;
return _create(SIMDMask, 'init', (_.arg0 = lhs._storage).constructor.$bitwiseAND(_.arg0, rhs._storage), {})
}
static /*Swift.(file).SIMDMask..^infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..^infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
infix_46_94(lhs, rhs, $info?) {
let _this = this;
return _create(SIMDMask, 'init', (_.arg0 = lhs._storage).constructor.$bitwiseXOR(_.arg0, rhs._storage), {})
}
static /*Swift.(file).SIMDMask..|infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..|infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
infix_46_124(lhs, rhs, $info?) {
let _this = this;
return _create(SIMDMask, 'init', (_.arg0 = lhs._storage).constructor.$bitwiseOR(_.arg0, rhs._storage), {})
}
static /*Swift.(file).SIMDMask..&infix(_:Bool,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..&infix(_:Bool,_:SIMDMask<Storage>)*/
/*!!!DUPLICATE NAME*/
infix_46_38(lhs, rhs, $info?) {
let _this = this;
return SIMDMask.infix_46_38(_create(SIMDMask, 'initRepeating', lhs, {}), rhs)
}
static /*Swift.(file).SIMDMask..^infix(_:Bool,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..^infix(_:Bool,_:SIMDMask<Storage>)*/
/*!!!DUPLICATE NAME*/
infix_46_94(lhs, rhs, $info?) {
let _this = this;
return SIMDMask.infix_46_94(_create(SIMDMask, 'initRepeating', lhs, {}), rhs)
}
static /*Swift.(file).SIMDMask..|infix(_:Bool,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..|infix(_:Bool,_:SIMDMask<Storage>)*/
/*!!!DUPLICATE NAME*/
infix_46_124(lhs, rhs, $info?) {
let _this = this;
return SIMDMask.infix_46_124(_create(SIMDMask, 'initRepeating', lhs, {}), rhs)
}
static /*Swift.(file).SIMDMask..&infix(_:SIMDMask<Storage>,_:Bool)*/
/*Swift.(file).SIMDMask..&infix(_:SIMDMask<Storage>,_:Bool)*/
/*!!!DUPLICATE NAME*/
infix_46_38(lhs, rhs, $info?) {
let _this = this;
return SIMDMask.infix_46_38(lhs, _create(SIMDMask, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMDMask..^infix(_:SIMDMask<Storage>,_:Bool)*/
/*Swift.(file).SIMDMask..^infix(_:SIMDMask<Storage>,_:Bool)*/
/*!!!DUPLICATE NAME*/
infix_46_94(lhs, rhs, $info?) {
let _this = this;
return SIMDMask.infix_46_94(lhs, _create(SIMDMask, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMDMask..|infix(_:SIMDMask<Storage>,_:Bool)*/
/*Swift.(file).SIMDMask..|infix(_:SIMDMask<Storage>,_:Bool)*/
/*!!!DUPLICATE NAME*/
infix_46_124(lhs, rhs, $info?) {
let _this = this;
return SIMDMask.infix_46_124(lhs, _create(SIMDMask, 'initRepeating', rhs, {}))
}
static /*Swift.(file).SIMDMask..&=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..&=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
infix_46_38_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_38(lhs, rhs));})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMDMask..^=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..^=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
infix_46_94_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_94(lhs, rhs));})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMDMask..|=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
/*Swift.(file).SIMDMask..|=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)*/
infix_46_124_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_124(lhs, rhs));})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMDMask..&=infix(_:SIMDMask<Storage>,_:Bool)*/
/*Swift.(file).SIMDMask..&=infix(_:SIMDMask<Storage>,_:Bool)*/
/*!!!DUPLICATE NAME*/
infix_46_38_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_38(lhs, rhs));})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMDMask..^=infix(_:SIMDMask<Storage>,_:Bool)*/
/*Swift.(file).SIMDMask..^=infix(_:SIMDMask<Storage>,_:Bool)*/
/*!!!DUPLICATE NAME*/
infix_46_94_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_94(lhs, rhs));})()
lhs$inout.set(lhs)
return $result
}
static /*Swift.(file).SIMDMask..|=infix(_:SIMDMask<Storage>,_:Bool)*/
/*Swift.(file).SIMDMask..|=infix(_:SIMDMask<Storage>,_:Bool)*/
/*!!!DUPLICATE NAME*/
infix_46_124_61(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_124(lhs, rhs));})()
lhs$inout.set(lhs)
return $result
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMDMask, SIMD$implementation, false)








class AnyIndex implements Comparable{
static readonly $struct = true





/*Swift.(file).AnyIndex.init(_:BaseIndex)*/
/*Swift.(file).AnyIndex.init(_:BaseIndex)*/
init<BaseIndex>(base, $info?) {
throw 'unsupported method Swift.(file).AnyIndex.init(_:BaseIndex) in ' + this.constructor.name
}
/*Swift.(file).AnyIndex.init(_box:_AnyIndexBox)*/
/*Swift.(file).AnyIndex.init(_box:_AnyIndexBox)*/
init_box_AnyIndexBox(_box, $info?) {
throw 'unsupported method Swift.(file).AnyIndex.init(_box:_AnyIndexBox) in ' + this.constructor.name
}



static /*Swift.(file).AnyIndex.==infix(_:AnyIndex,_:AnyIndex)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).AnyIndex.<infix(_:AnyIndex,_:AnyIndex)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
init$vars() {let _this = this;

}
}
if(typeof Comparable$implementation != 'undefined') _mixin(AnyIndex, Comparable$implementation, false)




interface _AnyCollectionProtocol extends Collection{



}
class _AnyCollectionProtocol$implementation{
}
if(typeof Collection$implementation != 'undefined') _mixin(_AnyCollectionProtocol$implementation, Collection$implementation, false)


class AnyCollection<Element> implements Collection, _AnyCollectionProtocol{
static readonly $struct = true



/*Swift.(file).AnyCollection.init(_box:_AnyCollectionBox<Element>)*/
/*Swift.(file).AnyCollection.init(_box:_AnyCollectionBox<Element>)*/
init_box_AnyCollectionBox(_box, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.init(_box:_AnyCollectionBox<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}
/*Swift.(file).AnyCollection.dropLast(_:Int)*/
/*Swift.(file).AnyCollection.dropLast(_:Int)*/
dropLast(n, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.dropLast(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.prefix(while:(Element) throws -> Bool)*/
/*Swift.(file).AnyCollection.prefix(while:(Element) throws -> Bool)*/
prefixWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.prefix(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.suffix(_:Int)*/
/*Swift.(file).AnyCollection.suffix(_:Int)*/
suffix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.suffix(_:Int) in ' + this.constructor.name
}

/*Swift.(file).AnyCollection.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return 0
}
get underestimatedCount() { return this.underestimatedCount$get() };



/*Swift.(file).AnyCollection.map(_:(Element) throws -> T)*/
/*Swift.(file).AnyCollection.map(_:(Element) throws -> T)*/
mapSwift<T>(transform, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.map(_:(Element) throws -> T) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.filter(_:(Element) throws -> Bool)*/
/*Swift.(file).AnyCollection.filter(_:(Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.filter(_:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.forEach(_:(Element) throws -> Void)*/
/*Swift.(file).AnyCollection.forEach(_:(Element) throws -> Void)*/
forEachSwift(body, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.forEach(_:(Element) throws -> Void) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.drop(while:(Element) throws -> Bool)*/
/*Swift.(file).AnyCollection.drop(while:(Element) throws -> Bool)*/
dropWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.drop(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.dropFirst(_:Int)*/
/*Swift.(file).AnyCollection.dropFirst(_:Int)*/
dropFirst(n, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.dropFirst(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.prefix(_:Int)*/
/*Swift.(file).AnyCollection.prefix(_:Int)*/
prefix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.prefix(_:Int) in ' + this.constructor.name
}







/*Swift.(file).AnyCollection.init(_:C)*/
/*Swift.(file).AnyCollection.init(_:C)*/
init<C>(base, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.init(_:C) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.init(_:AnyCollection<Element>)*/
/*Swift.(file).AnyCollection.init(_:AnyCollection<Element>)*/
initAnyCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.init(_:AnyCollection<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.init(_:C)*/
/*Swift.(file).AnyCollection.init(_:C)*/
init<C>(base, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.init(_:C) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.init(_:AnyBidirectionalCollection<Element>)*/
/*Swift.(file).AnyCollection.init(_:AnyBidirectionalCollection<Element>)*/
initAnyBidirectionalCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.init(_:AnyBidirectionalCollection<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.init(_:C)*/
/*Swift.(file).AnyCollection.init(_:C)*/
init<C>(base, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.init(_:C) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.init(_:AnyRandomAccessCollection<Element>)*/
/*Swift.(file).AnyCollection.init(_:AnyRandomAccessCollection<Element>)*/
initAnyRandomAccessCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.init(_:AnyRandomAccessCollection<Element>) in ' + this.constructor.name
}

/*Swift.(file).AnyCollection.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).AnyCollection.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).AnyCollection.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).AnyCollection.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).AnyCollection.subscript(_:AnyCollection<Element>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.subscript(_:AnyCollection<Element>.Index) in ' + this.constructor.name
}


/*Swift.(file).AnyCollection.subscript(_:Range<AnyCollection<Element>.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}



/*Swift.(file).AnyCollection.index(after:AnyCollection<Element>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.index(after:AnyCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.formIndex(after:AnyCollection<Element>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).AnyCollection.index(_:AnyCollection<Element>.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).AnyCollection.index(_:AnyCollection<Element>.Index,offsetBy:Int,limitedBy:AnyCollection<Element>.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).AnyCollection.formIndex(_:AnyCollection<Element>.Index,offsetBy:Int)*/
/*Swift.(file).AnyCollection.formIndex(_:AnyCollection<Element>.Index,offsetBy:Int)*/
formIndexOffsetBy(i$inout, n, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.formIndex(_:AnyCollection<Element>.Index,offsetBy:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.formIndex(_:AnyCollection<Element>.Index,offsetBy:Int,limitedBy:AnyCollection<Element>.Index)*/
/*Swift.(file).AnyCollection.formIndex(_:AnyCollection<Element>.Index,offsetBy:Int,limitedBy:AnyCollection<Element>.Index)*/
formIndexOffsetByLimitedBy(i$inout, n, limit, $info?) {
throw 'unsupported method Swift.(file).AnyCollection.formIndex(_:AnyCollection<Element>.Index,offsetBy:Int,limitedBy:AnyCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyCollection.distance(from:AnyCollection<Element>.Index,to:AnyCollection<Element>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}

/*Swift.(file).AnyCollection.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };







init$vars() {let _this = this;

}
}
if(typeof Collection$implementation != 'undefined') _mixin(AnyCollection, Collection$implementation, false)
if(typeof _AnyCollectionProtocol$implementation != 'undefined') _mixin(AnyCollection, _AnyCollectionProtocol$implementation, false)






class SIMD2<Scalar> implements SIMD, ElementaryFunctions, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).SIMD2.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMD2.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).SIMD2.init() in ' + this.constructor.name
}
/*Swift.(file).SIMD2.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).SIMD2.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).SIMD2.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).SIMD2.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file).SIMD2.init(_:Scalar,_:Scalar)*/
/*Swift.(file).SIMD2.init(_:Scalar,_:Scalar)*/
/*!!!DUPLICATE NAME*/
init(v0, v1, $info?) {
throw 'unsupported method Swift.(file).SIMD2.init(_:Scalar,_:Scalar) in ' + this.constructor.name
}
/*Swift.(file).SIMD2.init(x:Scalar,y:Scalar)*/
/*Swift.(file).SIMD2.init(x:Scalar,y:Scalar)*/
initXY(x, y, $info?) {
throw 'unsupported method Swift.(file).SIMD2.init(x:Scalar,y:Scalar) in ' + this.constructor.name
}

/*Swift.(file).SIMD2.x*/
x$get() {
throw 'unsupported variable Swift.(file).SIMD2.x in ' + this.constructor.name
}
get x() { return this.x$get() };






/*Swift.(file).SIMD2.y*/
y$get() {
throw 'unsupported variable Swift.(file).SIMD2.y in ' + this.constructor.name
}
get y() { return this.y$get() };










/*Swift.(file).SIMD2.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMD2.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).SIMD2.init(truncatingIfNeeded:SIMD2<Other>)*/
/*Swift.(file).SIMD2.init(truncatingIfNeeded:SIMD2<Other>)*/
initTruncatingIfNeededSIMD2<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD2.init(truncatingIfNeeded:SIMD2<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD2.init(clamping:SIMD2<Other>)*/
/*Swift.(file).SIMD2.init(clamping:SIMD2<Other>)*/
initClampingSIMD2<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD2.init(clamping:SIMD2<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD2.init(_:SIMD2<Other>,rounding:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD2.init(_:SIMD2<Other>,rounding:FloatingPointRoundingRule)*/
initSIMD2RoundingFloatingPointRoundingRule<Other>(other, rule, $info?) {
throw 'unsupported method Swift.(file).SIMD2.init(_:SIMD2<Other>,rounding:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).SIMD2.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).SIMD2.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).SIMD2.init(_:SIMD2<Other>)*/
/*Swift.(file).SIMD2.init(_:SIMD2<Other>)*/
initSIMD2<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD2.init(_:SIMD2<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD2.init(_:SIMD2<Other>)*/
/*Swift.(file).SIMD2.init(_:SIMD2<Other>)*/
initSIMD2<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD2.init(_:SIMD2<Other>) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMD2, SIMD$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(SIMD2, ElementaryFunctions$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(SIMD2, CustomDebugStringConvertible$implementation, false)








class SIMD4<Scalar> implements SIMD, ElementaryFunctions, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).SIMD4.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMD4.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).SIMD4.init() in ' + this.constructor.name
}
/*Swift.(file).SIMD4.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).SIMD4.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).SIMD4.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).SIMD4.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file).SIMD4.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*Swift.(file).SIMD4.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*!!!DUPLICATE NAME*/
init(v0, v1, v2, v3, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar) in ' + this.constructor.name
}
/*Swift.(file).SIMD4.init(x:Scalar,y:Scalar,z:Scalar,w:Scalar)*/
/*Swift.(file).SIMD4.init(x:Scalar,y:Scalar,z:Scalar,w:Scalar)*/
initXYZW(x, y, z, w, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(x:Scalar,y:Scalar,z:Scalar,w:Scalar) in ' + this.constructor.name
}

/*Swift.(file).SIMD4.x*/
x$get() {
throw 'unsupported variable Swift.(file).SIMD4.x in ' + this.constructor.name
}
get x() { return this.x$get() };






/*Swift.(file).SIMD4.y*/
y$get() {
throw 'unsupported variable Swift.(file).SIMD4.y in ' + this.constructor.name
}
get y() { return this.y$get() };






/*Swift.(file).SIMD4.z*/
z$get() {
throw 'unsupported variable Swift.(file).SIMD4.z in ' + this.constructor.name
}
get z() { return this.z$get() };






/*Swift.(file).SIMD4.w*/
w$get() {
throw 'unsupported variable Swift.(file).SIMD4.w in ' + this.constructor.name
}
get w() { return this.w$get() };





/*Swift.(file).SIMD4.init(lowHalf:SIMD2<Scalar>,highHalf:SIMD2<Scalar>)*/
/*Swift.(file).SIMD4.init(lowHalf:SIMD2<Scalar>,highHalf:SIMD2<Scalar>)*/
initLowHalfSIMD2HighHalfSIMD2(lowHalf, highHalf, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(lowHalf:SIMD2<Scalar>,highHalf:SIMD2<Scalar>) in ' + this.constructor.name
}

/*Swift.(file).SIMD4.lowHalf*/
lowHalf$get() {
throw 'unsupported variable Swift.(file).SIMD4.lowHalf in ' + this.constructor.name
}
get lowHalf() { return this.lowHalf$get() };






/*Swift.(file).SIMD4.highHalf*/
highHalf$get() {
throw 'unsupported variable Swift.(file).SIMD4.highHalf in ' + this.constructor.name
}
get highHalf() { return this.highHalf$get() };






/*Swift.(file).SIMD4.evenHalf*/
evenHalf$get() {
throw 'unsupported variable Swift.(file).SIMD4.evenHalf in ' + this.constructor.name
}
get evenHalf() { return this.evenHalf$get() };






/*Swift.(file).SIMD4.oddHalf*/
oddHalf$get() {
throw 'unsupported variable Swift.(file).SIMD4.oddHalf in ' + this.constructor.name
}
get oddHalf() { return this.oddHalf$get() };










/*Swift.(file).SIMD4.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMD4.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).SIMD4.init(truncatingIfNeeded:SIMD4<Other>)*/
/*Swift.(file).SIMD4.init(truncatingIfNeeded:SIMD4<Other>)*/
initTruncatingIfNeededSIMD4<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(truncatingIfNeeded:SIMD4<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD4.init(clamping:SIMD4<Other>)*/
/*Swift.(file).SIMD4.init(clamping:SIMD4<Other>)*/
initClampingSIMD4<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(clamping:SIMD4<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD4.init(_:SIMD4<Other>,rounding:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD4.init(_:SIMD4<Other>,rounding:FloatingPointRoundingRule)*/
initSIMD4RoundingFloatingPointRoundingRule<Other>(other, rule, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(_:SIMD4<Other>,rounding:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).SIMD4.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).SIMD4.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).SIMD4.init(_:SIMD4<Other>)*/
/*Swift.(file).SIMD4.init(_:SIMD4<Other>)*/
initSIMD4<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(_:SIMD4<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD4.init(_:SIMD4<Other>)*/
/*Swift.(file).SIMD4.init(_:SIMD4<Other>)*/
initSIMD4<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(_:SIMD4<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD4.init(_:SIMD3<Scalar>,_:Scalar)*/
/*Swift.(file).SIMD4.init(_:SIMD3<Scalar>,_:Scalar)*/
initSIMD3(xyz, w, $info?) {
throw 'unsupported method Swift.(file).SIMD4.init(_:SIMD3<Scalar>,_:Scalar) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMD4, SIMD$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(SIMD4, ElementaryFunctions$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(SIMD4, CustomDebugStringConvertible$implementation, false)










class SIMD8<Scalar> implements SIMD, ElementaryFunctions, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).SIMD8.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMD8.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).SIMD8.init() in ' + this.constructor.name
}
/*Swift.(file).SIMD8.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).SIMD8.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).SIMD8.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).SIMD8.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file).SIMD8.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*Swift.(file).SIMD8.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*!!!DUPLICATE NAME*/
init(v0, v1, v2, v3, v4, v5, v6, v7, $info?) {
throw 'unsupported method Swift.(file).SIMD8.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar) in ' + this.constructor.name
}
/*Swift.(file).SIMD8.init(lowHalf:SIMD4<Scalar>,highHalf:SIMD4<Scalar>)*/
/*Swift.(file).SIMD8.init(lowHalf:SIMD4<Scalar>,highHalf:SIMD4<Scalar>)*/
initLowHalfSIMD4HighHalfSIMD4(lowHalf, highHalf, $info?) {
throw 'unsupported method Swift.(file).SIMD8.init(lowHalf:SIMD4<Scalar>,highHalf:SIMD4<Scalar>) in ' + this.constructor.name
}

/*Swift.(file).SIMD8.lowHalf*/
lowHalf$get() {
throw 'unsupported variable Swift.(file).SIMD8.lowHalf in ' + this.constructor.name
}
get lowHalf() { return this.lowHalf$get() };






/*Swift.(file).SIMD8.highHalf*/
highHalf$get() {
throw 'unsupported variable Swift.(file).SIMD8.highHalf in ' + this.constructor.name
}
get highHalf() { return this.highHalf$get() };






/*Swift.(file).SIMD8.evenHalf*/
evenHalf$get() {
throw 'unsupported variable Swift.(file).SIMD8.evenHalf in ' + this.constructor.name
}
get evenHalf() { return this.evenHalf$get() };






/*Swift.(file).SIMD8.oddHalf*/
oddHalf$get() {
throw 'unsupported variable Swift.(file).SIMD8.oddHalf in ' + this.constructor.name
}
get oddHalf() { return this.oddHalf$get() };










/*Swift.(file).SIMD8.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMD8.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).SIMD8.init(truncatingIfNeeded:SIMD8<Other>)*/
/*Swift.(file).SIMD8.init(truncatingIfNeeded:SIMD8<Other>)*/
initTruncatingIfNeededSIMD8<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD8.init(truncatingIfNeeded:SIMD8<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD8.init(clamping:SIMD8<Other>)*/
/*Swift.(file).SIMD8.init(clamping:SIMD8<Other>)*/
initClampingSIMD8<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD8.init(clamping:SIMD8<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD8.init(_:SIMD8<Other>,rounding:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD8.init(_:SIMD8<Other>,rounding:FloatingPointRoundingRule)*/
initSIMD8RoundingFloatingPointRoundingRule<Other>(other, rule, $info?) {
throw 'unsupported method Swift.(file).SIMD8.init(_:SIMD8<Other>,rounding:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).SIMD8.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).SIMD8.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).SIMD8.init(_:SIMD8<Other>)*/
/*Swift.(file).SIMD8.init(_:SIMD8<Other>)*/
initSIMD8<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD8.init(_:SIMD8<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD8.init(_:SIMD8<Other>)*/
/*Swift.(file).SIMD8.init(_:SIMD8<Other>)*/
initSIMD8<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD8.init(_:SIMD8<Other>) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMD8, SIMD$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(SIMD8, ElementaryFunctions$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(SIMD8, CustomDebugStringConvertible$implementation, false)








class SIMD16<Scalar> implements SIMD, ElementaryFunctions, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).SIMD16.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMD16.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).SIMD16.init() in ' + this.constructor.name
}
/*Swift.(file).SIMD16.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).SIMD16.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).SIMD16.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).SIMD16.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file).SIMD16.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*Swift.(file).SIMD16.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*!!!DUPLICATE NAME*/
init(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, $info?) {
throw 'unsupported method Swift.(file).SIMD16.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar) in ' + this.constructor.name
}
/*Swift.(file).SIMD16.init(lowHalf:SIMD8<Scalar>,highHalf:SIMD8<Scalar>)*/
/*Swift.(file).SIMD16.init(lowHalf:SIMD8<Scalar>,highHalf:SIMD8<Scalar>)*/
initLowHalfSIMD8HighHalfSIMD8(lowHalf, highHalf, $info?) {
throw 'unsupported method Swift.(file).SIMD16.init(lowHalf:SIMD8<Scalar>,highHalf:SIMD8<Scalar>) in ' + this.constructor.name
}

/*Swift.(file).SIMD16.lowHalf*/
lowHalf$get() {
throw 'unsupported variable Swift.(file).SIMD16.lowHalf in ' + this.constructor.name
}
get lowHalf() { return this.lowHalf$get() };






/*Swift.(file).SIMD16.highHalf*/
highHalf$get() {
throw 'unsupported variable Swift.(file).SIMD16.highHalf in ' + this.constructor.name
}
get highHalf() { return this.highHalf$get() };






/*Swift.(file).SIMD16.evenHalf*/
evenHalf$get() {
throw 'unsupported variable Swift.(file).SIMD16.evenHalf in ' + this.constructor.name
}
get evenHalf() { return this.evenHalf$get() };






/*Swift.(file).SIMD16.oddHalf*/
oddHalf$get() {
throw 'unsupported variable Swift.(file).SIMD16.oddHalf in ' + this.constructor.name
}
get oddHalf() { return this.oddHalf$get() };










/*Swift.(file).SIMD16.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMD16.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).SIMD16.init(truncatingIfNeeded:SIMD16<Other>)*/
/*Swift.(file).SIMD16.init(truncatingIfNeeded:SIMD16<Other>)*/
initTruncatingIfNeededSIMD16<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD16.init(truncatingIfNeeded:SIMD16<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD16.init(clamping:SIMD16<Other>)*/
/*Swift.(file).SIMD16.init(clamping:SIMD16<Other>)*/
initClampingSIMD16<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD16.init(clamping:SIMD16<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD16.init(_:SIMD16<Other>,rounding:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD16.init(_:SIMD16<Other>,rounding:FloatingPointRoundingRule)*/
initSIMD16RoundingFloatingPointRoundingRule<Other>(other, rule, $info?) {
throw 'unsupported method Swift.(file).SIMD16.init(_:SIMD16<Other>,rounding:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).SIMD16.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).SIMD16.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).SIMD16.init(_:SIMD16<Other>)*/
/*Swift.(file).SIMD16.init(_:SIMD16<Other>)*/
initSIMD16<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD16.init(_:SIMD16<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD16.init(_:SIMD16<Other>)*/
/*Swift.(file).SIMD16.init(_:SIMD16<Other>)*/
initSIMD16<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD16.init(_:SIMD16<Other>) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMD16, SIMD$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(SIMD16, ElementaryFunctions$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(SIMD16, CustomDebugStringConvertible$implementation, false)








class SIMD32<Scalar> implements SIMD, ElementaryFunctions, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).SIMD32.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMD32.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).SIMD32.init() in ' + this.constructor.name
}
/*Swift.(file).SIMD32.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).SIMD32.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).SIMD32.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).SIMD32.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file).SIMD32.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*Swift.(file).SIMD32.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*!!!DUPLICATE NAME*/
init(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, $info?) {
throw 'unsupported method Swift.(file).SIMD32.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar) in ' + this.constructor.name
}
/*Swift.(file).SIMD32.init(lowHalf:SIMD16<Scalar>,highHalf:SIMD16<Scalar>)*/
/*Swift.(file).SIMD32.init(lowHalf:SIMD16<Scalar>,highHalf:SIMD16<Scalar>)*/
initLowHalfSIMD16HighHalfSIMD16(lowHalf, highHalf, $info?) {
throw 'unsupported method Swift.(file).SIMD32.init(lowHalf:SIMD16<Scalar>,highHalf:SIMD16<Scalar>) in ' + this.constructor.name
}

/*Swift.(file).SIMD32.lowHalf*/
lowHalf$get() {
throw 'unsupported variable Swift.(file).SIMD32.lowHalf in ' + this.constructor.name
}
get lowHalf() { return this.lowHalf$get() };






/*Swift.(file).SIMD32.highHalf*/
highHalf$get() {
throw 'unsupported variable Swift.(file).SIMD32.highHalf in ' + this.constructor.name
}
get highHalf() { return this.highHalf$get() };






/*Swift.(file).SIMD32.evenHalf*/
evenHalf$get() {
throw 'unsupported variable Swift.(file).SIMD32.evenHalf in ' + this.constructor.name
}
get evenHalf() { return this.evenHalf$get() };






/*Swift.(file).SIMD32.oddHalf*/
oddHalf$get() {
throw 'unsupported variable Swift.(file).SIMD32.oddHalf in ' + this.constructor.name
}
get oddHalf() { return this.oddHalf$get() };










/*Swift.(file).SIMD32.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMD32.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).SIMD32.init(truncatingIfNeeded:SIMD32<Other>)*/
/*Swift.(file).SIMD32.init(truncatingIfNeeded:SIMD32<Other>)*/
initTruncatingIfNeededSIMD32<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD32.init(truncatingIfNeeded:SIMD32<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD32.init(clamping:SIMD32<Other>)*/
/*Swift.(file).SIMD32.init(clamping:SIMD32<Other>)*/
initClampingSIMD32<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD32.init(clamping:SIMD32<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD32.init(_:SIMD32<Other>,rounding:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD32.init(_:SIMD32<Other>,rounding:FloatingPointRoundingRule)*/
initSIMD32RoundingFloatingPointRoundingRule<Other>(other, rule, $info?) {
throw 'unsupported method Swift.(file).SIMD32.init(_:SIMD32<Other>,rounding:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).SIMD32.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).SIMD32.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).SIMD32.init(_:SIMD32<Other>)*/
/*Swift.(file).SIMD32.init(_:SIMD32<Other>)*/
initSIMD32<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD32.init(_:SIMD32<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD32.init(_:SIMD32<Other>)*/
/*Swift.(file).SIMD32.init(_:SIMD32<Other>)*/
initSIMD32<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD32.init(_:SIMD32<Other>) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMD32, SIMD$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(SIMD32, ElementaryFunctions$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(SIMD32, CustomDebugStringConvertible$implementation, false)








class SIMD64<Scalar> implements SIMD, ElementaryFunctions, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).SIMD64.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMD64.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).SIMD64.init() in ' + this.constructor.name
}
/*Swift.(file).SIMD64.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).SIMD64.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).SIMD64.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).SIMD64.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file).SIMD64.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*Swift.(file).SIMD64.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar)*/
/*!!!DUPLICATE NAME*/
init(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, $info?) {
throw 'unsupported method Swift.(file).SIMD64.init(_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar,_:Scalar) in ' + this.constructor.name
}
/*Swift.(file).SIMD64.init(lowHalf:SIMD32<Scalar>,highHalf:SIMD32<Scalar>)*/
/*Swift.(file).SIMD64.init(lowHalf:SIMD32<Scalar>,highHalf:SIMD32<Scalar>)*/
initLowHalfSIMD32HighHalfSIMD32(lowHalf, highHalf, $info?) {
throw 'unsupported method Swift.(file).SIMD64.init(lowHalf:SIMD32<Scalar>,highHalf:SIMD32<Scalar>) in ' + this.constructor.name
}

/*Swift.(file).SIMD64.lowHalf*/
lowHalf$get() {
throw 'unsupported variable Swift.(file).SIMD64.lowHalf in ' + this.constructor.name
}
get lowHalf() { return this.lowHalf$get() };






/*Swift.(file).SIMD64.highHalf*/
highHalf$get() {
throw 'unsupported variable Swift.(file).SIMD64.highHalf in ' + this.constructor.name
}
get highHalf() { return this.highHalf$get() };






/*Swift.(file).SIMD64.evenHalf*/
evenHalf$get() {
throw 'unsupported variable Swift.(file).SIMD64.evenHalf in ' + this.constructor.name
}
get evenHalf() { return this.evenHalf$get() };






/*Swift.(file).SIMD64.oddHalf*/
oddHalf$get() {
throw 'unsupported variable Swift.(file).SIMD64.oddHalf in ' + this.constructor.name
}
get oddHalf() { return this.oddHalf$get() };










/*Swift.(file).SIMD64.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMD64.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).SIMD64.init(truncatingIfNeeded:SIMD64<Other>)*/
/*Swift.(file).SIMD64.init(truncatingIfNeeded:SIMD64<Other>)*/
initTruncatingIfNeededSIMD64<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD64.init(truncatingIfNeeded:SIMD64<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD64.init(clamping:SIMD64<Other>)*/
/*Swift.(file).SIMD64.init(clamping:SIMD64<Other>)*/
initClampingSIMD64<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD64.init(clamping:SIMD64<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD64.init(_:SIMD64<Other>,rounding:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD64.init(_:SIMD64<Other>,rounding:FloatingPointRoundingRule)*/
initSIMD64RoundingFloatingPointRoundingRule<Other>(other, rule, $info?) {
throw 'unsupported method Swift.(file).SIMD64.init(_:SIMD64<Other>,rounding:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).SIMD64.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).SIMD64.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).SIMD64.init(_:SIMD64<Other>)*/
/*Swift.(file).SIMD64.init(_:SIMD64<Other>)*/
initSIMD64<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD64.init(_:SIMD64<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD64.init(_:SIMD64<Other>)*/
/*Swift.(file).SIMD64.init(_:SIMD64<Other>)*/
initSIMD64<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD64.init(_:SIMD64<Other>) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMD64, SIMD$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(SIMD64, ElementaryFunctions$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(SIMD64, CustomDebugStringConvertible$implementation, false)








class SIMD3<Scalar> implements SIMD, ElementaryFunctions, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).SIMD3.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).SIMD3.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).SIMD3.init() in ' + this.constructor.name
}
/*Swift.(file).SIMD3.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).SIMD3.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).SIMD3.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).SIMD3.subscript(_:Int) in ' + this.constructor.name
}



/*Swift.(file).SIMD3.init(_:Scalar,_:Scalar,_:Scalar)*/
/*Swift.(file).SIMD3.init(_:Scalar,_:Scalar,_:Scalar)*/
/*!!!DUPLICATE NAME*/
init(v0, v1, v2, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(_:Scalar,_:Scalar,_:Scalar) in ' + this.constructor.name
}
/*Swift.(file).SIMD3.init(x:Scalar,y:Scalar,z:Scalar)*/
/*Swift.(file).SIMD3.init(x:Scalar,y:Scalar,z:Scalar)*/
initXYZ(x, y, z, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(x:Scalar,y:Scalar,z:Scalar) in ' + this.constructor.name
}

/*Swift.(file).SIMD3.x*/
x$get() {
throw 'unsupported variable Swift.(file).SIMD3.x in ' + this.constructor.name
}
get x() { return this.x$get() };






/*Swift.(file).SIMD3.y*/
y$get() {
throw 'unsupported variable Swift.(file).SIMD3.y in ' + this.constructor.name
}
get y() { return this.y$get() };






/*Swift.(file).SIMD3.z*/
z$get() {
throw 'unsupported variable Swift.(file).SIMD3.z in ' + this.constructor.name
}
get z() { return this.z$get() };










/*Swift.(file).SIMD3.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).SIMD3.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).SIMD3.init(truncatingIfNeeded:SIMD3<Other>)*/
/*Swift.(file).SIMD3.init(truncatingIfNeeded:SIMD3<Other>)*/
initTruncatingIfNeededSIMD3<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(truncatingIfNeeded:SIMD3<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD3.init(clamping:SIMD3<Other>)*/
/*Swift.(file).SIMD3.init(clamping:SIMD3<Other>)*/
initClampingSIMD3<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(clamping:SIMD3<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD3.init(_:SIMD3<Other>,rounding:FloatingPointRoundingRule)*/
/*Swift.(file).SIMD3.init(_:SIMD3<Other>,rounding:FloatingPointRoundingRule)*/
initSIMD3RoundingFloatingPointRoundingRule<Other>(other, rule, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(_:SIMD3<Other>,rounding:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).SIMD3.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).SIMD3.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).SIMD3.init(_:SIMD3<Other>)*/
/*Swift.(file).SIMD3.init(_:SIMD3<Other>)*/
initSIMD3<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(_:SIMD3<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD3.init(_:SIMD3<Other>)*/
/*Swift.(file).SIMD3.init(_:SIMD3<Other>)*/
initSIMD3<Other>(other, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(_:SIMD3<Other>) in ' + this.constructor.name
}
/*Swift.(file).SIMD3.init(_:SIMD2<Scalar>,_:Scalar)*/
/*Swift.(file).SIMD3.init(_:SIMD2<Scalar>,_:Scalar)*/
initSIMD2(xy, z, $info?) {
throw 'unsupported method Swift.(file).SIMD3.init(_:SIMD2<Scalar>,_:Scalar) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof SIMD$implementation != 'undefined') _mixin(SIMD3, SIMD$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(SIMD3, ElementaryFunctions$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(SIMD3, CustomDebugStringConvertible$implementation, false)










interface _ArrayProtocol<_Buffer> extends RangeReplaceableCollection, ExpressibleByArrayLiteral{

/*Swift.(file)._ArrayProtocol.capacity*/
capacity;









/*Swift.(file)._ArrayProtocol.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
reserveCapacity(minimumCapacity, $info?)
/*Swift.(file)._ArrayProtocol.insert(_:Self.Element,at:Int)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
insertAt(newElement, i, $info?)
/*Swift.(file)._ArrayProtocol.remove(at:Int)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
removeAt(index, $info?)

/*Swift.(file)._ArrayProtocol.init(_:Self._Buffer)*/
/*Swift.(file)._ArrayProtocol.init(_:Self._Buffer)*/
initBuffer(buffer, $info?)



}
class _ArrayProtocol$implementation{
/*Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)*/
/*Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
let _this = this;
let result = _create(Array, 'init', {});
let iterator = _cloneStruct(_this.makeIterator( {}));
while(true){
const $ifLet0, _element_1
if(!((($ifLet0 = iterator.next( {$setThis: $val => iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((isIncluded(_element_1))) {
result.append(_element_1, {$setThis: $val => result = $val});
};
};
return _create(Array, 'initBuffer', result, {})
}
}
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(_ArrayProtocol$implementation, RangeReplaceableCollection$implementation, false)
if(typeof ExpressibleByArrayLiteral$implementation != 'undefined') _mixin(_ArrayProtocol$implementation, ExpressibleByArrayLiteral$implementation, false)




interface BidirectionalCollection<Element, Index, SubSequence, Indices> extends Collection{




/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?)
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?)
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?)
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?)
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?)
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?)
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?)

/*Swift.(file).BidirectionalCollection.indices*/;



/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?)

/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?)



/*Swift.(file).BidirectionalCollection.startIndex*/;




/*Swift.(file).BidirectionalCollection.endIndex*/;



}
class BidirectionalCollection$implementation{
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?) {
let _this = this;
return _this._indexOffsetBy(i, distance)
}

/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?) {
let _this = this;
return _this._indexOffsetByLimitedBy(i, distance, limit)
}

/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._distanceFromTo(start, end)
}

/*Swift.(file).BidirectionalCollection.popLast()*/
/*Swift.(file).BidirectionalCollection.popLast()*/
popLast($info?) {
let _this = this;
if(!((Bool.$not(_this.isEmpty)))) {
return _injectIntoOptional(null);
};
const _element = _this.last[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.indexBefore(_this.endIndex)))));
return _injectIntoOptional(_element)
}
/*Swift.(file).BidirectionalCollection.removeLast()*/
/*Swift.(file).BidirectionalCollection.removeLast()*/
removeLast($info?) {
let _this = this;
const _element = _this.last[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.indexBefore(_this.endIndex)))));
return _element
}
/*Swift.(file).BidirectionalCollection.removeLast(_:Int)*/
/*Swift.(file).BidirectionalCollection.removeLast(_:Int)*/
/*!!!DUPLICATE NAME*/
removeLast(k, $info?) {
let _this = this;
if((Int.$equal(k, 0))) {
return ;
};
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Number of elements to remove should be non-negative", null, null);
preconditionFileLine(() => Int.$greaterThanOrEqual(_this.count, k), () => "Can't remove more items from a collection than it contains", null, null);
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.indexOffsetBy(_this.endIndex, Int.$negate(k))))))
}
/*Swift.(file).BidirectionalCollection.dropLast(_:Int)*/
/*Swift.(file).BidirectionalCollection.dropLast(_:Int)*/
dropLast(k, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(k, 0), () => "Can't drop a negative number of elements from a collection", null, null);
const end = $nilCoalescing(_this.indexOffsetByLimitedBy(_this.endIndex, Int.$negate(k), _this.startIndex), () => _this.startIndex);
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, end))
}
/*Swift.(file).BidirectionalCollection.suffix(_:Int)*/
/*Swift.(file).BidirectionalCollection.suffix(_:Int)*/
suffix(maxLength, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(maxLength, 0), () => "Can't take a suffix of negative length from a collection", null, null);
const start = $nilCoalescing(_this.indexOffsetByLimitedBy(_this.endIndex, Int.$negate(maxLength), _this.startIndex), () => _this.startIndex);
return _this.subscriptRange$get((_.arg0 = start).constructor.$halfOpenRange(_.arg0, _this.endIndex))
}

/*Swift.(file).BidirectionalCollection.last*/
last$get() {
let _this = this;
return (_this.isEmpty ? _injectIntoOptional(null) : _injectIntoOptional(_this.subscript$get(_this.indexBefore(_this.endIndex))))
}
get last() { return this.last$get() };



/*Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)*/
lastWhere(predicate, $info?) {
let _this = this;
return _this.lastIndexWhere(predicate).mapSwift((($0, $info?) => _this.subscript$get($0)))
}
/*Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)*/
/*Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)*/
lastIndexWhere(predicate, $info?) {
let _this = this;
let i = _this.endIndex;
while(true){
if(!(((_.arg0 = i).constructor.$notEqual(_.arg0, _this.startIndex)))) break
_this.formIndexBefore({get: () => i, set: $val => i = $val});
if((predicate(_this.subscript$get(i)))) {
return _injectIntoOptional(i);
};
};
return _injectIntoOptional(null)
}
/*Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)*/
/*Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)*/
lastIndexOfSwift(_element, $info?) {
let _this = this;
const $ifLet0, result_1
if((($ifLet0 = _this._customLastIndexOfEquatableElement(_element))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return result_1;
};
return _this.lastIndexWhere((($0, $info?) => (_.arg0 = $0).constructor.$equal(_.arg0, _element)))
}
/*Swift.(file).BidirectionalCollection.reversed()*/
/*Swift.(file).BidirectionalCollection.reversed()*/
reversed($info?) {
let _this = this;
return _create(ReversedCollection, 'init_base', _this, {})
}
/*Swift.(file).BidirectionalCollection.joined(separator:String)*/
/*Swift.(file).BidirectionalCollection.joined(separator:String)*/
joinedSeparator(separator, $info?) {
let _this = this;
let result = "";
if((separator.isEmpty)) {
{
let $x$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, x_1;
if(!((($ifLet0 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true))) break
result.append(_create(String, 'initString', x_1, {}), {$setThis: $val => result = $val});
}
};
return result;
};
let iter = _this.makeIterator( {});
const $ifLet2, first_3
if((($ifLet2 = iter.next( {$setThis: $val => iter = $val}))||true) && $ifLet2.rawValue == 'some' && ((first_3 = $ifLet2[0])||true)) {
result.append(_create(String, 'initString', first_3, {}), {$setThis: $val => result = $val});
while(true){
const $ifLet4, next_5
if(!((($ifLet4 = iter.next( {$setThis: $val => iter = $val}))||true) && $ifLet4.rawValue == 'some' && ((next_5 = $ifLet4[0])||true))) break
result.append(separator, {$setThis: $val => result = $val});
result.append(_create(String, 'initString', next_5, {}), {$setThis: $val => result = $val});
};
};
return result
}
/*Swift.(file).BidirectionalCollection.difference(from:C,by:(Self.Element, C.Element) -> Bool)*/
/*Swift.(file).BidirectionalCollection.difference(from:C,by:(Self.Element, C.Element) -> Bool)*/
differenceFromBy<C>(other, areEquivalent, $info?) {
throw 'unsupported method Swift.(file).BidirectionalCollection.difference(from:C,by:(Self.Element, C.Element) -> Bool) in ' + this.constructor.name
}
/*Swift.(file).BidirectionalCollection.difference(from:C)*/
/*Swift.(file).BidirectionalCollection.difference(from:C)*/
differenceFrom<C>(other, $info?) {
throw 'unsupported method Swift.(file).BidirectionalCollection.difference(from:C) in ' + this.constructor.name
}

}
if(typeof Collection$implementation != 'undefined') _mixin(BidirectionalCollection$implementation, Collection$implementation, false)
























class Character implements _ExpressibleByBuiltinExtendedGraphemeClusterLiteral, ExpressibleByExtendedGraphemeClusterLiteral, CustomStringConvertible, LosslessStringConvertible, CustomDebugStringConvertible, Equatable, Comparable, Hashable, TextOutputStreamable, CustomReflectable, _CustomPlaygroundQuickLookable{
static readonly $struct = true





/*Swift.(file).Character.init(unchecked:String)*/
/*Swift.(file).Character.init(unchecked:String)*/
initUncheckedString(str, $info?) {
return str
}



/*Swift.(file).Character.utf8*/
utf8$get() {
let _this = this;
return _this.utf8
}
get utf8() { return this.utf8$get() };





/*Swift.(file).Character.utf16*/
utf16$get() {
let _this = this;
return _this.utf16
}
get utf16() { return this.utf16$get() };





/*Swift.(file).Character.unicodeScalars*/
unicodeScalars$get() {
let _this = this;
return _this.unicodeScalars
}
get unicodeScalars() { return this.unicodeScalars$get() };



/*Swift.(file).Character.init(_:Unicode.Scalar)*/
/*Swift.(file).Character.init(_:Unicode.Scalar)*/
initUnicodeScalar(content, $info?) {
let _this = this;
_this.initUncheckedString(_create(String, 'initUnicodeScalar', content, {}));
return
}
/*Swift.(file).Character.init(_builtinUnicodeScalarLiteral:Int32)*/
/*Swift.(file)._ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:Int32)*/
init_builtinUnicodeScalarLiteralInt32(value, $info?) {
throw 'unsupported method Swift.(file).Character.init(_builtinUnicodeScalarLiteral:Int32) in ' + this.constructor.name
}
/*Swift.(file).Character.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinExtendedGraphemeClusterLiteral.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_builtinExtendedGraphemeClusterLiteralRawPointerUtf8CodeUnitCountWordIsASCIIInt1(start, utf8CodeUnitCount, isASCII, $info?) {
throw 'unsupported method Swift.(file).Character.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1) in ' + this.constructor.name
}
/*Swift.(file).Character.init(extendedGraphemeClusterLiteral:Character)*/
/*Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(extendedGraphemeClusterLiteral:Self.ExtendedGraphemeClusterLiteralType)*/
initExtendedGraphemeClusterLiteral(value, $info?) {
let _this = this;
_this.initUncheckedString(value);
return
}
/*Swift.(file).Character.init(_:String)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString(s, $info?) {
throw 'unsupported method Swift.(file).Character.init(_:String) in ' + this.constructor.name
}



/*Swift.(file).Character.description*/
description$get() {
let _this = this;
return _this
}
get description() { return this.description$get() };




/*Swift.(file).Character.debugDescription*/
debugDescription$get() {
let _this = this;
return _this.debugDescription
}
get debugDescription() { return this.debugDescription$get() };



static /*Swift.(file).Character.==infix(_:Character,_:Character)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return String.$equal(lhs, rhs)
}
static /*Swift.(file).Character.<infix(_:Character,_:Character)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
return String.$lessThan(lhs, rhs)
}
/*Swift.(file).Character.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
_this.hashInto({get: () => hasher, set: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).Character.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Character.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };




/*Swift.(file).Character.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?) {
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_create(String, 'initCharacter', _this, {}), {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
}







/*Swift.(file).Character.isASCII*/
isASCII$get() {
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this.asciiValue, _injectIntoOptional(null))
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file).Character.asciiValue*/
asciiValue$get() {
let _this = this;
if((_slowPath(Character.$equal(_this, "\r\n")))) {
return _injectIntoOptional(0x000A);
};
if((_slowPath(Bool.$logicalOR(Bool.$not(_this._isSingleScalar), () => UInt32.$greaterThanOrEqual(_this._firstScalar.value, 0x80))))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_create(UInt8, 'initT', _this._firstScalar.value, {}))
}
get asciiValue() { return this.asciiValue$get() };




/*Swift.(file).Character.isWhitespace*/
isWhitespace$get() {
let _this = this;
return _this._firstScalar.properties.isWhitespace
}
get isWhitespace() { return this.isWhitespace$get() };




/*Swift.(file).Character.isNewline*/
isNewline$get() {
let _this = this;
const $match = _this._firstScalar.value
if((((ClosedRange.$patternMatch(UInt32.$closedRange(0x000A, 0x000D), $match))))) {
return true;
}
else if(((($patternMatch(0x0085, $match))))) {
return true;
}
else if(((($patternMatch(0x2028, $match))))) {
return true;
}
else if(((($patternMatch(0x2029, $match))))) {
return true;
}
else if(((true))) {
return false;
}
}
get isNewline() { return this.isNewline$get() };




/*Swift.(file).Character.isNumber*/
isNumber$get() {
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this._firstScalar.properties.numericType, _injectIntoOptional(null))
}
get isNumber() { return this.isNumber$get() };




/*Swift.(file).Character.isWholeNumber*/
isWholeNumber$get() {
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this.wholeNumberValue, _injectIntoOptional(null))
}
get isWholeNumber() { return this.isWholeNumber$get() };




/*Swift.(file).Character.wholeNumberValue*/
wholeNumberValue$get() {
let _this = this;
if(!((_this._isSingleScalar))) {
return _injectIntoOptional(null);
};
const $ifLet0, value_1
if(!((($ifLet0 = _this._firstScalar.properties.numericValue)||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
return _create(Int, 'initExactlyDouble', value_1, {})
}
get wholeNumberValue() { return this.wholeNumberValue$get() };




/*Swift.(file).Character.isHexDigit*/
isHexDigit$get() {
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this.hexDigitValue, _injectIntoOptional(null))
}
get isHexDigit() { return this.isHexDigit$get() };




/*Swift.(file).Character.hexDigitValue*/
hexDigitValue$get() {
let _this = this;
if(!((_this._isSingleScalar))) {
return _injectIntoOptional(null);
};
const value = _this._firstScalar.value;
const $match = value
if((((ClosedRange.$patternMatch(UInt32.$closedRange(0x0030, 0x0039), $match))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.$subtractWithOverflow(value, 0x0030), {}));
}
else if((((ClosedRange.$patternMatch(UInt32.$closedRange(0x0041, 0x0046), $match))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.$subtractWithOverflow(UInt32.$addWithOverflow(value, 10), 0x0041), {}));
}
else if((((ClosedRange.$patternMatch(UInt32.$closedRange(0x0061, 0x0066), $match))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.$subtractWithOverflow(UInt32.$addWithOverflow(value, 10), 0x0061), {}));
}
else if((((ClosedRange.$patternMatch(UInt32.$closedRange(0xFF10, 0xFF19), $match))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.$subtractWithOverflow(value, 0xFF10), {}));
}
else if((((ClosedRange.$patternMatch(UInt32.$closedRange(0xFF21, 0xFF26), $match))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.$subtractWithOverflow(UInt32.$addWithOverflow(value, 10), 0xFF21), {}));
}
else if((((ClosedRange.$patternMatch(UInt32.$closedRange(0xFF41, 0xFF46), $match))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.$subtractWithOverflow(UInt32.$addWithOverflow(value, 10), 0xFF41), {}));
}
else if(((true))) {
return _injectIntoOptional(null);
}
}
get hexDigitValue() { return this.hexDigitValue$get() };




/*Swift.(file).Character.isLetter*/
isLetter$get() {
let _this = this;
return _this._firstScalar.properties.isAlphabetic
}
get isLetter() { return this.isLetter$get() };



/*Swift.(file).Character.uppercased()*/
/*Swift.(file).Character.uppercased()*/
uppercased($info?) {
let _this = this;
return _create(String, 'initCharacter', _this, {}).uppercased( {})
}
/*Swift.(file).Character.lowercased()*/
/*Swift.(file).Character.lowercased()*/
lowercased($info?) {
let _this = this;
return _create(String, 'initCharacter', _this, {}).lowercased( {})
}







/*Swift.(file).Character.isUppercase*/
isUppercase$get() {
let _this = this;
if((_fastPath(Bool.$logicalAND(_this._isSingleScalar, () => _this._firstScalar.properties.isUppercase)))) {
return true;
};
return Bool.$logicalAND(_this._isUppercased, () => _this.isCased)
}
get isUppercase() { return this.isUppercase$get() };




/*Swift.(file).Character.isLowercase*/
isLowercase$get() {
let _this = this;
if((_fastPath(Bool.$logicalAND(_this._isSingleScalar, () => _this._firstScalar.properties.isLowercase)))) {
return true;
};
return Bool.$logicalAND(_this._isLowercased, () => _this.isCased)
}
get isLowercase() { return this.isLowercase$get() };




/*Swift.(file).Character.isCased*/
isCased$get() {
let _this = this;
if((_fastPath(Bool.$logicalAND(_this._isSingleScalar, () => _this._firstScalar.properties.isCased)))) {
return true;
};
return Bool.$logicalOR(Bool.$not(_this._isUppercased), () => Bool.$not(_this._isLowercased))
}
get isCased() { return this.isCased$get() };




/*Swift.(file).Character.isSymbol*/
isSymbol$get() {
let _this = this;
return _this._firstScalar.properties.generalCategory._isSymbol
}
get isSymbol() { return this.isSymbol$get() };




/*Swift.(file).Character.isMathSymbol*/
isMathSymbol$get() {
let _this = this;
return _this._firstScalar.properties.isMath
}
get isMathSymbol() { return this.isMathSymbol$get() };




/*Swift.(file).Character.isCurrencySymbol*/
isCurrencySymbol$get() {
let _this = this;
return Unicode.GeneralCategory.$equal(_this._firstScalar.properties.generalCategory, Unicode.GeneralCategory.currencySymbol)
}
get isCurrencySymbol() { return this.isCurrencySymbol$get() };




/*Swift.(file).Character.isPunctuation*/
isPunctuation$get() {
let _this = this;
return _this._firstScalar.properties.generalCategory._isPunctuation
}
get isPunctuation() { return this.isPunctuation$get() };




/*Swift.(file).Character.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Character.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Character.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Character.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}
if(typeof _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(Character, _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation, false)
if(typeof ExpressibleByExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(Character, ExpressibleByExtendedGraphemeClusterLiteral$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(Character, CustomStringConvertible$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(Character, LosslessStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(Character, CustomDebugStringConvertible$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(Character, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(Character, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(Character, Hashable$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(Character, TextOutputStreamable$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(Character, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(Character, _CustomPlaygroundQuickLookable$implementation, false)






























class __EmptyArrayStorage extends __ContiguousArrayStorageBase{
/*Swift.(file).__EmptyArrayStorage.init(_doNotCallMe:())*/
/*Swift.(file).__EmptyArrayStorage.init(_doNotCallMe:())*/
init_doNotCallMetuple_type(_doNotCallMe, $info?) {
throw 'unsupported method Swift.(file).__EmptyArrayStorage.init(_doNotCallMe:()) in ' + this.constructor.name
}



/*Swift.(file).__EmptyArrayStorage.canStoreElements(ofDynamicType:Any.Type)*/
/*Swift.(file).__ContiguousArrayStorageBase.canStoreElements(ofDynamicType:Any.Type)*/
canStoreElementsOfDynamicType(_, $info?) {
throw 'unsupported method Swift.(file).__EmptyArrayStorage.canStoreElements(ofDynamicType:Any.Type) in ' + this.constructor.name
}

/*Swift.(file).__EmptyArrayStorage.staticElementType*/
staticElementType$get() {
throw 'unsupported variable Swift.(file).__EmptyArrayStorage.staticElementType in ' + this.constructor.name
}
get staticElementType() { return this.staticElementType$get() };



/*Swift.(file).__EmptyArrayStorage.init(_doNotCallMeBase:())*/
/*Swift.(file).__ContiguousArrayStorageBase.init(_doNotCallMeBase:())*/
init_doNotCallMeBasetuple_type(_doNotCallMeBase, $info?) {
throw 'unsupported method Swift.(file).__EmptyArrayStorage.init(_doNotCallMeBase:()) in ' + this.constructor.name
}

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _ContiguousArrayStorage<Element> extends __ContiguousArrayStorageBase{





/*Swift.(file)._ContiguousArrayStorage.canStoreElements(ofDynamicType:Any.Type)*/
/*Swift.(file).__ContiguousArrayStorageBase.canStoreElements(ofDynamicType:Any.Type)*/
canStoreElementsOfDynamicType(proposedElementType, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayStorage.canStoreElements(ofDynamicType:Any.Type) in ' + this.constructor.name
}

/*Swift.(file)._ContiguousArrayStorage.staticElementType*/
staticElementType$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayStorage.staticElementType in ' + this.constructor.name
}
get staticElementType() { return this.staticElementType$get() };






/*Swift.(file)._ContiguousArrayStorage.init(_doNotCallMeBase:())*/
/*Swift.(file).__ContiguousArrayStorageBase.init(_doNotCallMeBase:())*/
init_doNotCallMeBasetuple_type(_doNotCallMeBase, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayStorage.init(_doNotCallMeBase:()) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class MIO_Mixin_Dictionary<Key, Value> implements Sequence, Collection, ExpressibleByDictionaryLiteral, Equatable, Hashable, _HasCustomAnyHashableRepresentation, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable, Encodable, Decodable{
static readonly $struct = true
static readonly $mixin = true
cloneStructFill(obj, $info?){obj.forEach((val, prop) => this.set(prop, _cloneStruct(val)))}






/*Swift.(file).Dictionary.init(_native:_NativeDictionary<Key, Value>)*/
/*Swift.(file).Dictionary.init(_native:_NativeDictionary<Key, Value>)*/
init_native_NativeDictionary(_native, $info?) {
throw 'unsupported method Swift.(file).Dictionary.init(_native:_NativeDictionary<Key, Value>) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.init(_cocoa:__CocoaDictionary)*/
/*Swift.(file).Dictionary.init(_cocoa:__CocoaDictionary)*/
init_cocoa__CocoaDictionary(_cocoa, $info?) {
throw 'unsupported method Swift.(file).Dictionary.init(_cocoa:__CocoaDictionary) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.init(_immutableCocoaDictionary:AnyObject)*/
/*Swift.(file).Dictionary.init(_immutableCocoaDictionary:AnyObject)*/
init_immutableCocoaDictionaryAnyObject(_immutableCocoaDictionary, $info?) {
throw 'unsupported method Swift.(file).Dictionary.init(_immutableCocoaDictionary:AnyObject) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.init()*/
/*Swift.(file).Dictionary.init()*/
init($info?) {
return new Map()
}
/*Swift.(file).Dictionary.init(minimumCapacity:Int)*/
/*Swift.(file).Dictionary.init(minimumCapacity:Int)*/
initMinimumCapacityInt(minimumCapacity, $info?) {
throw 'unsupported method Swift.(file).Dictionary.init(minimumCapacity:Int) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.init(uniqueKeysWithValues:S)*/
/*Swift.(file).Dictionary.init(uniqueKeysWithValues:S)*/
initUniqueKeysWithValues<S>(keysAndValues, $info?) {
let _this = this;
const $ifLet0, d_1
if((($ifLet0 = _injectIntoOptional(keysAndValues))||true) && $ifLet0.rawValue == 'some' && ((d_1 = $ifLet0[0])||true)) {
return _cloneStruct(_cloneStruct(d_1));
return ;
};
let _native = _create(_NativeDictionary, 'initCapacityInt', keysAndValues.underestimatedCount, {});
_native.mergeIsUniqueUniquingKeysWith(keysAndValues, true, ((_, _, $info?) => { 
throw _MergeError.keyCollision; }), {$setThis: $val => _native = $val});
_this.init_native_NativeDictionary(_native);
return
}
/*Swift.(file).Dictionary.init(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
/*Swift.(file).Dictionary.init(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
initUniquingKeysWithfunction_type<S>(keysAndValues, combine, $info?) {
let _this = this;
let _native = _create(_NativeDictionary, 'initCapacityInt', keysAndValues.underestimatedCount, {});
_native.mergeIsUniqueUniquingKeysWith(keysAndValues, true, combine, {$setThis: $val => _native = $val});
_this.init_native_NativeDictionary(_native);
return
}
/*Swift.(file).Dictionary.init(grouping:S,by:(S.Element) throws -> Key)*/
/*Swift.(file).Dictionary.init(grouping:S,by:(S.Element) throws -> Key)*/
initGroupingByfunction_type<S>(values, keyForValue, $info?) {
let _this = this;
_this.init_native_NativeDictionary(_create(_NativeDictionary, 'initGroupingByfunction_type', values, keyForValue, {}));
return
}
/*Swift.(file).Dictionary.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
//TODO use _create for Array
//TODO change SwiftIterator because now only Dictionary is using it to use js Map.iterator (much faster)
//TODO preferably move to Swift and use the proper Iterator (then remove SwiftIterator.js too)
return new SwiftIterator((current) => _injectIntoOptional(Array.from(this)[current]))
}
/*Swift.(file).Dictionary.filter(_:(Dictionary<Key, Value>.Element) throws -> Bool)*/
/*Swift.(file).Dictionary.filter(_:(Dictionary<Key, Value>.Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
let _this = this;
let result = _create(Dictionary, 'init', {});
{
let $element$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((isIncluded(_element_1))) {
result.subscript$set(_injectIntoOptional(_element_1["1"]), _element_1["0"], {$setThis: $val => result = $val});
};
}
};
return result
}


/*Swift.(file).Dictionary.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Dictionary.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Dictionary.index(after:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Dictionary.index(after:Dictionary<Key, Value>.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.formIndex(after:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Dictionary.index(forKey:Key)*/
/*Swift.(file).Dictionary.index(forKey:Key)*/
indexForKey(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary.index(forKey:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.subscript(_:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
if(this.has(position)) return Optional.some(this.get(position), {})
return Optional.none
}



/*Swift.(file).Dictionary.count*/
count$get() {
return this.size
}
get count() { return this.count$get() };




/*Swift.(file).Dictionary.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };




/*Swift.(file).Dictionary.subscript(_:Key)*/
/*Swift.(file).Dictionary.subscript(_:Key)*/
/*!!!DUPLICATE NAME*/
subscript$get(key, $info?) {
if(this.has(key)) return Optional.some(this.get(key), {})
return Optional.none
}/*Swift.(file).Dictionary.subscript(_:Key)*/
/*Swift.(file).Dictionary.subscript(_:Key)*/
subscript$set(newValue, key, $info?) {
if(newValue.rawValue === 'none') this.delete(key)
else this.set(key, _cloneStruct(newValue[0]))
}/*Swift.(file).Dictionary.subscript(_:Key)*/
/*Swift.(file).Dictionary.subscript(_:Key)*/
subscript$_modify(key, $info?) {
if(this.has(key)) return Optional.some(this.get(key), {})
return Optional.none
}



/*Swift.(file).Dictionary.init(dictionaryLiteral:[(Key, Value)])*/
/*Swift.(file).ExpressibleByDictionaryLiteral.init(dictionaryLiteral:[(Self.Key, Self.Value)])*/
initDictionaryLiteralArray(_elements, $info?) {
throw 'unsupported method Swift.(file).Dictionary.init(dictionaryLiteral:[(Key, Value)]) in ' + this.constructor.name
}


/*Swift.(file).Dictionary.subscript(_:Key,default:() -> Value)*/
/*Swift.(file).Dictionary.subscript(_:Key,default:() -> Value)*/
subscriptDefault$get(key, defaultValue, $info?) {
throw 'unsupported method Swift.(file).Dictionary.subscript(_:Key,default:() -> Value) in ' + this.constructor.name
}/*Swift.(file).Dictionary.subscript(_:Key,default:() -> Value)*/
/*Swift.(file).Dictionary.subscript(_:Key,default:() -> Value)*/
subscriptDefault$_modify(key, defaultValue, $info?) {
throw 'unsupported method Swift.(file).Dictionary.subscript(_:Key,default:() -> Value) in ' + this.constructor.name
}



/*Swift.(file).Dictionary.mapValues(_:(Value) throws -> T)*/
/*Swift.(file).Dictionary.mapValues(_:(Value) throws -> T)*/
mapValues<T>(transform, $info?) {
throw 'unsupported method Swift.(file).Dictionary.mapValues(_:(Value) throws -> T) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.compactMapValues(_:(Value) throws -> T?)*/
/*Swift.(file).Dictionary.compactMapValues(_:(Value) throws -> T?)*/
compactMapValues<T>(transform, $info?) {
throw 'unsupported method Swift.(file).Dictionary.compactMapValues(_:(Value) throws -> T?) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.updateValue(_:Value,forKey:Key)*/
/*Swift.(file).Dictionary.updateValue(_:Value,forKey:Key)*/
updateValueForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).Dictionary.updateValue(_:Value,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.merge(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
/*Swift.(file).Dictionary.merge(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
mergeUniquingKeysWith<S>(other, combine, $info?) {
throw 'unsupported method Swift.(file).Dictionary.merge(_:S,uniquingKeysWith:(Value, Value) throws -> Value) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.merge(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)*/
/*Swift.(file).Dictionary.merge(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)*/
/*!!!DUPLICATE NAME*/
mergeUniquingKeysWith(other, combine, $info?) {
throw 'unsupported method Swift.(file).Dictionary.merge(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.merging(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
/*Swift.(file).Dictionary.merging(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
mergingUniquingKeysWith<S>(other, combine, $info?) {
throw 'unsupported method Swift.(file).Dictionary.merging(_:S,uniquingKeysWith:(Value, Value) throws -> Value) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.merging(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)*/
/*Swift.(file).Dictionary.merging(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)*/
/*!!!DUPLICATE NAME*/
mergingUniquingKeysWith(other, combine, $info?) {
throw 'unsupported method Swift.(file).Dictionary.merging(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.remove(at:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Dictionary.remove(at:Dictionary<Key, Value>.Index)*/
removeAt(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary.remove(at:Dictionary<Key, Value>.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.removeValue(forKey:Key)*/
/*Swift.(file).Dictionary.removeValue(forKey:Key)*/
removeValueForKey(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary.removeValue(forKey:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).Dictionary.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
throw 'unsupported method Swift.(file).Dictionary.removeAll(keepingCapacity:Bool) in ' + this.constructor.name
}

/*Swift.(file).Dictionary.keys*/
keys$get() {
throw 'unsupported variable Swift.(file).Dictionary.keys in ' + this.constructor.name
}
get keys() { return this.keys$get() };




/*Swift.(file).Dictionary.values*/
values$get() {
throw 'unsupported variable Swift.(file).Dictionary.values in ' + this.constructor.name
}
get values() { return this.values$get() };





static Keys = class implements Collection, Equatable, CustomStringConvertible, CustomDebugStringConvertible{
static readonly $struct = true







/*Swift.(file).Dictionary.Keys.init(_dictionary:Dictionary<Key, Value>)*/
/*Swift.(file).Dictionary.Keys.init(_dictionary:Dictionary<Key, Value>)*/
init_dictionaryDictionary(_dictionary, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Keys.init(_dictionary:Dictionary<Key, Value>) in ' + this.constructor.name
}

/*Swift.(file).Dictionary.Keys.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary.Keys.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Dictionary.Keys.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary.Keys.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Dictionary.Keys.index(after:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Keys.index(after:Dictionary<Key, Value>.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Keys.formIndex(after:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Dictionary.Keys.subscript(_:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Keys.subscript(_:Dictionary<Key, Value>.Index) in ' + this.constructor.name
}



/*Swift.(file).Dictionary.Keys.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).Dictionary.Keys.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };






static /*Swift.(file).Dictionary.Keys.==infix(_:Dictionary<Key, Value>.Keys,_:Dictionary<Key, Value>.Keys)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}

/*Swift.(file).Dictionary.Keys.description*/
description$get() {
throw 'unsupported variable Swift.(file).Dictionary.Keys.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).Dictionary.Keys.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Dictionary.Keys.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };





static Iterator = class implements IteratorProtocol{
static readonly $struct = true





/*Swift.(file).Dictionary.Keys.Iterator.init(_:Dictionary<Key, Value>.Iterator)*/
/*Swift.(file).Dictionary.Keys.Iterator.init(_:Dictionary<Key, Value>.Iterator)*/
initDictionaryIterator(base, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Keys.Iterator.init(_:Dictionary<Key, Value>.Iterator) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Keys.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).Dictionary.Keys.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
/*Swift.(file).Dictionary.Keys.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}
init$vars() {let _this = this;

}
}
static Values = class implements MutableCollection, CustomStringConvertible, CustomDebugStringConvertible{
static readonly $struct = true






/*Swift.(file).Dictionary.Values.init(_variant:Dictionary<Key, Value>._Variant)*/
/*Swift.(file).Dictionary.Values.init(_variant:Dictionary<Key, Value>._Variant)*/
init_variantDictionary_Variant(_variant, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Values.init(_variant:Dictionary<Key, Value>._Variant) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Values.init(_dictionary:Dictionary<Key, Value>)*/
/*Swift.(file).Dictionary.Values.init(_dictionary:Dictionary<Key, Value>)*/
init_dictionaryDictionary(_dictionary, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Values.init(_dictionary:Dictionary<Key, Value>) in ' + this.constructor.name
}

/*Swift.(file).Dictionary.Values.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary.Values.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Dictionary.Values.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary.Values.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Dictionary.Values.index(after:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Values.index(after:Dictionary<Key, Value>.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Values.formIndex(after:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Dictionary.Values.subscript(_:Dictionary<Key, Value>.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Values.subscript(_:Dictionary<Key, Value>.Index) in ' + this.constructor.name
}/*Swift.(file).Dictionary.Values.subscript(_:Dictionary<Key, Value>.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$_modify(position, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Values.subscript(_:Dictionary<Key, Value>.Index) in ' + this.constructor.name
}





/*Swift.(file).Dictionary.Values.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).Dictionary.Values.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };




/*Swift.(file).Dictionary.Values.description*/
description$get() {
throw 'unsupported variable Swift.(file).Dictionary.Values.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).Dictionary.Values.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Dictionary.Values.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).Dictionary.Values.swapAt(_:Dictionary<Key, Value>.Index,_:Dictionary<Key, Value>.Index)*/
/*Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)*/
swapAt(i, j, $info?) {
let _this = this;
if(!(((_.arg0 = i).constructor.$notEqual(_.arg0, j)))) {
return ;
};
const tmp = _this.subscript$get(i);
_this.subscript$set(_this.subscript$get(j), i, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.subscript$set(tmp, j, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}



static Iterator = class implements IteratorProtocol{
static readonly $struct = true





/*Swift.(file).Dictionary.Values.Iterator.init(_:Dictionary<Key, Value>.Iterator)*/
/*Swift.(file).Dictionary.Values.Iterator.init(_:Dictionary<Key, Value>.Iterator)*/
initDictionaryIterator(base, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Values.Iterator.init(_:Dictionary<Key, Value>.Iterator) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Values.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).Dictionary.Values.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
/*Swift.(file).Dictionary.Values.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}
init$vars() {let _this = this;

}
}
static /*Swift.(file).Dictionary.==infix(_:[Key : Value],_:[Key : Value])*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
/*Swift.(file).Dictionary.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Dictionary.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).Dictionary.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Dictionary.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).Dictionary.description*/
description$get() {
throw 'unsupported variable Swift.(file).Dictionary.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).Dictionary.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Dictionary.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



static Index = class implements Equatable, Comparable, Hashable{
static readonly $struct = true
static _Variant = class{

static _native() {return Object.assign(new MIO_Mixin_Dictionary.Index._Variant(), {rawValue: "_native", ...Array.from(arguments)})}

static cocoa() {return Object.assign(new MIO_Mixin_Dictionary.Index._Variant(), {rawValue: "cocoa", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}





/*Swift.(file).Dictionary.Index.init(_variant:Dictionary<Key, Value>.Index._Variant)*/
/*Swift.(file).Dictionary.Index.init(_variant:Dictionary<Key, Value>.Index._Variant)*/
init_variantDictionaryIndex_Variant(_variant, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Index.init(_variant:Dictionary<Key, Value>.Index._Variant) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Index.init(_native:_HashTable.Index)*/
/*Swift.(file).Dictionary.Index.init(_native:_HashTable.Index)*/
init_native_HashTableIndex(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Index.init(_native:_HashTable.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Index.init(_cocoa:__CocoaDictionary.Index)*/
/*Swift.(file).Dictionary.Index.init(_cocoa:__CocoaDictionary.Index)*/
init_cocoa__CocoaDictionaryIndex(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Index.init(_cocoa:__CocoaDictionary.Index) in ' + this.constructor.name
}
















static /*Swift.(file).Dictionary.Index.==infix(_:Dictionary<Key, Value>.Index,_:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Dictionary.Index.<infix(_:Dictionary<Key, Value>.Index,_:Dictionary<Key, Value>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
/*Swift.(file).Dictionary.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Index.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).Dictionary.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Dictionary.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}
static Iterator = class implements IteratorProtocol, CustomReflectable{
static readonly $struct = true
static _Variant = class{

static _native() {return Object.assign(new MIO_Mixin_Dictionary.Iterator._Variant(), {rawValue: "_native", ...Array.from(arguments)})}

static cocoa() {return Object.assign(new MIO_Mixin_Dictionary.Iterator._Variant(), {rawValue: "cocoa", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}





/*Swift.(file).Dictionary.Iterator.init(_variant:Dictionary<Key, Value>.Iterator._Variant)*/
/*Swift.(file).Dictionary.Iterator.init(_variant:Dictionary<Key, Value>.Iterator._Variant)*/
init_variantDictionaryIterator_Variant(_variant, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Iterator.init(_variant:Dictionary<Key, Value>.Iterator._Variant) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Iterator.init(_native:_NativeDictionary<Key, Value>.Iterator)*/
/*Swift.(file).Dictionary.Iterator.init(_native:_NativeDictionary<Key, Value>.Iterator)*/
init_native_NativeDictionaryIterator(_native, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Iterator.init(_native:_NativeDictionary<Key, Value>.Iterator) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.Iterator.init(_cocoa:__CocoaDictionary.Iterator)*/
/*Swift.(file).Dictionary.Iterator.init(_cocoa:__CocoaDictionary.Iterator)*/
init_cocoa__CocoaDictionaryIterator(_cocoa, $info?) {
throw 'unsupported method Swift.(file).Dictionary.Iterator.init(_cocoa:__CocoaDictionary.Iterator) in ' + this.constructor.name
}















/*Swift.(file).Dictionary.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).Dictionary.Iterator.next() in ' + this.constructor.name
}


/*Swift.(file).Dictionary.Iterator.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Dictionary.Iterator.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}

/*Swift.(file).Dictionary.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Dictionary.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };



/*Swift.(file).Dictionary.popFirst()*/
/*Swift.(file).Dictionary.popFirst()*/
popFirst($info?) {
throw 'unsupported method Swift.(file).Dictionary.popFirst() in ' + this.constructor.name
}

/*Swift.(file).Dictionary.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file).Dictionary.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };



/*Swift.(file).Dictionary.reserveCapacity(_:Int)*/
/*Swift.(file).Dictionary.reserveCapacity(_:Int)*/
reserveCapacity(minimumCapacity, $info?) {
throw 'unsupported method Swift.(file).Dictionary.reserveCapacity(_:Int) in ' + this.constructor.name
}


/*Swift.(file).Dictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>) -> Int)*/
/*Swift.(file).Dictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>) -> Int)*/
init_unsafeUninitializedCapacityIntAllowingDuplicatesBoolInitializingWithfunction_type(capacity, allowingDuplicates, initializer, $info?) {
let _this = this;
_this.init_native_NativeDictionary(_create(_NativeDictionary, 'init_unsafeUninitializedCapacityIntAllowingDuplicatesBoolInitializingWithfunction_type', capacity, allowingDuplicates, initializer, {}));
return
}
/*Swift.(file).Dictionary.init(_mapping:C,allowingDuplicates:Bool,transform:(C.Element) -> (key: Key, value: Value)?)*/
/*Swift.(file).Dictionary.init(_mapping:C,allowingDuplicates:Bool,transform:(C.Element) -> (key: Key, value: Value)?)*/
init_mappingAllowingDuplicatesBoolTransformfunction_type<C>(source, allowingDuplicates, transform, $info?) {
let _this = this;
let target = _create(_NativeDictionary, 'initCapacityInt', source.count, {});
if((allowingDuplicates)) {
{
let $member$generator = source.makeIterator( {});
while(true) {
const $ifLet0, member_1;
if(!((($ifLet0 = $member$generator.next( {$setThis: $val => $member$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((member_1 = $ifLet0[0])||true))) break
const $ifLet2, key_3, value_4
if(!((($ifLet2 = transform(member_1))||true) && $ifLet2.rawValue == 'some' && ((key_3 = $ifLet2[0][0])||true) && ((value_4 = $ifLet2[0][1])||true))) {
return (this.$failed = true);
};
target._unsafeUpdateKeyValue(key_3, value_4, {$setThis: $val => target = $val});
}
};
}
else {
{
let $member$generator = source.makeIterator( {});
while(true) {
const $ifLet5, member_6;
if(!((($ifLet5 = $member$generator.next( {$setThis: $val => $member$generator = $val}))||true) && $ifLet5.rawValue == 'some' && ((member_6 = $ifLet5[0])||true))) break
const $ifLet7, key_8, value_9
if(!((($ifLet7 = transform(member_6))||true) && $ifLet7.rawValue == 'some' && ((key_8 = $ifLet7[0][0])||true) && ((value_9 = $ifLet7[0][1])||true))) {
return (this.$failed = true);
};
target._unsafeInsertNewKeyValue(key_8, value_9);
}
};
};
_this.init_native_NativeDictionary(target);
return
}
static readonly init_mappingAllowingDuplicatesBoolTransformfunction_type$failable = true
static _Variant = class implements _DictionaryBuffer{
static readonly $struct = true

/*Swift.(file).Dictionary._Variant.object*/
object$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.object in ' + this.constructor.name
}
get object() { return this.object$get() };





/*Swift.(file).Dictionary._Variant.init(native:_NativeDictionary<Key, Value>)*/
/*Swift.(file).Dictionary._Variant.init(native:_NativeDictionary<Key, Value>)*/
initNative_NativeDictionary(_native, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.init(native:_NativeDictionary<Key, Value>) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.init(dummy:Void)*/
/*Swift.(file).Dictionary._Variant.init(dummy:Void)*/
initDummyVoid(dummy, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.init(dummy:Void) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.init(cocoa:__CocoaDictionary)*/
/*Swift.(file).Dictionary._Variant.init(cocoa:__CocoaDictionary)*/
initCocoa__CocoaDictionary(cocoa, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.init(cocoa:__CocoaDictionary) in ' + this.constructor.name
}

/*Swift.(file).Dictionary._Variant.guaranteedNative*/
guaranteedNative$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.guaranteedNative in ' + this.constructor.name
}
get guaranteedNative() { return this.guaranteedNative$get() };



/*Swift.(file).Dictionary._Variant.isUniquelyReferenced()*/
/*Swift.(file).Dictionary._Variant.isUniquelyReferenced()*/
isUniquelyReferenced($info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.isUniquelyReferenced() in ' + this.constructor.name
}

/*Swift.(file).Dictionary._Variant.isNative*/
isNative$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.isNative in ' + this.constructor.name
}
get isNative() { return this.isNative$get() };




/*Swift.(file).Dictionary._Variant.asNative*/
asNative$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.asNative in ' + this.constructor.name
}
get asNative() { return this.asNative$get() };






/*Swift.(file).Dictionary._Variant.asCocoa*/
asCocoa$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.asCocoa in ' + this.constructor.name
}
get asCocoa() { return this.asCocoa$get() };



/*Swift.(file).Dictionary._Variant.reserveCapacity(_:Int)*/
/*Swift.(file).Dictionary._Variant.reserveCapacity(_:Int)*/
reserveCapacity(capacity, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.reserveCapacity(_:Int) in ' + this.constructor.name
}

/*Swift.(file).Dictionary._Variant.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };






/*Swift.(file).Dictionary._Variant.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Dictionary._Variant.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Dictionary._Variant.index(after:Dictionary<Key, Value>._Variant.Index)*/
/*Swift.(file)._DictionaryBuffer.index(after:Self.Index)*/
indexAfter(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.index(after:Dictionary<Key, Value>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.formIndex(after:Dictionary<Key, Value>._Variant.Index)*/
/*Swift.(file).Dictionary._Variant.formIndex(after:Dictionary<Key, Value>._Variant.Index)*/
formIndexAfter(index$inout, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.formIndex(after:Dictionary<Key, Value>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.index(forKey:Key)*/
/*Swift.(file)._DictionaryBuffer.index(forKey:Self.Key)*/
indexForKey(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.index(forKey:Key) in ' + this.constructor.name
}

/*Swift.(file).Dictionary._Variant.count*/
count$get() {
throw 'unsupported variable Swift.(file).Dictionary._Variant.count in ' + this.constructor.name
}
get count() { return this.count$get() };



/*Swift.(file).Dictionary._Variant.contains(_:Key)*/
/*Swift.(file)._DictionaryBuffer.contains(_:Self.Key)*/
contains(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.contains(_:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.lookup(_:Key)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Key)*/
lookup(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.lookup(_:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.lookup(_:Dictionary<Key, Value>._Variant.Index)*/
/*Swift.(file)._DictionaryBuffer.lookup(_:Self.Index)*/
/*!!!DUPLICATE NAME*/
lookup(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.lookup(_:Dictionary<Key, Value>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.key(at:Dictionary<Key, Value>._Variant.Index)*/
/*Swift.(file)._DictionaryBuffer.key(at:Self.Index)*/
keyAt(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.key(at:Dictionary<Key, Value>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.value(at:Dictionary<Key, Value>._Variant.Index)*/
/*Swift.(file)._DictionaryBuffer.value(at:Self.Index)*/
valueAt(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.value(at:Dictionary<Key, Value>._Variant.Index) in ' + this.constructor.name
}


/*Swift.(file).Dictionary._Variant.subscript(_:Key)*/
/*Swift.(file).Dictionary._Variant.subscript(_:Key)*/
subscript$get(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.subscript(_:Key) in ' + this.constructor.name
}/*Swift.(file).Dictionary._Variant.subscript(_:Key)*/
/*Swift.(file).Dictionary._Variant.subscript(_:Key)*/
subscript$_modify(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.subscript(_:Key) in ' + this.constructor.name
}



/*Swift.(file).Dictionary._Variant.mutatingFind(_:Key)*/
/*Swift.(file).Dictionary._Variant.mutatingFind(_:Key)*/
mutatingFind(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.mutatingFind(_:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.ensureUniqueNative()*/
/*Swift.(file).Dictionary._Variant.ensureUniqueNative()*/
ensureUniqueNative($info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.ensureUniqueNative() in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.updateValue(_:Value,forKey:Key)*/
/*Swift.(file).Dictionary._Variant.updateValue(_:Value,forKey:Key)*/
updateValueForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.updateValue(_:Value,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.setValue(_:Value,forKey:Key)*/
/*Swift.(file).Dictionary._Variant.setValue(_:Value,forKey:Key)*/
setValueForKey(value, key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.setValue(_:Value,forKey:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.remove(at:Dictionary<Key, Value>._Variant.Index)*/
/*Swift.(file).Dictionary._Variant.remove(at:Dictionary<Key, Value>._Variant.Index)*/
removeAt(index, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.remove(at:Dictionary<Key, Value>._Variant.Index) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.removeValue(forKey:Key)*/
/*Swift.(file).Dictionary._Variant.removeValue(forKey:Key)*/
removeValueForKey(key, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.removeValue(forKey:Key) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).Dictionary._Variant.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.removeAll(keepingCapacity:Bool) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.makeIterator()*/
/*Swift.(file).Dictionary._Variant.makeIterator()*/
makeIterator($info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.makeIterator() in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.mapValues(_:(Value) throws -> T)*/
/*Swift.(file).Dictionary._Variant.mapValues(_:(Value) throws -> T)*/
mapValues<T>(transform, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.mapValues(_:(Value) throws -> T) in ' + this.constructor.name
}
/*Swift.(file).Dictionary._Variant.merge(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
/*Swift.(file).Dictionary._Variant.merge(_:S,uniquingKeysWith:(Value, Value) throws -> Value)*/
mergeUniquingKeysWith<S>(keysAndValues, combine, $info?) {
throw 'unsupported method Swift.(file).Dictionary._Variant.merge(_:S,uniquingKeysWith:(Value, Value) throws -> Value) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
/*Swift.(file).Dictionary.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Dictionary.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Dictionary.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Dictionary.init(from:Decoder) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Keys.Iterator, IteratorProtocol$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Keys, Collection$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Keys, Equatable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Keys, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Keys, CustomDebugStringConvertible$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Values.Iterator, IteratorProtocol$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Values, MutableCollection$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Values, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Values, CustomDebugStringConvertible$implementation, false)
_mixin(MIO_Mixin_Dictionary.Index._Variant, _DefaultEnumImplementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Index, Hashable$implementation, false)
_mixin(MIO_Mixin_Dictionary.Iterator._Variant, _DefaultEnumImplementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Iterator, IteratorProtocol$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary.Iterator, CustomReflectable$implementation, false)
if(typeof _DictionaryBuffer$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary._Variant, _DictionaryBuffer$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, Collection$implementation, false)
if(typeof ExpressibleByDictionaryLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, ExpressibleByDictionaryLiteral$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, CustomReflectable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, Encodable$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(MIO_Mixin_Dictionary, Decodable$implementation, false)
_mixin(Map, MIO_Mixin_Dictionary, true)
class Dictionary{}
_mixin(Dictionary, MIO_Mixin_Dictionary, true)












































class FlattenSequence<Base> implements Sequence, Collection, BidirectionalCollection{
static readonly $struct = true





/*Swift.(file).FlattenSequence.init(_base:Base)*/
/*Swift.(file).FlattenSequence.init(_base:Base)*/
init_base(_base, $info?) {
let _this = this;
_this._base = _base;
return
}
static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true










/*Swift.(file).FlattenSequence.Iterator.init(_base:Base.Iterator)*/
/*Swift.(file).FlattenSequence.Iterator.init(_base:Base.Iterator)*/
init_base(_base, $info?) {
let _this = this;
_this._base = _base;
return
}

/*Swift.(file).FlattenSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
do {
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(_this._inner, _injectIntoOptional(null))))) {
const ret = _this._inner[0].next( {$setThis: $val => _this._inner[0] = $val});
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(ret, _injectIntoOptional(null))))) {
return ret;
};
};
const s = _this._base.next( {$setThis: $val => _this._base = $val});
if((_slowPath(Optional.wrappedEqualsOptionalNilComparisonType(s, _injectIntoOptional(null))))) {
return _injectIntoOptional(null);
};
_this._inner = _injectIntoOptional(s[0].makeIterator( {}));
} while(true)
}

init$vars() {let _this = this;

}
}
/*Swift.(file).FlattenSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(FlattenSequence.Iterator, 'init_base', _this._base.makeIterator( {}), {})
}

static Index = class implements Equatable, Comparable, Hashable{
static readonly $struct = true






/*Swift.(file).FlattenSequence.Index.init(_:Base.Index,_:Base.Element.Index?)*/
/*Swift.(file).FlattenSequence.Index.init(_:Base.Index,_:Base.Element.Index?)*/
initOptional(_outer, inner, $info?) {
throw 'unsupported method Swift.(file).FlattenSequence.Index.init(_:Base.Index,_:Base.Element.Index?) in ' + this.constructor.name
}
static /*Swift.(file).FlattenSequence.Index.==infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return Bool.$logicalAND((_.arg0 = lhs._outer).constructor.$equal(_.arg0, rhs._outer), () => Optional.$equal(lhs._inner, rhs._inner))
}
static /*Swift.(file).FlattenSequence.Index.<infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
if(((_.arg0 = lhs._outer).constructor.$notEqual(_.arg0, rhs._outer))) {
return (_.arg1 = lhs._outer).constructor.$lessThan(_.arg1, rhs._outer);
};
const $ifLet0, lhsInner_1
const $ifLet2, rhsInner_3
if((($ifLet0 = lhs._inner)||true) && $ifLet0.rawValue == 'some' && ((lhsInner_1 = $ifLet0[0])||true) && (($ifLet2 = rhs._inner)||true) && $ifLet2.rawValue == 'some' && ((rhsInner_3 = $ifLet2[0])||true)) {
return (_.arg2 = lhsInner_1).constructor.$lessThan(_.arg2, rhsInner_3);
};
preconditionFileLine(() => Bool.$logicalAND(Optional.wrappedEqualsOptionalNilComparisonType(lhs._inner, _injectIntoOptional(null)), () => Optional.wrappedEqualsOptionalNilComparisonType(rhs._inner, _injectIntoOptional(null))), null, null, null);
return false
}
/*Swift.(file).FlattenSequence.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this._outer, {$setThis: $val => hasher = $val});
hasher.combine(_this._inner, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).FlattenSequence.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).FlattenSequence.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}

/*Swift.(file).FlattenSequence.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).FlattenSequence.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).FlattenSequence.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).FlattenSequence.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };





/*Swift.(file).FlattenSequence.index(after:FlattenSequence<Base>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).FlattenSequence.index(after:FlattenSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).FlattenSequence.formIndex(after:FlattenSequence<Base>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).FlattenSequence.distance(from:FlattenSequence<Base>.Index,to:FlattenSequence<Base>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}


/*Swift.(file).FlattenSequence.index(_:FlattenSequence<Base>.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)*/
/*Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)*/
formIndexOffsetBy(i$inout, n, $info?) {
throw 'unsupported method Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int) in ' + this.constructor.name
}
/*Swift.(file).FlattenSequence.index(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)*/
/*Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)*/
formIndexOffsetByLimitedBy(i$inout, n, limit, $info?) {
throw 'unsupported method Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).FlattenSequence.subscript(_:FlattenSequence<Base>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).FlattenSequence.subscript(_:FlattenSequence<Base>.Index) in ' + this.constructor.name
}


/*Swift.(file).FlattenSequence.subscript(_:Range<FlattenSequence<Base>.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}

/*Swift.(file).FlattenSequence.index(before:FlattenSequence<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).FlattenSequence.index(before:FlattenSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).FlattenSequence.formIndex(before:FlattenSequence<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}


init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(FlattenSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(FlattenSequence.Iterator, Sequence$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(FlattenSequence.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(FlattenSequence.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(FlattenSequence.Index, Hashable$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(FlattenSequence, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(FlattenSequence, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(FlattenSequence, BidirectionalCollection$implementation, false)












interface FloatingPoint<Exponent> extends SignedNumeric, Strideable, Hashable{

/*Swift.(file).FloatingPoint.init(sign:FloatingPointSign,exponent:Self.Exponent,significand:Self)*/
/*Swift.(file).FloatingPoint.init(sign:FloatingPointSign,exponent:Self.Exponent,significand:Self)*/
initSignFloatingPointSignExponentSignificand(sign, exponent, significand, $info?)
/*Swift.(file).FloatingPoint.init(signOf:Self,magnitudeOf:Self)*/
/*Swift.(file).FloatingPoint.init(signOf:Self,magnitudeOf:Self)*/
initSignOfMagnitudeOf(signOf, magnitudeOf, $info?)
/*Swift.(file).FloatingPoint.init(_:Int)*/
/*Swift.(file).FloatingPoint.init(_:Int)*/
initInt(value, $info?)
/*Swift.(file).FloatingPoint.init(_:Source)*/
/*Swift.(file).FloatingPoint.init(_:Source)*/
initSource<Source>(value, $info?)
/*Swift.(file).FloatingPoint.init(exactly:Source)*/
/*Swift.(file).FloatingPoint.init(exactly:Source)*/
initExactly<Source>(value, $info?)

/*Swift.(file).FloatingPoint.radix*/
static radix;




/*Swift.(file).FloatingPoint.nan*/
static nan;




/*Swift.(file).FloatingPoint.signalingNaN*/
static signalingNaN;




/*Swift.(file).FloatingPoint.infinity*/
static infinity;




/*Swift.(file).FloatingPoint.greatestFiniteMagnitude*/
static greatestFiniteMagnitude;




/*Swift.(file).FloatingPoint.pi*/
static pi;




/*Swift.(file).FloatingPoint.ulp*/
ulp;




/*Swift.(file).FloatingPoint.ulpOfOne*/
static ulpOfOne;




/*Swift.(file).FloatingPoint.leastNormalMagnitude*/
static leastNormalMagnitude;




/*Swift.(file).FloatingPoint.leastNonzeroMagnitude*/
static leastNonzeroMagnitude;




/*Swift.(file).FloatingPoint.sign*/
sign;




/*Swift.(file).FloatingPoint.exponent*/
exponent;




/*Swift.(file).FloatingPoint.significand*/
significand;



static /*Swift.(file).FloatingPoint.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?)
static /*Swift.(file).FloatingPoint.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).FloatingPoint.-prefix(_:Self)*/
/*Swift.(file).SignedNumeric.-prefix(_:Self)*/
$negate(operand, $info?)
/*Swift.(file).FloatingPoint.negate()*/
/*Swift.(file).SignedNumeric.negate()*/
negate($info?)
static /*Swift.(file).FloatingPoint.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?)
static /*Swift.(file).FloatingPoint.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).FloatingPoint.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?)
static /*Swift.(file).FloatingPoint.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).FloatingPoint./infix(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?)
static /*Swift.(file).FloatingPoint./=infix(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?)
/*Swift.(file).FloatingPoint.remainder(dividingBy:Self)*/
/*Swift.(file).FloatingPoint.remainder(dividingBy:Self)*/
remainderDividingBy(other, $info?)
/*Swift.(file).FloatingPoint.formRemainder(dividingBy:Self)*/
/*Swift.(file).FloatingPoint.formRemainder(dividingBy:Self)*/
formRemainderDividingBy(other, $info?)
/*Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)*/
/*Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)*/
truncatingRemainderDividingBy(other, $info?)
/*Swift.(file).FloatingPoint.formTruncatingRemainder(dividingBy:Self)*/
/*Swift.(file).FloatingPoint.formTruncatingRemainder(dividingBy:Self)*/
formTruncatingRemainderDividingBy(other, $info?)
/*Swift.(file).FloatingPoint.squareRoot()*/
/*Swift.(file).FloatingPoint.squareRoot()*/
squareRoot($info?)
/*Swift.(file).FloatingPoint.formSquareRoot()*/
/*Swift.(file).FloatingPoint.formSquareRoot()*/
formSquareRoot($info?)
/*Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)*/
addingProduct(lhs, rhs, $info?)
/*Swift.(file).FloatingPoint.addProduct(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.addProduct(_:Self,_:Self)*/
addProduct(lhs, rhs, $info?)
static /*Swift.(file).FloatingPoint.minimum(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.minimum(_:Self,_:Self)*/
minimum(x, y, $info?)
static /*Swift.(file).FloatingPoint.maximum(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.maximum(_:Self,_:Self)*/
maximum(x, y, $info?)
static /*Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)*/
minimumMagnitude(x, y, $info?)
static /*Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)*/
maximumMagnitude(x, y, $info?)
/*Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)*/
/*Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)*/
rounded(rule, $info?)
/*Swift.(file).FloatingPoint.round(_:FloatingPointRoundingRule)*/
/*Swift.(file).FloatingPoint.round(_:FloatingPointRoundingRule)*/
round(rule, $info?)

/*Swift.(file).FloatingPoint.nextUp*/
nextUp;




/*Swift.(file).FloatingPoint.nextDown*/
nextDown;



/*Swift.(file).FloatingPoint.isEqual(to:Self)*/
/*Swift.(file).FloatingPoint.isEqual(to:Self)*/
isEqualTo(other, $info?)
/*Swift.(file).FloatingPoint.isLess(than:Self)*/
/*Swift.(file).FloatingPoint.isLess(than:Self)*/
isLessThan(other, $info?)
/*Swift.(file).FloatingPoint.isLessThanOrEqualTo(_:Self)*/
/*Swift.(file).FloatingPoint.isLessThanOrEqualTo(_:Self)*/
isLessThanOrEqualTo(other, $info?)
/*Swift.(file).FloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)*/
/*Swift.(file).FloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)*/
isTotallyOrderedBelowOrEqualTo(other, $info?)

/*Swift.(file).FloatingPoint.isNormal*/
isNormal;







/*Swift.(file).FloatingPoint.isZero*/
isZero;




/*Swift.(file).FloatingPoint.isSubnormal*/
isSubnormal;




/*Swift.(file).FloatingPoint.isInfinite*/
isInfinite;







/*Swift.(file).FloatingPoint.isSignalingNaN*/
isSignalingNaN;




/*Swift.(file).FloatingPoint.floatingPointClass*/
floatingPointClass;




/*Swift.(file).FloatingPoint.isCanonical*/
isCanonical;



}
class FloatingPoint$implementation{
static /*Swift.(file).FloatingPoint.==infix(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).FloatingPoint.<infix(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
return lhs <= rhs
}
static /*Swift.(file).FloatingPoint.>infix(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
return lhs > rhs
}
static /*Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
return lhs >= rhs
}

/*Swift.(file).FloatingPoint.ulpOfOne*/
static ulpOfOne$get() {
let _this = this;
return 1.ulp;
}
static get ulpOfOne() { return this.ulpOfOne$get()
}
static get ulpOfOne() { return this.ulpOfOne$get() };



/*Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)*/
/*Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)*/
rounded(rule, $info?) {
let _this = this;
let lhs = _this;
lhs.round(rule, {$setThis: $val => lhs = $val});
return lhs
}
/*Swift.(file).FloatingPoint.rounded()*/
/*Swift.(file).FloatingPoint.rounded()*/
/*!!!DUPLICATE NAME*/
rounded($info?) {
let _this = this;
return _this.constructor.prototype.rounded.call(_this, FloatingPointRoundingRule.toNearestOrAwayFromZero)
}
/*Swift.(file).FloatingPoint.round()*/
/*Swift.(file).FloatingPoint.round()*/
/*!!!DUPLICATE NAME*/
round($info?) {
let _this = this;
_this.round(FloatingPointRoundingRule.toNearestOrAwayFromZero, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}

/*Swift.(file).FloatingPoint.nextDown*/
nextDown$get() {
let _this = this;
return _this.constructor.$negate(_this.constructor.$negate(_this).nextUp)
}
get nextDown() { return this.nextDown$get() };



/*Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)*/
/*Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)*/
truncatingRemainderDividingBy(other, $info?) {
let _this = this;
let lhs = _this;
lhs.formTruncatingRemainderDividingBy(other, {$setThis: $val => lhs = $val});
return lhs
}
/*Swift.(file).FloatingPoint.remainder(dividingBy:Self)*/
/*Swift.(file).FloatingPoint.remainder(dividingBy:Self)*/
remainderDividingBy(other, $info?) {
let _this = this;
let lhs = _this;
lhs.formRemainderDividingBy(other, {$setThis: $val => lhs = $val});
return lhs
}
/*Swift.(file).FloatingPoint.squareRoot()*/
/*Swift.(file).FloatingPoint.squareRoot()*/
squareRoot($info?) {
let _this = this;
let lhs = _this;
lhs.formSquareRoot( {$setThis: $val => lhs = $val});
return lhs
}
/*Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)*/
addingProduct(lhs, rhs, $info?) {
let _this = this;
let addend = _this;
addend.addProduct(lhs, rhs, {$setThis: $val => addend = $val});
return addend
}
static /*Swift.(file).FloatingPoint.minimum(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.minimum(_:Self,_:Self)*/
minimum(x, y, $info?) {
let _this = this;
if((Bool.$logicalOR(_this.$lessThanOrEqual(x, y), () => _this.prototype._isNaN$get.call(y)))) {
return x;
};
return y
}
static /*Swift.(file).FloatingPoint.maximum(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.maximum(_:Self,_:Self)*/
maximum(x, y, $info?) {
let _this = this;
if((Bool.$logicalOR(_this.$greaterThan(x, y), () => _this.prototype._isNaN$get.call(y)))) {
return x;
};
return y
}
static /*Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)*/
minimumMagnitude(x, y, $info?) {
let _this = this;
if((Bool.$logicalOR(_this.$lessThanOrEqual(_this.prototype.magnitude$get.call(x), _this.prototype.magnitude$get.call(y)), () => _this.prototype._isNaN$get.call(y)))) {
return x;
};
return y
}
static /*Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)*/
/*Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)*/
maximumMagnitude(x, y, $info?) {
let _this = this;
if((Bool.$logicalOR(_this.$greaterThan(_this.prototype.magnitude$get.call(x), _this.prototype.magnitude$get.call(y)), () => _this.prototype._isNaN$get.call(y)))) {
return x;
};
return y
}

/*Swift.(file).FloatingPoint.floatingPointClass*/
floatingPointClass$get() {
let _this = this;
if((_this.constructor.prototype.isSignalingNaN$get.call(_this))) {
return FloatingPointClassification.signalingNaN;
};
if((_this.constructor.prototype._isNaN$get.call(_this))) {
return FloatingPointClassification.quietNaN;
};
if((_this.constructor.prototype.isInfinite$get.call(_this))) {
return (FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus) ? FloatingPointClassification.negativeInfinity : FloatingPointClassification.positiveInfinity);
};
if((_this.constructor.prototype.isNormal$get.call(_this))) {
return (FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus) ? FloatingPointClassification.negativeNormal : FloatingPointClassification.positiveNormal);
};
if((_this.constructor.prototype.isSubnormal$get.call(_this))) {
return (FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus) ? FloatingPointClassification.negativeSubnormal : FloatingPointClassification.positiveSubnormal);
};
return (FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus) ? FloatingPointClassification.negativeZero : FloatingPointClassification.positiveZero)
}
get floatingPointClass() { return this.floatingPointClass$get() };



}
if(typeof SignedNumeric$implementation != 'undefined') _mixin(FloatingPoint$implementation, SignedNumeric$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(FloatingPoint$implementation, Strideable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(FloatingPoint$implementation, Hashable$implementation, false)






interface BinaryFloatingPoint<RawSignificand, RawExponent> extends FloatingPoint, ExpressibleByFloatLiteral{


/*Swift.(file).BinaryFloatingPoint.init(sign:FloatingPointSign,exponentBitPattern:Self.RawExponent,significandBitPattern:Self.RawSignificand)*/
/*Swift.(file).BinaryFloatingPoint.init(sign:FloatingPointSign,exponentBitPattern:Self.RawExponent,significandBitPattern:Self.RawSignificand)*/
initSignFloatingPointSignExponentBitPatternSignificandBitPattern(sign, exponentBitPattern, significandBitPattern, $info?)
/*Swift.(file).BinaryFloatingPoint.init(_:Float)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float)*/
initFloat(value, $info?)
/*Swift.(file).BinaryFloatingPoint.init(_:Double)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Double)*/
initDouble(value, $info?)
/*Swift.(file).BinaryFloatingPoint.init(_:Float80)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float80)*/
initFloat80(value, $info?)
/*Swift.(file).BinaryFloatingPoint.init(_:Source)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Source)*/
initSource<Source>(value, $info?)
/*Swift.(file).BinaryFloatingPoint.init(exactly:Source)*/
/*Swift.(file).BinaryFloatingPoint.init(exactly:Source)*/
initExactly<Source>(value, $info?)

/*Swift.(file).BinaryFloatingPoint.exponentBitCount*/
static exponentBitCount;




/*Swift.(file).BinaryFloatingPoint.significandBitCount*/
static significandBitCount;




/*Swift.(file).BinaryFloatingPoint.exponentBitPattern*/
exponentBitPattern;




/*Swift.(file).BinaryFloatingPoint.significandBitPattern*/
significandBitPattern;




/*Swift.(file).BinaryFloatingPoint.binade*/
binade;




/*Swift.(file).BinaryFloatingPoint.significandWidth*/
significandWidth;



}
class BinaryFloatingPoint$implementation{

/*Swift.(file).BinaryFloatingPoint.radix*/
static radix$get() {
let _this = this;
return 2;
}
static get radix() { return this.radix$get()
}
static get radix() { return this.radix$get() };



/*Swift.(file).BinaryFloatingPoint.init(signOf:Self,magnitudeOf:Self)*/
/*Swift.(file).BinaryFloatingPoint.init(signOf:Self,magnitudeOf:Self)*/
initSignOfMagnitudeOf(signOf, magnitudeOf, $info?) {
let _this = this;
_this.initSignFloatingPointSignExponentBitPatternSignificandBitPattern(_this.constructor.prototype.sign$get.call(signOf), _this.constructor.prototype.exponentBitPattern$get.call(magnitudeOf), _this.constructor.prototype.significandBitPattern$get.call(magnitudeOf));
return
}

/*Swift.(file).BinaryFloatingPoint.init(_:Source)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Source)*/
initSource<Source>(value, $info?) {
let _this = this;
return _cloneStruct(_this.constructor._convertFrom(value)["0"]);
return
}
/*Swift.(file).BinaryFloatingPoint.init(exactly:Source)*/
/*Swift.(file).BinaryFloatingPoint.init(exactly:Source)*/
initExactly<Source>(value, $info?) {
let _this = this;
const $tuple = _this.constructor._convertFrom(value), value_ = $tuple && $tuple[0], exact = $tuple && $tuple[1];
if(!((exact))) {
return (this.$failed = true);
};
return _cloneStruct(value_);
return
}
static readonly initExactly$failable = true
/*Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)*/
/*Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)*/
isTotallyOrderedBelowOrEqualTo(other, $info?) {
let _this = this;
if((_this.constructor.$lessThan(_this, other))) {
return true;
};
if((_this.constructor.$greaterThan(other, _this))) {
return false;
};
if((FloatingPointSign.$notEqual(_this.constructor.prototype.sign$get.call(_this), _this.constructor.prototype.sign$get.call(other)))) {
return FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus);
};
if((((function(){throw '!unclarifiedGeneric:Self.RawExponent'})()).$greaterThan(_this.constructor.prototype.exponentBitPattern$get.call(_this), _this.constructor.prototype.exponentBitPattern$get.call(other)))) {
return FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus);
};
if((((function(){throw '!unclarifiedGeneric:Self.RawExponent'})()).$lessThan(_this.constructor.prototype.exponentBitPattern$get.call(_this), _this.constructor.prototype.exponentBitPattern$get.call(other)))) {
return FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.plus);
};
if((((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$greaterThan(_this.constructor.prototype.significandBitPattern$get.call(_this), _this.constructor.prototype.significandBitPattern$get.call(other)))) {
return FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus);
};
if((((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$lessThan(_this.constructor.prototype.significandBitPattern$get.call(_this), _this.constructor.prototype.significandBitPattern$get.call(other)))) {
return FloatingPointSign.$equal(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.plus);
};
return true
}

/*Swift.(file).BinaryFloatingPoint.init(_:Source)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Source)*/
initSource<Source>(value, $info?) {
let _this = this;
return _cloneStruct(_this.constructor._convertFrom(value)["0"]);
return
}
/*Swift.(file).BinaryFloatingPoint.init(exactly:Source)*/
/*Swift.(file).BinaryFloatingPoint.init(exactly:Source)*/
initExactly<Source>(value, $info?) {
let _this = this;
const $tuple = _this.constructor._convertFrom(value), value_ = $tuple && $tuple[0], exact = $tuple && $tuple[1];
if(!((exact))) {
return (this.$failed = true);
};
return _cloneStruct(value_);
return
}
static readonly initExactly$failable = true
static /*Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)*/
/*Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.$not(range.isEmpty), () => "Can't get random value with an empty range", null, null);
const delta = _this.$subtract(range.upperBound, range.lowerBound);
preconditionFileLine(() => _this.prototype._isFinite$get.call(delta), () => "There is no uniform distribution on an infinite range", null, null);
const rand;
if((Int.$equal(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).bitWidth, Int.$add(_this.significandBitCount, 1)))) {
rand = generator.next( {$setThis: $val => generator = $val});
}
else {
const significandCount = Int.$add(_this.significandBitCount, 1);
const maxSignificand = ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$bitwiseLeftShift(1, significandCount);
rand = ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$bitwiseAND(generator.next( {$setThis: $val => generator = $val}), ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$subtract(maxSignificand, 1));
};
const unitRandom = _this.$multiply(_create(_this, 'initSource', rand, {}), _this.$divide(_this.ulpOfOne, 2));
const randFloat = _this.$add(_this.$multiply(delta, unitRandom), range.lowerBound);
if((_this.$equal(randFloat, range.upperBound))) {
return _this.randomInUsing(range, {get: () => generator, set: $val => generator = $val});
};
return randFloat;})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)*/
/*Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}
static /*Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)*/
/*Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)*/
/*!!!DUPLICATE NAME*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.$not(range.isEmpty), () => "Can't get random value with an empty range", null, null);
const delta = _this.$subtract(range.upperBound, range.lowerBound);
preconditionFileLine(() => _this.prototype._isFinite$get.call(delta), () => "There is no uniform distribution on an infinite range", null, null);
const rand;
if((Int.$equal(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).bitWidth, Int.$add(_this.significandBitCount, 1)))) {
rand = generator.next( {$setThis: $val => generator = $val});
const tmp = UInt8.$bitwiseAND(generator.next( {$setThis: $val => generator = $val}), 1);
if((Bool.$logicalAND(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$equal(rand, ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).max), () => UInt8.$equal(tmp, 1)))) {
return range.upperBound;
};
}
else {
const significandCount = Int.$add(_this.significandBitCount, 1);
const maxSignificand = ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$bitwiseLeftShift(1, significandCount);
rand = generator.nextUpperBound(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$add(maxSignificand, 1), {$setThis: $val => generator = $val});
if((((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).$equal(rand, maxSignificand))) {
return range.upperBound;
};
};
const unitRandom = _this.$multiply(_create(_this, 'initSource', rand, {}), _this.$divide(_this.ulpOfOne, 2));
const randFloat = _this.$add(_this.$multiply(delta, unitRandom), range.lowerBound);
return randFloat;})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)*/
/*Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)*/
/*!!!DUPLICATE NAME*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}
static _convertFrom(number, $info) {
    return {0: number, 1: true/*exact*/}
}
}
if(typeof FloatingPoint$implementation != 'undefined') _mixin(BinaryFloatingPoint$implementation, FloatingPoint$implementation, false)
if(typeof ExpressibleByFloatLiteral$implementation != 'undefined') _mixin(BinaryFloatingPoint$implementation, ExpressibleByFloatLiteral$implementation, false)






interface BinaryInteger<Words> extends Hashable, Numeric, CustomStringConvertible, Strideable{

/*Swift.(file).BinaryInteger.isSigned*/
static isSigned;



/*Swift.(file).BinaryInteger.init(exactly:T)*/
/*Swift.(file).BinaryInteger.init(exactly:T)*/
initExactly<T>(source, $info?)
/*Swift.(file).BinaryInteger.init(_:T)*/
/*Swift.(file).BinaryInteger.init(_:T)*/
initT<T>(source, $info?)
/*Swift.(file).BinaryInteger.init(_:T)*/
/*Swift.(file).BinaryInteger.init(_:T)*/
initT<T>(source, $info?)
/*Swift.(file).BinaryInteger.init(truncatingIfNeeded:T)*/
/*Swift.(file).BinaryInteger.init(truncatingIfNeeded:T)*/
initTruncatingIfNeeded<T>(source, $info?)
/*Swift.(file).BinaryInteger.init(clamping:T)*/
/*Swift.(file).BinaryInteger.init(clamping:T)*/
initClamping<T>(source, $info?)


/*Swift.(file).BinaryInteger.words*/
words;







/*Swift.(file).BinaryInteger.bitWidth*/
bitWidth;





/*Swift.(file).BinaryInteger.trailingZeroBitCount*/
trailingZeroBitCount;



static /*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.~prefix(_:Self)*/
/*Swift.(file).BinaryInteger.~prefix(_:Self)*/
$bitwiseNot(x, $info?)
static /*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)*/
/*Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)*/
$bitwiseRightShift<RHS>(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.>>=infix(_:Self,_:RHS)*/
/*Swift.(file).BinaryInteger.>>=infix(_:Self,_:RHS)*/
$rightBitShiftAndAssign<RHS>(lhs$inout, rhs, $info?)
static /*Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)*/
/*Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)*/
$bitwiseLeftShift<RHS>(lhs, rhs, $info?)
static /*Swift.(file).BinaryInteger.<<=infix(_:Self,_:RHS)*/
/*Swift.(file).BinaryInteger.<<=infix(_:Self,_:RHS)*/
$leftBitShiftAndAssign<RHS>(lhs$inout, rhs, $info?)
/*Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)*/
/*Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)*/
quotientAndRemainderDividingBy(rhs, $info?)
/*Swift.(file).BinaryInteger.isMultiple(of:Self)*/
/*Swift.(file).BinaryInteger.isMultiple(of:Self)*/
isMultipleOf(other, $info?)
/*Swift.(file).BinaryInteger.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?)
}
class BinaryInteger$implementation{
/*Swift.(file).BinaryInteger.init()*/
/*Swift.(file).BinaryInteger.init()*/
init($info?) {
let _this = this;
return _cloneStruct(0);
return
}
/*Swift.(file).BinaryInteger.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}




/*Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)*/
/*Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)*/
quotientAndRemainderDividingBy(rhs, $info?) {
let _this = this;
return {0: _this.constructor.$divide(_this, rhs), 1: _this.constructor.$remainder(_this, rhs)}
}
/*Swift.(file).BinaryInteger.isMultiple(of:Self)*/
/*Swift.(file).BinaryInteger.isMultiple(of:Self)*/
isMultipleOf(other, $info?) {
let _this = this;
if((_this.constructor.$equal(other, 0))) {
return _this.constructor.$equal(_this, 0);
};
return ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$equal(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$remainder(_this.constructor.prototype.magnitude$get.call(_this), _this.constructor.prototype.magnitude$get.call(other)), 0)
}
static /*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)*/
/*Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)*/
$bitwiseRightShift<RHS>(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)*/
/*Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)*/
$bitwiseLeftShift<RHS>(lhs, rhs, $info?) {
return lhs << rhs
}


/*Swift.(file).BinaryInteger.description*/
description$get() {
return this.toString()
}
get description() { return this.description$get() };



/*Swift.(file).BinaryInteger.distance(to:Self)*/
/*Swift.(file).BinaryInteger.distance(to:Self)*/
distanceTo(other, $info?) {
let _this = this;
if((Bool.$not(_this.constructor.isSigned))) {
if((_this.constructor.$greaterThan(_this, other))) {
const $ifLet0, result_1
if((($ifLet0 = _create(Int, 'initExactly', _this.constructor.$subtract(_this, other), {}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return Int.$negate(result_1);
};
}
else {
const $ifLet2, result_3
if((($ifLet2 = _create(Int, 'initExactly', _this.constructor.$subtract(other, _this), {}))||true) && $ifLet2.rawValue == 'some' && ((result_3 = $ifLet2[0])||true)) {
return result_3;
};
};
}
else {
const isNegative = _this.constructor.$lessThan(_this, 0);
if((Bool.$equal(isNegative, _this.constructor.$lessThan(other, 0)))) {
const $ifLet4, result_5
if((($ifLet4 = _create(Int, 'initExactly', _this.constructor.$subtract(other, _this), {}))||true) && $ifLet4.rawValue == 'some' && ((result_5 = $ifLet4[0])||true)) {
return result_5;
};
}
else {
const $ifLet6, result_7
if((($ifLet6 = _create(Int, 'initExactly', ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$add(_this.constructor.prototype.magnitude$get.call(_this), _this.constructor.prototype.magnitude$get.call(other)), {}))||true) && $ifLet6.rawValue == 'some' && ((result_7 = $ifLet6[0])||true)) {
return (isNegative ? result_7 : Int.$negate(result_7));
};
};
};
preconditionFailureFileLine(() => "Distance is not representable in Int", null, null)
}
/*Swift.(file).BinaryInteger.advanced(by:Int)*/
/*Swift.(file).BinaryInteger.advanced(by:Int)*/
advancedBy(n, $info?) {
let _this = this;
if((Bool.$not(_this.constructor.isSigned))) {
return (Int.$lessThan(n, 0) ? _this.constructor.$subtract(_this, _create(_this.constructor, 'initT', Int.$negate(n), {})) : _this.constructor.$add(_this, _create(_this.constructor, 'initT', n, {})));
};
if((Bool.$equal(_this.constructor.$lessThan(_this, 0), Int.$lessThan(n, 0)))) {
return _this.constructor.$add(_this, _create(_this.constructor, 'initT', n, {}));
};
return (((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$lessThan(_this.constructor.prototype.magnitude$get.call(_this), Int.prototype.magnitude$get.call(n)) ? _create(_this.constructor, 'initT', Int.$add(_create(Int, 'initT', _this, {}), n), {}) : _this.constructor.$add(_this, _create(_this.constructor, 'initT', n, {})))
}
static /*Swift.(file).BinaryInteger.==infix(_:Self,_:Other)*/
/*Swift.(file).BinaryInteger.==infix(_:Self,_:Other)*/
$equal<Other>(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)*/
/*Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)*/
$notEqual<Other>(lhs, rhs, $info?) {
return lhs != rhs
}
static /*Swift.(file).BinaryInteger.<infix(_:Self,_:Other)*/
/*Swift.(file).BinaryInteger.<infix(_:Self,_:Other)*/
$lessThan<Other>(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)*/
/*Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)*/
$lessThanOrEqual<Other>(lhs, rhs, $info?) {
return lhs <= rhs
}
static /*Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)*/
/*Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)*/
$greaterThanOrEqual<Other>(lhs, rhs, $info?) {
return lhs >= rhs
}
static /*Swift.(file).BinaryInteger.>infix(_:Self,_:Other)*/
/*Swift.(file).BinaryInteger.>infix(_:Self,_:Other)*/
$greaterThan<Other>(lhs, rhs, $info?) {
return lhs > rhs
}
static /*Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)*/
/*!!!DUPLICATE NAME*/
$notEqual(lhs, rhs, $info?) {
return lhs != rhs
}
static /*Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)*/
/*!!!DUPLICATE NAME*/
$lessThanOrEqual(lhs, rhs, $info?) {
return lhs <= rhs
}
static /*Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)*/
/*!!!DUPLICATE NAME*/
$greaterThanOrEqual(lhs, rhs, $info?) {
return lhs >= rhs
}
static /*Swift.(file).BinaryInteger.>infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.>infix(_:Self,_:Self)*/
/*!!!DUPLICATE NAME*/
$greaterThan(lhs, rhs, $info?) {
return lhs > rhs
}
//not sure why missing; it's there in generated-by-step-2.txt
initT(from, $info) {
    return from
}
}
if(typeof Hashable$implementation != 'undefined') _mixin(BinaryInteger$implementation, Hashable$implementation, false)
if(typeof Numeric$implementation != 'undefined') _mixin(BinaryInteger$implementation, Numeric$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(BinaryInteger$implementation, CustomStringConvertible$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(BinaryInteger$implementation, Strideable$implementation, false)












interface FixedWidthInteger extends BinaryInteger, LosslessStringConvertible{

/*Swift.(file).FixedWidthInteger.bitWidth*/
static bitWidth;




/*Swift.(file).FixedWidthInteger.max*/
static max;




/*Swift.(file).FixedWidthInteger.min*/
static min;



/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(rhs, $info?)
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(rhs, $info?)
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(rhs, $info?)
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(rhs, $info?)
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(rhs, $info?)
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?)
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?)
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?)

/*Swift.(file).FixedWidthInteger.nonzeroBitCount*/
nonzeroBitCount;




/*Swift.(file).FixedWidthInteger.leadingZeroBitCount*/
leadingZeroBitCount;



/*Swift.(file).FixedWidthInteger.init(bigEndian:Self)*/
/*Swift.(file).FixedWidthInteger.init(bigEndian:Self)*/
initBigEndian(value, $info?)
/*Swift.(file).FixedWidthInteger.init(littleEndian:Self)*/
/*Swift.(file).FixedWidthInteger.init(littleEndian:Self)*/
initLittleEndian(value, $info?)

/*Swift.(file).FixedWidthInteger.bigEndian*/
bigEndian;




/*Swift.(file).FixedWidthInteger.littleEndian*/
littleEndian;




/*Swift.(file).FixedWidthInteger.byteSwapped*/
byteSwapped;



static /*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?)
static /*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?)
static /*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?)
static /*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?)
}
class FixedWidthInteger$implementation{

/*Swift.(file).FixedWidthInteger.init(_:S,radix:Int)*/
/*Swift.(file).FixedWidthInteger.init(_:S,radix:Int)*/
initRadixInt<S>(text, radix, $info?) {
let result = parseInt(_text)
if(isNaN(result)) return Optional.none
return Optional.some(result, {})
}
static readonly initRadixInt$failable = true
/*Swift.(file).FixedWidthInteger.init(_:String)*/
/*Swift.(file).FixedWidthInteger.init(_:String)*/
initString(description, $info?) {
let _this = this;
_this.initRadixInt(description, 10);
return
}
static readonly initString$failable = true

/*Swift.(file).FixedWidthInteger.bitWidth*/
bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).FixedWidthInteger.init(littleEndian:Self)*/
/*Swift.(file).FixedWidthInteger.init(littleEndian:Self)*/
initLittleEndian(value, $info?) {
let _this = this;
return _cloneStruct(value);
return
}
/*Swift.(file).FixedWidthInteger.init(bigEndian:Self)*/
/*Swift.(file).FixedWidthInteger.init(bigEndian:Self)*/
initBigEndian(value, $info?) {
let _this = this;
return _cloneStruct(_this.constructor.prototype.byteSwapped$get.call(value));
return
}

/*Swift.(file).FixedWidthInteger.littleEndian*/
littleEndian$get() {
let _this = this;
return _this
}
get littleEndian() { return this.littleEndian$get() };




/*Swift.(file).FixedWidthInteger.bigEndian*/
bigEndian$get() {
let _this = this;
return _this.constructor.prototype.byteSwapped$get.call(_this)
}
get bigEndian() { return this.bigEndian$get() };



static /*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)*/
/*!!!DUPLICATE NAME*/
infix_38_62_62<Other>(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)*/
/*!!!DUPLICATE NAME*/
infix_38_62_62_61<Other>(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)*/
/*!!!DUPLICATE NAME*/
infix_38_60_60<Other>(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)*/
/*!!!DUPLICATE NAME*/
infix_38_60_60_61<Other>(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}
static /*Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)*/
/*Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.$not(range.isEmpty), () => "Can't get random value with an empty range", null, null);
const delta = _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', _this.$subtractWithOverflow(range.upperBound, range.lowerBound), {});
return _create(_this, 'initTruncatingIfNeeded', ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$addWithOverflow(_create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', range.lowerBound, {}), generator.nextUpperBound(delta, {$setThis: $val => generator = $val})), {});})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).FixedWidthInteger.random(in:Range<Self>)*/
/*Swift.(file).FixedWidthInteger.random(in:Range<Self>)*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}
static /*Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)*/
/*Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)*/
/*!!!DUPLICATE NAME*/
randomInUsing<T>(range, generator$inout, $info?) {
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.$not(range.isEmpty), () => "Can't get random value with an empty range", null, null);
let delta = _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', _this.$subtractWithOverflow(range.upperBound, range.lowerBound), {});
if((((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$equal(delta, ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).max))) {
return _create(_this, 'initTruncatingIfNeeded', generator.next( {$setThis: $val => generator = $val}), {});
};
((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$addAndAssign({get: () => delta, set: $val => delta = $val}, 1);
return _create(_this, 'initTruncatingIfNeeded', ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).$addWithOverflow(_create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', range.lowerBound, {}), generator.nextUpperBound(delta, {$setThis: $val => generator = $val})), {});})()
generator$inout.set(generator)
return $result
}
static /*Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)*/
/*Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)*/
/*!!!DUPLICATE NAME*/
randomIn(range, $info?) {
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val})
}
static /*Swift.(file).FixedWidthInteger.~prefix(_:Self)*/
/*Swift.(file).FixedWidthInteger.~prefix(_:Self)*/
$bitwiseNot(x, $info?) {
return ~x
}
static /*Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)*/
$bitwiseRightShift<Other>(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)*/
$rightBitShiftAndAssign<Other>(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}


static /*Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)*/
$bitwiseLeftShift<Other>(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)*/
/*Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)*/
$leftBitShiftAndAssign<Other>(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}



/*Swift.(file).FixedWidthInteger.init(_:T)*/
/*Swift.(file).FixedWidthInteger.init(_:T)*/
initT<T>(source, $info?) {
let _this = this;
const $ifLet0, value_1
if(!((($ifLet0 = _this.constructor._convertFrom(source)["0"])||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) {
fatalErrorFileLine(() => (("") + (((function(){throw '!unclarifiedGeneric:T'})())) + (" value cannot be converted to ") + (_this.constructor) + (" because it is outside the representable range")), null, null);
};
return _cloneStruct(value_1);
return
}
/*Swift.(file).FixedWidthInteger.init(exactly:T)*/
/*Swift.(file).FixedWidthInteger.init(exactly:T)*/
initExactly<T>(source, $info?) {
let _this = this;
const $tuple = _this.constructor._convertFrom(source), temporary = $tuple && $tuple[0], exact = $tuple && $tuple[1];
const $ifLet0, value_1
if(!((exact) && (($ifLet0 = temporary)||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
return _cloneStruct(value_1);
return
}
static readonly initExactly$failable = true
/*Swift.(file).FixedWidthInteger.init(clamping:Other)*/
/*Swift.(file).FixedWidthInteger.init(clamping:Other)*/
initClamping<Other>(source, $info?) {
let _this = this;
if((_slowPath(((function(){throw '!unclarifiedGeneric:Other'})()).$lessThan(source, _this.constructor.min)))) {
return _cloneStruct(_this.constructor.min);
}
else {
if((_slowPath(((function(){throw '!unclarifiedGeneric:Other'})()).$greaterThan(source, _this.constructor.max)))) {
return _cloneStruct(_this.constructor.max);
}
else {
return _cloneStruct(_create(_this.constructor, 'initTruncatingIfNeeded', source, {}));
}
};
return
}
/*Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)*/
/*Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)*/
initTruncatingIfNeeded<T>(source, $info?) {
let _this = this;
if((Int.$lessThanOrEqual(_this.constructor.bitWidth, Int.bitWidth))) {
return _cloneStruct(_create(_this.constructor, 'init_truncatingBitsUInt', ((function(){throw '!unclarifiedGeneric:T'})()).prototype._lowWord$get.call(source), {}));
}
else {
const neg = ((function(){throw '!unclarifiedGeneric:T'})()).$lessThan(source, 0);
let result = (neg ? _this.constructor.$bitwiseNot(0) : 0);
let shift = 0;
const width = _create(_this.constructor, 'init_truncatingBitsUInt', Int.prototype._lowWord$get.call(_this.constructor.bitWidth), {});
{
let $word$generator = ((function(){throw '!unclarifiedGeneric:T'})()).prototype.words$get.call(source).makeIterator( {});
while(true) {
const $ifLet0, word_1;
if(!((($ifLet0 = $word$generator.next( {$setThis: $val => $word$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((word_1 = $ifLet0[0])||true))) break
if(!((_this.constructor.$lessThan(shift, width)))) {
break;
};
_this.constructor.$bitwiseXORAndAssign({get: () => result, set: $val => result = $val}, _this.constructor.infix_38_60_60(_create(_this.constructor, 'init_truncatingBitsUInt', (neg ? UInt.$bitwiseNot(word_1) : word_1), {}), shift));
_this.constructor.$addAndAssign({get: () => shift, set: $val => shift = $val}, _create(_this.constructor, 'init_truncatingBitsUInt', Int.prototype._lowWord$get.call(Int.bitWidth), {}));
}
};
return _cloneStruct(result);
};
return
}



static /*Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)*/
$addWithOverflow(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)*/
infix_38_43_61(lhs$inout, rhs, $info?) {
return lhs$inout += rhs
}
static /*Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)*/
$subtractWithOverflow(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)*/
infix_38_45_61(lhs$inout, rhs, $info?) {
return lhs$inout -= rhs
}
static /*Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)*/
$multiplyIgnoringOverflow(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)*/
/*Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)*/
infix_38_42_61(lhs$inout, rhs, $info?) {
return lhs$inout *= rhs
}




static _convertFrom(number, $info) {
    return {0: _injectIntoOptional(number), 1: true/*exact*/}
}
}
if(typeof BinaryInteger$implementation != 'undefined') _mixin(FixedWidthInteger$implementation, BinaryInteger$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(FixedWidthInteger$implementation, LosslessStringConvertible$implementation, false)














interface UnsignedInteger extends BinaryInteger{

}
class UnsignedInteger$implementation{
/*Swift.(file).UnsignedInteger.magnitude*/
magnitude$get() {
let _this = this;
return _this
}
get magnitude() { return this.magnitude$get() };




/*Swift.(file).UnsignedInteger.isSigned*/
static isSigned$get() {
let _this = this;
return false;
}
static get isSigned() { return this.isSigned$get()
}
static get isSigned() { return this.isSigned$get() };



/*Swift.(file).UnsignedInteger.init(_:T)*/
/*Swift.(file).UnsignedInteger.init(_:T)*/
initT<T>(source, $info?) {
let _this = this;
if((((function(){throw '!unclarifiedGeneric:T'})()).isSigned)) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).$greaterThanOrEqual(source, 0), () => "Negative value is not representable", null, null);
};
if((Int.$greaterThanOrEqual(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth))) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).$lessThanOrEqual(source, _this.constructor.max), () => "Not enough bits to represent the passed value", null, null);
};
_this.initTruncatingIfNeeded(source);
return
}
/*Swift.(file).UnsignedInteger.init(exactly:T)*/
/*Swift.(file).UnsignedInteger.init(exactly:T)*/
initExactly<T>(source, $info?) {
let _this = this;
if((Bool.$logicalAND(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => ((function(){throw '!unclarifiedGeneric:T'})()).$lessThan(source, 0)))) {
return (this.$failed = true);
};
if((Bool.$logicalAND(Int.$greaterThanOrEqual(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth), () => ((function(){throw '!unclarifiedGeneric:T'})()).$greaterThan(source, _this.constructor.max)))) {
return (this.$failed = true);
};
_this.initTruncatingIfNeeded(source);
return
}
static readonly initExactly$failable = true

/*Swift.(file).UnsignedInteger.max*/
static max$get() {
return Number.MAX_SAFE_INTEGER
}
static get max() { return this.max$get() };




/*Swift.(file).UnsignedInteger.min*/
static min$get() {
let _this = this;
return 0;
}
static get min() { return this.min$get()
}
static get min() { return this.min$get() };



}
if(typeof BinaryInteger$implementation != 'undefined') _mixin(UnsignedInteger$implementation, BinaryInteger$implementation, false)






interface SignedInteger extends BinaryInteger, SignedNumeric{


}
class SignedInteger$implementation{

/*Swift.(file).SignedInteger.isSigned*/
static isSigned$get() {
let _this = this;
return true;
}
static get isSigned() { return this.isSigned$get()
}
static get isSigned() { return this.isSigned$get() };



/*Swift.(file).SignedInteger.init(_:T)*/
/*Swift.(file).SignedInteger.init(_:T)*/
initT<T>(source, $info?) {
let _this = this;
if((Bool.$logicalAND(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => Int.$greaterThan(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth)))) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).$greaterThanOrEqual(source, _this.constructor.min), () => "Not enough bits to represent a signed value", null, null);
};
if((Bool.$logicalOR(Int.$greaterThan(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth), () => Bool.$logicalAND(Int.$equal(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth), () => Bool.$not(((function(){throw '!unclarifiedGeneric:T'})()).isSigned))))) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).$lessThanOrEqual(source, _this.constructor.max), () => "Not enough bits to represent the passed value", null, null);
};
_this.initTruncatingIfNeeded(source);
return
}
/*Swift.(file).SignedInteger.init(exactly:T)*/
/*Swift.(file).SignedInteger.init(exactly:T)*/
initExactly<T>(source, $info?) {
let _this = this;
if((Bool.$logicalAND(Bool.$logicalAND(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => Int.$greaterThan(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth)), () => ((function(){throw '!unclarifiedGeneric:T'})()).$lessThan(source, _this.constructor.min)))) {
return (this.$failed = true);
};
if((Bool.$logicalAND(Bool.$logicalOR(Int.$greaterThan(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth), () => Bool.$logicalAND(Int.$equal(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth), () => Bool.$not(((function(){throw '!unclarifiedGeneric:T'})()).isSigned))), () => ((function(){throw '!unclarifiedGeneric:T'})()).$greaterThan(source, _this.constructor.max)))) {
return (this.$failed = true);
};
_this.initTruncatingIfNeeded(source);
return
}
static readonly initExactly$failable = true

/*Swift.(file).SignedInteger.max*/
static max$get() {
let _this = this;
return _this.$bitwiseNot(_this.min);
}
static get max() { return this.max$get()
}
static get max() { return this.max$get() };




/*Swift.(file).SignedInteger.min*/
static min$get() {
let _this = this;
return _this.infix_38_60_60(-1, _this._highBitIndex);
}
static get min() { return this.min$get()
}
static get min() { return this.min$get() };



/*Swift.(file).SignedInteger.isMultiple(of:Self)*/
/*Swift.(file).SignedInteger.isMultiple(of:Self)*/
isMultipleOf(other, $info?) {
let _this = this;
if((_this.constructor.$equal(other, 0))) {
return _this.constructor.$equal(_this, 0);
};
if((_this.constructor.$equal(other, -1))) {
return true;
};
return _this.constructor.$equal(_this.constructor.$remainder(_this, other), 0)
}


static /*Swift.(file).SignedInteger.&+infix(_:Self,_:Self)*/
/*Swift.(file).SignedInteger.&+infix(_:Self,_:Self)*/
$addWithOverflow(lhs, rhs, $info?) {
return lhs + rhs
}

static /*Swift.(file).SignedInteger.&-infix(_:Self,_:Self)*/
/*Swift.(file).SignedInteger.&-infix(_:Self,_:Self)*/
$subtractWithOverflow(lhs, rhs, $info?) {
return lhs - rhs
}

}
if(typeof BinaryInteger$implementation != 'undefined') _mixin(SignedInteger$implementation, BinaryInteger$implementation, false)
if(typeof SignedNumeric$implementation != 'undefined') _mixin(SignedInteger$implementation, SignedNumeric$implementation, false)










interface LazyCollectionProtocol extends Collection, LazySequenceProtocol{

}
class LazyCollectionProtocol$implementation{
/*Swift.(file).LazyCollectionProtocol.lazy*/
lazy$get() {
let _this = this;
return _this._elements.lazy
}
get lazy() { return this.lazy$get() };




/*Swift.(file).LazyCollectionProtocol.lazy*/
lazy$get() {
let _this = this;
return _this._elements.lazy
}
get lazy() { return this.lazy$get() };



}
if(typeof Collection$implementation != 'undefined') _mixin(LazyCollectionProtocol$implementation, Collection$implementation, false)
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(LazyCollectionProtocol$implementation, LazySequenceProtocol$implementation, false)






interface _Pointer<Pointee> extends Hashable, Strideable, CustomDebugStringConvertible, CustomReflectable{





/*Swift.(file)._Pointer.init(_:RawPointer)*/
/*Swift.(file)._Pointer.init(_:RawPointer)*/
initRawPointer(_rawValue, $info?)
}
class _Pointer$implementation{
/*Swift.(file)._Pointer.init(_:OpaquePointer)*/
/*Swift.(file)._Pointer.init(_:OpaquePointer)*/
initOpaquePointer(from, $info?) {
let _this = this;
_this.initRawPointer(from._rawValue);
return
}
/*Swift.(file)._Pointer.init(_:OpaquePointer?)*/
/*Swift.(file)._Pointer.init(_:OpaquePointer?)*/
initOptional(from, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initOpaquePointer(unwrapped_1);
return
}
static readonly initOptional$failable = true
/*Swift.(file)._Pointer.init(bitPattern:Int)*/
/*Swift.(file)._Pointer.init(bitPattern:Int)*/
initBitPatternInt(bitPattern, $info?) {
throw 'unsupported method Swift.(file)._Pointer.init(bitPattern:Int) in ' + this.constructor.name
}
static readonly initBitPatternInt$failable = true
/*Swift.(file)._Pointer.init(bitPattern:UInt)*/
/*Swift.(file)._Pointer.init(bitPattern:UInt)*/
initBitPatternUInt(bitPattern, $info?) {
throw 'unsupported method Swift.(file)._Pointer.init(bitPattern:UInt) in ' + this.constructor.name
}
static readonly initBitPatternUInt$failable = true
/*Swift.(file)._Pointer.init(_:Self)*/
/*Swift.(file)._Pointer.init(_:Self)*/
init(other, $info?) {
let _this = this;
_this.initRawPointer(other._rawValue);
return
}
/*Swift.(file)._Pointer.init(_:Self?)*/
/*Swift.(file)._Pointer.init(_:Self?)*/
/*!!!DUPLICATE NAME*/
initOptional(other, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initRawPointer(unwrapped_1._rawValue);
return
}
static readonly initOptional$failable = true
static /*Swift.(file)._Pointer.==infix(_:Self,_:Self)*/
/*Swift.(file)._Pointer.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file)._Pointer.<infix(_:Self,_:Self)*/
/*Swift.(file)._Pointer.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
/*Swift.(file)._Pointer.successor()*/
/*Swift.(file)._Pointer.successor()*/
successor($info?) {
let _this = this;
return _this.advancedBy(1)
}
/*Swift.(file)._Pointer.predecessor()*/
/*Swift.(file)._Pointer.predecessor()*/
predecessor($info?) {
let _this = this;
return _this.advancedBy(-1)
}
/*Swift.(file)._Pointer.distance(to:Self)*/
/*Swift.(file)._Pointer.distance(to:Self)*/
distanceTo(end, $info?) {
throw 'unsupported method Swift.(file)._Pointer.distance(to:Self) in ' + this.constructor.name
}
/*Swift.(file)._Pointer.advanced(by:Int)*/
/*Swift.(file)._Pointer.advanced(by:Int)*/
advancedBy(n, $info?) {
throw 'unsupported method Swift.(file)._Pointer.advanced(by:Int) in ' + this.constructor.name
}
/*Swift.(file)._Pointer.hash(into:Hasher)*/
/*Swift.(file)._Pointer.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_create(UInt, 'initBitPatternOptional', _injectIntoOptional(_this), {}), {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}


/*Swift.(file)._Pointer.debugDescription*/
debugDescription$get() {
let _this = this;
return _rawPointerToString(_this._rawValue)
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file)._Pointer.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file)._Pointer.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };



}
if(typeof Hashable$implementation != 'undefined') _mixin(_Pointer$implementation, Hashable$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(_Pointer$implementation, Strideable$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(_Pointer$implementation, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(_Pointer$implementation, CustomReflectable$implementation, false)
















class LazyPrefixWhileSequence<Base> implements Sequence, LazySequenceProtocol, Collection, LazyCollectionProtocol, BidirectionalCollection{
static readonly $struct = true

/*Swift.(file).LazyPrefixWhileSequence.init(_base:Base,predicate:(LazyPrefixWhileSequence<Base>.Element) -> Bool)*/
/*Swift.(file).LazyPrefixWhileSequence.init(_base:Base,predicate:(LazyPrefixWhileSequence<Base>.Element) -> Bool)*/
init_basePredicatefunction_type(_base, predicate, $info?) {
throw 'unsupported method Swift.(file).LazyPrefixWhileSequence.init(_base:Base,predicate:(LazyPrefixWhileSequence<Base>.Element) -> Bool) in ' + this.constructor.name
}








static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true














/*Swift.(file).LazyPrefixWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyPrefixWhileSequence<Base>.Iterator.Element) -> Bool)*/
/*Swift.(file).LazyPrefixWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyPrefixWhileSequence<Base>.Iterator.Element) -> Bool)*/
init_basePredicatefunction_type(_base, predicate, $info?) {
throw 'unsupported method Swift.(file).LazyPrefixWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyPrefixWhileSequence<Base>.Iterator.Element) -> Bool) in ' + this.constructor.name
}
/*Swift.(file).LazyPrefixWhileSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const $ifLet0, nextElement_1
if((Bool.$not(_this._predicateHasFailed)) && (($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((nextElement_1 = $ifLet0[0])||true)) {
if((_this._predicate(nextElement_1))) {
return _injectIntoOptional(nextElement_1);
}
else {
_this._predicateHasFailed = true;
};
};
return _injectIntoOptional(null)
}

init$vars() {let _this = this;

}
}
/*Swift.(file).LazyPrefixWhileSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(LazyPrefixWhileSequence.Iterator, 'init_basePredicatefunction_type', _this._base.makeIterator( {}), _this._predicate, {})
}

static _IndexRepresentation = class{

static index() {return Object.assign(new LazyPrefixWhileSequence._IndexRepresentation(), {rawValue: "index", ...Array.from(arguments)})}

static get pastEnd() {return Object.assign(new LazyPrefixWhileSequence._IndexRepresentation(), {rawValue: "pastEnd", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}
static Index = class implements Comparable, Hashable{
static readonly $struct = true



/*Swift.(file).LazyPrefixWhileSequence.Index.init(_:Base.Index)*/
/*Swift.(file).LazyPrefixWhileSequence.Index.init(_:Base.Index)*/
init(i, $info?) {
throw 'unsupported method Swift.(file).LazyPrefixWhileSequence.Index.init(_:Base.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyPrefixWhileSequence.Index.init(endOf:Base)*/
/*Swift.(file).LazyPrefixWhileSequence.Index.init(endOf:Base)*/
initEndOf(endOf, $info?) {
throw 'unsupported method Swift.(file).LazyPrefixWhileSequence.Index.init(endOf:Base) in ' + this.constructor.name
}
static /*Swift.(file).LazyPrefixWhileSequence.Index.==infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
const $match = {0: lhs._value, 1: rhs._value}
if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Base.Index'})()).$equal(l, r);
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return true;
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue) || ($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return false;
}
}
static /*Swift.(file).LazyPrefixWhileSequence.Index.<infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
const $match = {0: lhs._value, 1: rhs._value}
if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Base.Index'})()).$lessThan(l, r);
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return true;
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return false;
}
}
/*Swift.(file).LazyPrefixWhileSequence.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
const $match = _this._value
if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const value = $match[0]
hasher.combine(value, {$setThis: $val => hasher = $val});
}
else if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
hasher.combine(Int.max, {$setThis: $val => hasher = $val});
};})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).LazyPrefixWhileSequence.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).LazyPrefixWhileSequence.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}


/*Swift.(file).LazyPrefixWhileSequence.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).LazyPrefixWhileSequence.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).LazyPrefixWhileSequence.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).LazyPrefixWhileSequence.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).LazyPrefixWhileSequence.index(after:LazyPrefixWhileSequence<Base>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).LazyPrefixWhileSequence.index(after:LazyPrefixWhileSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyPrefixWhileSequence.subscript(_:LazyPrefixWhileSequence<Base>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).LazyPrefixWhileSequence.subscript(_:LazyPrefixWhileSequence<Base>.Index) in ' + this.constructor.name
}



/*Swift.(file).LazyPrefixWhileSequence.index(before:LazyPrefixWhileSequence<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).LazyPrefixWhileSequence.index(before:LazyPrefixWhileSequence<Base>.Index) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(LazyPrefixWhileSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(LazyPrefixWhileSequence.Iterator, Sequence$implementation, false)
_mixin(LazyPrefixWhileSequence._IndexRepresentation, _DefaultEnumImplementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(LazyPrefixWhileSequence.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(LazyPrefixWhileSequence.Index, Hashable$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(LazyPrefixWhileSequence, Sequence$implementation, false)
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(LazyPrefixWhileSequence, LazySequenceProtocol$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(LazyPrefixWhileSequence, Collection$implementation, false)
if(typeof LazyCollectionProtocol$implementation != 'undefined') _mixin(LazyPrefixWhileSequence, LazyCollectionProtocol$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(LazyPrefixWhileSequence, BidirectionalCollection$implementation, false)
















interface RandomAccessCollection<Element, Index, SubSequence, Indices> extends BidirectionalCollection{





/*Swift.(file).RandomAccessCollection.indices*/;



/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?)

/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?)



/*Swift.(file).RandomAccessCollection.startIndex*/;




/*Swift.(file).RandomAccessCollection.endIndex*/;



/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?)
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?)
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?)
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?)
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?)
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?)
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?)
}
class RandomAccessCollection$implementation{
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?) {
let _this = this;
const l = _this.distanceFromTo(i, limit);
if(((Int.$greaterThan(distance, 0) ? Bool.$logicalAND(Int.$greaterThanOrEqual(l, 0), () => Int.$lessThan(l, distance)) : Bool.$logicalAND(Int.$lessThanOrEqual(l, 0), () => Int.$lessThan(distance, l))))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.indexOffsetBy(i, distance))
}


/*Swift.(file).RandomAccessCollection.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*!!!DUPLICATE NAME*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).RandomAccessCollection.index(after:Self.Index) in ' + this.constructor.name
}
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*!!!DUPLICATE NAME*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).RandomAccessCollection.index(before:Self.Index) in ' + this.constructor.name
}
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Self.Index.Stride)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Self.Index.Stride)*/
/*!!!DUPLICATE NAME*/
indexOffsetBy(i, distance, $info?) {
throw 'unsupported method Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Self.Index.Stride) in ' + this.constructor.name
}
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
throw 'unsupported method Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index) in ' + this.constructor.name
}
}
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(RandomAccessCollection$implementation, BidirectionalCollection$implementation, false)








class Range<Bound> implements Sequence, Collection, BidirectionalCollection, RandomAccessCollection, RangeExpression, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable, Equatable, Hashable, Decodable, Encodable{
static readonly $struct = true

/*Swift.(file).Range.lowerBound*/
readonly lowerBound$get() {
return this.lowerBound$internal
}
readonly get lowerBound() { return this.lowerBound$get() };




/*Swift.(file).Range.upperBound*/
readonly upperBound$get() {
return this.upperBound$internal
}
readonly get upperBound() { return this.upperBound$get() };



/*Swift.(file).Range.init(uncheckedBounds:(lower: Bound, upper: Bound))*/
/*Swift.(file).Range.init(uncheckedBounds:(lower: Bound, upper: Bound))*/
initUncheckedBoundstuple_type(bounds, $info?) {
this.lowerBound$internal = bounds[0]
this.upperBound$internal = bounds[1]
}
/*Swift.(file).Range.contains(_:Bound)*/
/*Swift.(file).RangeExpression.contains(_:Self.Bound)*/
contains(_element, $info?) {
let _this = this;
return Bool.$logicalAND((_.arg0 = _this.lowerBound).constructor.$lessThanOrEqual(_.arg0, _element), () => (_.arg1 = _element).constructor.$lessThan(_.arg1, _this.upperBound))
}

/*Swift.(file).Range.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.lowerBound).constructor.$equal(_.arg0, _this.upperBound)
}
get isEmpty() { return this.isEmpty$get() };









/*Swift.(file).Range.startIndex*/
startIndex$get() {
let _this = this;
return _this.lowerBound
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Range.endIndex*/
endIndex$get() {
let _this = this;
return _this.upperBound
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Range.index(after:Range<Bound>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return i.advancedBy(1)
}
/*Swift.(file).Range.index(before:Range<Bound>.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = i).constructor.$greaterThan(_.arg0, _this.lowerBound), null, null, null);
preconditionFileLine(() => (_.arg1 = i).constructor.$lessThanOrEqual(_.arg1, _this.upperBound), null, null, null);
return i.advancedBy(-1)
}
/*Swift.(file).Range.index(_:Range<Bound>.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
const r = i.advancedBy(numericCast(n, {T: Int, U: ((function(){throw '!unclarifiedGeneric:Bound.Stride'})())}));
preconditionFileLine(() => (_.arg0 = r).constructor.$greaterThanOrEqual(_.arg0, _this.lowerBound), null, null, null);
preconditionFileLine(() => (_.arg1 = r).constructor.$lessThanOrEqual(_.arg1, _this.upperBound), null, null, null);
return r
}
/*Swift.(file).Range.distance(from:Range<Bound>.Index,to:Range<Bound>.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return numericCast(start.distanceTo(end), {T: ((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), U: Int})
}
/*Swift.(file).Range.subscript(_:Range<Range<Bound>.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return bounds
}


/*Swift.(file).Range.indices*/
indices$get() {
let _this = this;
return _this
}
get indices() { return this.indices$get() };






/*Swift.(file).Range.subscript(_:Range<Bound>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
preconditionFileLine(() => _this.contains(position), () => "Index out of range", null, null);
return position
}


/*Swift.(file).Range.init(_:ClosedRange<Bound>)*/
/*Swift.(file).Range.init(_:ClosedRange<Bound>)*/
initClosedRange(other, $info?) {
let _this = this;
const upperBound = other.upperBound.advancedBy(1);
_this.initUncheckedBoundstuple_type({0: other.lowerBound, 1: upperBound});
return
}
/*Swift.(file).Range.relative(to:C)*/
/*Swift.(file).RangeExpression.relative(to:C)*/
relativeTo<C>(collection, $info?) {
let _this = this;
return _create(Range, 'initUncheckedBoundstuple_type', {0: _this.lowerBound, 1: _this.upperBound}, {})
}

/*Swift.(file).Range.clamped(to:Range<Bound>)*/
/*Swift.(file).Range.clamped(to:Range<Bound>)*/
clampedTo(limits, $info?) {
let _this = this;
const lower = ((_.arg0 = limits.lowerBound).constructor.$greaterThan(_.arg0, _this.lowerBound) ? limits.lowerBound : ((_.arg1 = limits.upperBound).constructor.$lessThan(_.arg1, _this.lowerBound) ? limits.upperBound : _this.lowerBound));
const upper = ((_.arg2 = limits.upperBound).constructor.$lessThan(_.arg2, _this.upperBound) ? limits.upperBound : ((_.arg3 = limits.lowerBound).constructor.$greaterThan(_.arg3, _this.upperBound) ? limits.lowerBound : _this.upperBound));
return _create(Range, 'initUncheckedBoundstuple_type', {0: lower, 1: upper}, {})
}

/*Swift.(file).Range.description*/
description$get() {
let _this = this;
return (("") + (_this.lowerBound) + ("..<") + (_this.upperBound) + (""))
}
get description() { return this.description$get() };




/*Swift.(file).Range.debugDescription*/
debugDescription$get() {
let _this = this;
return String.$add((("Range(") + (_create(String, 'initReflecting', _this.lowerBound, {})) + ("")), (("..<") + (_create(String, 'initReflecting', _this.upperBound, {})) + (")")))
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).Range.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["lowerBound", _this.lowerBound], ["upperBound", _this.upperBound]]), , , {})
}
get customMirror() { return this.customMirror$get() };



static /*Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return Bool.$logicalAND((_.arg0 = lhs.lowerBound).constructor.$equal(_.arg0, rhs.lowerBound), () => (_.arg1 = lhs.upperBound).constructor.$equal(_.arg1, rhs.upperBound))
}
/*Swift.(file).Range.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.lowerBound, {$setThis: $val => hasher = $val});
hasher.combine(_this.upperBound, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).Range.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Range.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Range.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
const lowerBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
const upperBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
if(!(((_.arg0 = lowerBound).constructor.$lessThanOrEqual(_.arg0, upperBound)))) {
throw DecodingError.dataCorrupted(_create(DecodingError.Context, 'initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional', decoder.codingPath, (("Cannot initialize ") + (Range) + (" with a lowerBound (") + (lowerBound) + (") greater than upperBound (") + (upperBound) + (")")), , {}));
};
_this.initUncheckedBoundstuple_type({0: lowerBound, 1: upperBound});
return
}
/*Swift.(file).Range.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.lowerBound, {$setThis: $val => container = $val});
container.encode(_this.upperBound, {$setThis: $val => container = $val})
}
/*Swift.(file).Range.overlaps(_:Range<Bound>)*/
/*Swift.(file).Range.overlaps(_:Range<Bound>)*/
overlaps(other, $info?) {
let _this = this;
const isDisjoint = Bool.$logicalOR(Bool.$logicalOR(Bool.$logicalOR((_.arg0 = other.upperBound).constructor.$lessThanOrEqual(_.arg0, _this.lowerBound), () => (_.arg1 = _this.upperBound).constructor.$lessThanOrEqual(_.arg1, other.lowerBound)), () => _this.isEmpty), () => other.isEmpty);
return Bool.$not(isDisjoint)
}
/*Swift.(file).Range.overlaps(_:ClosedRange<Bound>)*/
/*Swift.(file).Range.overlaps(_:ClosedRange<Bound>)*/
/*!!!DUPLICATE NAME*/
overlaps(other, $info?) {
let _this = this;
const isDisjoint = Bool.$logicalOR(Bool.$logicalOR((_.arg0 = other.upperBound).constructor.$lessThan(_.arg0, _this.lowerBound), () => (_.arg1 = _this.upperBound).constructor.$lessThanOrEqual(_.arg1, other.lowerBound)), () => _this.isEmpty);
return Bool.$not(isDisjoint)
}

/*Swift.(file).Range.init(_:Range<Bound>)*/
/*Swift.(file).Range.init(_:Range<Bound>)*/
initRange(other, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(other)));
return
}
init$vars() {let _this = this;

}
}
if(typeof Sequence$implementation != 'undefined') _mixin(Range, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(Range, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(Range, BidirectionalCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(Range, RandomAccessCollection$implementation, false)
if(typeof RangeExpression$implementation != 'undefined') _mixin(Range, RangeExpression$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(Range, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(Range, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(Range, CustomReflectable$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(Range, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(Range, Hashable$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(Range, Decodable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(Range, Encodable$implementation, false)
































class Repeated<Element> implements RandomAccessCollection{
static readonly $struct = true

/*Swift.(file).Repeated.count*/
readonly count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
readonly get count() { return this.count$get() };




/*Swift.(file).Repeated.repeatedValue*/
readonly repeatedValue$get() {
throw 'unsupported variable Swift.(file).Repeated.repeatedValue in ' + this.constructor.name
}
readonly get repeatedValue() { return this.repeatedValue$get() };



/*Swift.(file).Repeated.init(count:Int,repeatedValue:Element)*/
/*Swift.(file).Repeated.init(count:Int,repeatedValue:Element)*/
initCountIntRepeatedValue(count, repeatedValue, $info?) {
throw 'unsupported method Swift.(file).Repeated.init(count:Int,repeatedValue:Element) in ' + this.constructor.name
}


/*Swift.(file).Repeated.init(_repeating:Element,count:Int)*/
/*Swift.(file).Repeated.init(_repeating:Element,count:Int)*/
init_repeatingCountInt(repeatedValue, count, $info?) {
throw 'unsupported method Swift.(file).Repeated.init(_repeating:Element,count:Int) in ' + this.constructor.name
}

/*Swift.(file).Repeated.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Repeated.endIndex*/
endIndex$get() {
let _this = this;
return _this.count
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Repeated.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$logicalAND(Int.$greaterThanOrEqual(position, 0), () => Int.$lessThan(position, _this.count)), () => "Index out of range", null, null);
return _this.repeatedValue
}





init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(Repeated, RandomAccessCollection$implementation, false)




class ReversedCollection<Base> implements LazySequenceProtocol, Sequence, BidirectionalCollection, RandomAccessCollection{
static readonly $struct = true



/*Swift.(file).ReversedCollection.init(_base:Base)*/
/*Swift.(file).ReversedCollection.init(_base:Base)*/
init_base(_base, $info?) {
throw 'unsupported method Swift.(file).ReversedCollection.init(_base:Base) in ' + this.constructor.name
}

static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true








/*Swift.(file).ReversedCollection.Iterator.init(_base:Base)*/
/*Swift.(file).ReversedCollection.Iterator.init(_base:Base)*/
init_base(_base, $info?) {
throw 'unsupported method Swift.(file).ReversedCollection.Iterator.init(_base:Base) in ' + this.constructor.name
}

/*Swift.(file).ReversedCollection.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if(!((_fastPath((_.arg0 = _this._position).constructor.$notEqual(_.arg0, _this._base.startIndex))))) {
return _injectIntoOptional(null);
};
_this._base.formIndexBefore({get: () => _this._position, set: $val => _this._position = $val});
return _injectIntoOptional(_this._base.subscript$get(_this._position))
}

init$vars() {let _this = this;

}
}

/*Swift.(file).ReversedCollection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(ReversedCollection.Iterator, 'init_base', _this._base, {})
}
static Index = class implements Comparable, Hashable{
static readonly $struct = true

/*Swift.(file).ReversedCollection.Index.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file).ReversedCollection.Index.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };



/*Swift.(file).ReversedCollection.Index.init(_:Base.Index)*/
/*Swift.(file).ReversedCollection.Index.init(_:Base.Index)*/
init(base, $info?) {
throw 'unsupported method Swift.(file).ReversedCollection.Index.init(_:Base.Index) in ' + this.constructor.name
}
static /*Swift.(file).ReversedCollection.Index.==infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs.base).constructor.$equal(_.arg0, rhs.base)
}
static /*Swift.(file).ReversedCollection.Index.<infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = lhs.base).constructor.$greaterThan(_.arg0, rhs.base)
}
/*Swift.(file).ReversedCollection.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.base, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).ReversedCollection.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).ReversedCollection.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}

/*Swift.(file).ReversedCollection.startIndex*/
startIndex$get() {
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.endIndex, {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).ReversedCollection.endIndex*/
endIndex$get() {
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.startIndex, {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.indexBefore(i.base), {})
}
/*Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.indexAfter(i.base), {})
}
/*Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.indexOffsetBy(i.base, Int.$negate(n)), {})
}
/*Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._base.indexOffsetByLimitedBy(i.base, Int.$negate(n), limit.base).mapSwift(init(ReversedCollection.Index))
}
/*Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._base.distanceFromTo(end.base, start.base)
}
/*Swift.(file).ReversedCollection.subscript(_:ReversedCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
return _this._base.subscript$get(_this._base.indexBefore(position.base))
}




/*Swift.(file).ReversedCollection.reversed()*/
/*Swift.(file).ReversedCollection.reversed()*/
reversed($info?) {
let _this = this;
return _this._base
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(ReversedCollection.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(ReversedCollection.Iterator, Sequence$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(ReversedCollection.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(ReversedCollection.Index, Hashable$implementation, false)
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(ReversedCollection, LazySequenceProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(ReversedCollection, Sequence$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(ReversedCollection, BidirectionalCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(ReversedCollection, RandomAccessCollection$implementation, false)














class Slice<Base> implements LazySequenceProtocol, Collection, BidirectionalCollection, MutableCollection, RandomAccessCollection, RangeReplaceableCollection{
static readonly $struct = true















/*Swift.(file).Slice.init(base:Base,bounds:Range<Base.Index>)*/
/*Swift.(file).Slice.init(base:Base,bounds:Range<Base.Index>)*/
initBaseBoundsRange(base, bounds, $info?) {
let _this = this;
_this._base = base;
_this._startIndex = bounds.lowerBound;
_this._endIndex = bounds.upperBound;
return
}

/*Swift.(file).Slice.base*/
base$get() {
let _this = this;
return _this._base
}
get base() { return this.base$get() };










/*Swift.(file).Slice.startIndex*/
startIndex$get() {
let _this = this;
return _this._startIndex
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Slice.endIndex*/
endIndex$get() {
let _this = this;
return _this._endIndex
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Slice.subscript(_:Slice<Base>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(index, $info?) {
let _this = this;
return _this._base.subscript$get(index)
}


/*Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this._base, bounds, {})
}


/*Swift.(file).Slice.indices*/
indices$get() {
let _this = this;
return _this._base.indices.subscriptRange$get((_.arg0 = _this._startIndex).constructor.$halfOpenRange(_.arg0, _this._endIndex))
}
get indices() { return this.indices$get() };



/*Swift.(file).Slice.index(after:Slice<Base>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return _this._base.indexAfter(i)
}
/*Swift.(file).Slice.formIndex(after:Slice<Base>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._base.formIndexAfter({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._base.indexOffsetBy(i, n)
}
/*Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int,limitedBy:Slice<Base>.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._base.indexOffsetByLimitedBy(i, n, limit)
}
/*Swift.(file).Slice.distance(from:Slice<Base>.Index,to:Slice<Base>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._base.distanceFromTo(start, end)
}


/*Swift.(file).Slice.index(before:Slice<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return _this._base.indexBefore(i)
}
/*Swift.(file).Slice.formIndex(before:Slice<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._base.formIndexBefore({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Slice.subscript(_:Slice<Base>.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*!!!DUPLICATE NAME*/
subscript$get(index, $info?) {
let _this = this;
return _this._base.subscript$get(index)
}/*Swift.(file).Slice.subscript(_:Slice<Base>.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
subscript$set(newValue, index, $info?) {
let _this = this;
_this._base.subscript$set(newValue, index, {$setThis: $val => _this._base = $val})
}




/*Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*!!!DUPLICATE NAME*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this._base, bounds, {})
}/*Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(newValue, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}



/*Swift.(file).Slice.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
let _this = this;
_this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'init', {});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.endIndex;
return
}
/*Swift.(file).Slice.init(repeating:Base.Element,count:Int)*/
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
initRepeatingCountInt(repeatedValue, count, $info?) {
let _this = this;
_this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'initRepeatingCountInt', repeatedValue, count, {});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.endIndex;
return
}
/*Swift.(file).Slice.init(_:S)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
initBuffer<S>(_elements, $info?) {
let _this = this;
_this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'initBuffer', _elements, {});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.endIndex;
return
}
/*Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(subRange, newElements, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$add(Int.$add(_this._base.distanceFromTo(_this._startIndex, subRange.lowerBound), _this._base.distanceFromTo(subRange.upperBound, _this._endIndex)), numericCast(newElements.count, {T: Int, U: Int}));
_this._base.replaceSubrangeWith(subRange, newElements, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
/*Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
insertAt(newElement, i, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$add(_this.count, 1);
_this._base.insertAt(newElement, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
/*Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(contentsOf:S,at:Self.Index)*/
insertContentsOfAt<S>(newElements, i, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$add(_this.count, newElements.count);
_this._base.insertContentsOfAt(newElements, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
/*Swift.(file).Slice.remove(at:Slice<Base>.Index)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
removeAt(i, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$subtract(_this.count, 1);
const result = _this._base.removeAt(i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount);
return result
}
/*Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)*/
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)*/
removeSubrangeRange(bounds, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$subtract(_this.count, _this.distanceFromTo(bounds.lowerBound, bounds.upperBound));
_this._base.removeSubrangeRange(bounds, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
/*Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)*/
/*Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)*/
/*!!!DUPLICATE NAME*/
replaceSubrangeWith<C>(subRange, newElements, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$add(Int.$add(_this._base.distanceFromTo(_this._startIndex, subRange.lowerBound), _this._base.distanceFromTo(subRange.upperBound, _this._endIndex)), numericCast(newElements.count, {T: Int, U: Int}));
_this._base.replaceSubrangeWith(subRange, newElements, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
/*Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)*/
/*Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)*/
/*!!!DUPLICATE NAME*/
insertAt(newElement, i, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$add(_this.count, 1);
_this._base.insertAt(newElement, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
/*Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)*/
/*Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)*/
/*!!!DUPLICATE NAME*/
insertContentsOfAt<S>(newElements, i, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$add(_this.count, newElements.count);
_this._base.insertContentsOfAt(newElements, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
/*Swift.(file).Slice.remove(at:Slice<Base>.Index)*/
/*Swift.(file).Slice.remove(at:Slice<Base>.Index)*/
/*!!!DUPLICATE NAME*/
removeAt(i, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$subtract(_this.count, 1);
const result = _this._base.removeAt(i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount);
return result
}
/*Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)*/
/*Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)*/
removeSubrange(bounds, $info?) {
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex);
const newSliceCount = Int.$subtract(_this.count, _this.distanceFromTo(bounds.lowerBound, bounds.upperBound));
_this._base.removeSubrangeRange(bounds, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset);
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount)
}
init$vars() {let _this = this;

}
}
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(Slice, LazySequenceProtocol$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(Slice, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(Slice, BidirectionalCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(Slice, MutableCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(Slice, RandomAccessCollection$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(Slice, RangeReplaceableCollection$implementation, false)














class _SmallString implements RandomAccessCollection, MutableCollection{
static readonly $struct = true







/*Swift.(file)._SmallString.rawBits*/
rawBits$get() {
throw 'unsupported variable Swift.(file)._SmallString.rawBits in ' + this.constructor.name
}
get rawBits() { return this.rawBits$get() };




/*Swift.(file)._SmallString.leadingRawBits*/
leadingRawBits$get() {
throw 'unsupported variable Swift.(file)._SmallString.leadingRawBits in ' + this.constructor.name
}
get leadingRawBits() { return this.leadingRawBits$get() };






/*Swift.(file)._SmallString.trailingRawBits*/
trailingRawBits$get() {
throw 'unsupported variable Swift.(file)._SmallString.trailingRawBits in ' + this.constructor.name
}
get trailingRawBits() { return this.trailingRawBits$get() };





/*Swift.(file)._SmallString.init(rawUnchecked:_SmallString.RawBitPattern)*/
/*Swift.(file)._SmallString.init(rawUnchecked:_SmallString.RawBitPattern)*/
initRawUnchecked_SmallStringRawBitPattern(bits, $info?) {
throw 'unsupported method Swift.(file)._SmallString.init(rawUnchecked:_SmallString.RawBitPattern) in ' + this.constructor.name
}
/*Swift.(file)._SmallString.init(raw:_SmallString.RawBitPattern)*/
/*Swift.(file)._SmallString.init(raw:_SmallString.RawBitPattern)*/
initRaw_SmallStringRawBitPattern(bits, $info?) {
throw 'unsupported method Swift.(file)._SmallString.init(raw:_SmallString.RawBitPattern) in ' + this.constructor.name
}
/*Swift.(file)._SmallString.init(_:_StringObject)*/
/*Swift.(file)._SmallString.init(_:_StringObject)*/
init_StringObject(object, $info?) {
throw 'unsupported method Swift.(file)._SmallString.init(_:_StringObject) in ' + this.constructor.name
}
/*Swift.(file)._SmallString.init()*/
/*Swift.(file)._SmallString.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SmallString.init() in ' + this.constructor.name
}

/*Swift.(file)._SmallString.capacity*/
static capacity$get() {
let _this = this;
return 15;
}
static get capacity() { return this.capacity$get()
}
static get capacity() { return this.capacity$get() };




/*Swift.(file)._SmallString.rawDiscriminatedObject*/
rawDiscriminatedObject$get() {
let _this = this;
return UInt64.prototype.littleEndian$get.call(_this._storage["1"])
}
get rawDiscriminatedObject() { return this.rawDiscriminatedObject$get() };




/*Swift.(file)._SmallString.capacity*/
capacity$get() {
let _this = this;
return 15;
}
static get capacity() { return this.capacity$get()
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._SmallString.count*/
count$get() {
let _this = this;
return _StringObject.getSmallCountFromRaw(_this.rawDiscriminatedObject)
}
get count() { return this.count$get() };




/*Swift.(file)._SmallString.unusedCapacity*/
unusedCapacity$get() {
let _this = this;
return Int.$subtractWithOverflow(_this.capacity, _this.count)
}
get unusedCapacity() { return this.unusedCapacity$get() };




/*Swift.(file)._SmallString.isASCII*/
isASCII$get() {
let _this = this;
return _StringObject.getSmallIsASCIIFromRaw(_this.rawDiscriminatedObject)
}
get isASCII() { return this.isASCII$get() };




/*Swift.(file)._SmallString.zeroTerminatedRawCodeUnits*/
zeroTerminatedRawCodeUnits$get() {
let _this = this;
const smallStringCodeUnitMask = UInt64.$bitwiseNot(UInt64.prototype.bigEndian$get.call(0xFF));
return {0: _this._storage["0"], 1: UInt64.$bitwiseAND(_this._storage["1"], smallStringCodeUnitMask)}
}
get zeroTerminatedRawCodeUnits() { return this.zeroTerminatedRawCodeUnits$get() };



/*Swift.(file)._SmallString.computeIsASCII()*/
/*Swift.(file)._SmallString.computeIsASCII()*/
computeIsASCII($info?) {
let _this = this;
const asciiMask = 0x8080808080808080;
const raw = _this.zeroTerminatedRawCodeUnits;
return UInt64.$equal(UInt64.$bitwiseAND(UInt64.$bitwiseOR(raw["0"], raw["1"]), asciiMask), 0)
}






/*Swift.(file)._SmallString.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._SmallString.endIndex*/
endIndex$get() {
let _this = this;
return _this.count
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._SmallString.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(idx, $info?) {
let _this = this;
if((Int.$lessThan(idx, 8))) {
return UInt64.prototype._uncheckedGetByteAt.call(_this.leadingRawBits, idx);
}
else {
return UInt64.prototype._uncheckedGetByteAt.call(_this.trailingRawBits, Int.$subtractWithOverflow(idx, 8));
};

}/*Swift.(file)._SmallString.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, idx, $info?) {
let _this = this;
if((Int.$lessThan(idx, 8))) {
_this.leadingRawBits._uncheckedSetByteAtTo(idx, newValue, {$setThis: $val => _this.leadingRawBits = $val});
}
else {
_this.trailingRawBits._uncheckedSetByteAtTo(Int.$subtractWithOverflow(idx, 8), newValue, {$setThis: $val => _this.trailingRawBits = $val});
}
}




/*Swift.(file)._SmallString.subscript(_:Range<_SmallString.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _this.withUTF8(((utf8, $info?) => { 
const rebased = _create(UnsafeBufferPointer, 'initRebasingSlice', utf8.subscriptRange$get(bounds), {});
return _create(_SmallString, 'initUnsafeBufferPointer', rebased, {})._unsafelyUnwrappedUnchecked; }))
}



/*Swift.(file)._SmallString.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> Result)*/
/*Swift.(file)._SmallString.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> Result)*/
withUTF8<Result>(f, $info?) {
let _this = this;
let raw = _this.zeroTerminatedRawCodeUnits;
return withUnsafeBytesOf({get: () => raw, set: $val => raw = $val}, ((rawBufPtr, $info?) => { 
const ptr = _cloneStruct(rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked.assumingMemoryBoundTo(UInt8));
return f(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(ptr), _this.count, {})); }))
}
/*Swift.(file)._SmallString.withMutableCapacity(_:(UnsafeMutableBufferPointer<UInt8>) throws -> Int)*/
/*Swift.(file)._SmallString.withMutableCapacity(_:(UnsafeMutableBufferPointer<UInt8>) throws -> Int)*/
withMutableCapacity(f, $info?) {
let _this = this;
const len = withUnsafeMutableBytesOf({get: () => _this._storage, set: $val => _this._storage = $val}, ((rawBufPtr, $info?) => { 
const ptr = _cloneStruct(rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked.assumingMemoryBoundTo(UInt8));
return f(_create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(ptr), _SmallString.capacity, {})); }));
const $tuple = _this.zeroTerminatedRawCodeUnits, leading = $tuple && $tuple[0], trailing = $tuple && $tuple[1];
$info.$setThis(_this = _cloneStruct(_create(_SmallString, 'initLeadingUInt64TrailingUInt64CountInt', leading, trailing, len, {})))
}
/*Swift.(file)._SmallString.init(leading:UInt64,trailing:UInt64,count:Int)*/
/*Swift.(file)._SmallString.init(leading:UInt64,trailing:UInt64,count:Int)*/
initLeadingUInt64TrailingUInt64CountInt(leading, trailing, count, $info?) {
let _this = this;
const isASCII = UInt64.$equal(UInt64.$bitwiseAND(UInt64.$bitwiseOR(leading, trailing), 0x8080808080808080), 0);
const discriminator = UInt64.prototype.littleEndian$get.call(_StringObject.Nibbles.smallWithCountIsASCII(count, isASCII));
_this.initRaw_SmallStringRawBitPattern({0: leading, 1: UInt64.$bitwiseOR(trailing, discriminator)});
return
}
/*Swift.(file)._SmallString.init(_:UnsafeBufferPointer<UInt8>)*/
/*Swift.(file)._SmallString.init(_:UnsafeBufferPointer<UInt8>)*/
initUnsafeBufferPointer(input, $info?) {
let _this = this;
if((input.isEmpty)) {
_this.init( {});
return ;
};
const count = input.count;
if(!((Int.$lessThanOrEqual(count, _SmallString.capacity)))) {
return (this.$failed = true);
};
const ptr = _cloneStruct(input.baseAddress._unsafelyUnwrappedUnchecked);
const leading = _bytesToUInt64(ptr, min(input.count, 8));
const trailing = (Int.$greaterThan(count, 8) ? _bytesToUInt64(UnsafePointer.$add(ptr, 8), Int.$subtractWithOverflow(count, 8)) : 0);
_this.initLeadingUInt64TrailingUInt64CountInt(leading, trailing, count);
return
}
static readonly initUnsafeBufferPointer$failable = true
/*Swift.(file)._SmallString.init(_:_SmallString,appending:_SmallString)*/
/*Swift.(file)._SmallString.init(_:_SmallString,appending:_SmallString)*/
init_SmallStringAppending_SmallString(base, other, $info?) {
let _this = this;
const totalCount = Int.$add(base.count, other.count);
if(!((Int.$lessThanOrEqual(totalCount, _SmallString.capacity)))) {
return (this.$failed = true);
};
let result = _cloneStruct(base);
let writeIdx = base.count;
{
let $readIdx$generator = _cloneStruct(Int.$halfOpenRange(0, other.count).makeIterator( {}));
while(true) {
const $ifLet0, readIdx_1;
if(!((($ifLet0 = $readIdx$generator.next( {$setThis: $val => $readIdx$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((readIdx_1 = $ifLet0[0])||true))) break
result.subscript$set(other.subscript$get(readIdx_1), writeIdx, {$setThis: $val => result = $val});
Int.infix_38_43_61({get: () => writeIdx, set: $val => writeIdx = $val}, 1);
}
};
const $tuple = result.zeroTerminatedRawCodeUnits, leading = $tuple && $tuple[0], trailing = $tuple && $tuple[1];
_this.initLeadingUInt64TrailingUInt64CountInt(leading, trailing, totalCount);
return
}
static readonly init_SmallStringAppending_SmallString$failable = true
/*Swift.(file)._SmallString.init(taggedCocoa:AnyObject)*/
/*Swift.(file)._SmallString.init(taggedCocoa:AnyObject)*/
initTaggedCocoaAnyObject(cocoa, $info?) {
throw 'unsupported method Swift.(file)._SmallString.init(taggedCocoa:AnyObject) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_SmallString, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(_SmallString, MutableCollection$implementation, false)














interface StringProtocol<UTF8View, UTF16View, UnicodeScalarView, SubSequence> extends BidirectionalCollection, TextOutputStream, TextOutputStreamable, LosslessStringConvertible, ExpressibleByStringInterpolation, Hashable, Comparable{





/*Swift.(file).StringProtocol.utf8*/
utf8;




/*Swift.(file).StringProtocol.utf16*/
utf16;




/*Swift.(file).StringProtocol.unicodeScalars*/
unicodeScalars;



/*Swift.(file).StringProtocol.hasPrefix(_:String)*/
/*Swift.(file).StringProtocol.hasPrefix(_:String)*/
hasPrefix(prefix, $info?)
/*Swift.(file).StringProtocol.hasSuffix(_:String)*/
/*Swift.(file).StringProtocol.hasSuffix(_:String)*/
hasSuffix(prefix, $info?)
/*Swift.(file).StringProtocol.lowercased()*/
/*Swift.(file).StringProtocol.lowercased()*/
lowercased($info?)
/*Swift.(file).StringProtocol.uppercased()*/
/*Swift.(file).StringProtocol.uppercased()*/
uppercased($info?)
/*Swift.(file).StringProtocol.init(decoding:C,as:Encoding.Type)*/
/*Swift.(file).StringProtocol.init(decoding:C,as:Encoding.Type)*/
initDecodingAs<C, Encoding>(codeUnits, sourceEncoding, $info?)
/*Swift.(file).StringProtocol.init(cString:UnsafePointer<CChar>)*/
/*Swift.(file).StringProtocol.init(cString:UnsafePointer<CChar>)*/
initCStringUnsafePointer(nullTerminatedUTF8, $info?)
/*Swift.(file).StringProtocol.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)*/
/*Swift.(file).StringProtocol.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)*/
initDecodingCStringUnsafePointerAs<Encoding>(nullTerminatedCodeUnits, sourceEncoding, $info?)
/*Swift.(file).StringProtocol.withCString(_:(UnsafePointer<CChar>) throws -> Result)*/
/*Swift.(file).StringProtocol.withCString(_:(UnsafePointer<CChar>) throws -> Result)*/
withCString<Result>(body, $info?)
/*Swift.(file).StringProtocol.withCString(encodedAs:Encoding.Type,_:(UnsafePointer<Encoding.CodeUnit>) throws -> Result)*/
/*Swift.(file).StringProtocol.withCString(encodedAs:Encoding.Type,_:(UnsafePointer<Encoding.CodeUnit>) throws -> Result)*/
withCStringEncodedAs<Result, Encoding>(targetEncoding, body, $info?)
}
class StringProtocol$implementation{
/*Swift.(file).StringProtocol.hash(into:Hasher)*/
/*Swift.(file).StringProtocol.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).StringProtocol.hash(into:Hasher) in ' + this.constructor.name
}




static /*Swift.(file).StringProtocol.==infix(_:Self,_:RHS)*/
/*Swift.(file).StringProtocol.==infix(_:Self,_:RHS)*/
$equal<RHS>(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)*/
/*Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)*/
$notEqual<RHS>(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$equal(_.arg0, rhs))
}
static /*Swift.(file).StringProtocol.<infix(_:Self,_:RHS)*/
/*Swift.(file).StringProtocol.<infix(_:Self,_:RHS)*/
$lessThan<RHS>(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).StringProtocol.>infix(_:Self,_:RHS)*/
/*Swift.(file).StringProtocol.>infix(_:Self,_:RHS)*/
$greaterThan<RHS>(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}
static /*Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)*/
/*Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)*/
$lessThanOrEqual<RHS>(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)*/
/*Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)*/
$greaterThanOrEqual<RHS>(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}












/*Swift.(file).StringProtocol.hasPrefix(_:Prefix)*/
/*Swift.(file).StringProtocol.hasPrefix(_:Prefix)*/
/*!!!DUPLICATE NAME*/
hasPrefix<Prefix>(prefix, $info?) {
let _this = this;
return _this.startsWithSwift(prefix)
}
/*Swift.(file).StringProtocol.hasSuffix(_:Suffix)*/
/*Swift.(file).StringProtocol.hasSuffix(_:Suffix)*/
/*!!!DUPLICATE NAME*/
hasSuffix<Suffix>(suffix, $info?) {
let _this = this;
return _this.reversed( {}).startsWithSwift(suffix.reversed( {}))
}
}
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(StringProtocol$implementation, BidirectionalCollection$implementation, false)
if(typeof TextOutputStream$implementation != 'undefined') _mixin(StringProtocol$implementation, TextOutputStream$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(StringProtocol$implementation, TextOutputStreamable$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(StringProtocol$implementation, LosslessStringConvertible$implementation, false)
if(typeof ExpressibleByStringInterpolation$implementation != 'undefined') _mixin(StringProtocol$implementation, ExpressibleByStringInterpolation$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(StringProtocol$implementation, Hashable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(StringProtocol$implementation, Comparable$implementation, false)






class Substring implements _HasContiguousBytes, Equatable, StringProtocol, CustomReflectable, CustomStringConvertible, CustomDebugStringConvertible, LosslessStringConvertible, RangeReplaceableCollection, TextOutputStream, TextOutputStreamable, ExpressibleByUnicodeScalarLiteral, ExpressibleByExtendedGraphemeClusterLiteral, ExpressibleByStringLiteral, _CustomPlaygroundQuickLookable{
static readonly $struct = true





/*Swift.(file).Substring.init(_:Slice<String>)*/
/*Swift.(file).Substring.init(_:Slice<String>)*/
initSlice(slice, $info?) {
let _this = this;
_this._slice = _cloneStruct(slice);
_this._invariantCheck( {});
return
}
/*Swift.(file).Substring.init(_:_StringGutsSlice)*/
/*Swift.(file).Substring.init(_:_StringGutsSlice)*/
init_StringGutsSlice(slice, $info?) {
throw 'unsupported method Swift.(file).Substring.init(_:_StringGutsSlice) in ' + this.constructor.name
}
/*Swift.(file).Substring.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
let _this = this;
_this.initSlice(_create(Slice, 'init', {}));
return
}



/*Swift.(file).Substring.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
let copy = _cloneStruct(_this);
return copy.withUTF8((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}))), {$setThis: $val => copy = $val})
}





/*Swift.(file).Substring.isContiguousUTF8*/
isContiguousUTF8$get() {
let _this = this;
return _this.base.isContiguousUTF8
}
get isContiguousUTF8() { return this.isContiguousUTF8$get() };



/*Swift.(file).Substring.makeContiguousUTF8()*/
/*Swift.(file).Substring.makeContiguousUTF8()*/
makeContiguousUTF8($info?) {
let _this = this;
if((_fastPath(_this.isContiguousUTF8))) {
return ;
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(String._copying(_this).subscriptUnboundedRange$get(UnboundedRange_.$openEndedRange))))
}
/*Swift.(file).Substring.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
/*Swift.(file).Substring.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
withUTF8<R>(body, $info?) {
let _this = this;
if((_fastPath(_this.isContiguousUTF8))) {
return _this._wholeGuts.withFastUTF8Range(_this._offsetRange, (($0, $info?) => body($0)));
};
_this.makeContiguousUTF8( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return _this._wholeGuts.withFastUTF8(body)
}
/*Swift.(file).Substring.init(stringInterpolation:DefaultStringInterpolation)*/
/*Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:Self.StringInterpolation)*/
initStringInterpolation(stringInterpolation, $info?) {
let _this = this;
_this.initString(stringInterpolation.make( {}));
return
}

/*Swift.(file).Substring.base*/
base$get() {
let _this = this;
return _this._slice.base
}
get base() { return this.base$get() };













/*Swift.(file).Substring.startIndex*/
startIndex$get() {
let _this = this;
return _this._slice.startIndex
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Substring.endIndex*/
endIndex$get() {
let _this = this;
return _this._slice.endIndex
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Substring.index(after:Substring.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
preconditionFileLine(() => String.Index.$lessThan(i, _this.endIndex), () => "Cannot increment beyond endIndex", null, null);
preconditionFileLine(() => Substring.Index.$greaterThanOrEqual(i, _this.startIndex), () => "Cannot increment an invalid index", null, null);
return _this._slice.indexAfter(i)
}
/*Swift.(file).Substring.index(before:Substring.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
preconditionFileLine(() => Substring.Index.$lessThanOrEqual(i, _this.endIndex), () => "Cannot decrement an invalid index", null, null);
preconditionFileLine(() => Substring.Index.$greaterThan(i, _this.startIndex), () => "Cannot decrement beyond startIndex", null, null);
return _this._slice.indexBefore(i)
}
/*Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
const result = _cloneStruct(_this._slice.indexOffsetBy(i, n));
preconditionFileLine(() => String.Index.$closedRange(_this._slice._startIndex, _this._slice.endIndex).contains(result), () => "Operation results in an invalid index", null, null);
return result
}
/*Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int,limitedBy:Substring.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
const result = _this._slice.indexOffsetByLimitedBy(i, n, limit);
preconditionFileLine(() => $nilCoalescing(result.mapSwift((($0, $info?) => String.Index.$closedRange(_this._slice._startIndex, _this._slice.endIndex).contains($0))), () => true), () => "Operation results in an invalid index", null, null);
return result
}
/*Swift.(file).Substring.distance(from:Substring.Index,to:Substring.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._slice.distanceFromTo(start, end)
}
/*Swift.(file).Substring.subscript(_:Substring.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
let _this = this;
return _this._slice.subscript$get(i)
}


/*Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(bounds, newElements, $info?) {
let _this = this;
_this._slice.replaceSubrangeWith(bounds, newElements, {$setThis: $val => _this._slice = $val})
}
/*Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:Substring)*/
/*Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:Substring)*/
/*!!!DUPLICATE NAME*/
replaceSubrangeWith(bounds, newElements, $info?) {
let _this = this;
_this.replaceSubrangeWith(bounds, newElements._slice, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).Substring.init(decoding:C,as:Encoding.Type)*/
/*Swift.(file).StringProtocol.init(decoding:C,as:Encoding.Type)*/
initDecodingAs<C, Encoding>(codeUnits, sourceEncoding, $info?) {
let _this = this;
_this.initString(_create(String, 'initDecodingAs', codeUnits, sourceEncoding, {}));
return
}
/*Swift.(file).Substring.init(cString:UnsafePointer<CChar>)*/
/*Swift.(file).StringProtocol.init(cString:UnsafePointer<CChar>)*/
initCStringUnsafePointer(nullTerminatedUTF8, $info?) {
let _this = this;
_this.initString(_create(String, 'initCStringUnsafePointer', nullTerminatedUTF8, {}));
return
}
/*Swift.(file).Substring.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)*/
/*Swift.(file).StringProtocol.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)*/
initDecodingCStringUnsafePointerAs<Encoding>(nullTerminatedCodeUnits, sourceEncoding, $info?) {
let _this = this;
_this.initString(_create(String, 'initDecodingCStringUnsafePointerAs', nullTerminatedCodeUnits, sourceEncoding, {}));
return
}
/*Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)*/
/*Swift.(file).StringProtocol.withCString(_:(UnsafePointer<CChar>) throws -> Result)*/
withCString<Result>(body, $info?) {
let _this = this;
return _create(String, 'initSubstring', _this, {}).withCString(body)
}
/*Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)*/
/*Swift.(file).StringProtocol.withCString(encodedAs:Encoding.Type,_:(UnsafePointer<Encoding.CodeUnit>) throws -> Result)*/
withCStringEncodedAs<Result, TargetEncoding>(targetEncoding, body, $info?) {
let _this = this;
return _create(String, 'initSubstring', _this, {}).withCStringEncodedAs(targetEncoding, body)
}







/*Swift.(file).Substring.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Substring.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


/*Swift.(file).Substring.customMirror*/
customMirror$get() {
let _this = this;
return _create(String, 'initSubstring', _this, {}).customMirror
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Substring.description*/
description$get() {
let _this = this;
return _create(String, 'initSubstring', _this, {})
}
get description() { return this.description$get() };




/*Swift.(file).Substring.debugDescription*/
debugDescription$get() {
let _this = this;
return _create(String, 'initSubstring', _this, {}).debugDescription
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).Substring.init(_:String)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString(content, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(content.subscriptUnboundedRange$get(UnboundedRange_.$openEndedRange))));
return
}
static UTF8View = class implements BidirectionalCollection{
static readonly $struct = true





/*Swift.(file).Substring.UTF8View.init(_slice:Slice<String.UTF8View>)*/
/*Swift.(file).Substring.UTF8View.init(_slice:Slice<String.UTF8View>)*/
init_sliceSlice(_slice, $info?) {
throw 'unsupported method Swift.(file).Substring.UTF8View.init(_slice:Slice<String.UTF8View>) in ' + this.constructor.name
}




/*Swift.(file).Substring.UTF8View.init(_:String.UTF8View,_bounds:Range<Substring.UTF8View.Index>)*/
/*Swift.(file).Substring.UTF8View.init(_:String.UTF8View,_bounds:Range<Substring.UTF8View.Index>)*/
initStringUTF8View_boundsRange(base, _bounds, $info?) {
throw 'unsupported method Swift.(file).Substring.UTF8View.init(_:String.UTF8View,_bounds:Range<Substring.UTF8View.Index>) in ' + this.constructor.name
}

/*Swift.(file).Substring.UTF8View.startIndex*/
startIndex$get() {
let _this = this;
return _this._slice.startIndex
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Substring.UTF8View.endIndex*/
endIndex$get() {
let _this = this;
return _this._slice.endIndex
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Substring.UTF8View.subscript(_:Substring.UTF8View.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(index, $info?) {
let _this = this;
return _this._slice.subscript$get(index)
}



/*Swift.(file).Substring.UTF8View.indices*/
indices$get() {
let _this = this;
return _this._slice.indices
}
get indices() { return this.indices$get() };



/*Swift.(file).Substring.UTF8View.index(after:Substring.UTF8View.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return _this._slice.indexAfter(i)
}
/*Swift.(file).Substring.UTF8View.formIndex(after:Substring.UTF8View.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexAfter({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._slice.indexOffsetBy(i, n)
}
/*Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int,limitedBy:Substring.UTF8View.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._slice.indexOffsetByLimitedBy(i, n, limit)
}
/*Swift.(file).Substring.UTF8View.distance(from:Substring.UTF8View.Index,to:Substring.UTF8View.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._slice.distanceFromTo(start, end)
}


/*Swift.(file).Substring.UTF8View.index(before:Substring.UTF8View.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return _this._slice.indexBefore(i)
}
/*Swift.(file).Substring.UTF8View.formIndex(before:Substring.UTF8View.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexBefore({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Substring.UTF8View.subscript(_:Range<Substring.UTF8View.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$logicalAND(Substring.UTF8View.Index.$greaterThanOrEqual(r.lowerBound, _this.startIndex), () => Substring.UTF8View.Index.$lessThanOrEqual(r.upperBound, _this.endIndex)), () => "UTF8View index range out of bounds", null, null);
return _create(Substring.UTF8View, 'initStringUTF8View_boundsRange', _this._slice.base, r, {})
}


init$vars() {let _this = this;

}
}

/*Swift.(file).Substring.utf8*/
utf8$get() {
let _this = this;
return _this.base.utf8.subscriptRange$get(String.UTF8View.Index.$halfOpenRange(_this.startIndex, _this.endIndex))
}
get utf8() { return this.utf8$get() };





/*Swift.(file).Substring.init(_:Substring.UTF8View)*/
/*Swift.(file).Substring.init(_:Substring.UTF8View)*/
initSubstringUTF8View(content, $info?) {
throw 'unsupported method Swift.(file).Substring.init(_:Substring.UTF8View) in ' + this.constructor.name
}
static UTF16View = class implements BidirectionalCollection{
static readonly $struct = true





/*Swift.(file).Substring.UTF16View.init(_slice:Slice<String.UTF16View>)*/
/*Swift.(file).Substring.UTF16View.init(_slice:Slice<String.UTF16View>)*/
init_sliceSlice(_slice, $info?) {
throw 'unsupported method Swift.(file).Substring.UTF16View.init(_slice:Slice<String.UTF16View>) in ' + this.constructor.name
}




/*Swift.(file).Substring.UTF16View.init(_:String.UTF16View,_bounds:Range<Substring.UTF16View.Index>)*/
/*Swift.(file).Substring.UTF16View.init(_:String.UTF16View,_bounds:Range<Substring.UTF16View.Index>)*/
initStringUTF16View_boundsRange(base, _bounds, $info?) {
throw 'unsupported method Swift.(file).Substring.UTF16View.init(_:String.UTF16View,_bounds:Range<Substring.UTF16View.Index>) in ' + this.constructor.name
}

/*Swift.(file).Substring.UTF16View.startIndex*/
startIndex$get() {
let _this = this;
return _this._slice.startIndex
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Substring.UTF16View.endIndex*/
endIndex$get() {
let _this = this;
return _this._slice.endIndex
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Substring.UTF16View.subscript(_:Substring.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(index, $info?) {
let _this = this;
return _this._slice.subscript$get(index)
}



/*Swift.(file).Substring.UTF16View.indices*/
indices$get() {
let _this = this;
return _this._slice.indices
}
get indices() { return this.indices$get() };



/*Swift.(file).Substring.UTF16View.index(after:Substring.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return _this._slice.indexAfter(i)
}
/*Swift.(file).Substring.UTF16View.formIndex(after:Substring.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexAfter({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._slice.indexOffsetBy(i, n)
}
/*Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int,limitedBy:Substring.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._slice.indexOffsetByLimitedBy(i, n, limit)
}
/*Swift.(file).Substring.UTF16View.distance(from:Substring.UTF16View.Index,to:Substring.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._slice.distanceFromTo(start, end)
}


/*Swift.(file).Substring.UTF16View.index(before:Substring.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return _this._slice.indexBefore(i)
}
/*Swift.(file).Substring.UTF16View.formIndex(before:Substring.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexBefore({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Substring.UTF16View.subscript(_:Range<Substring.UTF16View.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
return _create(Substring.UTF16View, 'initStringUTF16View_boundsRange', _this._slice.base, r, {})
}


init$vars() {let _this = this;

}
}

/*Swift.(file).Substring.utf16*/
utf16$get() {
let _this = this;
return _this.base.utf16.subscriptRange$get(String.UTF16View.Index.$halfOpenRange(_this.startIndex, _this.endIndex))
}
get utf16() { return this.utf16$get() };





/*Swift.(file).Substring.init(_:Substring.UTF16View)*/
/*Swift.(file).Substring.init(_:Substring.UTF16View)*/
initSubstringUTF16View(content, $info?) {
throw 'unsupported method Swift.(file).Substring.init(_:Substring.UTF16View) in ' + this.constructor.name
}
static UnicodeScalarView = class implements BidirectionalCollection, RangeReplaceableCollection{
static readonly $struct = true





/*Swift.(file).Substring.UnicodeScalarView.init(_slice:Slice<String.UnicodeScalarView>)*/
/*Swift.(file).Substring.UnicodeScalarView.init(_slice:Slice<String.UnicodeScalarView>)*/
init_sliceSlice(_slice, $info?) {
throw 'unsupported method Swift.(file).Substring.UnicodeScalarView.init(_slice:Slice<String.UnicodeScalarView>) in ' + this.constructor.name
}




/*Swift.(file).Substring.UnicodeScalarView.init(_:String.UnicodeScalarView,_bounds:Range<Substring.UnicodeScalarView.Index>)*/
/*Swift.(file).Substring.UnicodeScalarView.init(_:String.UnicodeScalarView,_bounds:Range<Substring.UnicodeScalarView.Index>)*/
initStringUnicodeScalarView_boundsRange(base, _bounds, $info?) {
throw 'unsupported method Swift.(file).Substring.UnicodeScalarView.init(_:String.UnicodeScalarView,_bounds:Range<Substring.UnicodeScalarView.Index>) in ' + this.constructor.name
}

/*Swift.(file).Substring.UnicodeScalarView.startIndex*/
startIndex$get() {
let _this = this;
return _this._slice.startIndex
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Substring.UnicodeScalarView.endIndex*/
endIndex$get() {
let _this = this;
return _this._slice.endIndex
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Substring.UnicodeScalarView.subscript(_:Substring.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(index, $info?) {
let _this = this;
return _this._slice.subscript$get(index)
}



/*Swift.(file).Substring.UnicodeScalarView.indices*/
indices$get() {
let _this = this;
return _this._slice.indices
}
get indices() { return this.indices$get() };



/*Swift.(file).Substring.UnicodeScalarView.index(after:Substring.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return _this._slice.indexAfter(i)
}
/*Swift.(file).Substring.UnicodeScalarView.formIndex(after:Substring.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexAfter({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._slice.indexOffsetBy(i, n)
}
/*Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int,limitedBy:Substring.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._slice.indexOffsetByLimitedBy(i, n, limit)
}
/*Swift.(file).Substring.UnicodeScalarView.distance(from:Substring.UnicodeScalarView.Index,to:Substring.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._slice.distanceFromTo(start, end)
}


/*Swift.(file).Substring.UnicodeScalarView.index(before:Substring.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return _this._slice.indexBefore(i)
}
/*Swift.(file).Substring.UnicodeScalarView.formIndex(before:Substring.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexBefore({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
/*Swift.(file).Substring.UnicodeScalarView.subscript(_:Range<Substring.UnicodeScalarView.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
return _create(Substring.UnicodeScalarView, 'initStringUnicodeScalarView_boundsRange', _this._slice.base, r, {})
}


/*Swift.(file).Substring.UnicodeScalarView.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
let _this = this;
_this._slice = _create(Slice, 'init', {});
return
}
/*Swift.(file).Substring.UnicodeScalarView.replaceSubrange(_:Range<Substring.UnicodeScalarView.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(target, replacement, $info?) {
let _this = this;
_this._slice.replaceSubrangeWith(target, replacement, {$setThis: $val => _this._slice = $val})
}
init$vars() {let _this = this;

}
}

/*Swift.(file).Substring.unicodeScalars*/
unicodeScalars$get() {
let _this = this;
return _this.base.unicodeScalars.subscriptRange$get(String.UnicodeScalarView.Index.$halfOpenRange(_this.startIndex, _this.endIndex))
}
get unicodeScalars() { return this.unicodeScalars$get() };





/*Swift.(file).Substring.init(_:Substring.UnicodeScalarView)*/
/*Swift.(file).Substring.init(_:Substring.UnicodeScalarView)*/
initSubstringUnicodeScalarView(content, $info?) {
throw 'unsupported method Swift.(file).Substring.init(_:Substring.UnicodeScalarView) in ' + this.constructor.name
}
/*Swift.(file).Substring.init(_:S)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
initBuffer<S>(_elements, $info?) {
let _this = this;
const $ifLet0, str_1
if((($ifLet0 = _injectIntoOptional(_elements))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(str_1.subscriptUnboundedRange$get(UnboundedRange_.$openEndedRange))));
return ;
};
const $ifLet2, subStr_3
if((($ifLet2 = _injectIntoOptional(_elements))||true) && $ifLet2.rawValue == 'some' && ((subStr_3 = $ifLet2[0])||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(subStr_3)));
return ;
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(_create(String, 'initBuffer', _elements, {}).subscriptUnboundedRange$get(UnboundedRange_.$openEndedRange))));
return
}
/*Swift.(file).Substring.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
appendContentsOf<S>(_elements, $info?) {
let _this = this;
let string = _create(String, 'initSubstring', _this, {});
$info.$setThis(_this = _cloneStruct(_create(Substring, 'init', {})));
string.appendContentsOf(_elements, {$setThis: $val => string = $val});
$info.$setThis(_this = _cloneStruct(_create(Substring, 'initString', string, {})))
}
/*Swift.(file).Substring.lowercased()*/
/*Swift.(file).StringProtocol.lowercased()*/
lowercased($info?) {
let _this = this;
return _create(String, 'initSubstring', _this, {}).lowercased( {})
}
/*Swift.(file).Substring.uppercased()*/
/*Swift.(file).StringProtocol.uppercased()*/
uppercased($info?) {
let _this = this;
return _create(String, 'initSubstring', _this, {}).uppercased( {})
}
/*Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)*/
/*Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
let _this = this;
return _create(String, 'initBuffer', _this.lazy.filterSwift(isIncluded), {})
}
/*Swift.(file).Substring.write(_:String)*/
/*Swift.(file).TextOutputStream.write(_:String)*/
write(other, $info?) {
let _this = this;
_this.appendContentsOf(other, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).Substring.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?) {
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_create(String, 'initSubstring', _this, {}), {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
}
/*Swift.(file).Substring.init(unicodeScalarLiteral:String)*/
/*Swift.(file).ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:Self.UnicodeScalarLiteralType)*/
initUnicodeScalarLiteral(value, $info?) {
let _this = this;
_this.initString(value);
return
}

/*Swift.(file).Substring.init(extendedGraphemeClusterLiteral:String)*/
/*Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(extendedGraphemeClusterLiteral:Self.ExtendedGraphemeClusterLiteralType)*/
initExtendedGraphemeClusterLiteral(value, $info?) {
let _this = this;
_this.initString(value);
return
}

/*Swift.(file).Substring.init(stringLiteral:String)*/
/*Swift.(file).ExpressibleByStringLiteral.init(stringLiteral:Self.StringLiteralType)*/
initStringLiteral(value, $info?) {
let _this = this;
_this.initString(value);
return
}

/*Swift.(file).Substring.subscript(_:Range<Substring.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
return _create(Substring, 'initSlice', _this._slice.subscriptRange$get(r), {})
}



/*Swift.(file).Substring.characters*/
characters$get() {
let _this = this;
return _this
}
get characters() { return this.characters$get() };





/*Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)*/
/*Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)*/
withMutableCharacters<R>(body, $info?) {
let _this = this;
return body({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}


/*Swift.(file).Substring.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return _create(String, 'initSubstring', _this, {}).customPlaygroundQuickLook
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(Substring.UTF8View, BidirectionalCollection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(Substring.UTF16View, BidirectionalCollection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(Substring.UnicodeScalarView, BidirectionalCollection$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(Substring.UnicodeScalarView, RangeReplaceableCollection$implementation, false)
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(Substring, _HasContiguousBytes$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(Substring, Equatable$implementation, false)
if(typeof StringProtocol$implementation != 'undefined') _mixin(Substring, StringProtocol$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(Substring, CustomReflectable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(Substring, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(Substring, CustomDebugStringConvertible$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(Substring, LosslessStringConvertible$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(Substring, RangeReplaceableCollection$implementation, false)
if(typeof TextOutputStream$implementation != 'undefined') _mixin(Substring, TextOutputStream$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(Substring, TextOutputStreamable$implementation, false)
if(typeof ExpressibleByUnicodeScalarLiteral$implementation != 'undefined') _mixin(Substring, ExpressibleByUnicodeScalarLiteral$implementation, false)
if(typeof ExpressibleByExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(Substring, ExpressibleByExtendedGraphemeClusterLiteral$implementation, false)
if(typeof ExpressibleByStringLiteral$implementation != 'undefined') _mixin(Substring, ExpressibleByStringLiteral$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(Substring, _CustomPlaygroundQuickLookable$implementation, false)














































class _UIntBuffer<Element> implements Sequence, Collection, BidirectionalCollection, RandomAccessCollection, RangeReplaceableCollection{
static readonly $struct = true











/*Swift.(file)._UIntBuffer.init(_storage:_UIntBuffer<Element>.Storage,_bitCount:UInt8)*/
/*Swift.(file)._UIntBuffer.init(_storage:_UIntBuffer<Element>.Storage,_bitCount:UInt8)*/
init_storage_UIntBufferStorage_bitCountUInt8(_storage, _bitCount, $info?) {
throw 'unsupported method Swift.(file)._UIntBuffer.init(_storage:_UIntBuffer<Element>.Storage,_bitCount:UInt8) in ' + this.constructor.name
}
/*Swift.(file)._UIntBuffer.init(containing:Element)*/
/*Swift.(file)._UIntBuffer.init(containing:Element)*/
initContaining(e, $info?) {
throw 'unsupported method Swift.(file)._UIntBuffer.init(containing:Element) in ' + this.constructor.name
}

static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true
/*Swift.(file)._UIntBuffer.Iterator.init(_:_UIntBuffer<Element>)*/
/*Swift.(file)._UIntBuffer.Iterator.init(_:_UIntBuffer<Element>)*/
init_UIntBuffer(x, $info?) {
let _this = this;
_this._impl = _cloneStruct(x);
return
}
/*Swift.(file)._UIntBuffer.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if((UInt8.$equal(_this._impl._bitCount, 0))) {
return _injectIntoOptional(null);
};
let $defer = () => {
_this._impl._storage = _UIntBuffer.Storage.infix_38_62_62(_this._impl._storage, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth);
_this._impl._bitCount = UInt8.$subtractWithOverflow(_this._impl._bitCount, _this._impl._elementWidth);
}
const $result = (() => {
try {;
return _injectIntoOptional(_create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', _this._impl._storage, {}));}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}







init$vars() {let _this = this;

}
}
/*Swift.(file)._UIntBuffer.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(_UIntBuffer.Iterator, 'init_UIntBuffer', _this, {})
}

static Index = class implements Comparable{
static readonly $struct = true

/*Swift.(file)._UIntBuffer.Index.bitOffset*/
bitOffset$get() {
throw 'unsupported variable Swift.(file)._UIntBuffer.Index.bitOffset in ' + this.constructor.name
}
get bitOffset() { return this.bitOffset$get() };





/*Swift.(file)._UIntBuffer.Index.init(bitOffset:UInt8)*/
/*Swift.(file)._UIntBuffer.Index.init(bitOffset:UInt8)*/
initBitOffsetUInt8(bitOffset, $info?) {
let _this = this;
_this.bitOffset = bitOffset;
return
}
static /*Swift.(file)._UIntBuffer.Index.==infix(_:_UIntBuffer<Element>.Index,_:_UIntBuffer<Element>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file)._UIntBuffer.Index.<infix(_:_UIntBuffer<Element>.Index,_:_UIntBuffer<Element>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
init$vars() {let _this = this;

}
}

/*Swift.(file)._UIntBuffer.startIndex*/
startIndex$get() {
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', 0, {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._UIntBuffer.endIndex*/
endIndex$get() {
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', _this._bitCount, {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._UIntBuffer.index(after:_UIntBuffer<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', UInt8.$addWithOverflow(i.bitOffset, _this._elementWidth), {})
}



/*Swift.(file)._UIntBuffer.subscript(_:_UIntBuffer<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
let _this = this;
return _create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', _UIntBuffer.Storage.infix_38_62_62(_this._storage, i.bitOffset), {})
}


/*Swift.(file)._UIntBuffer.index(before:_UIntBuffer<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', UInt8.$subtractWithOverflow(i.bitOffset, _this._elementWidth), {})
}

/*Swift.(file)._UIntBuffer.index(_:_UIntBuffer<Element>.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
const x = Int.$addWithOverflow(_create(Int, 'initT', i.bitOffset, {}), Int.$multiplyIgnoringOverflow(n, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth));
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', _create(UInt8, 'initTruncatingIfNeeded', x, {}), {})
}
/*Swift.(file)._UIntBuffer.distance(from:_UIntBuffer<Element>.Index,to:_UIntBuffer<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(i, j, $info?) {
let _this = this;
return Int.$divide(Int.$subtractWithOverflow(_create(Int, 'initT', j.bitOffset, {}), _create(Int, 'initT', i.bitOffset, {})), ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth)
}
/*Swift.(file)._UIntBuffer.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
let _this = this;
_this._storage = 0;
_this._bitCount = 0;
return
}

/*Swift.(file)._UIntBuffer.capacity*/
capacity$get() {
let _this = this;
return Int.$divide(_UIntBuffer.Storage.bitWidth, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth)
}
get capacity() { return this.capacity$get() };



/*Swift.(file)._UIntBuffer.append(_:Element)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(newElement, $info?) {
let _this = this;
preconditionFileLine(() => Int.$lessThanOrEqual(Int.$add(_this.count, 1), _this.capacity), null, null, null);
UInt32.$bitwiseANDAndAssign({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.$bitwiseNot(_UIntBuffer.Storage.infix_38_60_60(_create(_UIntBuffer.Storage, 'initT', ((function(){throw '!unclarifiedGeneric:Element'})()).max, {}), _this._bitCount)));
UInt32.$bitwiseORAndAssign({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.infix_38_60_60(_create(_UIntBuffer.Storage, 'initT', newElement, {}), _this._bitCount));
_this._bitCount = UInt8.$addWithOverflow(_this._bitCount, _this._elementWidth)
}
/*Swift.(file)._UIntBuffer.removeFirst()*/
/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
removeFirst($info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), null, null, null);
const result = _create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', _this._storage, {});
_this._bitCount = UInt8.$subtractWithOverflow(_this._bitCount, _this._elementWidth);
_this._storage = _UIntBuffer.Storage.prototype._fullShiftRight.call(_this._storage, _this._elementWidth);
return result
}
/*Swift.(file)._UIntBuffer.replaceSubrange(_:Range<_UIntBuffer<Element>.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(target, replacement, $info?) {
let _this = this;
preconditionFileLine(() => UInt8.$halfOpenRange(0, _this._bitCount)._contains_(UInt8.$halfOpenRange(target.lowerBound.bitOffset, target.upperBound.bitOffset)), null, null, null);
const replacement1 = _create(_UIntBuffer, 'initBuffer', replacement, {});
const targetCount = _this.distanceFromTo(target.lowerBound, target.upperBound);
const growth = Int.$subtractWithOverflow(replacement1.count, targetCount);
preconditionFileLine(() => Int.$lessThanOrEqual(Int.$add(_this.count, growth), _this.capacity), null, null, null);
const headCount = _this.distanceFromTo(_this.startIndex, target.lowerBound);
const tailOffset = _this.distanceFromTo(_this.startIndex, target.upperBound);
const w = ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth;
const headBits = UInt32.$bitwiseAND(_this._storage, UInt32._lowBits(Int.$multiplyIgnoringOverflow(headCount, w)));
const tailBits = _UIntBuffer.Storage.prototype._fullShiftRight.call(_this._storage, Int.$multiplyIgnoringOverflow(tailOffset, w));
_this._storage = headBits;
UInt32.$bitwiseORAndAssign({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.infix_38_60_60(replacement1._storage, Int.$multiplyIgnoringOverflow(headCount, w)));
UInt32.$bitwiseORAndAssign({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.infix_38_60_60(tailBits, Int.$multiplyIgnoringOverflow(Int.$addWithOverflow(tailOffset, growth), w)));
_this._bitCount = _create(UInt8, 'initTruncatingIfNeeded', Int.$addWithOverflow(_create(Int, 'initT', _this._bitCount, {}), Int.$multiplyIgnoringOverflow(growth, w)), {})
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_UIntBuffer.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_UIntBuffer.Iterator, Sequence$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(_UIntBuffer.Index, Comparable$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_UIntBuffer, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(_UIntBuffer, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(_UIntBuffer, BidirectionalCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_UIntBuffer, RandomAccessCollection$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(_UIntBuffer, RangeReplaceableCollection$implementation, false)












class UnsafePointer<Pointee> implements _Pointer, _CustomPlaygroundQuickLookable, CVarArg{
static readonly $struct = true




/*Swift.(file).UnsafePointer.init(_:RawPointer)*/
/*Swift.(file)._Pointer.init(_:RawPointer)*/
initRawPointer(_rawValue, $info?) {
throw 'unsupported method Swift.(file).UnsafePointer.init(_:RawPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafePointer.deallocate()*/
/*Swift.(file).UnsafePointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafePointer.deallocate() in ' + this.constructor.name
}

/*Swift.(file).UnsafePointer.pointee*/
pointee$get() {
 return this.pointee$internal
}
get pointee() { return this.pointee$get() };




/*Swift.(file).UnsafePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafePointer<T>) throws -> Result)*/
/*Swift.(file).UnsafePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafePointer<T>) throws -> Result)*/
withMemoryReboundToCapacity<T, Result>(type, count, body, $info?) {
throw 'unsupported method Swift.(file).UnsafePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafePointer<T>) throws -> Result) in ' + this.constructor.name
}
/*Swift.(file).UnsafePointer.subscript(_:Int)*/
/*Swift.(file).UnsafePointer.subscript(_:Int)*/
subscript$unsafeAddress(i, $info?) {
let _this = this;
return UnsafePointer.$add(_this, i)
}










/*Swift.(file).UnsafePointer.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UnsafePointer.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };








/*Swift.(file).UnsafePointer.summary*/
summary$get() {
throw 'unsupported variable Swift.(file).UnsafePointer.summary in ' + this.constructor.name
}
get summary() { return this.summary$get() };




/*Swift.(file).UnsafePointer.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return PlaygroundQuickLook.text(_this.summary)
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };






init$vars() {let _this = this;

}
}
if(typeof _Pointer$implementation != 'undefined') _mixin(UnsafePointer, _Pointer$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(UnsafePointer, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(UnsafePointer, CVarArg$implementation, false)






class UnsafeMutablePointer<Pointee> implements _Pointer, _CustomPlaygroundQuickLookable, CVarArg{
static readonly $struct = true




/*Swift.(file).UnsafeMutablePointer.init(_:RawPointer)*/
/*Swift.(file)._Pointer.init(_:RawPointer)*/
initRawPointer(_rawValue, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.init(_:RawPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>)*/
/*Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>)*/
initMutatingUnsafePointer(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>?)*/
/*Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>?)*/
initMutatingOptional(other, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initMutatingUnsafePointer(unwrapped_1);
return
}
static readonly initMutatingOptional$failable = true
/*Swift.(file).UnsafeMutablePointer.init(_:UnsafeMutablePointer<Pointee>)*/
/*Swift.(file).UnsafeMutablePointer.init(_:UnsafeMutablePointer<Pointee>)*/
initUnsafeMutablePointer(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.init(_:UnsafeMutablePointer<Pointee>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.init(_:UnsafeMutablePointer<Pointee>?)*/
/*Swift.(file).UnsafeMutablePointer.init(_:UnsafeMutablePointer<Pointee>?)*/
initOptional(other, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeMutablePointer(unwrapped_1);
return
}
static readonly initOptional$failable = true
static /*Swift.(file).UnsafeMutablePointer.allocate(capacity:Int)*/
/*Swift.(file).UnsafeMutablePointer.allocate(capacity:Int)*/
allocateCapacity(count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.allocate(capacity:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.deallocate()*/
/*Swift.(file).UnsafeMutablePointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.deallocate() in ' + this.constructor.name
}

/*Swift.(file).UnsafeMutablePointer.pointee*/
pointee$get() {
 return this.pointee$internal
}
get pointee() { return this.pointee$get() };







/*Swift.(file).UnsafeMutablePointer.initialize(repeating:Pointee,count:Int)*/
/*Swift.(file).UnsafeMutablePointer.initialize(repeating:Pointee,count:Int)*/
initializeRepeatingCount(repeatedValue, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.initialize(repeating:Pointee,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.initialize(to:Pointee)*/
/*Swift.(file).UnsafeMutablePointer.initialize(to:Pointee)*/
initializeTo(value, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.initialize(to:Pointee) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.move()*/
/*Swift.(file).UnsafeMutablePointer.move()*/
move($info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.move() in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)*/
/*Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)*/
assignRepeatingCount(repeatedValue, count, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(count, 0), () => "UnsafeMutablePointer.assign(repeating:count:) with negative count", null, null);
{
let $i$generator = _cloneStruct(Int.$halfOpenRange(0, count).makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set(repeatedValue, i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct(_cloneStruct($val)))});
}
}
}
/*Swift.(file).UnsafeMutablePointer.assign(from:UnsafePointer<Pointee>,count:Int)*/
/*Swift.(file).UnsafeMutablePointer.assign(from:UnsafePointer<Pointee>,count:Int)*/
assignFromCount(source, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.assign(from:UnsafePointer<Pointee>,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.moveInitialize(from:UnsafeMutablePointer<Pointee>,count:Int)*/
/*Swift.(file).UnsafeMutablePointer.moveInitialize(from:UnsafeMutablePointer<Pointee>,count:Int)*/
moveInitializeFromCount(source, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.moveInitialize(from:UnsafeMutablePointer<Pointee>,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.initialize(from:UnsafePointer<Pointee>,count:Int)*/
/*Swift.(file).UnsafeMutablePointer.initialize(from:UnsafePointer<Pointee>,count:Int)*/
initializeFromCount(source, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.initialize(from:UnsafePointer<Pointee>,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.moveAssign(from:UnsafeMutablePointer<Pointee>,count:Int)*/
/*Swift.(file).UnsafeMutablePointer.moveAssign(from:UnsafeMutablePointer<Pointee>,count:Int)*/
moveAssignFromCount(source, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.moveAssign(from:UnsafeMutablePointer<Pointee>,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.deinitialize(count:Int)*/
/*Swift.(file).UnsafeMutablePointer.deinitialize(count:Int)*/
deinitializeCount(count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.deinitialize(count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafeMutablePointer<T>) throws -> Result)*/
/*Swift.(file).UnsafeMutablePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafeMutablePointer<T>) throws -> Result)*/
withMemoryReboundToCapacity<T, Result>(type, count, body, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutablePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafeMutablePointer<T>) throws -> Result) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutablePointer.subscript(_:Int)*/
/*Swift.(file).UnsafeMutablePointer.subscript(_:Int)*/
subscript$unsafeAddress(i, $info?) {
let _this = this;
return _create(UnsafePointer, 'init', UnsafeMutablePointer.$add(_this, i), {});
}subscript$unsafeMutableAddress(i, $info?){
let _this = this;
return UnsafeMutablePointer.$add(_this, i)
}/*Swift.(file).UnsafeMutablePointer.subscript(_:Int)*/
/*Swift.(file).UnsafeMutablePointer.subscript(_:Int)*/
subscript$unsafeMutableAddress(i, $info?) {
let _this = this;
return _create(UnsafePointer, 'init', UnsafeMutablePointer.$add(_this, i), {});
}subscript$unsafeMutableAddress(i, $info?){
let _this = this;
return UnsafeMutablePointer.$add(_this, i)
}













/*Swift.(file).UnsafeMutablePointer.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UnsafeMutablePointer.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)*/
/*Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)*/
initializeToCount(newValue, count, $info?) {
let _this = this;
_this.initializeRepeatingCount(newValue, count)
}
/*Swift.(file).UnsafeMutablePointer.deinitialize()*/
/*Swift.(file).UnsafeMutablePointer.deinitialize()*/
deinitialize($info?) {
let _this = this;
return _this.deinitializeCount(1)
}
/*Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)*/
/*Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)*/
deallocateCapacity(_, $info?) {
let _this = this;
_this.deallocate( {})
}
/*Swift.(file).UnsafeMutablePointer.initialize(from:C)*/
/*Swift.(file).UnsafeMutablePointer.initialize(from:C)*/
initializeFrom<C>(source, $info?) {
let _this = this;
const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(_this), numericCast(source.count, {T: Int, U: Int}), {});
let $tuple = source._copyContentsInitializing(buf), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
preconditionFileLine(() => Optional.wrappedEqualsOptionalNilComparisonType(remainders.next( {$setThis: $val => remainders = $val}), _injectIntoOptional(null)), () => "rhs underreported its count", null, null);
preconditionFileLine(() => Int.$equal(writtenUpTo, buf.endIndex), () => "rhs overreported its count", null, null)
}

/*Swift.(file).UnsafeMutablePointer.summary*/
summary$get() {
throw 'unsupported variable Swift.(file).UnsafeMutablePointer.summary in ' + this.constructor.name
}
get summary() { return this.summary$get() };




/*Swift.(file).UnsafeMutablePointer.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return PlaygroundQuickLook.text(_this.summary)
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };






init$vars() {let _this = this;

}
}
if(typeof _Pointer$implementation != 'undefined') _mixin(UnsafeMutablePointer, _Pointer$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(UnsafeMutablePointer, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(UnsafeMutablePointer, CVarArg$implementation, false)








class UnsafeRawPointer implements _Pointer, Strideable, _CustomPlaygroundQuickLookable{
static readonly $struct = true




/*Swift.(file).UnsafeRawPointer.init(_:RawPointer)*/
/*Swift.(file)._Pointer.init(_:RawPointer)*/
initRawPointer(_rawValue, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:RawPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>)*/
/*Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>)*/
initUnsafePointer<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>?)*/
/*Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>?)*/
initOptional<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>?) in ' + this.constructor.name
}
static readonly initOptional$failable = true
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer)*/
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer)*/
initUnsafeMutableRawPointer(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer?)*/
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer?)*/
/*!!!DUPLICATE NAME*/
initOptional(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static readonly initOptional$failable = true
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutablePointer<T>)*/
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutablePointer<T>)*/
initUnsafeMutablePointer<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:UnsafeMutablePointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutablePointer<T>?)*/
/*Swift.(file).UnsafeRawPointer.init(_:UnsafeMutablePointer<T>?)*/
/*!!!DUPLICATE NAME*/
initOptional<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:UnsafeMutablePointer<T>?) in ' + this.constructor.name
}
static readonly initOptional$failable = true
/*Swift.(file).UnsafeRawPointer.deallocate()*/
/*Swift.(file).UnsafeRawPointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.deallocate() in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawPointer.bindMemory(to:T.Type,capacity:Int)*/
/*Swift.(file).UnsafeRawPointer.bindMemory(to:T.Type,capacity:Int)*/
bindMemoryToCapacity<T>(type, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.bindMemory(to:T.Type,capacity:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)*/
/*Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)*/
assumingMemoryBoundTo<T>(to, $info?) {
let _this = this;
return _create(UnsafePointer, 'initRawPointer', _this._rawValue, {})
}
/*Swift.(file).UnsafeRawPointer.load(fromByteOffset:Int,as:T.Type)*/
/*Swift.(file).UnsafeRawPointer.load(fromByteOffset:Int,as:T.Type)*/
loadFromByteOffsetAs<T>(offset, type, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.load(fromByteOffset:Int,as:T.Type) in ' + this.constructor.name
}



/*Swift.(file).UnsafeRawPointer.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UnsafeRawPointer.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>)*/
/*Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>)*/
initAutoreleasingUnsafeMutablePointer<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)*/
/*Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)*/
/*!!!DUPLICATE NAME*/
initOptional<T>(other, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.init(unwrapped_1);
return
}
static readonly initOptional$failable = true
/*Swift.(file).UnsafeRawPointer.advanced(by:Int)*/
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
advancedBy(n, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawPointer.advanced(by:Int) in ' + this.constructor.name
}


/*Swift.(file).UnsafeRawPointer.summary*/
summary$get() {
throw 'unsupported variable Swift.(file).UnsafeRawPointer.summary in ' + this.constructor.name
}
get summary() { return this.summary$get() };




/*Swift.(file).UnsafeRawPointer.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return _PlaygroundQuickLook.text(_this.summary)
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}
if(typeof _Pointer$implementation != 'undefined') _mixin(UnsafeRawPointer, _Pointer$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(UnsafeRawPointer, Strideable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(UnsafeRawPointer, _CustomPlaygroundQuickLookable$implementation, false)






class UnsafeMutableRawPointer implements _Pointer, Strideable, _CustomPlaygroundQuickLookable{
static readonly $struct = true




/*Swift.(file).UnsafeMutableRawPointer.init(_:RawPointer)*/
/*Swift.(file)._Pointer.init(_:RawPointer)*/
initRawPointer(_rawValue, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:RawPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>)*/
initUnsafeMutablePointer<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>?)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>?)*/
initOptional<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>?) in ' + this.constructor.name
}
static readonly initOptional$failable = true
/*Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer)*/
/*Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer)*/
initMutatingUnsafeRawPointer(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer?)*/
/*Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer?)*/
initMutatingOptional(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer?) in ' + this.constructor.name
}
static readonly initMutatingOptional$failable = true
static /*Swift.(file).UnsafeMutableRawPointer.allocate(byteCount:Int,alignment:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.allocate(byteCount:Int,alignment:Int)*/
allocateByteCountAlignment(byteCount, alignment, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.allocate(byteCount:Int,alignment:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.deallocate()*/
/*Swift.(file).UnsafeMutableRawPointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.deallocate() in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.bindMemory(to:T.Type,capacity:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.bindMemory(to:T.Type,capacity:Int)*/
bindMemoryToCapacity<T>(type, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.bindMemory(to:T.Type,capacity:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)*/
/*Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)*/
assumingMemoryBoundTo<T>(to, $info?) {
let _this = this;
return _create(UnsafeMutablePointer, 'initRawPointer', _this._rawValue, {})
}
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,repeating:T,count:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,repeating:T,count:Int)*/
initializeMemoryAsRepeatingCount<T>(type, repeatedValue, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,repeating:T,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,from:UnsafePointer<T>,count:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,from:UnsafePointer<T>,count:Int)*/
initializeMemoryAsFromCount<T>(type, source, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,from:UnsafePointer<T>,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.moveInitializeMemory(as:T.Type,from:UnsafeMutablePointer<T>,count:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.moveInitializeMemory(as:T.Type,from:UnsafeMutablePointer<T>,count:Int)*/
moveInitializeMemoryAsFromCount<T>(type, source, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.moveInitializeMemory(as:T.Type,from:UnsafeMutablePointer<T>,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.load(fromByteOffset:Int,as:T.Type)*/
/*Swift.(file).UnsafeMutableRawPointer.load(fromByteOffset:Int,as:T.Type)*/
loadFromByteOffsetAs<T>(offset, type, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.load(fromByteOffset:Int,as:T.Type) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type)*/
/*Swift.(file).UnsafeMutableRawPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type)*/
storeBytesOfToByteOffsetAs<T>(value, offset, type, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.copyMemory(from:UnsafeRawPointer,byteCount:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.copyMemory(from:UnsafeRawPointer,byteCount:Int)*/
copyMemoryFromByteCount(source, byteCount, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(byteCount, 0), () => "UnsafeMutableRawPointer.copyMemory with negative count", null, null);
_memmoveDestSrcSize(_this, source, _create(UInt, 'initT', byteCount, {}))
}



/*Swift.(file).UnsafeMutableRawPointer.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableRawPointer.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>)*/
initAutoreleasingUnsafeMutablePointer<T>(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)*/
/*!!!DUPLICATE NAME*/
initOptional<T>(other, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initAutoreleasingUnsafeMutablePointer(unwrapped_1);
return
}
static readonly initOptional$failable = true
/*Swift.(file).UnsafeMutableRawPointer.advanced(by:Int)*/
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
advancedBy(n, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.advanced(by:Int) in ' + this.constructor.name
}

/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer)*/
initUnsafeRawPointer(from, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer?)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer?)*/
/*!!!DUPLICATE NAME*/
initOptional(from, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer?) in ' + this.constructor.name
}
static readonly initOptional$failable = true
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>)*/
initUnsafePointer<T>(from, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>?)*/
/*Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>?)*/
/*!!!DUPLICATE NAME*/
initOptional<T>(from, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>?) in ' + this.constructor.name
}
static readonly initOptional$failable = true

/*Swift.(file).UnsafeMutableRawPointer.summary*/
summary$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableRawPointer.summary in ' + this.constructor.name
}
get summary() { return this.summary$get() };




/*Swift.(file).UnsafeMutableRawPointer.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return _PlaygroundQuickLook.text(_this.summary)
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



static /*Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)*/
allocateBytesAlignedTo(size, alignment, $info?) {
let _this = this;
return UnsafeMutableRawPointer.allocateByteCountAlignment(size, alignment)
}
/*Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)*/
deallocateBytesAlignedTo(_, _, $info?) {
let _this = this;
_this.deallocate( {})
}
/*Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)*/
/*Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)*/
copyBytesFromCount(source, count, $info?) {
let _this = this;
_this.copyMemoryFromByteCount(source, count)
}
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)*/
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)*/
initializeMemoryAsAtCountTo<T>(type, offset, count, repeatedValue, $info?) {
let _this = this;
return UnsafeMutableRawPointer.$add(_this, Int.$multiply(offset, MemoryLayout.stride)).initializeMemoryAsRepeatingCount(type, repeatedValue, count)
}
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)*/
/*Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)*/
initializeMemoryAsFrom<C>(type, source, $info?) {
let _this = this;
let ptr = _cloneStruct(_this);
{
let $element$generator = source.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
ptr.initializeMemoryAsRepeatingCount(((function(){throw '!unclarifiedGeneric:C.Element'})()), _element_1, 1);
UnsafeMutableRawPointer.$addAndAssign({get: () => ptr, set: $val => ptr = $val}, MemoryLayout.stride);
}
};
return _create(UnsafeMutablePointer, 'initRawPointer', _this._rawValue, {})
}
init$vars() {let _this = this;

}
}
if(typeof _Pointer$implementation != 'undefined') _mixin(UnsafeMutableRawPointer, _Pointer$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(UnsafeMutableRawPointer, Strideable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(UnsafeMutableRawPointer, _CustomPlaygroundQuickLookable$implementation, false)










class Unicode{
static Scalar = class implements _ExpressibleByBuiltinUnicodeScalarLiteral, ExpressibleByUnicodeScalarLiteral, CustomStringConvertible, CustomDebugStringConvertible, LosslessStringConvertible, Hashable, Equatable, Comparable, TextOutputStreamable, CustomReflectable, _CustomPlaygroundQuickLookable{
static readonly $struct = true
/*Swift.(file).Unicode.Scalar.init(_value:UInt32)*/
/*Swift.(file).Unicode.Scalar.init(_value:UInt32)*/
init_valueUInt32(_value, $info?) {
let _this = this;
_this._value = _value;
return
}






/*Swift.(file).Unicode.Scalar.value*/
value$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.value in ' + this.constructor.name
}
get value() { return this.value$get() };



/*Swift.(file).Unicode.Scalar.init(_builtinUnicodeScalarLiteral:Int32)*/
/*Swift.(file)._ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:Int32)*/
init_builtinUnicodeScalarLiteralInt32(value, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_builtinUnicodeScalarLiteral:Int32) in ' + this.constructor.name
}
/*Swift.(file).Unicode.Scalar.init(unicodeScalarLiteral:Unicode.Scalar)*/
/*Swift.(file).ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:Self.UnicodeScalarLiteralType)*/
initUnicodeScalarLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(unicodeScalarLiteral:Unicode.Scalar) in ' + this.constructor.name
}
/*Swift.(file).Unicode.Scalar.init(_:UInt32)*/
/*Swift.(file).Unicode.Scalar.init(_:UInt32)*/
initUInt32(v, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_:UInt32) in ' + this.constructor.name
}
static readonly initUInt32$failable = true
/*Swift.(file).Unicode.Scalar.init(_:UInt16)*/
/*Swift.(file).Unicode.Scalar.init(_:UInt16)*/
initUInt16(v, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_:UInt16) in ' + this.constructor.name
}
static readonly initUInt16$failable = true
/*Swift.(file).Unicode.Scalar.init(_:UInt8)*/
/*Swift.(file).Unicode.Scalar.init(_:UInt8)*/
initUInt8(v, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_:UInt8) in ' + this.constructor.name
}
/*Swift.(file).Unicode.Scalar.init(_:Unicode.Scalar)*/
/*Swift.(file).Unicode.Scalar.init(_:Unicode.Scalar)*/
initUnicodeScalar(v, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_:Unicode.Scalar) in ' + this.constructor.name
}
/*Swift.(file).Unicode.Scalar.escaped(asASCII:Bool)*/
/*Swift.(file).Unicode.Scalar.escaped(asASCII:Bool)*/
escapedAsASCII(forceASCII, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.escaped(asASCII:Bool) in ' + this.constructor.name
}

/*Swift.(file).Unicode.Scalar.isASCII*/
isASCII$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.isASCII in ' + this.constructor.name
}
get isASCII() { return this.isASCII$get() };








/*Swift.(file).Unicode.Scalar.description*/
description$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).Unicode.Scalar.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).Unicode.Scalar.init(_:String)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString(description, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_:String) in ' + this.constructor.name
}
static readonly initString$failable = true
/*Swift.(file).Unicode.Scalar.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).Unicode.Scalar.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Unicode.Scalar.init(_:Int)*/
/*Swift.(file).Unicode.Scalar.init(_:Int)*/
initInt(v, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_:Int) in ' + this.constructor.name
}
static readonly initInt$failable = true
static /*Swift.(file).Unicode.Scalar.==infix(_:Unicode.Scalar,_:Unicode.Scalar)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Unicode.Scalar.<infix(_:Unicode.Scalar,_:Unicode.Scalar)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static UTF16View = class implements RandomAccessCollection{
static readonly $struct = true
/*Swift.(file).Unicode.Scalar.UTF16View.init(value:Unicode.Scalar)*/
/*Swift.(file).Unicode.Scalar.UTF16View.init(value:Unicode.Scalar)*/
initValueUnicodeScalar(value, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.UTF16View.init(value:Unicode.Scalar) in ' + this.constructor.name
}

/*Swift.(file).Unicode.Scalar.UTF16View.value*/
value$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.UTF16View.value in ' + this.constructor.name
}
get value() { return this.value$get() };







/*Swift.(file).Unicode.Scalar.UTF16View.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.UTF16View.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Unicode.Scalar.UTF16View.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.UTF16View.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Unicode.Scalar.UTF16View.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.UTF16View.subscript(_:Int) in ' + this.constructor.name
}






init$vars() {let _this = this;

}
}

/*Swift.(file).Unicode.Scalar.utf16*/
utf16$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.utf16 in ' + this.constructor.name
}
get utf16() { return this.utf16$get() };



static UTF8View = class implements RandomAccessCollection{
static readonly $struct = true
/*Swift.(file).Unicode.Scalar.UTF8View.init(value:Unicode.Scalar)*/
/*Swift.(file).Unicode.Scalar.UTF8View.init(value:Unicode.Scalar)*/
initValueUnicodeScalar(value, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.UTF8View.init(value:Unicode.Scalar) in ' + this.constructor.name
}

/*Swift.(file).Unicode.Scalar.UTF8View.value*/
value$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.UTF8View.value in ' + this.constructor.name
}
get value() { return this.value$get() };







/*Swift.(file).Unicode.Scalar.UTF8View.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.UTF8View.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Unicode.Scalar.UTF8View.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.UTF8View.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Unicode.Scalar.UTF8View.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.UTF8View.subscript(_:Int) in ' + this.constructor.name
}






init$vars() {let _this = this;

}
}

/*Swift.(file).Unicode.Scalar.utf8*/
utf8$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.utf8 in ' + this.constructor.name
}
get utf8() { return this.utf8$get() };






/*Swift.(file).Unicode.Scalar.init()*/
/*Swift.(file).Unicode.Scalar.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init() in ' + this.constructor.name
}
/*Swift.(file).Unicode.Scalar.withUTF16CodeUnits(_:(UnsafeBufferPointer<UInt16>) throws -> Result)*/
/*Swift.(file).Unicode.Scalar.withUTF16CodeUnits(_:(UnsafeBufferPointer<UInt16>) throws -> Result)*/
withUTF16CodeUnits<Result>(body, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.withUTF16CodeUnits(_:(UnsafeBufferPointer<UInt16>) throws -> Result) in ' + this.constructor.name
}
/*Swift.(file).Unicode.Scalar.withUTF8CodeUnits(_:(UnsafeBufferPointer<UInt8>) throws -> Result)*/
/*Swift.(file).Unicode.Scalar.withUTF8CodeUnits(_:(UnsafeBufferPointer<UInt8>) throws -> Result)*/
withUTF8CodeUnits<Result>(body, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.withUTF8CodeUnits(_:(UnsafeBufferPointer<UInt8>) throws -> Result) in ' + this.constructor.name
}
/*Swift.(file).Unicode.Scalar.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?) {
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_create(String, 'initCharacter', _create(Character, 'initUnicodeScalar', _this, {}), {}), {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
}









static Properties = class{
static readonly $struct = true





/*Swift.(file).Unicode.Scalar.Properties.init(_:Unicode.Scalar)*/
/*Swift.(file).Unicode.Scalar.Properties.init(_:Unicode.Scalar)*/
initUnicodeScalar(scalar, $info?) {
let _this = this;
_this._scalar = _cloneStruct(scalar);
return
}

/*Swift.(file).Unicode.Scalar.Properties.icuValue*/
icuValue$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.icuValue in ' + this.constructor.name
}
get icuValue() { return this.icuValue$get() };





/*Swift.(file).Unicode.Scalar.Properties.isAlphabetic*/
isAlphabetic$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isAlphabetic in ' + this.constructor.name
}
get isAlphabetic() { return this.isAlphabetic$get() };




/*Swift.(file).Unicode.Scalar.Properties.isASCIIHexDigit*/
isASCIIHexDigit$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isASCIIHexDigit in ' + this.constructor.name
}
get isASCIIHexDigit() { return this.isASCIIHexDigit$get() };




/*Swift.(file).Unicode.Scalar.Properties.isBidiControl*/
isBidiControl$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isBidiControl in ' + this.constructor.name
}
get isBidiControl() { return this.isBidiControl$get() };




/*Swift.(file).Unicode.Scalar.Properties.isBidiMirrored*/
isBidiMirrored$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isBidiMirrored in ' + this.constructor.name
}
get isBidiMirrored() { return this.isBidiMirrored$get() };




/*Swift.(file).Unicode.Scalar.Properties.isDash*/
isDash$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isDash in ' + this.constructor.name
}
get isDash() { return this.isDash$get() };




/*Swift.(file).Unicode.Scalar.Properties.isDefaultIgnorableCodePoint*/
isDefaultIgnorableCodePoint$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isDefaultIgnorableCodePoint in ' + this.constructor.name
}
get isDefaultIgnorableCodePoint() { return this.isDefaultIgnorableCodePoint$get() };




/*Swift.(file).Unicode.Scalar.Properties.isDeprecated*/
isDeprecated$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isDeprecated in ' + this.constructor.name
}
get isDeprecated() { return this.isDeprecated$get() };




/*Swift.(file).Unicode.Scalar.Properties.isDiacritic*/
isDiacritic$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isDiacritic in ' + this.constructor.name
}
get isDiacritic() { return this.isDiacritic$get() };




/*Swift.(file).Unicode.Scalar.Properties.isExtender*/
isExtender$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isExtender in ' + this.constructor.name
}
get isExtender() { return this.isExtender$get() };




/*Swift.(file).Unicode.Scalar.Properties.isFullCompositionExclusion*/
isFullCompositionExclusion$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isFullCompositionExclusion in ' + this.constructor.name
}
get isFullCompositionExclusion() { return this.isFullCompositionExclusion$get() };




/*Swift.(file).Unicode.Scalar.Properties.isGraphemeBase*/
isGraphemeBase$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isGraphemeBase in ' + this.constructor.name
}
get isGraphemeBase() { return this.isGraphemeBase$get() };




/*Swift.(file).Unicode.Scalar.Properties.isGraphemeExtend*/
isGraphemeExtend$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isGraphemeExtend in ' + this.constructor.name
}
get isGraphemeExtend() { return this.isGraphemeExtend$get() };




/*Swift.(file).Unicode.Scalar.Properties.isHexDigit*/
isHexDigit$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isHexDigit in ' + this.constructor.name
}
get isHexDigit() { return this.isHexDigit$get() };




/*Swift.(file).Unicode.Scalar.Properties.isIDContinue*/
isIDContinue$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isIDContinue in ' + this.constructor.name
}
get isIDContinue() { return this.isIDContinue$get() };




/*Swift.(file).Unicode.Scalar.Properties.isIDStart*/
isIDStart$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isIDStart in ' + this.constructor.name
}
get isIDStart() { return this.isIDStart$get() };




/*Swift.(file).Unicode.Scalar.Properties.isIdeographic*/
isIdeographic$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isIdeographic in ' + this.constructor.name
}
get isIdeographic() { return this.isIdeographic$get() };




/*Swift.(file).Unicode.Scalar.Properties.isIDSBinaryOperator*/
isIDSBinaryOperator$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isIDSBinaryOperator in ' + this.constructor.name
}
get isIDSBinaryOperator() { return this.isIDSBinaryOperator$get() };




/*Swift.(file).Unicode.Scalar.Properties.isIDSTrinaryOperator*/
isIDSTrinaryOperator$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isIDSTrinaryOperator in ' + this.constructor.name
}
get isIDSTrinaryOperator() { return this.isIDSTrinaryOperator$get() };




/*Swift.(file).Unicode.Scalar.Properties.isJoinControl*/
isJoinControl$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isJoinControl in ' + this.constructor.name
}
get isJoinControl() { return this.isJoinControl$get() };




/*Swift.(file).Unicode.Scalar.Properties.isLogicalOrderException*/
isLogicalOrderException$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isLogicalOrderException in ' + this.constructor.name
}
get isLogicalOrderException() { return this.isLogicalOrderException$get() };




/*Swift.(file).Unicode.Scalar.Properties.isLowercase*/
isLowercase$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isLowercase in ' + this.constructor.name
}
get isLowercase() { return this.isLowercase$get() };




/*Swift.(file).Unicode.Scalar.Properties.isMath*/
isMath$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isMath in ' + this.constructor.name
}
get isMath() { return this.isMath$get() };




/*Swift.(file).Unicode.Scalar.Properties.isNoncharacterCodePoint*/
isNoncharacterCodePoint$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isNoncharacterCodePoint in ' + this.constructor.name
}
get isNoncharacterCodePoint() { return this.isNoncharacterCodePoint$get() };




/*Swift.(file).Unicode.Scalar.Properties.isQuotationMark*/
isQuotationMark$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isQuotationMark in ' + this.constructor.name
}
get isQuotationMark() { return this.isQuotationMark$get() };




/*Swift.(file).Unicode.Scalar.Properties.isRadical*/
isRadical$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isRadical in ' + this.constructor.name
}
get isRadical() { return this.isRadical$get() };




/*Swift.(file).Unicode.Scalar.Properties.isSoftDotted*/
isSoftDotted$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isSoftDotted in ' + this.constructor.name
}
get isSoftDotted() { return this.isSoftDotted$get() };




/*Swift.(file).Unicode.Scalar.Properties.isTerminalPunctuation*/
isTerminalPunctuation$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isTerminalPunctuation in ' + this.constructor.name
}
get isTerminalPunctuation() { return this.isTerminalPunctuation$get() };




/*Swift.(file).Unicode.Scalar.Properties.isUnifiedIdeograph*/
isUnifiedIdeograph$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isUnifiedIdeograph in ' + this.constructor.name
}
get isUnifiedIdeograph() { return this.isUnifiedIdeograph$get() };




/*Swift.(file).Unicode.Scalar.Properties.isUppercase*/
isUppercase$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isUppercase in ' + this.constructor.name
}
get isUppercase() { return this.isUppercase$get() };




/*Swift.(file).Unicode.Scalar.Properties.isWhitespace*/
isWhitespace$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isWhitespace in ' + this.constructor.name
}
get isWhitespace() { return this.isWhitespace$get() };




/*Swift.(file).Unicode.Scalar.Properties.isXIDContinue*/
isXIDContinue$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isXIDContinue in ' + this.constructor.name
}
get isXIDContinue() { return this.isXIDContinue$get() };




/*Swift.(file).Unicode.Scalar.Properties.isXIDStart*/
isXIDStart$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isXIDStart in ' + this.constructor.name
}
get isXIDStart() { return this.isXIDStart$get() };




/*Swift.(file).Unicode.Scalar.Properties.isSentenceTerminal*/
isSentenceTerminal$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isSentenceTerminal in ' + this.constructor.name
}
get isSentenceTerminal() { return this.isSentenceTerminal$get() };




/*Swift.(file).Unicode.Scalar.Properties.isVariationSelector*/
isVariationSelector$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isVariationSelector in ' + this.constructor.name
}
get isVariationSelector() { return this.isVariationSelector$get() };




/*Swift.(file).Unicode.Scalar.Properties.isPatternSyntax*/
isPatternSyntax$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isPatternSyntax in ' + this.constructor.name
}
get isPatternSyntax() { return this.isPatternSyntax$get() };




/*Swift.(file).Unicode.Scalar.Properties.isPatternWhitespace*/
isPatternWhitespace$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isPatternWhitespace in ' + this.constructor.name
}
get isPatternWhitespace() { return this.isPatternWhitespace$get() };




/*Swift.(file).Unicode.Scalar.Properties.isCased*/
isCased$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isCased in ' + this.constructor.name
}
get isCased() { return this.isCased$get() };




/*Swift.(file).Unicode.Scalar.Properties.isCaseIgnorable*/
isCaseIgnorable$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isCaseIgnorable in ' + this.constructor.name
}
get isCaseIgnorable() { return this.isCaseIgnorable$get() };




/*Swift.(file).Unicode.Scalar.Properties.changesWhenLowercased*/
changesWhenLowercased$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.changesWhenLowercased in ' + this.constructor.name
}
get changesWhenLowercased() { return this.changesWhenLowercased$get() };




/*Swift.(file).Unicode.Scalar.Properties.changesWhenUppercased*/
changesWhenUppercased$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.changesWhenUppercased in ' + this.constructor.name
}
get changesWhenUppercased() { return this.changesWhenUppercased$get() };




/*Swift.(file).Unicode.Scalar.Properties.changesWhenTitlecased*/
changesWhenTitlecased$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.changesWhenTitlecased in ' + this.constructor.name
}
get changesWhenTitlecased() { return this.changesWhenTitlecased$get() };




/*Swift.(file).Unicode.Scalar.Properties.changesWhenCaseFolded*/
changesWhenCaseFolded$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.changesWhenCaseFolded in ' + this.constructor.name
}
get changesWhenCaseFolded() { return this.changesWhenCaseFolded$get() };




/*Swift.(file).Unicode.Scalar.Properties.changesWhenCaseMapped*/
changesWhenCaseMapped$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.changesWhenCaseMapped in ' + this.constructor.name
}
get changesWhenCaseMapped() { return this.changesWhenCaseMapped$get() };




/*Swift.(file).Unicode.Scalar.Properties.changesWhenNFKCCaseFolded*/
changesWhenNFKCCaseFolded$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.changesWhenNFKCCaseFolded in ' + this.constructor.name
}
get changesWhenNFKCCaseFolded() { return this.changesWhenNFKCCaseFolded$get() };




/*Swift.(file).Unicode.Scalar.Properties.isEmoji*/
isEmoji$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isEmoji in ' + this.constructor.name
}
get isEmoji() { return this.isEmoji$get() };




/*Swift.(file).Unicode.Scalar.Properties.isEmojiPresentation*/
isEmojiPresentation$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isEmojiPresentation in ' + this.constructor.name
}
get isEmojiPresentation() { return this.isEmojiPresentation$get() };




/*Swift.(file).Unicode.Scalar.Properties.isEmojiModifier*/
isEmojiModifier$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isEmojiModifier in ' + this.constructor.name
}
get isEmojiModifier() { return this.isEmojiModifier$get() };




/*Swift.(file).Unicode.Scalar.Properties.isEmojiModifierBase*/
isEmojiModifierBase$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.isEmojiModifierBase in ' + this.constructor.name
}
get isEmojiModifierBase() { return this.isEmojiModifierBase$get() };






/*Swift.(file).Unicode.Scalar.Properties.lowercaseMapping*/
lowercaseMapping$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.lowercaseMapping in ' + this.constructor.name
}
get lowercaseMapping() { return this.lowercaseMapping$get() };




/*Swift.(file).Unicode.Scalar.Properties.titlecaseMapping*/
titlecaseMapping$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.titlecaseMapping in ' + this.constructor.name
}
get titlecaseMapping() { return this.titlecaseMapping$get() };




/*Swift.(file).Unicode.Scalar.Properties.uppercaseMapping*/
uppercaseMapping$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.uppercaseMapping in ' + this.constructor.name
}
get uppercaseMapping() { return this.uppercaseMapping$get() };




/*Swift.(file).Unicode.Scalar.Properties.age*/
age$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.age in ' + this.constructor.name
}
get age() { return this.age$get() };




/*Swift.(file).Unicode.Scalar.Properties.generalCategory*/
generalCategory$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.generalCategory in ' + this.constructor.name
}
get generalCategory() { return this.generalCategory$get() };








/*Swift.(file).Unicode.Scalar.Properties.nameAlias*/
nameAlias$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.nameAlias in ' + this.constructor.name
}
get nameAlias() { return this.nameAlias$get() };




/*Swift.(file).Unicode.Scalar.Properties.canonicalCombiningClass*/
canonicalCombiningClass$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.canonicalCombiningClass in ' + this.constructor.name
}
get canonicalCombiningClass() { return this.canonicalCombiningClass$get() };




/*Swift.(file).Unicode.Scalar.Properties.numericType*/
numericType$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.numericType in ' + this.constructor.name
}
get numericType() { return this.numericType$get() };




/*Swift.(file).Unicode.Scalar.Properties.numericValue*/
numericValue$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.Properties.numericValue in ' + this.constructor.name
}
get numericValue() { return this.numericValue$get() };



init$vars() {let _this = this;

}
}

/*Swift.(file).Unicode.Scalar.properties*/
properties$get() {
let _this = this;
return _create(Unicode.Scalar.Properties, 'initUnicodeScalar', _this, {})
}
get properties() { return this.properties$get() };



/*Swift.(file).Unicode.Scalar.init(_unchecked:UInt32)*/
/*Swift.(file).Unicode.Scalar.init(_unchecked:UInt32)*/
init_uncheckedUInt32(value, $info?) {
throw 'unsupported method Swift.(file).Unicode.Scalar.init(_unchecked:UInt32) in ' + this.constructor.name
}

/*Swift.(file).Unicode.Scalar.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Unicode.Scalar.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Unicode.Scalar.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}
static ASCII = class implements Unicode.Encoding{



/*Swift.(file).Unicode.ASCII.encodedReplacementCharacter*/
static encodedReplacementCharacter$get() {
throw 'unsupported variable Swift.(file).Unicode.ASCII.encodedReplacementCharacter in ' + this.constructor.name
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get() };



static /*Swift.(file).Unicode.ASCII.isASCII(_:Unicode.ASCII.CodeUnit)*/
/*Swift.(file).Unicode.ASCII.isASCII(_:Unicode.ASCII.CodeUnit)*/
isASCII(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.ASCII.isASCII(_:Unicode.ASCII.CodeUnit) in ' + this.constructor.name
}

static /*Swift.(file).Unicode.ASCII.decode(_:Unicode.ASCII.EncodedScalar)*/
/*Swift.(file)._UnicodeEncoding.decode(_:Self.EncodedScalar)*/
decode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.ASCII.decode(_:Unicode.ASCII.EncodedScalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.ASCII.encode(_:Unicode.Scalar)*/
/*Swift.(file)._UnicodeEncoding.encode(_:Unicode.Scalar)*/
encode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.ASCII.encode(_:Unicode.Scalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.ASCII.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
/*Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
transcodeFrom<FromEncoding>(content, _, $info?) {
throw 'unsupported method Swift.(file).Unicode.ASCII.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type) in ' + this.constructor.name
}
static Parser = class implements Unicode.Parser{
static readonly $struct = true
/*Swift.(file).Unicode.ASCII.Parser.init()*/
/*Swift.(file)._UnicodeParser.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.ASCII.Parser.init() in ' + this.constructor.name
}

/*Swift.(file).Unicode.ASCII.Parser.parseScalar(from:I)*/
/*Swift.(file)._UnicodeParser.parseScalar(from:I)*/
parseScalarFrom<I>(input$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.ASCII.Parser.parseScalar(from:I) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


init$vars() {let _this = this;

}
}


static UTF16 = class implements Unicode.Encoding, UnicodeCodec{

static _swift3Buffer() {return Object.assign(new Unicode.UTF16(), {rawValue: "_swift3Buffer", ...Array.from(arguments)})}






/*Swift.(file).Unicode.UTF16.encodedReplacementCharacter*/
static encodedReplacementCharacter$get() {
throw 'unsupported variable Swift.(file).Unicode.UTF16.encodedReplacementCharacter in ' + this.constructor.name
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get() };



static /*Swift.(file).Unicode.UTF16.isASCII(_:Unicode.UTF16.CodeUnit)*/
/*Swift.(file).Unicode.UTF16.isASCII(_:Unicode.UTF16.CodeUnit)*/
isASCII(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.isASCII(_:Unicode.UTF16.CodeUnit) in ' + this.constructor.name
}


static /*Swift.(file).Unicode.UTF16.decode(_:Unicode.UTF16.EncodedScalar)*/
/*Swift.(file)._UnicodeEncoding.decode(_:Self.EncodedScalar)*/
decode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.decode(_:Unicode.UTF16.EncodedScalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF16.encode(_:Unicode.Scalar)*/
/*Swift.(file)._UnicodeEncoding.encode(_:Unicode.Scalar)*/
encode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.encode(_:Unicode.Scalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF16.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
/*Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
transcodeFrom<FromEncoding>(content, _, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type) in ' + this.constructor.name
}
static ForwardParser = class implements Unicode.Parser, _UTFParser{
static readonly $struct = true

/*Swift.(file).Unicode.UTF16.ForwardParser.init()*/
/*Swift.(file)._UnicodeParser.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.ForwardParser.init() in ' + this.constructor.name
}








init$vars() {let _this = this;

}
}
static ReverseParser = class implements Unicode.Parser, _UTFParser{
static readonly $struct = true

/*Swift.(file).Unicode.UTF16.ReverseParser.init()*/
/*Swift.(file)._UnicodeParser.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.ReverseParser.init() in ' + this.constructor.name
}








init$vars() {let _this = this;

}
}

static /*Swift.(file).Unicode.UTF16.width(_:Unicode.Scalar)*/
/*Swift.(file).Unicode.UTF16.width(_:Unicode.Scalar)*/
width(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.width(_:Unicode.Scalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF16.leadSurrogate(_:Unicode.Scalar)*/
/*Swift.(file).Unicode.UTF16.leadSurrogate(_:Unicode.Scalar)*/
leadSurrogate(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.leadSurrogate(_:Unicode.Scalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF16.trailSurrogate(_:Unicode.Scalar)*/
/*Swift.(file).Unicode.UTF16.trailSurrogate(_:Unicode.Scalar)*/
trailSurrogate(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.trailSurrogate(_:Unicode.Scalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)*/
/*Swift.(file).Unicode.UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)*/
isLeadSurrogate(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)*/
/*Swift.(file).Unicode.UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)*/
isTrailSurrogate(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF16.isSurrogate(_:Unicode.UTF16.CodeUnit)*/
/*Swift.(file).Unicode.UTF16.isSurrogate(_:Unicode.UTF16.CodeUnit)*/
isSurrogate(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.isSurrogate(_:Unicode.UTF16.CodeUnit) in ' + this.constructor.name
}

static /*Swift.(file).Unicode.UTF16.transcodedLength(of:Input,decodedAs:Encoding.Type,repairingIllFormedSequences:Bool)*/
/*Swift.(file).Unicode.UTF16.transcodedLength(of:Input,decodedAs:Encoding.Type,repairingIllFormedSequences:Bool)*/
transcodedLengthOfDecodedAsRepairingIllFormedSequences<Input, Encoding>(input, sourceEncoding, repairingIllFormedSequences, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.transcodedLength(of:Input,decodedAs:Encoding.Type,repairingIllFormedSequences:Bool) in ' + this.constructor.name
}
/*Swift.(file).Unicode.UTF16.init()*/
/*Swift.(file).UnicodeCodec.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.init() in ' + this.constructor.name
}
/*Swift.(file).Unicode.UTF16.decode(_:I)*/
/*Swift.(file).UnicodeCodec.decode(_:I)*/
/*!!!DUPLICATE NAME*/
decode<I>(input$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.decode(_:I) in ' + this.constructor.name
}

static /*Swift.(file).Unicode.UTF16.encode(_:Unicode.Scalar,into:(Unicode.UTF16.CodeUnit) -> Void)*/
/*Swift.(file).UnicodeCodec.encode(_:Unicode.Scalar,into:(Self.CodeUnit) -> Void)*/
encodeInto(input, processCodeUnit, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF16.encode(_:Unicode.Scalar,into:(Unicode.UTF16.CodeUnit) -> Void) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
static ParseResult = class<T>{

static valid() {return Object.assign(new Unicode.ParseResult(), {rawValue: "valid", ...Array.from(arguments)})}

static get emptyInput() {return Object.assign(new Unicode.ParseResult(), {rawValue: "emptyInput", ...Array.from(arguments)})}

static error() {return Object.assign(new Unicode.ParseResult(), {rawValue: "error", ...Array.from(arguments)})}






init$vars() {let _this = this;

}
}

static GeneralCategory = class{

static get uppercaseLetter() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "uppercaseLetter", ...Array.from(arguments)})}

static get lowercaseLetter() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "lowercaseLetter", ...Array.from(arguments)})}

static get titlecaseLetter() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "titlecaseLetter", ...Array.from(arguments)})}

static get modifierLetter() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "modifierLetter", ...Array.from(arguments)})}

static get otherLetter() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "otherLetter", ...Array.from(arguments)})}

static get nonspacingMark() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "nonspacingMark", ...Array.from(arguments)})}

static get spacingMark() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "spacingMark", ...Array.from(arguments)})}

static get enclosingMark() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "enclosingMark", ...Array.from(arguments)})}

static get decimalNumber() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "decimalNumber", ...Array.from(arguments)})}

static get letterNumber() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "letterNumber", ...Array.from(arguments)})}

static get otherNumber() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "otherNumber", ...Array.from(arguments)})}

static get connectorPunctuation() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "connectorPunctuation", ...Array.from(arguments)})}

static get dashPunctuation() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "dashPunctuation", ...Array.from(arguments)})}

static get openPunctuation() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "openPunctuation", ...Array.from(arguments)})}

static get closePunctuation() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "closePunctuation", ...Array.from(arguments)})}

static get initialPunctuation() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "initialPunctuation", ...Array.from(arguments)})}

static get finalPunctuation() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "finalPunctuation", ...Array.from(arguments)})}

static get otherPunctuation() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "otherPunctuation", ...Array.from(arguments)})}

static get mathSymbol() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "mathSymbol", ...Array.from(arguments)})}

static get currencySymbol() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "currencySymbol", ...Array.from(arguments)})}

static get modifierSymbol() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "modifierSymbol", ...Array.from(arguments)})}

static get otherSymbol() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "otherSymbol", ...Array.from(arguments)})}

static get spaceSeparator() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "spaceSeparator", ...Array.from(arguments)})}

static get lineSeparator() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "lineSeparator", ...Array.from(arguments)})}

static get paragraphSeparator() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "paragraphSeparator", ...Array.from(arguments)})}

static get control() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "control", ...Array.from(arguments)})}

static get format() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "format", ...Array.from(arguments)})}

static get surrogate() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "surrogate", ...Array.from(arguments)})}

static get privateUse() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "privateUse", ...Array.from(arguments)})}

static get unassigned() {return Object.assign(new Unicode.GeneralCategory(), {rawValue: "unassigned", ...Array.from(arguments)})}
/*Swift.(file).Unicode.GeneralCategory.init(rawValue:__swift_stdlib_UCharCategory)*/
/*Swift.(file).Unicode.GeneralCategory.init(rawValue:__swift_stdlib_UCharCategory)*/
initRawValue__swift_stdlib_UCharCategory(rawValue, $info?) {
throw 'unsupported method Swift.(file).Unicode.GeneralCategory.init(rawValue:__swift_stdlib_UCharCategory) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.GeneralCategory.==(_:Unicode.GeneralCategory,_:Unicode.GeneralCategory)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).Unicode.GeneralCategory.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Unicode.GeneralCategory.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Unicode.GeneralCategory.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.GeneralCategory.hash(into:Hasher) in ' + this.constructor.name
}






init$vars() {let _this = this;

}
}
static CanonicalCombiningClass = class implements Comparable, Hashable, RawRepresentable{
static readonly $struct = true

/*Swift.(file).Unicode.CanonicalCombiningClass.notReordered*/
static readonly notReordered$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.notReordered in ' + this.constructor.name
}
static readonly get notReordered() { return this.notReordered$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.overlay*/
static readonly overlay$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.overlay in ' + this.constructor.name
}
static readonly get overlay() { return this.overlay$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.nukta*/
static readonly nukta$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.nukta in ' + this.constructor.name
}
static readonly get nukta() { return this.nukta$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.kanaVoicing*/
static readonly kanaVoicing$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.kanaVoicing in ' + this.constructor.name
}
static readonly get kanaVoicing() { return this.kanaVoicing$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.virama*/
static readonly virama$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.virama in ' + this.constructor.name
}
static readonly get virama() { return this.virama$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.attachedBelowLeft*/
static readonly attachedBelowLeft$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.attachedBelowLeft in ' + this.constructor.name
}
static readonly get attachedBelowLeft() { return this.attachedBelowLeft$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.attachedBelow*/
static readonly attachedBelow$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.attachedBelow in ' + this.constructor.name
}
static readonly get attachedBelow() { return this.attachedBelow$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.attachedAbove*/
static readonly attachedAbove$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.attachedAbove in ' + this.constructor.name
}
static readonly get attachedAbove() { return this.attachedAbove$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.attachedAboveRight*/
static readonly attachedAboveRight$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.attachedAboveRight in ' + this.constructor.name
}
static readonly get attachedAboveRight() { return this.attachedAboveRight$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.belowLeft*/
static readonly belowLeft$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.belowLeft in ' + this.constructor.name
}
static readonly get belowLeft() { return this.belowLeft$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.below*/
static readonly below$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.below in ' + this.constructor.name
}
static readonly get below() { return this.below$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.belowRight*/
static readonly belowRight$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.belowRight in ' + this.constructor.name
}
static readonly get belowRight() { return this.belowRight$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.left*/
static readonly left$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.left in ' + this.constructor.name
}
static readonly get left() { return this.left$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.right*/
static readonly right$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.right in ' + this.constructor.name
}
static readonly get right() { return this.right$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.aboveLeft*/
static readonly aboveLeft$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.aboveLeft in ' + this.constructor.name
}
static readonly get aboveLeft() { return this.aboveLeft$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.above*/
static readonly above$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.above in ' + this.constructor.name
}
static readonly get above() { return this.above$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.aboveRight*/
static readonly aboveRight$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.aboveRight in ' + this.constructor.name
}
static readonly get aboveRight() { return this.aboveRight$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.doubleBelow*/
static readonly doubleBelow$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.doubleBelow in ' + this.constructor.name
}
static readonly get doubleBelow() { return this.doubleBelow$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.doubleAbove*/
static readonly doubleAbove$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.doubleAbove in ' + this.constructor.name
}
static readonly get doubleAbove() { return this.doubleAbove$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.iotaSubscript*/
static readonly iotaSubscript$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.iotaSubscript in ' + this.constructor.name
}
static readonly get iotaSubscript() { return this.iotaSubscript$get() };




/*Swift.(file).Unicode.CanonicalCombiningClass.rawValue*/
readonly rawValue$get() {
throw 'unsupported variable Swift.(file).Unicode.CanonicalCombiningClass.rawValue in ' + this.constructor.name
}
readonly get rawValue() { return this.rawValue$get() };



/*Swift.(file).Unicode.CanonicalCombiningClass.init(rawValue:UInt8)*/
/*Swift.(file).RawRepresentable.init(rawValue:Self.RawValue)*/
initRawValue(rawValue, $info?) {
throw 'unsupported method Swift.(file).Unicode.CanonicalCombiningClass.init(rawValue:UInt8) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.CanonicalCombiningClass.==infix(_:Unicode.CanonicalCombiningClass,_:Unicode.CanonicalCombiningClass)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Unicode.CanonicalCombiningClass.<infix(_:Unicode.CanonicalCombiningClass,_:Unicode.CanonicalCombiningClass)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}

/*Swift.(file).Unicode.CanonicalCombiningClass.hashValue*/
hashValue$get() {
let _this = this;
return UInt8.prototype.hashValue$get.call(_this.rawValue)
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).Unicode.CanonicalCombiningClass.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}

init$vars() {let _this = this;

}
}
static NumericType = class{

static get decimal() {return Object.assign(new Unicode.NumericType(), {rawValue: "decimal", ...Array.from(arguments)})}

static get digit() {return Object.assign(new Unicode.NumericType(), {rawValue: "digit", ...Array.from(arguments)})}

static get numeric() {return Object.assign(new Unicode.NumericType(), {rawValue: "numeric", ...Array.from(arguments)})}
/*Swift.(file).Unicode.NumericType.init(rawValue:__swift_stdlib_UNumericType)*/
/*Swift.(file).Unicode.NumericType.init(rawValue:__swift_stdlib_UNumericType)*/
initRawValue__swift_stdlib_UNumericType(rawValue, $info?) {
throw 'unsupported method Swift.(file).Unicode.NumericType.init(rawValue:__swift_stdlib_UNumericType) in ' + this.constructor.name
}
static readonly initRawValue__swift_stdlib_UNumericType$failable = true
static /*Swift.(file).Unicode.NumericType.==(_:Unicode.NumericType,_:Unicode.NumericType)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).Unicode.NumericType.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Unicode.NumericType.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Unicode.NumericType.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.NumericType.hash(into:Hasher) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
static UTF8 = class implements _UnicodeEncoding, UnicodeCodec{

static _swift3Buffer() {return Object.assign(new Unicode.UTF8(), {rawValue: "_swift3Buffer", ...Array.from(arguments)})}
static /*Swift.(file).Unicode.UTF8.width(_:Unicode.Scalar)*/
/*Swift.(file).Unicode.UTF8.width(_:Unicode.Scalar)*/
width(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.width(_:Unicode.Scalar) in ' + this.constructor.name
}



/*Swift.(file).Unicode.UTF8.encodedReplacementCharacter*/
static encodedReplacementCharacter$get() {
throw 'unsupported variable Swift.(file).Unicode.UTF8.encodedReplacementCharacter in ' + this.constructor.name
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get() };




static /*Swift.(file).Unicode.UTF8.isASCII(_:Unicode.UTF8.CodeUnit)*/
/*Swift.(file).Unicode.UTF8.isASCII(_:Unicode.UTF8.CodeUnit)*/
isASCII(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.isASCII(_:Unicode.UTF8.CodeUnit) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF8.decode(_:Unicode.UTF8.EncodedScalar)*/
/*Swift.(file)._UnicodeEncoding.decode(_:Self.EncodedScalar)*/
decode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.decode(_:Unicode.UTF8.EncodedScalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF8.encode(_:Unicode.Scalar)*/
/*Swift.(file)._UnicodeEncoding.encode(_:Unicode.Scalar)*/
encode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.encode(_:Unicode.Scalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF8.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
/*Swift.(file)._UnicodeEncoding.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)*/
transcodeFrom<FromEncoding>(content, _, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type) in ' + this.constructor.name
}
static ForwardParser = class implements Unicode.Parser, _UTFParser{
static readonly $struct = true

/*Swift.(file).Unicode.UTF8.ForwardParser.init()*/
/*Swift.(file)._UnicodeParser.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.ForwardParser.init() in ' + this.constructor.name
}









init$vars() {let _this = this;

}
}
static ReverseParser = class implements Unicode.Parser, _UTFParser{
static readonly $struct = true

/*Swift.(file).Unicode.UTF8.ReverseParser.init()*/
/*Swift.(file)._UnicodeParser.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.ReverseParser.init() in ' + this.constructor.name
}









init$vars() {let _this = this;

}
}
/*Swift.(file).Unicode.UTF8.init()*/
/*Swift.(file).UnicodeCodec.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.init() in ' + this.constructor.name
}
/*Swift.(file).Unicode.UTF8.decode(_:I)*/
/*Swift.(file).UnicodeCodec.decode(_:I)*/
/*!!!DUPLICATE NAME*/
decode<I>(input$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.decode(_:I) in ' + this.constructor.name
}

static /*Swift.(file).Unicode.UTF8.encode(_:Unicode.Scalar,into:(Unicode.UTF8.CodeUnit) -> Void)*/
/*Swift.(file).UnicodeCodec.encode(_:Unicode.Scalar,into:(Self.CodeUnit) -> Void)*/
encodeInto(input, processCodeUnit, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.encode(_:Unicode.Scalar,into:(Unicode.UTF8.CodeUnit) -> Void) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF8.isContinuation(_:Unicode.UTF8.CodeUnit)*/
/*Swift.(file).Unicode.UTF8.isContinuation(_:Unicode.UTF8.CodeUnit)*/
isContinuation(_byte, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF8.isContinuation(_:Unicode.UTF8.CodeUnit) in ' + this.constructor.name
}


init$vars() {let _this = this;

}
}
static UTF32 = class implements Unicode.Encoding, UnicodeCodec{

static get _swift3Codec() {return Object.assign(new Unicode.UTF32(), {rawValue: "_swift3Codec", ...Array.from(arguments)})}
static /*Swift.(file).Unicode.UTF32.==(_:Unicode.UTF32,_:Unicode.UTF32)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).Unicode.UTF32.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Unicode.UTF32.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Unicode.UTF32.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.hash(into:Hasher) in ' + this.constructor.name
}






/*Swift.(file).Unicode.UTF32.encodedReplacementCharacter*/
static encodedReplacementCharacter$get() {
throw 'unsupported variable Swift.(file).Unicode.UTF32.encodedReplacementCharacter in ' + this.constructor.name
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get() };




static /*Swift.(file).Unicode.UTF32.isASCII(_:Unicode.UTF32.CodeUnit)*/
/*Swift.(file).Unicode.UTF32.isASCII(_:Unicode.UTF32.CodeUnit)*/
isASCII(x, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.isASCII(_:Unicode.UTF32.CodeUnit) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF32.decode(_:Unicode.UTF32.EncodedScalar)*/
/*Swift.(file)._UnicodeEncoding.decode(_:Self.EncodedScalar)*/
decode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.decode(_:Unicode.UTF32.EncodedScalar) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF32.encode(_:Unicode.Scalar)*/
/*Swift.(file)._UnicodeEncoding.encode(_:Unicode.Scalar)*/
encode(source, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.encode(_:Unicode.Scalar) in ' + this.constructor.name
}
static Parser = class implements Unicode.Parser{
static readonly $struct = true
/*Swift.(file).Unicode.UTF32.Parser.init()*/
/*Swift.(file)._UnicodeParser.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.Parser.init() in ' + this.constructor.name
}

/*Swift.(file).Unicode.UTF32.Parser.parseScalar(from:I)*/
/*Swift.(file)._UnicodeParser.parseScalar(from:I)*/
parseScalarFrom<I>(input$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.Parser.parseScalar(from:I) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}


/*Swift.(file).Unicode.UTF32.init()*/
/*Swift.(file).UnicodeCodec.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.init() in ' + this.constructor.name
}
/*Swift.(file).Unicode.UTF32.decode(_:I)*/
/*Swift.(file).UnicodeCodec.decode(_:I)*/
/*!!!DUPLICATE NAME*/
decode<I>(input$inout, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.decode(_:I) in ' + this.constructor.name
}
static /*Swift.(file).Unicode.UTF32.encode(_:Unicode.Scalar,into:(Unicode.UTF32.CodeUnit) -> Void)*/
/*Swift.(file).UnicodeCodec.encode(_:Unicode.Scalar,into:(Self.CodeUnit) -> Void)*/
encodeInto(input, processCodeUnit, $info?) {
throw 'unsupported method Swift.(file).Unicode.UTF32.encode(_:Unicode.Scalar,into:(Unicode.UTF32.CodeUnit) -> Void) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(Unicode.Scalar.UTF16View, RandomAccessCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(Unicode.Scalar.UTF8View, RandomAccessCollection$implementation, false)
if(typeof _ExpressibleByBuiltinUnicodeScalarLiteral$implementation != 'undefined') _mixin(Unicode.Scalar, _ExpressibleByBuiltinUnicodeScalarLiteral$implementation, false)
if(typeof ExpressibleByUnicodeScalarLiteral$implementation != 'undefined') _mixin(Unicode.Scalar, ExpressibleByUnicodeScalarLiteral$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(Unicode.Scalar, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(Unicode.Scalar, CustomDebugStringConvertible$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(Unicode.Scalar, LosslessStringConvertible$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(Unicode.Scalar, Hashable$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(Unicode.Scalar, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(Unicode.Scalar, Comparable$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(Unicode.Scalar, TextOutputStreamable$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(Unicode.Scalar, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(Unicode.Scalar, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Parser$implementation != 'undefined') _mixin(Unicode.ASCII.Parser, Unicode.Parser$implementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Encoding$implementation != 'undefined') _mixin(Unicode.ASCII, Unicode.Encoding$implementation, false)
_mixin(Unicode.ASCII, _DefaultEnumImplementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Parser$implementation != 'undefined') _mixin(Unicode.UTF16.ForwardParser, Unicode.Parser$implementation, false)
if(typeof _UTFParser$implementation != 'undefined') _mixin(Unicode.UTF16.ForwardParser, _UTFParser$implementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Parser$implementation != 'undefined') _mixin(Unicode.UTF16.ReverseParser, Unicode.Parser$implementation, false)
if(typeof _UTFParser$implementation != 'undefined') _mixin(Unicode.UTF16.ReverseParser, _UTFParser$implementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Encoding$implementation != 'undefined') _mixin(Unicode.UTF16, Unicode.Encoding$implementation, false)
if(typeof UnicodeCodec$implementation != 'undefined') _mixin(Unicode.UTF16, UnicodeCodec$implementation, false)
_mixin(Unicode.UTF16, _DefaultEnumImplementation, false)
_mixin(Unicode.ParseResult, _DefaultEnumImplementation, false)
_mixin(Unicode.GeneralCategory, _DefaultEnumImplementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(Unicode.CanonicalCombiningClass, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(Unicode.CanonicalCombiningClass, Hashable$implementation, false)
if(typeof RawRepresentable$implementation != 'undefined') _mixin(Unicode.CanonicalCombiningClass, RawRepresentable$implementation, false)
_mixin(Unicode.NumericType, _DefaultEnumImplementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Parser$implementation != 'undefined') _mixin(Unicode.UTF8.ForwardParser, Unicode.Parser$implementation, false)
if(typeof _UTFParser$implementation != 'undefined') _mixin(Unicode.UTF8.ForwardParser, _UTFParser$implementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Parser$implementation != 'undefined') _mixin(Unicode.UTF8.ReverseParser, Unicode.Parser$implementation, false)
if(typeof _UTFParser$implementation != 'undefined') _mixin(Unicode.UTF8.ReverseParser, _UTFParser$implementation, false)
if(typeof _UnicodeEncoding$implementation != 'undefined') _mixin(Unicode.UTF8, _UnicodeEncoding$implementation, false)
if(typeof UnicodeCodec$implementation != 'undefined') _mixin(Unicode.UTF8, UnicodeCodec$implementation, false)
_mixin(Unicode.UTF8, _DefaultEnumImplementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Parser$implementation != 'undefined') _mixin(Unicode.UTF32.Parser, Unicode.Parser$implementation, false)
if(typeof Unicode != 'undefined' && typeof Unicode.Encoding$implementation != 'undefined') _mixin(Unicode.UTF32, Unicode.Encoding$implementation, false)
if(typeof UnicodeCodec$implementation != 'undefined') _mixin(Unicode.UTF32, UnicodeCodec$implementation, false)
_mixin(Unicode.UTF32, _DefaultEnumImplementation, false)
_mixin(Unicode, _DefaultEnumImplementation, false)


class _ValidUTF8Buffer implements Sequence, Collection, BidirectionalCollection, RandomAccessCollection, RangeReplaceableCollection{
static readonly $struct = true






/*Swift.(file)._ValidUTF8Buffer.init(_biasedBits:UInt32)*/
/*Swift.(file)._ValidUTF8Buffer.init(_biasedBits:UInt32)*/
init_biasedBitsUInt32(_biasedBits, $info?) {
throw 'unsupported method Swift.(file)._ValidUTF8Buffer.init(_biasedBits:UInt32) in ' + this.constructor.name
}
/*Swift.(file)._ValidUTF8Buffer.init(_containing:_ValidUTF8Buffer.Element)*/
/*Swift.(file)._ValidUTF8Buffer.init(_containing:_ValidUTF8Buffer.Element)*/
init_containing_ValidUTF8BufferElement(e, $info?) {
throw 'unsupported method Swift.(file)._ValidUTF8Buffer.init(_containing:_ValidUTF8Buffer.Element) in ' + this.constructor.name
}

static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true
/*Swift.(file)._ValidUTF8Buffer.Iterator.init(_:_ValidUTF8Buffer)*/
/*Swift.(file)._ValidUTF8Buffer.Iterator.init(_:_ValidUTF8Buffer)*/
init_ValidUTF8Buffer(x, $info?) {
let _this = this;
_this._biasedBits = x._biasedBits;
return
}
/*Swift.(file)._ValidUTF8Buffer.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if((UInt32.$equal(_this._biasedBits, 0))) {
return _injectIntoOptional(null);
};
let $defer = () => {
UInt32.$rightBitShiftAndAssign({get: () => _this._biasedBits, set: $val => _this._biasedBits = $val}, 8);
}
const $result = (() => {
try {;
return _injectIntoOptional(_ValidUTF8Buffer.Iterator.Element.$subtractWithOverflow(_create(_ValidUTF8Buffer.Iterator.Element, 'initTruncatingIfNeeded', _this._biasedBits, {}), 1));}catch($error){$defer( {});throw $error}})();$defer( {});return $result
}







init$vars() {let _this = this;

}
}
/*Swift.(file)._ValidUTF8Buffer.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(_ValidUTF8Buffer.Iterator, 'init_ValidUTF8Buffer', _this, {})
}
static Index = class implements Comparable{
static readonly $struct = true





/*Swift.(file)._ValidUTF8Buffer.Index.init(_biasedBits:UInt32)*/
/*Swift.(file)._ValidUTF8Buffer.Index.init(_biasedBits:UInt32)*/
init_biasedBitsUInt32(_biasedBits, $info?) {
let _this = this;
_this._biasedBits = _biasedBits;
return
}
static /*Swift.(file)._ValidUTF8Buffer.Index.==infix(_:_ValidUTF8Buffer.Index,_:_ValidUTF8Buffer.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file)._ValidUTF8Buffer.Index.<infix(_:_ValidUTF8Buffer.Index,_:_ValidUTF8Buffer.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
init$vars() {let _this = this;

}
}

/*Swift.(file)._ValidUTF8Buffer.startIndex*/
startIndex$get() {
let _this = this;
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', _this._biasedBits, {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._ValidUTF8Buffer.endIndex*/
endIndex$get() {
let _this = this;
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', 0, {})
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file)._ValidUTF8Buffer.count*/
count$get() {
let _this = this;
return Int.$subtractWithOverflow(Int.infix_38_62_62(UInt32.bitWidth, 3), Int.infix_38_62_62(UInt32.prototype.leadingZeroBitCount$get.call(_this._biasedBits), 3))
}
get count() { return this.count$get() };




/*Swift.(file)._ValidUTF8Buffer.isEmpty*/
isEmpty$get() {
let _this = this;
return UInt32.$equal(_this._biasedBits, 0)
}
get isEmpty() { return this.isEmpty$get() };



/*Swift.(file)._ValidUTF8Buffer.index(after:_ValidUTF8Buffer.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
preconditionFileLine(() => UInt32.$notEqual(i._biasedBits, 0), null, null, null);
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', UInt32.$bitwiseRightShift(i._biasedBits, 8), {})
}
/*Swift.(file)._ValidUTF8Buffer.subscript(_:_ValidUTF8Buffer.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
let _this = this;
return _ValidUTF8Buffer.Element.$subtractWithOverflow(_create(_ValidUTF8Buffer.Element, 'initTruncatingIfNeeded', i._biasedBits, {}), 1)
}


/*Swift.(file)._ValidUTF8Buffer.index(before:_ValidUTF8Buffer.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
const offset = _create(_ValidUTF8Buffer, 'init_biasedBitsUInt32', i._biasedBits, {}).count;
preconditionFileLine(() => Int.$notEqual(offset, 0), null, null, null);
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', UInt32.infix_38_62_62(_this._biasedBits, Int.$subtract(Int.infix_38_60_60(offset, 3), 8)), {})
}

/*Swift.(file)._ValidUTF8Buffer.distance(from:_ValidUTF8Buffer.Index,to:_ValidUTF8Buffer.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(i, j, $info?) {
let _this = this;
preconditionFileLine(() => _this._isValid(i), null, null, null);
preconditionFileLine(() => _this._isValid(j), null, null, null);
return Int.infix_38_62_62(Int.$subtract(UInt32.prototype.leadingZeroBitCount$get.call(i._biasedBits), UInt32.prototype.leadingZeroBitCount$get.call(j._biasedBits)), 3)
}
/*Swift.(file)._ValidUTF8Buffer.index(_:_ValidUTF8Buffer.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
const startOffset = _this.distanceFromTo(_this.startIndex, i);
const newOffset = Int.$add(startOffset, n);
preconditionFileLine(() => Int.$greaterThanOrEqual(newOffset, 0), null, null, null);
preconditionFileLine(() => Int.$lessThanOrEqual(newOffset, _this.count), null, null, null);
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', UInt32.prototype._fullShiftRight.call(_this._biasedBits, Int.infix_38_60_60(newOffset, 3)), {})
}
/*Swift.(file)._ValidUTF8Buffer.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
let _this = this;
_this._biasedBits = 0;
return
}

/*Swift.(file)._ValidUTF8Buffer.capacity*/
capacity$get() {
let _this = this;
return Int.$divide(UInt32.bitWidth, _ValidUTF8Buffer.Element.bitWidth);
}
static get capacity() { return this.capacity$get()
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._ValidUTF8Buffer.capacity*/
static capacity$get() {
let _this = this;
return Int.$divide(UInt32.bitWidth, _ValidUTF8Buffer.Element.bitWidth);
}
static get capacity() { return this.capacity$get()
}
static get capacity() { return this.capacity$get() };



/*Swift.(file)._ValidUTF8Buffer.append(_:_ValidUTF8Buffer.Element)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(e, $info?) {
let _this = this;
_this.insertAt(newElement, _this.endIndex, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file)._ValidUTF8Buffer.removeFirst()*/
/*Swift.(file).RangeReplaceableCollection.removeFirst()*/
removeFirst($info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), null, null, null);
const result = _ValidUTF8Buffer.Element.$subtractWithOverflow(_create(_ValidUTF8Buffer.Element, 'initTruncatingIfNeeded', _this._biasedBits, {}), 1);
_this._biasedBits = UInt32.prototype._fullShiftRight.call(_this._biasedBits, 8);
return result
}

/*Swift.(file)._ValidUTF8Buffer.replaceSubrange(_:Range<_ValidUTF8Buffer.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(target, replacement, $info?) {
let _this = this;
preconditionFileLine(() => _this._isValid(target.lowerBound), null, null, null);
preconditionFileLine(() => _this._isValid(target.upperBound), null, null, null);
let r = _create(_ValidUTF8Buffer, 'init', {});
{
let $x$generator = _cloneStruct(_this.subscript$get(_ValidUTF8Buffer.Index.prefix_46_46_60(target.lowerBound)).makeIterator( {}));
while(true) {
const $ifLet0, x_1;
if(!((($ifLet0 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true))) break
r.append(x_1, {$setThis: $val => r = $val});
}
};
{
let $x$generator = replacement.makeIterator( {});
while(true) {
const $ifLet2, x_3;
if(!((($ifLet2 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet2.rawValue == 'some' && ((x_3 = $ifLet2[0])||true))) break
r.append(x_3, {$setThis: $val => r = $val});
}
};
{
let $x$generator = _cloneStruct(_this.subscript$get(_ValidUTF8Buffer.Index.$openEndedRange(target.upperBound)).makeIterator( {}));
while(true) {
const $ifLet4, x_5;
if(!((($ifLet4 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet4.rawValue == 'some' && ((x_5 = $ifLet4[0])||true))) break
r.append(x_5, {$setThis: $val => r = $val});
}
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(r)))
}
/*Swift.(file)._ValidUTF8Buffer.append(contentsOf:_ValidUTF8Buffer)*/
/*Swift.(file)._ValidUTF8Buffer.append(contentsOf:_ValidUTF8Buffer)*/
appendContentsOf(other, $info?) {
let _this = this;
preconditionFileLine(() => Int.$lessThanOrEqual(Int.$add(_this.count, other.count), _this.capacity), null, null, null);
UInt32.$bitwiseORAndAssign({get: () => _this._biasedBits, set: $val => _this._biasedBits = $val}, UInt32.infix_38_60_60(_create(UInt32, 'initTruncatingIfNeeded', other._biasedBits, {}), Int.infix_38_60_60(_this.count, 3)))
}

/*Swift.(file)._ValidUTF8Buffer.encodedReplacementCharacter*/
static encodedReplacementCharacter$get() {
let _this = this;
return _create(_ValidUTF8Buffer, 'init_biasedBitsUInt32', UInt32.$addWithOverflow(0xBDBFEF, 0x010101), {});
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get() };






init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(_ValidUTF8Buffer.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_ValidUTF8Buffer.Iterator, Sequence$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(_ValidUTF8Buffer.Index, Comparable$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(_ValidUTF8Buffer, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(_ValidUTF8Buffer, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(_ValidUTF8Buffer, BidirectionalCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_ValidUTF8Buffer, RandomAccessCollection$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(_ValidUTF8Buffer, RangeReplaceableCollection$implementation, false)
















class CollectionOfOne<Element> implements RandomAccessCollection, MutableCollection, CustomDebugStringConvertible, CustomReflectable{
static readonly $struct = true





/*Swift.(file).CollectionOfOne.init(_:Element)*/
/*Swift.(file).CollectionOfOne.init(_:Element)*/
init(_element, $info?) {
let _this = this;
_this._element = _element;
return
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true





/*Swift.(file).CollectionOfOne.Iterator.init(_elements:CollectionOfOne<Element>.Iterator.Element?)*/
/*Swift.(file).CollectionOfOne.Iterator.init(_elements:CollectionOfOne<Element>.Iterator.Element?)*/
init_elementsOptional(_elements, $info?) {
let _this = this;
_this._elements = _elements;
return
}
/*Swift.(file).CollectionOfOne.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
const result = _this._elements;
_this._elements = _injectIntoOptional(null);
return result
}

init$vars() {let _this = this;

}
}




/*Swift.(file).CollectionOfOne.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).CollectionOfOne.endIndex*/
endIndex$get() {
let _this = this;
return 1
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).CollectionOfOne.index(after:CollectionOfOne<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
preconditionFileLine(() => Int.$equal(i, _this.startIndex), null, null, null);
return 1
}
/*Swift.(file).CollectionOfOne.index(before:CollectionOfOne<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
preconditionFileLine(() => Int.$equal(i, _this.endIndex), null, null, null);
return 0
}
/*Swift.(file).CollectionOfOne.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(CollectionOfOne.Iterator, 'init_elementsOptional', _injectIntoOptional(_this._element), {})
}
/*Swift.(file).CollectionOfOne.subscript(_:Int)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$_read(position, $info?) {
let _this = this;
preconditionFileLine(() => Int.$equal(position, 0), () => "Index out of range", null, null);
/*yield*/;
}subscript$_modify(position, $info?){
let _this = this;
preconditionFileLine(() => Int.$equal(position, 0), () => "Index out of range", null, null);
/*yield*/
}/*Swift.(file).CollectionOfOne.subscript(_:Int)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$_modify(position, $info?) {
let _this = this;
preconditionFileLine(() => Int.$equal(position, 0), () => "Index out of range", null, null);
/*yield*/;
}subscript$_modify(position, $info?){
let _this = this;
preconditionFileLine(() => Int.$equal(position, 0), () => "Index out of range", null, null);
/*yield*/
}




/*Swift.(file).CollectionOfOne.subscript(_:Range<Int>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}/*Swift.(file).CollectionOfOne.subscript(_:Range<Int>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(newValue, bounds, $info?) {
let _this = this;
const n = newValue.count;
preconditionFileLine(() => Int.$equal(bounds.count, n), () => "CollectionOfOne can't be resized", null, null);
if((Int.$equal(n, 1))) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(newValue.base)));
}
}




/*Swift.(file).CollectionOfOne.count*/
count$get() {
let _this = this;
return 1
}
get count() { return this.count$get() };





/*Swift.(file).CollectionOfOne.debugDescription*/
debugDescription$get() {
let _this = this;
return (("CollectionOfOne(") + (_create(String, 'initReflecting', _this._element, {})) + (")"))
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).CollectionOfOne.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["element", _this._element]]), , , {})
}
get customMirror() { return this.customMirror$get() };



init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(CollectionOfOne.Iterator, IteratorProtocol$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(CollectionOfOne, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(CollectionOfOne, MutableCollection$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(CollectionOfOne, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(CollectionOfOne, CustomReflectable$implementation, false)










class _CollectionChanges<SourceIndex, TargetIndex> implements RandomAccessCollection, CustomStringConvertible{
static readonly $struct = true


/*Swift.(file)._CollectionChanges.pathStorage*/
pathStorage$get() {
throw 'unsupported variable Swift.(file)._CollectionChanges.pathStorage in ' + this.constructor.name
}
get pathStorage() { return this.pathStorage$get() };






/*Swift.(file)._CollectionChanges.pathStartIndex*/
pathStartIndex$get() {
throw 'unsupported variable Swift.(file)._CollectionChanges.pathStartIndex in ' + this.constructor.name
}
get pathStartIndex() { return this.pathStartIndex$get() };





/*Swift.(file)._CollectionChanges.init(pathStorage:[_CollectionChanges<SourceIndex, TargetIndex>.Endpoint],pathStartIndex:Int)*/
/*Swift.(file)._CollectionChanges.init(pathStorage:[_CollectionChanges<SourceIndex, TargetIndex>.Endpoint],pathStartIndex:Int)*/
initPathStorageArrayPathStartIndexInt(pathStorage, pathStartIndex, $info?) {
throw 'unsupported method Swift.(file)._CollectionChanges.init(pathStorage:[_CollectionChanges<SourceIndex, TargetIndex>.Endpoint],pathStartIndex:Int) in ' + this.constructor.name
}
/*Swift.(file)._CollectionChanges.init()*/
/*Swift.(file)._CollectionChanges.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._CollectionChanges.init() in ' + this.constructor.name
}
static Element = class{

static removed() {return Object.assign(new _CollectionChanges.Element(), {rawValue: "removed", ...Array.from(arguments)})}

static inserted() {return Object.assign(new _CollectionChanges.Element(), {rawValue: "inserted", ...Array.from(arguments)})}

static matched() {return Object.assign(new _CollectionChanges.Element(), {rawValue: "matched", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}


/*Swift.(file)._CollectionChanges.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._CollectionChanges.endIndex*/
endIndex$get() {
let _this = this;
return max(0, Int.$subtract(Int.$subtract(_this.pathStorage.endIndex, _this.pathStartIndex), 1))
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._CollectionChanges.index(after:_CollectionChanges<SourceIndex, TargetIndex>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return Int.$add(i, 1)
}
/*Swift.(file)._CollectionChanges.subscript(_:_CollectionChanges<SourceIndex, TargetIndex>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
const current = _this.pathStorage.subscript$get(Int.$add(position, _this.pathStartIndex));
const next = _this.pathStorage.subscript$get(Int.$add(Int.$add(position, _this.pathStartIndex), 1));
if((Bool.$logicalAND((_.arg0 = current["0"]).constructor.$notEqual(_.arg0, next["0"]), () => (_.arg1 = current["1"]).constructor.$notEqual(_.arg1, next["1"])))) {
return _CollectionChanges.Element.matched((_.arg2 = current["0"]).constructor.$halfOpenRange(_.arg2, next["0"]), (_.arg3 = current["1"]).constructor.$halfOpenRange(_.arg3, next["1"]));
}
else {
if(((_.arg4 = current["0"]).constructor.$notEqual(_.arg4, next["0"]))) {
return _CollectionChanges.Element.removed((_.arg5 = current["0"]).constructor.$halfOpenRange(_.arg5, next["0"]));
}
else {
return _CollectionChanges.Element.inserted((_.arg6 = current["1"]).constructor.$halfOpenRange(_.arg6, next["1"]));
}
}
}






/*Swift.(file)._CollectionChanges.description*/
description$get() {
let _this = this;
return _this._makeCollectionDescriptionWithTypeName( null)
}
get description() { return this.description$get() };



/*Swift.(file)._CollectionChanges.init(from:Source,to:Target,by:(Source.Element, Target.Element) -> Bool)*/
/*Swift.(file)._CollectionChanges.init(from:Source,to:Target,by:(Source.Element, Target.Element) -> Bool)*/
initFromToByfunction_type<Source, Target>(source, target, areEquivalent, $info?) {
let _this = this;
_this.init( {});
_this.formChangesFromToBy(source, target, areEquivalent, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return
}
/*Swift.(file)._CollectionChanges.formChanges(from:Source,to:Target,by:(Source.Element, Target.Element) -> Bool)*/
/*Swift.(file)._CollectionChanges.formChanges(from:Source,to:Target,by:(Source.Element, Target.Element) -> Bool)*/
formChangesFromToBy<Source, Target>(source, target, areEquivalent, $info?) {
let _this = this;
const pathStart = {0: source.startIndex, 1: target.startIndex};
const pathEnd = {0: source.endIndex, 1: target.endIndex};
const matches = source._commonPrefixWithBy(target, areEquivalent);
const $tuple = {0: matches["0"].endIndex, 1: matches["1"].endIndex}, x = $tuple && $tuple[0], y = $tuple && $tuple[1];
if(($equal(pathStart, pathEnd))) {
_this.pathStorage.removeAllKeepingCapacity(true, {$setThis: $val => _this.pathStorage = $val});
_this.pathStartIndex = 0;
}
else {
if((Bool.$logicalOR((_.arg0 = x).constructor.$equal(_.arg0, pathEnd["0"]), () => (_.arg1 = y).constructor.$equal(_.arg1, pathEnd["1"])))) {
_this.pathStorage.removeAllKeepingCapacity(true, {$setThis: $val => _this.pathStorage = $val});
_this.pathStorage.append(pathStart, {$setThis: $val => _this.pathStorage = $val});
if((Bool.$logicalAND($notEqual(pathStart, {0: x, 1: y}), () => $notEqual(pathEnd, {0: x, 1: y})))) {
_this.pathStorage.append({0: x, 1: y}, {$setThis: $val => _this.pathStorage = $val});
};
_this.pathStorage.append(pathEnd, {$setThis: $val => _this.pathStorage = $val});
_this.pathStartIndex = 0;
}
else {
_this.formChangesCoreFromToXYBy(source, target, x, y, areEquivalent, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file)._CollectionChanges.formChangesCore(from:Source,to:Target,x:Source.Index,y:Target.Index,by:(Source.Element, Target.Element) -> Bool)*/
/*Swift.(file)._CollectionChanges.formChangesCore(from:Source,to:Target,x:Source.Index,y:Target.Index,by:(Source.Element, Target.Element) -> Bool)*/
formChangesCoreFromToXYBy<Source, Target>(a, b, x, y, areEquivalent, $info?) {
let _this = this;
let $tuple = {0: x, 1: y}, x = $tuple && $tuple[0], y = $tuple && $tuple[1];
const $tuple = {0: a.endIndex, 1: b.endIndex}, n = $tuple && $tuple[0], m = $tuple && $tuple[1];
let v = _create(_SearchState, 'initConsumingArray', {get: () => _this.pathStorage, set: $val => _this.pathStorage = $val}, {});
v.appendFrontierRepeating({0: x, 1: y}, {$setThis: $val => v = $val});
let d = 1;
let delta = 0;
while(true){
if(!((true))) break
v.appendFrontierRepeating({0: n, 1: m}, {$setThis: $val => v = $val});
{
let $k$generator = _cloneStruct(strideFromThroughBy(Int.$negate(d), d, 2).makeIterator( {}));
while(true) {
const $ifLet0, k_1;
if(!((($ifLet0 = $k$generator.next( {$setThis: $val => $k$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((k_1 = $ifLet0[0])||true))) break
if((Bool.$logicalOR(Int.$equal(k_1, Int.$negate(d)), () => Bool.$logicalAND(Int.$notEqual(k_1, d), () => (_.arg0 = v.subscript$get(Int.$subtract(d, 1), Int.$subtract(k_1, 1))["0"]).constructor.$lessThan(_.arg0, v.subscript$get(Int.$subtract(d, 1), Int.$add(k_1, 1))["0"]))))) {
let $tuple = v.subscript$get(Int.$subtract(d, 1), Int.$add(k_1, 1))
x = $tuple[0]
y = $tuple[1];
if(((_.arg1 = y).constructor.$notEqual(_.arg1, m))) {
b.formIndexAfter({get: () => y, set: $val => y = $val});
};
}
else {
let $tuple = v.subscript$get(Int.$subtract(d, 1), Int.$subtract(k_1, 1))
x = $tuple[0]
y = $tuple[1];
if(((_.arg2 = x).constructor.$notEqual(_.arg2, n))) {
a.formIndexAfter({get: () => x, set: $val => x = $val});
};
};
const matches = a.subscriptRange$get((_.arg3 = x).constructor.$halfOpenRange(_.arg3, n))._commonPrefixWithBy(b.subscriptRange$get((_.arg4 = y).constructor.$halfOpenRange(_.arg4, m)), areEquivalent);
let $tuple = {0: matches["0"].endIndex, 1: matches["1"].endIndex}
x = $tuple[0]
y = $tuple[1];
v.subscript$set({0: x, 1: y}, d, k_1, {$setThis: $val => v = $val});
if((Bool.$logicalAND((_.arg5 = x).constructor.$equal(_.arg5, n), () => (_.arg6 = y).constructor.$equal(_.arg6, m)))) {
delta = k_1;
break;
};
}
};
Int.$addAndAssign({get: () => d, set: $val => d = $val}, 1);
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(v.removeCollectionChangesABDDelta(a, b, d, delta, {$setThis: $val => v = $val}))))
}
init$vars() {let _this = this;

}
}
_mixin(_CollectionChanges.Element, _DefaultEnumImplementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_CollectionChanges, RandomAccessCollection$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(_CollectionChanges, CustomStringConvertible$implementation, false)










class _CountingIndexCollection<Base> implements BidirectionalCollection{
static readonly $struct = true

/*Swift.(file)._CountingIndexCollection.base*/
readonly base$get() {
throw 'unsupported variable Swift.(file)._CountingIndexCollection.base in ' + this.constructor.name
}
readonly get base() { return this.base$get() };



/*Swift.(file)._CountingIndexCollection.init(_:Base)*/
/*Swift.(file)._CountingIndexCollection.init(_:Base)*/
init(base, $info?) {
throw 'unsupported method Swift.(file)._CountingIndexCollection.init(_:Base) in ' + this.constructor.name
}



/*Swift.(file)._CountingIndexCollection.startIndex*/
startIndex$get() {
let _this = this;
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', _this.base.startIndex, (_this.base.isEmpty ? _injectIntoOptional(null) : _injectIntoOptional(0)), {})
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._CountingIndexCollection.endIndex*/
endIndex$get() {
let _this = this;
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', _this.base.endIndex, _injectIntoOptional(null), {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._CountingIndexCollection.index(after:_CountingIndexCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
const next = _this.base.indexAfter(i.base);
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', next, ((_.arg0 = next).constructor.$equal(_.arg0, _this.base.endIndex) ? _injectIntoOptional(null) : _injectIntoOptional(Int.$add(i.offset[0], 1))), {})
}
/*Swift.(file)._CountingIndexCollection.index(before:_CountingIndexCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
const prev = _this.base.indexBefore(i.base);
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', prev, ((_.arg0 = prev).constructor.$equal(_.arg0, _this.base.endIndex) ? _injectIntoOptional(null) : _injectIntoOptional(Int.$add(i.offset[0], 1))), {})
}
/*Swift.(file)._CountingIndexCollection.subscript(_:_CountingIndexCollection<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
return _this.base.subscript$get(position.base)
}





init$vars() {let _this = this;

}
}
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(_CountingIndexCollection, BidirectionalCollection$implementation, false)




class _LowerTriangularMatrix<Element> implements CustomStringConvertible{
static readonly $struct = true

/*Swift.(file)._LowerTriangularMatrix.storage*/
storage$get() {
throw 'unsupported variable Swift.(file)._LowerTriangularMatrix.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };






/*Swift.(file)._LowerTriangularMatrix.dimension*/
dimension$get() {
throw 'unsupported variable Swift.(file)._LowerTriangularMatrix.dimension in ' + this.constructor.name
}
get dimension() { return this.dimension$get() };





/*Swift.(file)._LowerTriangularMatrix.subscript(_:Int,_:Int)*/
/*Swift.(file)._LowerTriangularMatrix.subscript(_:Int,_:Int)*/
subscript$get(row, column, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.subscript(_:Int,_:Int) in ' + this.constructor.name
}/*Swift.(file)._LowerTriangularMatrix.subscript(_:Int,_:Int)*/
/*Swift.(file)._LowerTriangularMatrix.subscript(_:Int,_:Int)*/
subscript$set(newValue, row, column, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.subscript(_:Int,_:Int) in ' + this.constructor.name
}



/*Swift.(file)._LowerTriangularMatrix.appendRow(repeating:Element)*/
/*Swift.(file)._LowerTriangularMatrix.appendRow(repeating:Element)*/
appendRowRepeating(repeatedValue, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.appendRow(repeating:Element) in ' + this.constructor.name
}
/*Swift.(file)._LowerTriangularMatrix.init(storage:[Element],dimension:Int)*/
/*Swift.(file)._LowerTriangularMatrix.init(storage:[Element],dimension:Int)*/
initStorageArrayDimensionInt(storage, dimension, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.init(storage:[Element],dimension:Int) in ' + this.constructor.name
}
/*Swift.(file)._LowerTriangularMatrix.init()*/
/*Swift.(file)._LowerTriangularMatrix.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.init() in ' + this.constructor.name
}
static RowMajorOrder = class implements RandomAccessCollection{
static readonly $struct = true

/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.base*/
base$get() {
throw 'unsupported variable Swift.(file)._LowerTriangularMatrix.RowMajorOrder.base in ' + this.constructor.name
}
get base() { return this.base$get() };





/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.init(base:_LowerTriangularMatrix<Element>)*/
/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.init(base:_LowerTriangularMatrix<Element>)*/
initBase_LowerTriangularMatrix(base, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.RowMajorOrder.init(base:_LowerTriangularMatrix<Element>) in ' + this.constructor.name
}

/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file)._LowerTriangularMatrix.RowMajorOrder.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file)._LowerTriangularMatrix.RowMajorOrder.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.RowMajorOrder.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.RowMajorOrder.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file)._LowerTriangularMatrix.RowMajorOrder.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file)._LowerTriangularMatrix.RowMajorOrder.subscript(_:Int) in ' + this.constructor.name
}







init$vars() {let _this = this;

}
}

/*Swift.(file)._LowerTriangularMatrix.rowMajorOrder*/
rowMajorOrder$get() {
let _this = this;
return _create(_LowerTriangularMatrix.RowMajorOrder, 'initBase_LowerTriangularMatrix', _this, {})
}
get rowMajorOrder() { return this.rowMajorOrder$get() };



/*Swift.(file)._LowerTriangularMatrix.subscript(row:Int)*/
/*Swift.(file)._LowerTriangularMatrix.subscript(row:Int)*/
subscriptRow$get(r, $info?) {
let _this = this;
return _this.rowMajorOrder.subscriptRange$get(Int.$halfOpenRange(_triangularNumber(r), _triangularNumber(Int.$add(r, 1))))
}


/*Swift.(file)._LowerTriangularMatrix.description*/
description$get() {
let _this = this;
let rows = _create(Array, 'initArrayLiteralArray', [], {});
{
let $row$generator = _cloneStruct(Int.$halfOpenRange(0, _this.dimension).makeIterator( {}));
while(true) {
const $ifLet0, row_1;
if(!((($ifLet0 = $row$generator.next( {$setThis: $val => $row$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((row_1 = $ifLet0[0])||true))) break
rows.append(_create(Array, 'initBuffer', _this.subscriptRow$get(row_1), {}), {$setThis: $val => rows = $val});
}
};
return _create(String, 'initDescribing', rows, {})
}
get description() { return this.description$get() };



init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_LowerTriangularMatrix.RowMajorOrder, RandomAccessCollection$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(_LowerTriangularMatrix, CustomStringConvertible$implementation, false)






class _FixedArray2<T> implements RandomAccessCollection, MutableCollection{
static readonly $struct = true

/*Swift.(file)._FixedArray2.storage*/
storage$get() {
throw 'unsupported variable Swift.(file)._FixedArray2.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };










/*Swift.(file)._FixedArray2.init(storage:(T, T),_count:Int8)*/
/*Swift.(file)._FixedArray2.init(storage:(T, T),_count:Int8)*/
initStoragetuple_type_countInt8(storage, _count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.init(storage:(T, T),_count:Int8) in ' + this.constructor.name
}

/*Swift.(file)._FixedArray2.capacity*/
static capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray2.capacity in ' + this.constructor.name
}
static get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray2.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray2.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray2.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };







/*Swift.(file)._FixedArray2.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray2.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._FixedArray2.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray2.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._FixedArray2.subscript(_:_FixedArray2<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.subscript(_:_FixedArray2<T>.Index) in ' + this.constructor.name
}/*Swift.(file)._FixedArray2.subscript(_:_FixedArray2<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.subscript(_:_FixedArray2<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray2.index(after:_FixedArray2<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.index(after:_FixedArray2<T>.Index) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray2.index(before:_FixedArray2<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.index(before:_FixedArray2<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray2.append(_:T)*/
/*Swift.(file)._FixedArray2.append(_:T)*/
append(newElement, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.append(_:T) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray2.init(count:Int)*/
/*Swift.(file)._FixedArray2.init(count:Int)*/
initCountInt(count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.init(count:Int) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray2.init()*/
/*Swift.(file)._FixedArray2.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._FixedArray2.init() in ' + this.constructor.name
}
/*Swift.(file)._FixedArray2.init(allZeros:())*/
/*Swift.(file)._FixedArray2.init(allZeros:())*/
initAllZerostuple_type(allZeros, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.init(allZeros:()) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray2.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
/*Swift.(file)._FixedArray2.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray2.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray2<T>.Element>) throws -> R)*/
/*Swift.(file)._FixedArray2.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray2<T>.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray2.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray2<T>.Element>) throws -> R) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_FixedArray2, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(_FixedArray2, MutableCollection$implementation, false)












class _FixedArray4<T> implements RandomAccessCollection, MutableCollection{
static readonly $struct = true

/*Swift.(file)._FixedArray4.storage*/
storage$get() {
throw 'unsupported variable Swift.(file)._FixedArray4.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };










/*Swift.(file)._FixedArray4.init(storage:(T, T, T, T),_count:Int8)*/
/*Swift.(file)._FixedArray4.init(storage:(T, T, T, T),_count:Int8)*/
initStoragetuple_type_countInt8(storage, _count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.init(storage:(T, T, T, T),_count:Int8) in ' + this.constructor.name
}

/*Swift.(file)._FixedArray4.capacity*/
static capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray4.capacity in ' + this.constructor.name
}
static get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray4.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray4.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray4.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };







/*Swift.(file)._FixedArray4.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray4.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._FixedArray4.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray4.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._FixedArray4.subscript(_:_FixedArray4<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.subscript(_:_FixedArray4<T>.Index) in ' + this.constructor.name
}/*Swift.(file)._FixedArray4.subscript(_:_FixedArray4<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.subscript(_:_FixedArray4<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray4.index(after:_FixedArray4<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.index(after:_FixedArray4<T>.Index) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray4.index(before:_FixedArray4<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.index(before:_FixedArray4<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray4.append(_:T)*/
/*Swift.(file)._FixedArray4.append(_:T)*/
append(newElement, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.append(_:T) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray4.init(count:Int)*/
/*Swift.(file)._FixedArray4.init(count:Int)*/
initCountInt(count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.init(count:Int) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray4.init()*/
/*Swift.(file)._FixedArray4.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._FixedArray4.init() in ' + this.constructor.name
}
/*Swift.(file)._FixedArray4.init(allZeros:())*/
/*Swift.(file)._FixedArray4.init(allZeros:())*/
initAllZerostuple_type(allZeros, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.init(allZeros:()) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray4.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
/*Swift.(file)._FixedArray4.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray4.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray4<T>.Element>) throws -> R)*/
/*Swift.(file)._FixedArray4.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray4<T>.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray4.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray4<T>.Element>) throws -> R) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_FixedArray4, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(_FixedArray4, MutableCollection$implementation, false)












class _FixedArray8<T> implements RandomAccessCollection, MutableCollection{
static readonly $struct = true

/*Swift.(file)._FixedArray8.storage*/
storage$get() {
throw 'unsupported variable Swift.(file)._FixedArray8.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };










/*Swift.(file)._FixedArray8.init(storage:(T, T, T, T, T, T, T, T),_count:Int8)*/
/*Swift.(file)._FixedArray8.init(storage:(T, T, T, T, T, T, T, T),_count:Int8)*/
initStoragetuple_type_countInt8(storage, _count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.init(storage:(T, T, T, T, T, T, T, T),_count:Int8) in ' + this.constructor.name
}

/*Swift.(file)._FixedArray8.capacity*/
static capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray8.capacity in ' + this.constructor.name
}
static get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray8.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray8.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray8.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };







/*Swift.(file)._FixedArray8.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray8.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._FixedArray8.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray8.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._FixedArray8.subscript(_:_FixedArray8<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.subscript(_:_FixedArray8<T>.Index) in ' + this.constructor.name
}/*Swift.(file)._FixedArray8.subscript(_:_FixedArray8<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.subscript(_:_FixedArray8<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray8.index(after:_FixedArray8<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.index(after:_FixedArray8<T>.Index) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray8.index(before:_FixedArray8<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.index(before:_FixedArray8<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray8.append(_:T)*/
/*Swift.(file)._FixedArray8.append(_:T)*/
append(newElement, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.append(_:T) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray8.init(count:Int)*/
/*Swift.(file)._FixedArray8.init(count:Int)*/
initCountInt(count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.init(count:Int) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray8.init()*/
/*Swift.(file)._FixedArray8.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._FixedArray8.init() in ' + this.constructor.name
}
/*Swift.(file)._FixedArray8.init(allZeros:())*/
/*Swift.(file)._FixedArray8.init(allZeros:())*/
initAllZerostuple_type(allZeros, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.init(allZeros:()) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray8.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
/*Swift.(file)._FixedArray8.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray8.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray8<T>.Element>) throws -> R)*/
/*Swift.(file)._FixedArray8.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray8<T>.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray8.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray8<T>.Element>) throws -> R) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_FixedArray8, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(_FixedArray8, MutableCollection$implementation, false)












class _FixedArray16<T> implements RandomAccessCollection, MutableCollection{
static readonly $struct = true

/*Swift.(file)._FixedArray16.storage*/
storage$get() {
throw 'unsupported variable Swift.(file)._FixedArray16.storage in ' + this.constructor.name
}
get storage() { return this.storage$get() };










/*Swift.(file)._FixedArray16.init(storage:(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T),_count:Int8)*/
/*Swift.(file)._FixedArray16.init(storage:(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T),_count:Int8)*/
initStoragetuple_type_countInt8(storage, _count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.init(storage:(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T),_count:Int8) in ' + this.constructor.name
}

/*Swift.(file)._FixedArray16.capacity*/
static capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray16.capacity in ' + this.constructor.name
}
static get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray16.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file)._FixedArray16.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };




/*Swift.(file)._FixedArray16.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };







/*Swift.(file)._FixedArray16.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray16.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._FixedArray16.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file)._FixedArray16.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._FixedArray16.subscript(_:_FixedArray16<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.subscript(_:_FixedArray16<T>.Index) in ' + this.constructor.name
}/*Swift.(file)._FixedArray16.subscript(_:_FixedArray16<T>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.subscript(_:_FixedArray16<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray16.index(after:_FixedArray16<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.index(after:_FixedArray16<T>.Index) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray16.index(before:_FixedArray16<T>.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.index(before:_FixedArray16<T>.Index) in ' + this.constructor.name
}




/*Swift.(file)._FixedArray16.append(_:T)*/
/*Swift.(file)._FixedArray16.append(_:T)*/
append(newElement, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.append(_:T) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray16.init(count:Int)*/
/*Swift.(file)._FixedArray16.init(count:Int)*/
initCountInt(count, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.init(count:Int) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray16.init()*/
/*Swift.(file)._FixedArray16.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._FixedArray16.init() in ' + this.constructor.name
}
/*Swift.(file)._FixedArray16.init(allZeros:())*/
/*Swift.(file)._FixedArray16.init(allZeros:())*/
initAllZerostuple_type(allZeros, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.init(allZeros:()) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray16.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
/*Swift.(file)._FixedArray16.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<T>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._FixedArray16.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray16<T>.Element>) throws -> R)*/
/*Swift.(file)._FixedArray16.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray16<T>.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._FixedArray16.withUnsafeBufferPointer(_:(UnsafeBufferPointer<_FixedArray16<T>.Element>) throws -> R) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_FixedArray16, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(_FixedArray16, MutableCollection$implementation, false)












class MIO_Mixin_Float implements _CVarArgPassedAsDouble, _CVarArgAligned, Codable, LosslessStringConvertible, CustomStringConvertible, CustomDebugStringConvertible, TextOutputStreamable, BinaryFloatingPoint, _ExpressibleByBuiltinIntegerLiteral, ExpressibleByIntegerLiteral, _ExpressibleByBuiltinFloatLiteral, Hashable, _HasCustomAnyHashableRepresentation, Strideable, CustomReflectable, _CustomPlaygroundQuickLookable, ElementaryFunctions, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true





/*Swift.(file).Float.init()*/
/*Swift.(file).Float.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float.init() in ' + this.constructor.name
}
/*Swift.(file).Float.init(_:FPIEEE32)*/
/*Swift.(file).Float.init(_:FPIEEE32)*/
initFPIEEE32(_value, $info?) {
throw 'unsupported method Swift.(file).Float.init(_:FPIEEE32) in ' + this.constructor.name
}






/*Swift.(file).Float.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Float.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Float.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Float.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Float.init(_:S)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString<S>(text, $info?) {
throw 'unsupported method Swift.(file).Float.init(_:S) in ' + this.constructor.name
}
static readonly initString$failable = true

/*Swift.(file).Float.description*/
description$get() {
let result = this.toString()
if(!result.includes('.')) result += '.0';
return result
}
get description() { return this.description$get() };




/*Swift.(file).Float.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Float.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).Float.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?) {
throw 'unsupported method Swift.(file).Float.write(to:Target) in ' + this.constructor.name
}




/*Swift.(file).Float.exponentBitCount*/
static exponentBitCount$get() {
throw 'unsupported variable Swift.(file).Float.exponentBitCount in ' + this.constructor.name
}
static get exponentBitCount() { return this.exponentBitCount$get() };




/*Swift.(file).Float.significandBitCount*/
static significandBitCount$get() {
throw 'unsupported variable Swift.(file).Float.significandBitCount in ' + this.constructor.name
}
static get significandBitCount() { return this.significandBitCount$get() };
















/*Swift.(file).Float.bitPattern*/
bitPattern$get() {
throw 'unsupported variable Swift.(file).Float.bitPattern in ' + this.constructor.name
}
get bitPattern() { return this.bitPattern$get() };



/*Swift.(file).Float.init(bitPattern:UInt32)*/
/*Swift.(file).Float.init(bitPattern:UInt32)*/
initBitPatternUInt32(bitPattern, $info?) {
throw 'unsupported method Swift.(file).Float.init(bitPattern:UInt32) in ' + this.constructor.name
}

/*Swift.(file).Float.sign*/
sign$get() {
throw 'unsupported variable Swift.(file).Float.sign in ' + this.constructor.name
}
get sign() { return this.sign$get() };




/*Swift.(file).Float.isSignMinus*/
isSignMinus$get() {
throw 'unsupported variable Swift.(file).Float.isSignMinus in ' + this.constructor.name
}
get isSignMinus() { return this.isSignMinus$get() };




/*Swift.(file).Float.exponentBitPattern*/
exponentBitPattern$get() {
throw 'unsupported variable Swift.(file).Float.exponentBitPattern in ' + this.constructor.name
}
get exponentBitPattern() { return this.exponentBitPattern$get() };




/*Swift.(file).Float.significandBitPattern*/
significandBitPattern$get() {
throw 'unsupported variable Swift.(file).Float.significandBitPattern in ' + this.constructor.name
}
get significandBitPattern() { return this.significandBitPattern$get() };



/*Swift.(file).Float.init(sign:FloatingPointSign,exponentBitPattern:UInt,significandBitPattern:UInt32)*/
/*Swift.(file).BinaryFloatingPoint.init(sign:FloatingPointSign,exponentBitPattern:Self.RawExponent,significandBitPattern:Self.RawSignificand)*/
initSignFloatingPointSignExponentBitPatternSignificandBitPattern(sign, exponentBitPattern, significandBitPattern, $info?) {
throw 'unsupported method Swift.(file).Float.init(sign:FloatingPointSign,exponentBitPattern:UInt,significandBitPattern:UInt32) in ' + this.constructor.name
}

/*Swift.(file).Float.isCanonical*/
isCanonical$get() {
throw 'unsupported variable Swift.(file).Float.isCanonical in ' + this.constructor.name
}
get isCanonical() { return this.isCanonical$get() };




/*Swift.(file).Float.infinity*/
static infinity$get() {
throw 'unsupported variable Swift.(file).Float.infinity in ' + this.constructor.name
}
static get infinity() { return this.infinity$get() };




/*Swift.(file).Float.nan*/
static nan$get() {
throw 'unsupported variable Swift.(file).Float.nan in ' + this.constructor.name
}
static get nan() { return this.nan$get() };




/*Swift.(file).Float.signalingNaN*/
static signalingNaN$get() {
throw 'unsupported variable Swift.(file).Float.signalingNaN in ' + this.constructor.name
}
static get signalingNaN() { return this.signalingNaN$get() };




/*Swift.(file).Float.quietNaN*/
static quietNaN$get() {
throw 'unsupported variable Swift.(file).Float.quietNaN in ' + this.constructor.name
}
static get quietNaN() { return this.quietNaN$get() };




/*Swift.(file).Float.greatestFiniteMagnitude*/
static greatestFiniteMagnitude$get() {
throw 'unsupported variable Swift.(file).Float.greatestFiniteMagnitude in ' + this.constructor.name
}
static get greatestFiniteMagnitude() { return this.greatestFiniteMagnitude$get() };




/*Swift.(file).Float.pi*/
static pi$get() {
throw 'unsupported variable Swift.(file).Float.pi in ' + this.constructor.name
}
static get pi() { return this.pi$get() };




/*Swift.(file).Float.ulp*/
ulp$get() {
throw 'unsupported variable Swift.(file).Float.ulp in ' + this.constructor.name
}
get ulp() { return this.ulp$get() };




/*Swift.(file).Float.leastNormalMagnitude*/
static leastNormalMagnitude$get() {
throw 'unsupported variable Swift.(file).Float.leastNormalMagnitude in ' + this.constructor.name
}
static get leastNormalMagnitude() { return this.leastNormalMagnitude$get() };




/*Swift.(file).Float.leastNonzeroMagnitude*/
static leastNonzeroMagnitude$get() {
throw 'unsupported variable Swift.(file).Float.leastNonzeroMagnitude in ' + this.constructor.name
}
static get leastNonzeroMagnitude() { return this.leastNonzeroMagnitude$get() };




/*Swift.(file).Float.ulpOfOne*/
static ulpOfOne$get() {
let _this = this;
return 1.ulp;
}
static get ulpOfOne() { return this.ulpOfOne$get()
}
static get ulpOfOne() { return this.ulpOfOne$get() };




/*Swift.(file).Float.exponent*/
exponent$get() {
throw 'unsupported variable Swift.(file).Float.exponent in ' + this.constructor.name
}
get exponent() { return this.exponent$get() };




/*Swift.(file).Float.significand*/
significand$get() {
throw 'unsupported variable Swift.(file).Float.significand in ' + this.constructor.name
}
get significand() { return this.significand$get() };



/*Swift.(file).Float.init(sign:FloatingPointSign,exponent:Int,significand:Float)*/
/*Swift.(file).FloatingPoint.init(sign:FloatingPointSign,exponent:Self.Exponent,significand:Self)*/
initSignFloatingPointSignExponentSignificand(sign, exponent, significand, $info?) {
throw 'unsupported method Swift.(file).Float.init(sign:FloatingPointSign,exponent:Int,significand:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.init(nan:Float.RawSignificand,signaling:Bool)*/
/*Swift.(file).Float.init(nan:Float.RawSignificand,signaling:Bool)*/
initNanFloatRawSignificandSignalingBool(payload, signaling, $info?) {
throw 'unsupported method Swift.(file).Float.init(nan:Float.RawSignificand,signaling:Bool) in ' + this.constructor.name
}

/*Swift.(file).Float.nextUp*/
nextUp$get() {
throw 'unsupported variable Swift.(file).Float.nextUp in ' + this.constructor.name
}
get nextUp() { return this.nextUp$get() };



/*Swift.(file).Float.init(signOf:Float,magnitudeOf:Float)*/
/*Swift.(file).FloatingPoint.init(signOf:Self,magnitudeOf:Self)*/
initSignOfMagnitudeOf(sign, mag, $info?) {
throw 'unsupported method Swift.(file).Float.init(signOf:Float,magnitudeOf:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.round(_:FloatingPointRoundingRule)*/
/*Swift.(file).FloatingPoint.round(_:FloatingPointRoundingRule)*/
round(rule, $info?) {
throw 'unsupported method Swift.(file).Float.round(_:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).Float.negate()*/
/*Swift.(file).FloatingPoint.negate()*/
/*Swift.(file).SignedNumeric.negate()*/
negate($info?) {
$info.$setThis(-this)
}
static /*Swift.(file).Float.+=infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Float.-=infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Float.*=infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Float./=infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() / rhs)
}
/*Swift.(file).Float.formRemainder(dividingBy:Float)*/
/*Swift.(file).FloatingPoint.formRemainder(dividingBy:Self)*/
formRemainderDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Float.formRemainder(dividingBy:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.formTruncatingRemainder(dividingBy:Float)*/
/*Swift.(file).FloatingPoint.formTruncatingRemainder(dividingBy:Self)*/
formTruncatingRemainderDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Float.formTruncatingRemainder(dividingBy:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.formSquareRoot()*/
/*Swift.(file).FloatingPoint.formSquareRoot()*/
formSquareRoot($info?) {
throw 'unsupported method Swift.(file).Float.formSquareRoot() in ' + this.constructor.name
}
/*Swift.(file).Float.addProduct(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint.addProduct(_:Self,_:Self)*/
addProduct(lhs, rhs, $info?) {
throw 'unsupported method Swift.(file).Float.addProduct(_:Float,_:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.isEqual(to:Float)*/
/*Swift.(file).FloatingPoint.isEqual(to:Self)*/
isEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).Float.isEqual(to:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.isLess(than:Float)*/
/*Swift.(file).FloatingPoint.isLess(than:Self)*/
isLessThan(other, $info?) {
throw 'unsupported method Swift.(file).Float.isLess(than:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.isLessThanOrEqualTo(_:Float)*/
/*Swift.(file).FloatingPoint.isLessThanOrEqualTo(_:Self)*/
isLessThanOrEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).Float.isLessThanOrEqualTo(_:Float) in ' + this.constructor.name
}

/*Swift.(file).Float.isNormal*/
isNormal$get() {
throw 'unsupported variable Swift.(file).Float.isNormal in ' + this.constructor.name
}
get isNormal() { return this.isNormal$get() };







/*Swift.(file).Float.isZero*/
isZero$get() {
throw 'unsupported variable Swift.(file).Float.isZero in ' + this.constructor.name
}
get isZero() { return this.isZero$get() };




/*Swift.(file).Float.isSubnormal*/
isSubnormal$get() {
throw 'unsupported variable Swift.(file).Float.isSubnormal in ' + this.constructor.name
}
get isSubnormal() { return this.isSubnormal$get() };




/*Swift.(file).Float.isInfinite*/
isInfinite$get() {
throw 'unsupported variable Swift.(file).Float.isInfinite in ' + this.constructor.name
}
get isInfinite() { return this.isInfinite$get() };







/*Swift.(file).Float.isSignalingNaN*/
isSignalingNaN$get() {
throw 'unsupported variable Swift.(file).Float.isSignalingNaN in ' + this.constructor.name
}
get isSignalingNaN() { return this.isSignalingNaN$get() };




/*Swift.(file).Float.binade*/
binade$get() {
throw 'unsupported variable Swift.(file).Float.binade in ' + this.constructor.name
}
get binade() { return this.binade$get() };




/*Swift.(file).Float.significandWidth*/
significandWidth$get() {
throw 'unsupported variable Swift.(file).Float.significandWidth in ' + this.constructor.name
}
get significandWidth() { return this.significandWidth$get() };



/*Swift.(file).Float.init(floatLiteral:Float)*/
/*Swift.(file).ExpressibleByFloatLiteral.init(floatLiteral:Self.FloatLiteralType)*/
initFloatLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Float.init(floatLiteral:Float) in ' + this.constructor.name
}


/*Swift.(file).Float.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Float.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Float.init(integerLiteral:Int64)*/
/*Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self.IntegerLiteralType)*/
initIntegerLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Float.init(integerLiteral:Int64) in ' + this.constructor.name
}

/*Swift.(file).Float.init(_builtinFloatLiteral:FPIEEE80)*/
/*Swift.(file)._ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:_MaxBuiltinFloatType)*/
init_builtinFloatLiteral_MaxBuiltinFloatType(value, $info?) {
throw 'unsupported method Swift.(file).Float.init(_builtinFloatLiteral:FPIEEE80) in ' + this.constructor.name
}
/*Swift.(file).Float.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Float.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Float.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Float.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).Float.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Float.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



static /*Swift.(file).Float.-prefix(_:Float)*/
/*Swift.(file).FloatingPoint.-prefix(_:Self)*/
/*Swift.(file).SignedNumeric.-prefix(_:Self)*/
$negate(x, $info?) {
return -x
}
/*Swift.(file).Float.init(_:Int)*/
/*Swift.(file).FloatingPoint.init(_:Int)*/
initInt(v, $info?) {
throw 'unsupported method Swift.(file).Float.init(_:Int) in ' + this.constructor.name
}
/*Swift.(file).Float.init(_:Float)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float)*/
initFloat(other, $info?) {
throw 'unsupported method Swift.(file).Float.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.init(exactly:Float)*/
/*Swift.(file).Float.init(exactly:Float)*/
initExactlyFloat(other, $info?) {
throw 'unsupported method Swift.(file).Float.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Float.init(_:Double)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Double)*/
initDouble(other, $info?) {
throw 'unsupported method Swift.(file).Float.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).Float.init(exactly:Double)*/
/*Swift.(file).Float.init(exactly:Double)*/
initExactlyDouble(other, $info?) {
throw 'unsupported method Swift.(file).Float.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Float.init(_:Float80)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float80)*/
initFloat80(other, $info?) {
throw 'unsupported method Swift.(file).Float.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float.init(exactly:Float80)*/
/*Swift.(file).Float.init(exactly:Float80)*/
initExactlyFloat80(other, $info?) {
throw 'unsupported method Swift.(file).Float.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Float.+infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Float.-infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Float.*infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Float./infix(_:Float,_:Float)*/
/*Swift.(file).FloatingPoint./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return lhs / rhs
}
/*Swift.(file).Float.distance(to:Float)*/
/*Swift.(file).Strideable.distance(to:Self)*/
distanceTo(other, $info?) {
throw 'unsupported method Swift.(file).Float.distance(to:Float) in ' + this.constructor.name
}
/*Swift.(file).Float.advanced(by:Float)*/
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
advancedBy(amount, $info?) {
throw 'unsupported method Swift.(file).Float.advanced(by:Float) in ' + this.constructor.name
}


/*Swift.(file).Float.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Float.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Float.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Float.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



static /*Swift.(file).Float.sqrt(_:Float)*/
/*Swift.(file).ElementaryFunctions.sqrt(_:Self)*/
sqrt(x, $info?) {
throw 'unsupported method Swift.(file).Float.sqrt(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.cos(_:Float)*/
/*Swift.(file).ElementaryFunctions.cos(_:Self)*/
cos(x, $info?) {
throw 'unsupported method Swift.(file).Float.cos(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.sin(_:Float)*/
/*Swift.(file).ElementaryFunctions.sin(_:Self)*/
sin(x, $info?) {
throw 'unsupported method Swift.(file).Float.sin(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.tan(_:Float)*/
/*Swift.(file).ElementaryFunctions.tan(_:Self)*/
tan(x, $info?) {
throw 'unsupported method Swift.(file).Float.tan(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.acos(_:Float)*/
/*Swift.(file).ElementaryFunctions.acos(_:Self)*/
acos(x, $info?) {
throw 'unsupported method Swift.(file).Float.acos(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.asin(_:Float)*/
/*Swift.(file).ElementaryFunctions.asin(_:Self)*/
asin(x, $info?) {
throw 'unsupported method Swift.(file).Float.asin(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.atan(_:Float)*/
/*Swift.(file).ElementaryFunctions.atan(_:Self)*/
atan(x, $info?) {
throw 'unsupported method Swift.(file).Float.atan(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.cosh(_:Float)*/
/*Swift.(file).ElementaryFunctions.cosh(_:Self)*/
cosh(x, $info?) {
throw 'unsupported method Swift.(file).Float.cosh(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.sinh(_:Float)*/
/*Swift.(file).ElementaryFunctions.sinh(_:Self)*/
sinh(x, $info?) {
throw 'unsupported method Swift.(file).Float.sinh(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.tanh(_:Float)*/
/*Swift.(file).ElementaryFunctions.tanh(_:Self)*/
tanh(x, $info?) {
throw 'unsupported method Swift.(file).Float.tanh(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.acosh(_:Float)*/
/*Swift.(file).ElementaryFunctions.acosh(_:Self)*/
acosh(x, $info?) {
throw 'unsupported method Swift.(file).Float.acosh(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.asinh(_:Float)*/
/*Swift.(file).ElementaryFunctions.asinh(_:Self)*/
asinh(x, $info?) {
throw 'unsupported method Swift.(file).Float.asinh(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.atanh(_:Float)*/
/*Swift.(file).ElementaryFunctions.atanh(_:Self)*/
atanh(x, $info?) {
throw 'unsupported method Swift.(file).Float.atanh(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.exp(_:Float)*/
/*Swift.(file).ElementaryFunctions.exp(_:Self)*/
exp(x, $info?) {
throw 'unsupported method Swift.(file).Float.exp(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.exp2(_:Float)*/
/*Swift.(file).ElementaryFunctions.exp2(_:Self)*/
exp2(x, $info?) {
throw 'unsupported method Swift.(file).Float.exp2(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.exp10(_:Float)*/
/*Swift.(file).ElementaryFunctions.exp10(_:Self)*/
exp10(x, $info?) {
throw 'unsupported method Swift.(file).Float.exp10(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.expm1(_:Float)*/
/*Swift.(file).ElementaryFunctions.expm1(_:Self)*/
expm1(x, $info?) {
throw 'unsupported method Swift.(file).Float.expm1(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.log(_:Float)*/
/*Swift.(file).ElementaryFunctions.log(_:Self)*/
log(x, $info?) {
throw 'unsupported method Swift.(file).Float.log(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.log2(_:Float)*/
/*Swift.(file).ElementaryFunctions.log2(_:Self)*/
log2(x, $info?) {
throw 'unsupported method Swift.(file).Float.log2(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.log10(_:Float)*/
/*Swift.(file).ElementaryFunctions.log10(_:Self)*/
log10(x, $info?) {
throw 'unsupported method Swift.(file).Float.log10(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.log1p(_:Float)*/
/*Swift.(file).ElementaryFunctions.log1p(_:Self)*/
log1p(x, $info?) {
throw 'unsupported method Swift.(file).Float.log1p(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.erf(_:Float)*/
/*Swift.(file).Float.erf(_:Float)*/
erf(x, $info?) {
throw 'unsupported method Swift.(file).Float.erf(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.erfc(_:Float)*/
/*Swift.(file).Float.erfc(_:Float)*/
erfc(x, $info?) {
throw 'unsupported method Swift.(file).Float.erfc(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.hypot(_:Float,_:Float)*/
/*Swift.(file).Float.hypot(_:Float,_:Float)*/
hypot(x, y, $info?) {
throw 'unsupported method Swift.(file).Float.hypot(_:Float,_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.gamma(_:Float)*/
/*Swift.(file).Float.gamma(_:Float)*/
gamma(x, $info?) {
throw 'unsupported method Swift.(file).Float.gamma(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.pow(_:Float,_:Float)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Self)*/
pow(x, y, $info?) {
throw 'unsupported method Swift.(file).Float.pow(_:Float,_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.pow(_:Float,_:Int)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Int)*/
/*!!!DUPLICATE NAME*/
pow(x, n, $info?) {
throw 'unsupported method Swift.(file).Float.pow(_:Float,_:Int) in ' + this.constructor.name
}
static /*Swift.(file).Float.root(_:Float,_:Int)*/
/*Swift.(file).ElementaryFunctions.root(_:Self,_:Int)*/
root(x, n, $info?) {
throw 'unsupported method Swift.(file).Float.root(_:Float,_:Int) in ' + this.constructor.name
}
static /*Swift.(file).Float.atan2(y:Float,x:Float)*/
/*Swift.(file).Float.atan2(y:Float,x:Float)*/
atan2YX(y, x, $info?) {
throw 'unsupported method Swift.(file).Float.atan2(y:Float,x:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.logGamma(_:Float)*/
/*Swift.(file).Float.logGamma(_:Float)*/
logGamma(x, $info?) {
throw 'unsupported method Swift.(file).Float.logGamma(_:Float) in ' + this.constructor.name
}
static /*Swift.(file).Float.signGamma(_:Float)*/
/*Swift.(file).Float.signGamma(_:Float)*/
signGamma(x, $info?) {
throw 'unsupported method Swift.(file).Float.signGamma(_:Float) in ' + this.constructor.name
}

static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Float.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Float.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Float.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Float.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Float.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Float.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Float.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Float.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Float.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Float.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Float.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Float.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Float.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Float.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Float.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Float.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Float.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Float.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Float.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Float.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Float.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Float.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Float.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Float.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Float.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Float.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Float.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Float.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Float.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Float.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Float.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof _CVarArgPassedAsDouble$implementation != 'undefined') _mixin(MIO_Mixin_Float, _CVarArgPassedAsDouble$implementation, false)
if(typeof _CVarArgAligned$implementation != 'undefined') _mixin(MIO_Mixin_Float, _CVarArgAligned$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Float, Codable$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Float, LosslessStringConvertible$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Float, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Float, CustomDebugStringConvertible$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(MIO_Mixin_Float, TextOutputStreamable$implementation, false)
if(typeof BinaryFloatingPoint$implementation != 'undefined') _mixin(MIO_Mixin_Float, BinaryFloatingPoint$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Float, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof ExpressibleByIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Float, ExpressibleByIntegerLiteral$implementation, false)
if(typeof _ExpressibleByBuiltinFloatLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Float, _ExpressibleByBuiltinFloatLiteral$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Float, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Float, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(MIO_Mixin_Float, Strideable$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Float, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Float, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(MIO_Mixin_Float, ElementaryFunctions$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_Float, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_Float, true)
class Float{}
_mixin(Float, MIO_Mixin_Float, true)




































class MIO_Mixin_Double implements _CVarArgPassedAsDouble, _CVarArgAligned, Codable, LosslessStringConvertible, CustomStringConvertible, CustomDebugStringConvertible, TextOutputStreamable, BinaryFloatingPoint, _ExpressibleByBuiltinIntegerLiteral, ExpressibleByIntegerLiteral, _ExpressibleByBuiltinFloatLiteral, Hashable, _HasCustomAnyHashableRepresentation, Strideable, CustomReflectable, _CustomPlaygroundQuickLookable, ElementaryFunctions, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true





/*Swift.(file).Double.init()*/
/*Swift.(file).Double.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Double.init() in ' + this.constructor.name
}
/*Swift.(file).Double.init(_:FPIEEE64)*/
/*Swift.(file).Double.init(_:FPIEEE64)*/
initFPIEEE64(_value, $info?) {
throw 'unsupported method Swift.(file).Double.init(_:FPIEEE64) in ' + this.constructor.name
}






/*Swift.(file).Double.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Double.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Double.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Double.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Double.init(_:S)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString<S>(text, $info?) {
throw 'unsupported method Swift.(file).Double.init(_:S) in ' + this.constructor.name
}
static readonly initString$failable = true

/*Swift.(file).Double.description*/
description$get() {
let result = this.toString()
if(!result.includes('.')) result += '.0';
return result
}
get description() { return this.description$get() };




/*Swift.(file).Double.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Double.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).Double.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?) {
throw 'unsupported method Swift.(file).Double.write(to:Target) in ' + this.constructor.name
}




/*Swift.(file).Double.exponentBitCount*/
static exponentBitCount$get() {
throw 'unsupported variable Swift.(file).Double.exponentBitCount in ' + this.constructor.name
}
static get exponentBitCount() { return this.exponentBitCount$get() };




/*Swift.(file).Double.significandBitCount*/
static significandBitCount$get() {
throw 'unsupported variable Swift.(file).Double.significandBitCount in ' + this.constructor.name
}
static get significandBitCount() { return this.significandBitCount$get() };
















/*Swift.(file).Double.bitPattern*/
bitPattern$get() {
throw 'unsupported variable Swift.(file).Double.bitPattern in ' + this.constructor.name
}
get bitPattern() { return this.bitPattern$get() };



/*Swift.(file).Double.init(bitPattern:UInt64)*/
/*Swift.(file).Double.init(bitPattern:UInt64)*/
initBitPatternUInt64(bitPattern, $info?) {
throw 'unsupported method Swift.(file).Double.init(bitPattern:UInt64) in ' + this.constructor.name
}

/*Swift.(file).Double.sign*/
sign$get() {
throw 'unsupported variable Swift.(file).Double.sign in ' + this.constructor.name
}
get sign() { return this.sign$get() };




/*Swift.(file).Double.isSignMinus*/
isSignMinus$get() {
throw 'unsupported variable Swift.(file).Double.isSignMinus in ' + this.constructor.name
}
get isSignMinus() { return this.isSignMinus$get() };




/*Swift.(file).Double.exponentBitPattern*/
exponentBitPattern$get() {
throw 'unsupported variable Swift.(file).Double.exponentBitPattern in ' + this.constructor.name
}
get exponentBitPattern() { return this.exponentBitPattern$get() };




/*Swift.(file).Double.significandBitPattern*/
significandBitPattern$get() {
throw 'unsupported variable Swift.(file).Double.significandBitPattern in ' + this.constructor.name
}
get significandBitPattern() { return this.significandBitPattern$get() };



/*Swift.(file).Double.init(sign:FloatingPointSign,exponentBitPattern:UInt,significandBitPattern:UInt64)*/
/*Swift.(file).BinaryFloatingPoint.init(sign:FloatingPointSign,exponentBitPattern:Self.RawExponent,significandBitPattern:Self.RawSignificand)*/
initSignFloatingPointSignExponentBitPatternSignificandBitPattern(sign, exponentBitPattern, significandBitPattern, $info?) {
throw 'unsupported method Swift.(file).Double.init(sign:FloatingPointSign,exponentBitPattern:UInt,significandBitPattern:UInt64) in ' + this.constructor.name
}

/*Swift.(file).Double.isCanonical*/
isCanonical$get() {
throw 'unsupported variable Swift.(file).Double.isCanonical in ' + this.constructor.name
}
get isCanonical() { return this.isCanonical$get() };




/*Swift.(file).Double.infinity*/
static infinity$get() {
return Infinity
}
static get infinity() { return this.infinity$get() };




/*Swift.(file).Double.nan*/
static nan$get() {
throw 'unsupported variable Swift.(file).Double.nan in ' + this.constructor.name
}
static get nan() { return this.nan$get() };




/*Swift.(file).Double.signalingNaN*/
static signalingNaN$get() {
throw 'unsupported variable Swift.(file).Double.signalingNaN in ' + this.constructor.name
}
static get signalingNaN() { return this.signalingNaN$get() };




/*Swift.(file).Double.quietNaN*/
static quietNaN$get() {
throw 'unsupported variable Swift.(file).Double.quietNaN in ' + this.constructor.name
}
static get quietNaN() { return this.quietNaN$get() };




/*Swift.(file).Double.greatestFiniteMagnitude*/
static greatestFiniteMagnitude$get() {
return Number.MAX_VALUE
}
static get greatestFiniteMagnitude() { return this.greatestFiniteMagnitude$get() };




/*Swift.(file).Double.pi*/
static pi$get() {
throw 'unsupported variable Swift.(file).Double.pi in ' + this.constructor.name
}
static get pi() { return this.pi$get() };




/*Swift.(file).Double.ulp*/
ulp$get() {
throw 'unsupported variable Swift.(file).Double.ulp in ' + this.constructor.name
}
get ulp() { return this.ulp$get() };




/*Swift.(file).Double.leastNormalMagnitude*/
static leastNormalMagnitude$get() {
throw 'unsupported variable Swift.(file).Double.leastNormalMagnitude in ' + this.constructor.name
}
static get leastNormalMagnitude() { return this.leastNormalMagnitude$get() };




/*Swift.(file).Double.leastNonzeroMagnitude*/
static leastNonzeroMagnitude$get() {
throw 'unsupported variable Swift.(file).Double.leastNonzeroMagnitude in ' + this.constructor.name
}
static get leastNonzeroMagnitude() { return this.leastNonzeroMagnitude$get() };




/*Swift.(file).Double.ulpOfOne*/
static ulpOfOne$get() {
let _this = this;
return 1.ulp;
}
static get ulpOfOne() { return this.ulpOfOne$get()
}
static get ulpOfOne() { return this.ulpOfOne$get() };




/*Swift.(file).Double.exponent*/
exponent$get() {
throw 'unsupported variable Swift.(file).Double.exponent in ' + this.constructor.name
}
get exponent() { return this.exponent$get() };




/*Swift.(file).Double.significand*/
significand$get() {
throw 'unsupported variable Swift.(file).Double.significand in ' + this.constructor.name
}
get significand() { return this.significand$get() };



/*Swift.(file).Double.init(sign:FloatingPointSign,exponent:Int,significand:Double)*/
/*Swift.(file).FloatingPoint.init(sign:FloatingPointSign,exponent:Self.Exponent,significand:Self)*/
initSignFloatingPointSignExponentSignificand(sign, exponent, significand, $info?) {
throw 'unsupported method Swift.(file).Double.init(sign:FloatingPointSign,exponent:Int,significand:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.init(nan:Double.RawSignificand,signaling:Bool)*/
/*Swift.(file).Double.init(nan:Double.RawSignificand,signaling:Bool)*/
initNanDoubleRawSignificandSignalingBool(payload, signaling, $info?) {
throw 'unsupported method Swift.(file).Double.init(nan:Double.RawSignificand,signaling:Bool) in ' + this.constructor.name
}

/*Swift.(file).Double.nextUp*/
nextUp$get() {
throw 'unsupported variable Swift.(file).Double.nextUp in ' + this.constructor.name
}
get nextUp() { return this.nextUp$get() };



/*Swift.(file).Double.init(signOf:Double,magnitudeOf:Double)*/
/*Swift.(file).FloatingPoint.init(signOf:Self,magnitudeOf:Self)*/
initSignOfMagnitudeOf(sign, mag, $info?) {
throw 'unsupported method Swift.(file).Double.init(signOf:Double,magnitudeOf:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.round(_:FloatingPointRoundingRule)*/
/*Swift.(file).FloatingPoint.round(_:FloatingPointRoundingRule)*/
round(rule, $info?) {
throw 'unsupported method Swift.(file).Double.round(_:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).Double.negate()*/
/*Swift.(file).FloatingPoint.negate()*/
/*Swift.(file).SignedNumeric.negate()*/
negate($info?) {
$info.$setThis(-this)
}
static /*Swift.(file).Double.+=infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Double.-=infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Double.*=infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Double./=infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() / rhs)
}
/*Swift.(file).Double.formRemainder(dividingBy:Double)*/
/*Swift.(file).FloatingPoint.formRemainder(dividingBy:Self)*/
formRemainderDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Double.formRemainder(dividingBy:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.formTruncatingRemainder(dividingBy:Double)*/
/*Swift.(file).FloatingPoint.formTruncatingRemainder(dividingBy:Self)*/
formTruncatingRemainderDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Double.formTruncatingRemainder(dividingBy:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.formSquareRoot()*/
/*Swift.(file).FloatingPoint.formSquareRoot()*/
formSquareRoot($info?) {
throw 'unsupported method Swift.(file).Double.formSquareRoot() in ' + this.constructor.name
}
/*Swift.(file).Double.addProduct(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint.addProduct(_:Self,_:Self)*/
addProduct(lhs, rhs, $info?) {
throw 'unsupported method Swift.(file).Double.addProduct(_:Double,_:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.isEqual(to:Double)*/
/*Swift.(file).FloatingPoint.isEqual(to:Self)*/
isEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).Double.isEqual(to:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.isLess(than:Double)*/
/*Swift.(file).FloatingPoint.isLess(than:Self)*/
isLessThan(other, $info?) {
throw 'unsupported method Swift.(file).Double.isLess(than:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.isLessThanOrEqualTo(_:Double)*/
/*Swift.(file).FloatingPoint.isLessThanOrEqualTo(_:Self)*/
isLessThanOrEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).Double.isLessThanOrEqualTo(_:Double) in ' + this.constructor.name
}

/*Swift.(file).Double.isNormal*/
isNormal$get() {
throw 'unsupported variable Swift.(file).Double.isNormal in ' + this.constructor.name
}
get isNormal() { return this.isNormal$get() };







/*Swift.(file).Double.isZero*/
isZero$get() {
throw 'unsupported variable Swift.(file).Double.isZero in ' + this.constructor.name
}
get isZero() { return this.isZero$get() };




/*Swift.(file).Double.isSubnormal*/
isSubnormal$get() {
throw 'unsupported variable Swift.(file).Double.isSubnormal in ' + this.constructor.name
}
get isSubnormal() { return this.isSubnormal$get() };




/*Swift.(file).Double.isInfinite*/
isInfinite$get() {
throw 'unsupported variable Swift.(file).Double.isInfinite in ' + this.constructor.name
}
get isInfinite() { return this.isInfinite$get() };







/*Swift.(file).Double.isSignalingNaN*/
isSignalingNaN$get() {
throw 'unsupported variable Swift.(file).Double.isSignalingNaN in ' + this.constructor.name
}
get isSignalingNaN() { return this.isSignalingNaN$get() };




/*Swift.(file).Double.binade*/
binade$get() {
throw 'unsupported variable Swift.(file).Double.binade in ' + this.constructor.name
}
get binade() { return this.binade$get() };




/*Swift.(file).Double.significandWidth*/
significandWidth$get() {
throw 'unsupported variable Swift.(file).Double.significandWidth in ' + this.constructor.name
}
get significandWidth() { return this.significandWidth$get() };



/*Swift.(file).Double.init(floatLiteral:Double)*/
/*Swift.(file).ExpressibleByFloatLiteral.init(floatLiteral:Self.FloatLiteralType)*/
initFloatLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Double.init(floatLiteral:Double) in ' + this.constructor.name
}


/*Swift.(file).Double.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Double.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Double.init(integerLiteral:Int64)*/
/*Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self.IntegerLiteralType)*/
initIntegerLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Double.init(integerLiteral:Int64) in ' + this.constructor.name
}

/*Swift.(file).Double.init(_builtinFloatLiteral:FPIEEE80)*/
/*Swift.(file)._ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:_MaxBuiltinFloatType)*/
init_builtinFloatLiteral_MaxBuiltinFloatType(value, $info?) {
throw 'unsupported method Swift.(file).Double.init(_builtinFloatLiteral:FPIEEE80) in ' + this.constructor.name
}
/*Swift.(file).Double.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Double.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Double.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Double.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).Double.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Double.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



static /*Swift.(file).Double.-prefix(_:Double)*/
/*Swift.(file).FloatingPoint.-prefix(_:Self)*/
/*Swift.(file).SignedNumeric.-prefix(_:Self)*/
$negate(x, $info?) {
return -x
}
/*Swift.(file).Double.init(_:Int)*/
/*Swift.(file).FloatingPoint.init(_:Int)*/
initInt(v, $info?) {
return v
}
/*Swift.(file).Double.init(_:Float)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float)*/
initFloat(other, $info?) {
throw 'unsupported method Swift.(file).Double.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Double.init(exactly:Float)*/
/*Swift.(file).Double.init(exactly:Float)*/
initExactlyFloat(other, $info?) {
throw 'unsupported method Swift.(file).Double.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Double.init(_:Double)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Double)*/
initDouble(other, $info?) {
throw 'unsupported method Swift.(file).Double.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.init(exactly:Double)*/
/*Swift.(file).Double.init(exactly:Double)*/
initExactlyDouble(other, $info?) {
throw 'unsupported method Swift.(file).Double.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Double.init(_:Float80)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float80)*/
initFloat80(other, $info?) {
throw 'unsupported method Swift.(file).Double.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Double.init(exactly:Float80)*/
/*Swift.(file).Double.init(exactly:Float80)*/
initExactlyFloat80(other, $info?) {
throw 'unsupported method Swift.(file).Double.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Double.+infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Double.-infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Double.*infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Double./infix(_:Double,_:Double)*/
/*Swift.(file).FloatingPoint./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return lhs / rhs
}
/*Swift.(file).Double.distance(to:Double)*/
/*Swift.(file).Strideable.distance(to:Self)*/
distanceTo(other, $info?) {
throw 'unsupported method Swift.(file).Double.distance(to:Double) in ' + this.constructor.name
}
/*Swift.(file).Double.advanced(by:Double)*/
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
advancedBy(amount, $info?) {
throw 'unsupported method Swift.(file).Double.advanced(by:Double) in ' + this.constructor.name
}


/*Swift.(file).Double.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Double.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Double.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Double.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



static /*Swift.(file).Double.sqrt(_:Double)*/
/*Swift.(file).ElementaryFunctions.sqrt(_:Self)*/
sqrt(x, $info?) {
throw 'unsupported method Swift.(file).Double.sqrt(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.cos(_:Double)*/
/*Swift.(file).ElementaryFunctions.cos(_:Self)*/
cos(x, $info?) {
throw 'unsupported method Swift.(file).Double.cos(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.sin(_:Double)*/
/*Swift.(file).ElementaryFunctions.sin(_:Self)*/
sin(x, $info?) {
throw 'unsupported method Swift.(file).Double.sin(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.tan(_:Double)*/
/*Swift.(file).ElementaryFunctions.tan(_:Self)*/
tan(x, $info?) {
throw 'unsupported method Swift.(file).Double.tan(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.acos(_:Double)*/
/*Swift.(file).ElementaryFunctions.acos(_:Self)*/
acos(x, $info?) {
throw 'unsupported method Swift.(file).Double.acos(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.asin(_:Double)*/
/*Swift.(file).ElementaryFunctions.asin(_:Self)*/
asin(x, $info?) {
throw 'unsupported method Swift.(file).Double.asin(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.atan(_:Double)*/
/*Swift.(file).ElementaryFunctions.atan(_:Self)*/
atan(x, $info?) {
throw 'unsupported method Swift.(file).Double.atan(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.cosh(_:Double)*/
/*Swift.(file).ElementaryFunctions.cosh(_:Self)*/
cosh(x, $info?) {
throw 'unsupported method Swift.(file).Double.cosh(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.sinh(_:Double)*/
/*Swift.(file).ElementaryFunctions.sinh(_:Self)*/
sinh(x, $info?) {
throw 'unsupported method Swift.(file).Double.sinh(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.tanh(_:Double)*/
/*Swift.(file).ElementaryFunctions.tanh(_:Self)*/
tanh(x, $info?) {
throw 'unsupported method Swift.(file).Double.tanh(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.acosh(_:Double)*/
/*Swift.(file).ElementaryFunctions.acosh(_:Self)*/
acosh(x, $info?) {
throw 'unsupported method Swift.(file).Double.acosh(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.asinh(_:Double)*/
/*Swift.(file).ElementaryFunctions.asinh(_:Self)*/
asinh(x, $info?) {
throw 'unsupported method Swift.(file).Double.asinh(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.atanh(_:Double)*/
/*Swift.(file).ElementaryFunctions.atanh(_:Self)*/
atanh(x, $info?) {
throw 'unsupported method Swift.(file).Double.atanh(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.exp(_:Double)*/
/*Swift.(file).ElementaryFunctions.exp(_:Self)*/
exp(x, $info?) {
throw 'unsupported method Swift.(file).Double.exp(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.exp2(_:Double)*/
/*Swift.(file).ElementaryFunctions.exp2(_:Self)*/
exp2(x, $info?) {
throw 'unsupported method Swift.(file).Double.exp2(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.exp10(_:Double)*/
/*Swift.(file).ElementaryFunctions.exp10(_:Self)*/
exp10(x, $info?) {
throw 'unsupported method Swift.(file).Double.exp10(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.expm1(_:Double)*/
/*Swift.(file).ElementaryFunctions.expm1(_:Self)*/
expm1(x, $info?) {
throw 'unsupported method Swift.(file).Double.expm1(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.log(_:Double)*/
/*Swift.(file).ElementaryFunctions.log(_:Self)*/
log(x, $info?) {
throw 'unsupported method Swift.(file).Double.log(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.log2(_:Double)*/
/*Swift.(file).ElementaryFunctions.log2(_:Self)*/
log2(x, $info?) {
throw 'unsupported method Swift.(file).Double.log2(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.log10(_:Double)*/
/*Swift.(file).ElementaryFunctions.log10(_:Self)*/
log10(x, $info?) {
throw 'unsupported method Swift.(file).Double.log10(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.log1p(_:Double)*/
/*Swift.(file).ElementaryFunctions.log1p(_:Self)*/
log1p(x, $info?) {
throw 'unsupported method Swift.(file).Double.log1p(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.erf(_:Double)*/
/*Swift.(file).Double.erf(_:Double)*/
erf(x, $info?) {
throw 'unsupported method Swift.(file).Double.erf(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.erfc(_:Double)*/
/*Swift.(file).Double.erfc(_:Double)*/
erfc(x, $info?) {
throw 'unsupported method Swift.(file).Double.erfc(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.hypot(_:Double,_:Double)*/
/*Swift.(file).Double.hypot(_:Double,_:Double)*/
hypot(x, y, $info?) {
throw 'unsupported method Swift.(file).Double.hypot(_:Double,_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.gamma(_:Double)*/
/*Swift.(file).Double.gamma(_:Double)*/
gamma(x, $info?) {
throw 'unsupported method Swift.(file).Double.gamma(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.pow(_:Double,_:Double)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Self)*/
pow(x, y, $info?) {
throw 'unsupported method Swift.(file).Double.pow(_:Double,_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.pow(_:Double,_:Int)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Int)*/
/*!!!DUPLICATE NAME*/
pow(x, n, $info?) {
throw 'unsupported method Swift.(file).Double.pow(_:Double,_:Int) in ' + this.constructor.name
}
static /*Swift.(file).Double.root(_:Double,_:Int)*/
/*Swift.(file).ElementaryFunctions.root(_:Self,_:Int)*/
root(x, n, $info?) {
throw 'unsupported method Swift.(file).Double.root(_:Double,_:Int) in ' + this.constructor.name
}
static /*Swift.(file).Double.atan2(y:Double,x:Double)*/
/*Swift.(file).Double.atan2(y:Double,x:Double)*/
atan2YX(y, x, $info?) {
throw 'unsupported method Swift.(file).Double.atan2(y:Double,x:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.logGamma(_:Double)*/
/*Swift.(file).Double.logGamma(_:Double)*/
logGamma(x, $info?) {
throw 'unsupported method Swift.(file).Double.logGamma(_:Double) in ' + this.constructor.name
}
static /*Swift.(file).Double.signGamma(_:Double)*/
/*Swift.(file).Double.signGamma(_:Double)*/
signGamma(x, $info?) {
throw 'unsupported method Swift.(file).Double.signGamma(_:Double) in ' + this.constructor.name
}

static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Double.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Double.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Double.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Double.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Double.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Double.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Double.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Double.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Double.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Double.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Double.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Double.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Double.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Double.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Double.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Double.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Double.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Double.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Double.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Double.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Double.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Double.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Double.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Double.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Double.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Double.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Double.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Double.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Double.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Double.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Double.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Double.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Double.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Double.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Double.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Double.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Double.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof _CVarArgPassedAsDouble$implementation != 'undefined') _mixin(MIO_Mixin_Double, _CVarArgPassedAsDouble$implementation, false)
if(typeof _CVarArgAligned$implementation != 'undefined') _mixin(MIO_Mixin_Double, _CVarArgAligned$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Double, Codable$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Double, LosslessStringConvertible$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Double, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Double, CustomDebugStringConvertible$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(MIO_Mixin_Double, TextOutputStreamable$implementation, false)
if(typeof BinaryFloatingPoint$implementation != 'undefined') _mixin(MIO_Mixin_Double, BinaryFloatingPoint$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Double, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof ExpressibleByIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Double, ExpressibleByIntegerLiteral$implementation, false)
if(typeof _ExpressibleByBuiltinFloatLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Double, _ExpressibleByBuiltinFloatLiteral$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Double, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Double, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(MIO_Mixin_Double, Strideable$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Double, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Double, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(MIO_Mixin_Double, ElementaryFunctions$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_Double, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_Double, true)
class Double{}
_mixin(Double, MIO_Mixin_Double, true)




































class MIO_Mixin_Float80 implements CVarArg, _CVarArgAligned, LosslessStringConvertible, CustomStringConvertible, CustomDebugStringConvertible, TextOutputStreamable, BinaryFloatingPoint, _ExpressibleByBuiltinIntegerLiteral, ExpressibleByIntegerLiteral, _ExpressibleByBuiltinFloatLiteral, Hashable, _HasCustomAnyHashableRepresentation, Strideable, CustomReflectable, ElementaryFunctions{
static readonly $struct = true
static readonly $mixin = true





/*Swift.(file).Float80.init()*/
/*Swift.(file).Float80.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Float80.init() in ' + this.constructor.name
}
/*Swift.(file).Float80.init(_:FPIEEE80)*/
/*Swift.(file).Float80.init(_:FPIEEE80)*/
initFPIEEE80(_value, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_:FPIEEE80) in ' + this.constructor.name
}






/*Swift.(file).Float80.init(_:S)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString<S>(text, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_:S) in ' + this.constructor.name
}
static readonly initString$failable = true

/*Swift.(file).Float80.description*/
description$get() {
let result = this.toString()
if(!result.includes('.')) result += '.0';
return result
}
get description() { return this.description$get() };




/*Swift.(file).Float80.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).Float80.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).Float80.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?) {
throw 'unsupported method Swift.(file).Float80.write(to:Target) in ' + this.constructor.name
}




/*Swift.(file).Float80.exponentBitCount*/
static exponentBitCount$get() {
throw 'unsupported variable Swift.(file).Float80.exponentBitCount in ' + this.constructor.name
}
static get exponentBitCount() { return this.exponentBitCount$get() };




/*Swift.(file).Float80.significandBitCount*/
static significandBitCount$get() {
throw 'unsupported variable Swift.(file).Float80.significandBitCount in ' + this.constructor.name
}
static get significandBitCount() { return this.significandBitCount$get() };















static _Representation = class{
static readonly $struct = true






/*Swift.(file).Float80._Representation.explicitSignificand*/
explicitSignificand$get() {
throw 'unsupported variable Swift.(file).Float80._Representation.explicitSignificand in ' + this.constructor.name
}
get explicitSignificand() { return this.explicitSignificand$get() };




/*Swift.(file).Float80._Representation.signAndExponent*/
signAndExponent$get() {
throw 'unsupported variable Swift.(file).Float80._Representation.signAndExponent in ' + this.constructor.name
}
get signAndExponent() { return this.signAndExponent$get() };




/*Swift.(file).Float80._Representation.sign*/
sign$get() {
throw 'unsupported variable Swift.(file).Float80._Representation.sign in ' + this.constructor.name
}
get sign() { return this.sign$get() };




/*Swift.(file).Float80._Representation.exponentBitPattern*/
exponentBitPattern$get() {
throw 'unsupported variable Swift.(file).Float80._Representation.exponentBitPattern in ' + this.constructor.name
}
get exponentBitPattern() { return this.exponentBitPattern$get() };



/*Swift.(file).Float80._Representation.init(explicitSignificand:UInt64,signAndExponent:UInt16)*/
/*Swift.(file).Float80._Representation.init(explicitSignificand:UInt64,signAndExponent:UInt16)*/
initExplicitSignificandUInt64SignAndExponentUInt16(explicitSignificand, signAndExponent, $info?) {
throw 'unsupported method Swift.(file).Float80._Representation.init(explicitSignificand:UInt64,signAndExponent:UInt16) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}




/*Swift.(file).Float80.sign*/
sign$get() {
throw 'unsupported variable Swift.(file).Float80.sign in ' + this.constructor.name
}
get sign() { return this.sign$get() };







/*Swift.(file).Float80.exponentBitPattern*/
exponentBitPattern$get() {
throw 'unsupported variable Swift.(file).Float80.exponentBitPattern in ' + this.constructor.name
}
get exponentBitPattern() { return this.exponentBitPattern$get() };




/*Swift.(file).Float80.significandBitPattern*/
significandBitPattern$get() {
throw 'unsupported variable Swift.(file).Float80.significandBitPattern in ' + this.constructor.name
}
get significandBitPattern() { return this.significandBitPattern$get() };



/*Swift.(file).Float80.init(sign:FloatingPointSign,exponentBitPattern:UInt,significandBitPattern:UInt64)*/
/*Swift.(file).BinaryFloatingPoint.init(sign:FloatingPointSign,exponentBitPattern:Self.RawExponent,significandBitPattern:Self.RawSignificand)*/
initSignFloatingPointSignExponentBitPatternSignificandBitPattern(sign, exponentBitPattern, significandBitPattern, $info?) {
throw 'unsupported method Swift.(file).Float80.init(sign:FloatingPointSign,exponentBitPattern:UInt,significandBitPattern:UInt64) in ' + this.constructor.name
}

/*Swift.(file).Float80.isCanonical*/
isCanonical$get() {
throw 'unsupported variable Swift.(file).Float80.isCanonical in ' + this.constructor.name
}
get isCanonical() { return this.isCanonical$get() };




/*Swift.(file).Float80.infinity*/
static infinity$get() {
throw 'unsupported variable Swift.(file).Float80.infinity in ' + this.constructor.name
}
static get infinity() { return this.infinity$get() };




/*Swift.(file).Float80.nan*/
static nan$get() {
throw 'unsupported variable Swift.(file).Float80.nan in ' + this.constructor.name
}
static get nan() { return this.nan$get() };




/*Swift.(file).Float80.signalingNaN*/
static signalingNaN$get() {
throw 'unsupported variable Swift.(file).Float80.signalingNaN in ' + this.constructor.name
}
static get signalingNaN() { return this.signalingNaN$get() };




/*Swift.(file).Float80.quietNaN*/
static quietNaN$get() {
throw 'unsupported variable Swift.(file).Float80.quietNaN in ' + this.constructor.name
}
static get quietNaN() { return this.quietNaN$get() };




/*Swift.(file).Float80.greatestFiniteMagnitude*/
static greatestFiniteMagnitude$get() {
throw 'unsupported variable Swift.(file).Float80.greatestFiniteMagnitude in ' + this.constructor.name
}
static get greatestFiniteMagnitude() { return this.greatestFiniteMagnitude$get() };




/*Swift.(file).Float80.pi*/
static pi$get() {
throw 'unsupported variable Swift.(file).Float80.pi in ' + this.constructor.name
}
static get pi() { return this.pi$get() };




/*Swift.(file).Float80.ulp*/
ulp$get() {
throw 'unsupported variable Swift.(file).Float80.ulp in ' + this.constructor.name
}
get ulp() { return this.ulp$get() };




/*Swift.(file).Float80.leastNormalMagnitude*/
static leastNormalMagnitude$get() {
throw 'unsupported variable Swift.(file).Float80.leastNormalMagnitude in ' + this.constructor.name
}
static get leastNormalMagnitude() { return this.leastNormalMagnitude$get() };




/*Swift.(file).Float80.leastNonzeroMagnitude*/
static leastNonzeroMagnitude$get() {
throw 'unsupported variable Swift.(file).Float80.leastNonzeroMagnitude in ' + this.constructor.name
}
static get leastNonzeroMagnitude() { return this.leastNonzeroMagnitude$get() };




/*Swift.(file).Float80.ulpOfOne*/
static ulpOfOne$get() {
let _this = this;
return 1.ulp;
}
static get ulpOfOne() { return this.ulpOfOne$get()
}
static get ulpOfOne() { return this.ulpOfOne$get() };




/*Swift.(file).Float80.exponent*/
exponent$get() {
throw 'unsupported variable Swift.(file).Float80.exponent in ' + this.constructor.name
}
get exponent() { return this.exponent$get() };




/*Swift.(file).Float80.significand*/
significand$get() {
throw 'unsupported variable Swift.(file).Float80.significand in ' + this.constructor.name
}
get significand() { return this.significand$get() };



/*Swift.(file).Float80.init(sign:FloatingPointSign,exponent:Int,significand:Float80)*/
/*Swift.(file).FloatingPoint.init(sign:FloatingPointSign,exponent:Self.Exponent,significand:Self)*/
initSignFloatingPointSignExponentSignificand(sign, exponent, significand, $info?) {
throw 'unsupported method Swift.(file).Float80.init(sign:FloatingPointSign,exponent:Int,significand:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.init(nan:Float80.RawSignificand,signaling:Bool)*/
/*Swift.(file).Float80.init(nan:Float80.RawSignificand,signaling:Bool)*/
initNanFloat80RawSignificandSignalingBool(payload, signaling, $info?) {
throw 'unsupported method Swift.(file).Float80.init(nan:Float80.RawSignificand,signaling:Bool) in ' + this.constructor.name
}

/*Swift.(file).Float80.nextUp*/
nextUp$get() {
throw 'unsupported variable Swift.(file).Float80.nextUp in ' + this.constructor.name
}
get nextUp() { return this.nextUp$get() };



/*Swift.(file).Float80.init(signOf:Float80,magnitudeOf:Float80)*/
/*Swift.(file).FloatingPoint.init(signOf:Self,magnitudeOf:Self)*/
initSignOfMagnitudeOf(sign, mag, $info?) {
throw 'unsupported method Swift.(file).Float80.init(signOf:Float80,magnitudeOf:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.round(_:FloatingPointRoundingRule)*/
/*Swift.(file).FloatingPoint.round(_:FloatingPointRoundingRule)*/
round(rule, $info?) {
throw 'unsupported method Swift.(file).Float80.round(_:FloatingPointRoundingRule) in ' + this.constructor.name
}

/*Swift.(file).Float80.negate()*/
/*Swift.(file).FloatingPoint.negate()*/
/*Swift.(file).SignedNumeric.negate()*/
negate($info?) {
$info.$setThis(-this)
}
static /*Swift.(file).Float80.+=infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Float80.-=infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Float80.*=infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Float80./=infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() / rhs)
}
/*Swift.(file).Float80.formRemainder(dividingBy:Float80)*/
/*Swift.(file).FloatingPoint.formRemainder(dividingBy:Self)*/
formRemainderDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Float80.formRemainder(dividingBy:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.formTruncatingRemainder(dividingBy:Float80)*/
/*Swift.(file).FloatingPoint.formTruncatingRemainder(dividingBy:Self)*/
formTruncatingRemainderDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Float80.formTruncatingRemainder(dividingBy:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.formSquareRoot()*/
/*Swift.(file).FloatingPoint.formSquareRoot()*/
formSquareRoot($info?) {
throw 'unsupported method Swift.(file).Float80.formSquareRoot() in ' + this.constructor.name
}
/*Swift.(file).Float80.addProduct(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint.addProduct(_:Self,_:Self)*/
addProduct(lhs, rhs, $info?) {
throw 'unsupported method Swift.(file).Float80.addProduct(_:Float80,_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.isEqual(to:Float80)*/
/*Swift.(file).FloatingPoint.isEqual(to:Self)*/
isEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).Float80.isEqual(to:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.isLess(than:Float80)*/
/*Swift.(file).FloatingPoint.isLess(than:Self)*/
isLessThan(other, $info?) {
throw 'unsupported method Swift.(file).Float80.isLess(than:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.isLessThanOrEqualTo(_:Float80)*/
/*Swift.(file).FloatingPoint.isLessThanOrEqualTo(_:Self)*/
isLessThanOrEqualTo(other, $info?) {
throw 'unsupported method Swift.(file).Float80.isLessThanOrEqualTo(_:Float80) in ' + this.constructor.name
}

/*Swift.(file).Float80.isNormal*/
isNormal$get() {
throw 'unsupported variable Swift.(file).Float80.isNormal in ' + this.constructor.name
}
get isNormal() { return this.isNormal$get() };







/*Swift.(file).Float80.isZero*/
isZero$get() {
throw 'unsupported variable Swift.(file).Float80.isZero in ' + this.constructor.name
}
get isZero() { return this.isZero$get() };




/*Swift.(file).Float80.isSubnormal*/
isSubnormal$get() {
throw 'unsupported variable Swift.(file).Float80.isSubnormal in ' + this.constructor.name
}
get isSubnormal() { return this.isSubnormal$get() };




/*Swift.(file).Float80.isInfinite*/
isInfinite$get() {
throw 'unsupported variable Swift.(file).Float80.isInfinite in ' + this.constructor.name
}
get isInfinite() { return this.isInfinite$get() };







/*Swift.(file).Float80.isSignalingNaN*/
isSignalingNaN$get() {
throw 'unsupported variable Swift.(file).Float80.isSignalingNaN in ' + this.constructor.name
}
get isSignalingNaN() { return this.isSignalingNaN$get() };




/*Swift.(file).Float80.binade*/
binade$get() {
throw 'unsupported variable Swift.(file).Float80.binade in ' + this.constructor.name
}
get binade() { return this.binade$get() };




/*Swift.(file).Float80.significandWidth*/
significandWidth$get() {
throw 'unsupported variable Swift.(file).Float80.significandWidth in ' + this.constructor.name
}
get significandWidth() { return this.significandWidth$get() };



/*Swift.(file).Float80.init(floatLiteral:Float80)*/
/*Swift.(file).ExpressibleByFloatLiteral.init(floatLiteral:Self.FloatLiteralType)*/
initFloatLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Float80.init(floatLiteral:Float80) in ' + this.constructor.name
}


/*Swift.(file).Float80.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Float80.init(integerLiteral:Int64)*/
/*Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self.IntegerLiteralType)*/
initIntegerLiteral(value, $info?) {
throw 'unsupported method Swift.(file).Float80.init(integerLiteral:Int64) in ' + this.constructor.name
}

/*Swift.(file).Float80.init(_builtinFloatLiteral:FPIEEE80)*/
/*Swift.(file)._ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:_MaxBuiltinFloatType)*/
init_builtinFloatLiteral_MaxBuiltinFloatType(value, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_builtinFloatLiteral:FPIEEE80) in ' + this.constructor.name
}
/*Swift.(file).Float80.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Float80.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Float80.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Float80.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).Float80.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Float80.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



static /*Swift.(file).Float80.-prefix(_:Float80)*/
/*Swift.(file).FloatingPoint.-prefix(_:Self)*/
/*Swift.(file).SignedNumeric.-prefix(_:Self)*/
$negate(x, $info?) {
return -x
}
/*Swift.(file).Float80.init(_:Int)*/
/*Swift.(file).FloatingPoint.init(_:Int)*/
initInt(v, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_:Int) in ' + this.constructor.name
}
/*Swift.(file).Float80.init(_:Float)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float)*/
initFloat(other, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Float80.init(exactly:Float)*/
/*Swift.(file).Float80.init(exactly:Float)*/
initExactlyFloat(other, $info?) {
throw 'unsupported method Swift.(file).Float80.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Float80.init(_:Double)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Double)*/
initDouble(other, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).Float80.init(exactly:Double)*/
/*Swift.(file).Float80.init(exactly:Double)*/
initExactlyDouble(other, $info?) {
throw 'unsupported method Swift.(file).Float80.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Float80.init(_:Float80)*/
/*Swift.(file).BinaryFloatingPoint.init(_:Float80)*/
initFloat80(other, $info?) {
throw 'unsupported method Swift.(file).Float80.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.init(exactly:Float80)*/
/*Swift.(file).Float80.init(exactly:Float80)*/
initExactlyFloat80(other, $info?) {
throw 'unsupported method Swift.(file).Float80.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Float80.+infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Float80.-infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Float80.*infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Float80./infix(_:Float80,_:Float80)*/
/*Swift.(file).FloatingPoint./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return lhs / rhs
}
/*Swift.(file).Float80.distance(to:Float80)*/
/*Swift.(file).Strideable.distance(to:Self)*/
distanceTo(other, $info?) {
throw 'unsupported method Swift.(file).Float80.distance(to:Float80) in ' + this.constructor.name
}
/*Swift.(file).Float80.advanced(by:Float80)*/
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
advancedBy(amount, $info?) {
throw 'unsupported method Swift.(file).Float80.advanced(by:Float80) in ' + this.constructor.name
}


/*Swift.(file).Float80.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Float80.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };



static /*Swift.(file).Float80.sqrt(_:Float80)*/
/*Swift.(file).ElementaryFunctions.sqrt(_:Self)*/
sqrt(x, $info?) {
throw 'unsupported method Swift.(file).Float80.sqrt(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.cos(_:Float80)*/
/*Swift.(file).ElementaryFunctions.cos(_:Self)*/
cos(x, $info?) {
throw 'unsupported method Swift.(file).Float80.cos(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.sin(_:Float80)*/
/*Swift.(file).ElementaryFunctions.sin(_:Self)*/
sin(x, $info?) {
throw 'unsupported method Swift.(file).Float80.sin(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.tan(_:Float80)*/
/*Swift.(file).ElementaryFunctions.tan(_:Self)*/
tan(x, $info?) {
throw 'unsupported method Swift.(file).Float80.tan(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.acos(_:Float80)*/
/*Swift.(file).ElementaryFunctions.acos(_:Self)*/
acos(x, $info?) {
throw 'unsupported method Swift.(file).Float80.acos(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.asin(_:Float80)*/
/*Swift.(file).ElementaryFunctions.asin(_:Self)*/
asin(x, $info?) {
throw 'unsupported method Swift.(file).Float80.asin(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.atan(_:Float80)*/
/*Swift.(file).ElementaryFunctions.atan(_:Self)*/
atan(x, $info?) {
throw 'unsupported method Swift.(file).Float80.atan(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.cosh(_:Float80)*/
/*Swift.(file).ElementaryFunctions.cosh(_:Self)*/
cosh(x, $info?) {
throw 'unsupported method Swift.(file).Float80.cosh(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.sinh(_:Float80)*/
/*Swift.(file).ElementaryFunctions.sinh(_:Self)*/
sinh(x, $info?) {
throw 'unsupported method Swift.(file).Float80.sinh(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.tanh(_:Float80)*/
/*Swift.(file).ElementaryFunctions.tanh(_:Self)*/
tanh(x, $info?) {
throw 'unsupported method Swift.(file).Float80.tanh(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.acosh(_:Float80)*/
/*Swift.(file).ElementaryFunctions.acosh(_:Self)*/
acosh(x, $info?) {
throw 'unsupported method Swift.(file).Float80.acosh(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.asinh(_:Float80)*/
/*Swift.(file).ElementaryFunctions.asinh(_:Self)*/
asinh(x, $info?) {
throw 'unsupported method Swift.(file).Float80.asinh(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.atanh(_:Float80)*/
/*Swift.(file).ElementaryFunctions.atanh(_:Self)*/
atanh(x, $info?) {
throw 'unsupported method Swift.(file).Float80.atanh(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.exp(_:Float80)*/
/*Swift.(file).ElementaryFunctions.exp(_:Self)*/
exp(x, $info?) {
throw 'unsupported method Swift.(file).Float80.exp(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.exp2(_:Float80)*/
/*Swift.(file).ElementaryFunctions.exp2(_:Self)*/
exp2(x, $info?) {
throw 'unsupported method Swift.(file).Float80.exp2(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.exp10(_:Float80)*/
/*Swift.(file).ElementaryFunctions.exp10(_:Self)*/
exp10(x, $info?) {
throw 'unsupported method Swift.(file).Float80.exp10(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.expm1(_:Float80)*/
/*Swift.(file).ElementaryFunctions.expm1(_:Self)*/
expm1(x, $info?) {
throw 'unsupported method Swift.(file).Float80.expm1(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.log(_:Float80)*/
/*Swift.(file).ElementaryFunctions.log(_:Self)*/
log(x, $info?) {
throw 'unsupported method Swift.(file).Float80.log(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.log2(_:Float80)*/
/*Swift.(file).ElementaryFunctions.log2(_:Self)*/
log2(x, $info?) {
throw 'unsupported method Swift.(file).Float80.log2(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.log10(_:Float80)*/
/*Swift.(file).ElementaryFunctions.log10(_:Self)*/
log10(x, $info?) {
throw 'unsupported method Swift.(file).Float80.log10(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.log1p(_:Float80)*/
/*Swift.(file).ElementaryFunctions.log1p(_:Self)*/
log1p(x, $info?) {
throw 'unsupported method Swift.(file).Float80.log1p(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.erf(_:Float80)*/
/*Swift.(file).Float80.erf(_:Float80)*/
erf(x, $info?) {
throw 'unsupported method Swift.(file).Float80.erf(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.erfc(_:Float80)*/
/*Swift.(file).Float80.erfc(_:Float80)*/
erfc(x, $info?) {
throw 'unsupported method Swift.(file).Float80.erfc(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.hypot(_:Float80,_:Float80)*/
/*Swift.(file).Float80.hypot(_:Float80,_:Float80)*/
hypot(x, y, $info?) {
throw 'unsupported method Swift.(file).Float80.hypot(_:Float80,_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.gamma(_:Float80)*/
/*Swift.(file).Float80.gamma(_:Float80)*/
gamma(x, $info?) {
throw 'unsupported method Swift.(file).Float80.gamma(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.pow(_:Float80,_:Float80)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Self)*/
pow(x, y, $info?) {
throw 'unsupported method Swift.(file).Float80.pow(_:Float80,_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.pow(_:Float80,_:Int)*/
/*Swift.(file).ElementaryFunctions.pow(_:Self,_:Int)*/
/*!!!DUPLICATE NAME*/
pow(x, n, $info?) {
throw 'unsupported method Swift.(file).Float80.pow(_:Float80,_:Int) in ' + this.constructor.name
}
static /*Swift.(file).Float80.root(_:Float80,_:Int)*/
/*Swift.(file).ElementaryFunctions.root(_:Self,_:Int)*/
root(x, n, $info?) {
throw 'unsupported method Swift.(file).Float80.root(_:Float80,_:Int) in ' + this.constructor.name
}
static /*Swift.(file).Float80.atan2(y:Float80,x:Float80)*/
/*Swift.(file).Float80.atan2(y:Float80,x:Float80)*/
atan2YX(y, x, $info?) {
throw 'unsupported method Swift.(file).Float80.atan2(y:Float80,x:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.logGamma(_:Float80)*/
/*Swift.(file).Float80.logGamma(_:Float80)*/
logGamma(x, $info?) {
throw 'unsupported method Swift.(file).Float80.logGamma(_:Float80) in ' + this.constructor.name
}
static /*Swift.(file).Float80.signGamma(_:Float80)*/
/*Swift.(file).Float80.signGamma(_:Float80)*/
signGamma(x, $info?) {
throw 'unsupported method Swift.(file).Float80.signGamma(_:Float80) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_Float80, CVarArg$implementation, false)
if(typeof _CVarArgAligned$implementation != 'undefined') _mixin(MIO_Mixin_Float80, _CVarArgAligned$implementation, false)
if(typeof LosslessStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Float80, LosslessStringConvertible$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Float80, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Float80, CustomDebugStringConvertible$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(MIO_Mixin_Float80, TextOutputStreamable$implementation, false)
if(typeof BinaryFloatingPoint$implementation != 'undefined') _mixin(MIO_Mixin_Float80, BinaryFloatingPoint$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Float80, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof ExpressibleByIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Float80, ExpressibleByIntegerLiteral$implementation, false)
if(typeof _ExpressibleByBuiltinFloatLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Float80, _ExpressibleByBuiltinFloatLiteral$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Float80, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Float80, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof Strideable$implementation != 'undefined') _mixin(MIO_Mixin_Float80, Strideable$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Float80, CustomReflectable$implementation, false)
if(typeof ElementaryFunctions$implementation != 'undefined') _mixin(MIO_Mixin_Float80, ElementaryFunctions$implementation, false)
_mixin(Number, MIO_Mixin_Float80, true)
class Float80{}
_mixin(Float80, MIO_Mixin_Float80, true)
































class MIO_Mixin_UInt8 implements FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral, _StringElement, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).UInt8.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).UInt8.init(bitPattern:Int8)*/
/*Swift.(file).UInt8.init(bitPattern:Int8)*/
initBitPatternInt8(x, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(bitPattern:Int8) in ' + this.constructor.name
}
/*Swift.(file).UInt8.init(_:Float)*/
/*Swift.(file).UInt8.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).UInt8.init(exactly:Float)*/
/*Swift.(file).UInt8.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).UInt8.init(_:Double)*/
/*Swift.(file).UInt8.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).UInt8.init(exactly:Double)*/
/*Swift.(file).UInt8.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).UInt8.init(_:Float80)*/
/*Swift.(file).UInt8.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).UInt8.init(exactly:Float80)*/
/*Swift.(file).UInt8.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).UInt8.==infix(_:UInt8,_:UInt8)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).UInt8.<infix(_:UInt8,_:UInt8)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).UInt8.+=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).UInt8.-=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).UInt8.*=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).UInt8./=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).UInt8.dividedReportingOverflow(by:UInt8)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt8.dividedReportingOverflow(by:UInt8) in ' + this.constructor.name
}
/*Swift.(file).UInt8.remainderReportingOverflow(dividingBy:UInt8)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt8.remainderReportingOverflow(dividingBy:UInt8) in ' + this.constructor.name
}
/*Swift.(file).UInt8.addingReportingOverflow(_:UInt8)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt8.addingReportingOverflow(_:UInt8) in ' + this.constructor.name
}
/*Swift.(file).UInt8.subtractingReportingOverflow(_:UInt8)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt8.subtractingReportingOverflow(_:UInt8) in ' + this.constructor.name
}
/*Swift.(file).UInt8.multipliedReportingOverflow(by:UInt8)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt8.multipliedReportingOverflow(by:UInt8) in ' + this.constructor.name
}
static /*Swift.(file).UInt8.%=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).UInt8.init(_:Int8)*/
/*Swift.(file).UInt8.init(_:Int8)*/
initInt8(_value, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(_:Int8) in ' + this.constructor.name
}
static /*Swift.(file).UInt8.&=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).UInt8.|=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).UInt8.^=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).UInt8.&>>=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).UInt8.&<<=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).UInt8.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).UInt8.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt8.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).UInt8.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt8.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).UInt8.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt8.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).UInt8.Words.init(_:UInt8)*/
/*Swift.(file).UInt8.Words.init(_:UInt8)*/
initUInt8(value, $info?) {
throw 'unsupported method Swift.(file).UInt8.Words.init(_:UInt8) in ' + this.constructor.name
}

/*Swift.(file).UInt8.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).UInt8.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UInt8.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UInt8.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UInt8.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).UInt8.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).UInt8.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).UInt8.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt8.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).UInt8.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt8.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).UInt8.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).UInt8.words*/
words$get() {
throw 'unsupported variable Swift.(file).UInt8.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).UInt8.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(_truncatingBits:UInt) in ' + this.constructor.name
}

/*Swift.(file).UInt8.multipliedFullWidth(by:UInt8)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt8.multipliedFullWidth(by:UInt8) in ' + this.constructor.name
}
/*Swift.(file).UInt8.dividingFullWidth(_:(high: UInt8, low: UInt8.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).UInt8.dividingFullWidth(_:(high: UInt8, low: UInt8.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).UInt8.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).UInt8.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).UInt8.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}

/*Swift.(file).UInt8.init(ascii:Unicode.Scalar)*/
/*Swift.(file).UInt8.init(ascii:Unicode.Scalar)*/
initAsciiUnicodeScalar(v, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(ascii:Unicode.Scalar) in ' + this.constructor.name
}





/*Swift.(file).UInt8.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).UInt8.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).UInt8.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).UInt8.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).UInt8.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).UInt8.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).UInt8.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UInt8.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).UInt8.&infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).UInt8.|infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).UInt8.^infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).UInt8.&>>infix(_:UInt8,_:UInt8)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).UInt8.&<<infix(_:UInt8,_:UInt8)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).UInt8./infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).UInt8.%infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).UInt8.+infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).UInt8.-infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).UInt8.*infix(_:UInt8,_:UInt8)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).UInt8.<=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).UInt8.>=infix(_:UInt8,_:UInt8)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).UInt8.>infix(_:UInt8,_:UInt8)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).UInt8.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).UInt8.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).UInt8.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).UInt8.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt8.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt8.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt8.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt8.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt8.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt8.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt8.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt8.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt8.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt8.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt8.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt8.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt8.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt8.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt8.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt8.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt8.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt8.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt8.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt8.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt8.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt8.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt8.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt8.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt8.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_UInt8.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt8.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt8.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt8.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt8.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt8.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt8.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, FixedWidthInteger$implementation, false)
if(typeof UnsignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, UnsignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof _StringElement$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, _StringElement$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_UInt8, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_UInt8, true)
class UInt8{}
_mixin(UInt8, MIO_Mixin_UInt8, true)














class MIO_Mixin_Int8 implements FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).Int8.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).Int8.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Int8.init(bitPattern:UInt8)*/
/*Swift.(file).Int8.init(bitPattern:UInt8)*/
initBitPatternUInt8(x, $info?) {
throw 'unsupported method Swift.(file).Int8.init(bitPattern:UInt8) in ' + this.constructor.name
}
/*Swift.(file).Int8.init(_:Float)*/
/*Swift.(file).Int8.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int8.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Int8.init(exactly:Float)*/
/*Swift.(file).Int8.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int8.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Int8.init(_:Double)*/
/*Swift.(file).Int8.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int8.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).Int8.init(exactly:Double)*/
/*Swift.(file).Int8.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int8.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Int8.init(_:Float80)*/
/*Swift.(file).Int8.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int8.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Int8.init(exactly:Float80)*/
/*Swift.(file).Int8.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int8.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Int8.==infix(_:Int8,_:Int8)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Int8.<infix(_:Int8,_:Int8)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).Int8.+=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Int8.-=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Int8.*=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Int8./=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).Int8.dividedReportingOverflow(by:Int8)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int8.dividedReportingOverflow(by:Int8) in ' + this.constructor.name
}
/*Swift.(file).Int8.remainderReportingOverflow(dividingBy:Int8)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Int8.remainderReportingOverflow(dividingBy:Int8) in ' + this.constructor.name
}
/*Swift.(file).Int8.addingReportingOverflow(_:Int8)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int8.addingReportingOverflow(_:Int8) in ' + this.constructor.name
}
/*Swift.(file).Int8.subtractingReportingOverflow(_:Int8)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int8.subtractingReportingOverflow(_:Int8) in ' + this.constructor.name
}
/*Swift.(file).Int8.multipliedReportingOverflow(by:Int8)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int8.multipliedReportingOverflow(by:Int8) in ' + this.constructor.name
}
static /*Swift.(file).Int8.%=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).Int8.init(_:Int8)*/
/*Swift.(file).Int8.init(_:Int8)*/
initInt8(_value, $info?) {
throw 'unsupported method Swift.(file).Int8.init(_:Int8) in ' + this.constructor.name
}
static /*Swift.(file).Int8.&=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).Int8.|=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).Int8.^=infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).Int8.&>>=infix(_:Int8,_:Int8)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).Int8.&<<=infix(_:Int8,_:Int8)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).Int8.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).Int8.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int8.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).Int8.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int8.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).Int8.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int8.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).Int8.Words.init(_:Int8)*/
/*Swift.(file).Int8.Words.init(_:Int8)*/
initInt8(value, $info?) {
throw 'unsupported method Swift.(file).Int8.Words.init(_:Int8) in ' + this.constructor.name
}

/*Swift.(file).Int8.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).Int8.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Int8.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Int8.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Int8.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).Int8.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).Int8.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Int8.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).Int8.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).Int8.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).Int8.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Int8.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).Int8.words*/
words$get() {
throw 'unsupported variable Swift.(file).Int8.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).Int8.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).Int8.init(_truncatingBits:UInt) in ' + this.constructor.name
}


/*Swift.(file).Int8.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Int8.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



/*Swift.(file).Int8.multipliedFullWidth(by:Int8)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).Int8.multipliedFullWidth(by:Int8) in ' + this.constructor.name
}
/*Swift.(file).Int8.dividingFullWidth(_:(high: Int8, low: Int8.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).Int8.dividingFullWidth(_:(high: Int8, low: Int8.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).Int8.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).Int8.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).Int8.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}




/*Swift.(file).Int8.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Int8.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Int8.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Int8.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Int8.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Int8.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Int8.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Int8.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).Int8.&infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).Int8.|infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).Int8.^infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).Int8.&>>infix(_:Int8,_:Int8)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).Int8.&<<infix(_:Int8,_:Int8)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).Int8./infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).Int8.%infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).Int8.+infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Int8.-infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Int8.*infix(_:Int8,_:Int8)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Int8.<=infix(_:Int8,_:Int8)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).Int8.>=infix(_:Int8,_:Int8)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).Int8.>infix(_:Int8,_:Int8)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).Int8.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Int8.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Int8.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Int8.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int8.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int8.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int8.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int8.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int8.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int8.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int8.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int8.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int8.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int8.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int8.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int8.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int8.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int8.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int8.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int8.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int8.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int8.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int8.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int8.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int8.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int8.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int8.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int8.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int8.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int8.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int8.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int8.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int8.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int8.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int8.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_Int8.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int8.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int8.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int8.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int8.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int8.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int8.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int8, FixedWidthInteger$implementation, false)
if(typeof SignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int8, SignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Int8, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_Int8, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Int8, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Int8, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Int8, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Int8, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Int8, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_Int8, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_Int8, true)
class Int8{}
_mixin(Int8, MIO_Mixin_Int8, true)














class MIO_Mixin_UInt16 implements FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral, _StringElement, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).UInt16.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).UInt16.init(bitPattern:Int16)*/
/*Swift.(file).UInt16.init(bitPattern:Int16)*/
initBitPatternInt16(x, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(bitPattern:Int16) in ' + this.constructor.name
}
/*Swift.(file).UInt16.init(_:Float)*/
/*Swift.(file).UInt16.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).UInt16.init(exactly:Float)*/
/*Swift.(file).UInt16.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).UInt16.init(_:Double)*/
/*Swift.(file).UInt16.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).UInt16.init(exactly:Double)*/
/*Swift.(file).UInt16.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).UInt16.init(_:Float80)*/
/*Swift.(file).UInt16.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).UInt16.init(exactly:Float80)*/
/*Swift.(file).UInt16.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).UInt16.==infix(_:UInt16,_:UInt16)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).UInt16.<infix(_:UInt16,_:UInt16)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).UInt16.+=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).UInt16.-=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).UInt16.*=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).UInt16./=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).UInt16.dividedReportingOverflow(by:UInt16)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt16.dividedReportingOverflow(by:UInt16) in ' + this.constructor.name
}
/*Swift.(file).UInt16.remainderReportingOverflow(dividingBy:UInt16)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt16.remainderReportingOverflow(dividingBy:UInt16) in ' + this.constructor.name
}
/*Swift.(file).UInt16.addingReportingOverflow(_:UInt16)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt16.addingReportingOverflow(_:UInt16) in ' + this.constructor.name
}
/*Swift.(file).UInt16.subtractingReportingOverflow(_:UInt16)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt16.subtractingReportingOverflow(_:UInt16) in ' + this.constructor.name
}
/*Swift.(file).UInt16.multipliedReportingOverflow(by:UInt16)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt16.multipliedReportingOverflow(by:UInt16) in ' + this.constructor.name
}
static /*Swift.(file).UInt16.%=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).UInt16.init(_:Int16)*/
/*Swift.(file).UInt16.init(_:Int16)*/
initInt16(_value, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(_:Int16) in ' + this.constructor.name
}
static /*Swift.(file).UInt16.&=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).UInt16.|=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).UInt16.^=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).UInt16.&>>=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).UInt16.&<<=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).UInt16.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).UInt16.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt16.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).UInt16.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt16.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).UInt16.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt16.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).UInt16.Words.init(_:UInt16)*/
/*Swift.(file).UInt16.Words.init(_:UInt16)*/
initUInt16(value, $info?) {
throw 'unsupported method Swift.(file).UInt16.Words.init(_:UInt16) in ' + this.constructor.name
}

/*Swift.(file).UInt16.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).UInt16.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UInt16.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UInt16.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UInt16.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).UInt16.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).UInt16.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).UInt16.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt16.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).UInt16.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt16.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).UInt16.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).UInt16.words*/
words$get() {
throw 'unsupported variable Swift.(file).UInt16.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).UInt16.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(_truncatingBits:UInt) in ' + this.constructor.name
}

/*Swift.(file).UInt16.multipliedFullWidth(by:UInt16)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt16.multipliedFullWidth(by:UInt16) in ' + this.constructor.name
}
/*Swift.(file).UInt16.dividingFullWidth(_:(high: UInt16, low: UInt16.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).UInt16.dividingFullWidth(_:(high: UInt16, low: UInt16.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).UInt16.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).UInt16.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).UInt16.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}






/*Swift.(file).UInt16.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).UInt16.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).UInt16.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).UInt16.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).UInt16.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).UInt16.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).UInt16.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UInt16.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).UInt16.&infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).UInt16.|infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).UInt16.^infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).UInt16.&>>infix(_:UInt16,_:UInt16)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).UInt16.&<<infix(_:UInt16,_:UInt16)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).UInt16./infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).UInt16.%infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).UInt16.+infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).UInt16.-infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).UInt16.*infix(_:UInt16,_:UInt16)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).UInt16.<=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).UInt16.>=infix(_:UInt16,_:UInt16)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).UInt16.>infix(_:UInt16,_:UInt16)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).UInt16.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).UInt16.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).UInt16.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).UInt16.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt16.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt16.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt16.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt16.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt16.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt16.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt16.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt16.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt16.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt16.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt16.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt16.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt16.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt16.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt16.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt16.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt16.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt16.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt16.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt16.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt16.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt16.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt16.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt16.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt16.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_UInt16.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt16.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt16.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt16.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt16.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt16.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt16.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, FixedWidthInteger$implementation, false)
if(typeof UnsignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, UnsignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof _StringElement$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, _StringElement$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_UInt16, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_UInt16, true)
class UInt16{}
_mixin(UInt16, MIO_Mixin_UInt16, true)














class MIO_Mixin_Int16 implements FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).Int16.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).Int16.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Int16.init(bitPattern:UInt16)*/
/*Swift.(file).Int16.init(bitPattern:UInt16)*/
initBitPatternUInt16(x, $info?) {
throw 'unsupported method Swift.(file).Int16.init(bitPattern:UInt16) in ' + this.constructor.name
}
/*Swift.(file).Int16.init(_:Float)*/
/*Swift.(file).Int16.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int16.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Int16.init(exactly:Float)*/
/*Swift.(file).Int16.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int16.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Int16.init(_:Double)*/
/*Swift.(file).Int16.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int16.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).Int16.init(exactly:Double)*/
/*Swift.(file).Int16.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int16.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Int16.init(_:Float80)*/
/*Swift.(file).Int16.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int16.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Int16.init(exactly:Float80)*/
/*Swift.(file).Int16.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int16.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Int16.==infix(_:Int16,_:Int16)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Int16.<infix(_:Int16,_:Int16)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).Int16.+=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Int16.-=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Int16.*=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Int16./=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).Int16.dividedReportingOverflow(by:Int16)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int16.dividedReportingOverflow(by:Int16) in ' + this.constructor.name
}
/*Swift.(file).Int16.remainderReportingOverflow(dividingBy:Int16)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Int16.remainderReportingOverflow(dividingBy:Int16) in ' + this.constructor.name
}
/*Swift.(file).Int16.addingReportingOverflow(_:Int16)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int16.addingReportingOverflow(_:Int16) in ' + this.constructor.name
}
/*Swift.(file).Int16.subtractingReportingOverflow(_:Int16)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int16.subtractingReportingOverflow(_:Int16) in ' + this.constructor.name
}
/*Swift.(file).Int16.multipliedReportingOverflow(by:Int16)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int16.multipliedReportingOverflow(by:Int16) in ' + this.constructor.name
}
static /*Swift.(file).Int16.%=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).Int16.init(_:Int16)*/
/*Swift.(file).Int16.init(_:Int16)*/
initInt16(_value, $info?) {
throw 'unsupported method Swift.(file).Int16.init(_:Int16) in ' + this.constructor.name
}
static /*Swift.(file).Int16.&=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).Int16.|=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).Int16.^=infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).Int16.&>>=infix(_:Int16,_:Int16)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).Int16.&<<=infix(_:Int16,_:Int16)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).Int16.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).Int16.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int16.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).Int16.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int16.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).Int16.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int16.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).Int16.Words.init(_:Int16)*/
/*Swift.(file).Int16.Words.init(_:Int16)*/
initInt16(value, $info?) {
throw 'unsupported method Swift.(file).Int16.Words.init(_:Int16) in ' + this.constructor.name
}

/*Swift.(file).Int16.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).Int16.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Int16.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Int16.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Int16.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).Int16.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).Int16.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Int16.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).Int16.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).Int16.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).Int16.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Int16.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).Int16.words*/
words$get() {
throw 'unsupported variable Swift.(file).Int16.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).Int16.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).Int16.init(_truncatingBits:UInt) in ' + this.constructor.name
}


/*Swift.(file).Int16.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Int16.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



/*Swift.(file).Int16.multipliedFullWidth(by:Int16)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).Int16.multipliedFullWidth(by:Int16) in ' + this.constructor.name
}
/*Swift.(file).Int16.dividingFullWidth(_:(high: Int16, low: Int16.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).Int16.dividingFullWidth(_:(high: Int16, low: Int16.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).Int16.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).Int16.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).Int16.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}




/*Swift.(file).Int16.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Int16.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Int16.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Int16.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Int16.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Int16.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Int16.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Int16.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).Int16.&infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).Int16.|infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).Int16.^infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).Int16.&>>infix(_:Int16,_:Int16)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).Int16.&<<infix(_:Int16,_:Int16)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).Int16./infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).Int16.%infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).Int16.+infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Int16.-infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Int16.*infix(_:Int16,_:Int16)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Int16.<=infix(_:Int16,_:Int16)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).Int16.>=infix(_:Int16,_:Int16)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).Int16.>infix(_:Int16,_:Int16)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).Int16.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Int16.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Int16.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Int16.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int16.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int16.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int16.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int16.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int16.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int16.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int16.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int16.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int16.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int16.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int16.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int16.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int16.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int16.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int16.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int16.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int16.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int16.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int16.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int16.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int16.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int16.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int16.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int16.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int16.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int16.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int16.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int16.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int16.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int16.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int16.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_Int16.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int16.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int16.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int16.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int16.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int16.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int16.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int16, FixedWidthInteger$implementation, false)
if(typeof SignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int16, SignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Int16, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_Int16, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Int16, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Int16, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Int16, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Int16, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Int16, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_Int16, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_Int16, true)
class Int16{}
_mixin(Int16, MIO_Mixin_Int16, true)














class MIO_Mixin_UInt32 implements FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).UInt32.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).UInt32.init(bitPattern:Int32)*/
/*Swift.(file).UInt32.init(bitPattern:Int32)*/
initBitPatternInt32(x, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(bitPattern:Int32) in ' + this.constructor.name
}
/*Swift.(file).UInt32.init(_:Float)*/
/*Swift.(file).UInt32.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).UInt32.init(exactly:Float)*/
/*Swift.(file).UInt32.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).UInt32.init(_:Double)*/
/*Swift.(file).UInt32.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).UInt32.init(exactly:Double)*/
/*Swift.(file).UInt32.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).UInt32.init(_:Float80)*/
/*Swift.(file).UInt32.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).UInt32.init(exactly:Float80)*/
/*Swift.(file).UInt32.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).UInt32.==infix(_:UInt32,_:UInt32)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).UInt32.<infix(_:UInt32,_:UInt32)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).UInt32.+=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).UInt32.-=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).UInt32.*=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).UInt32./=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).UInt32.dividedReportingOverflow(by:UInt32)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt32.dividedReportingOverflow(by:UInt32) in ' + this.constructor.name
}
/*Swift.(file).UInt32.remainderReportingOverflow(dividingBy:UInt32)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt32.remainderReportingOverflow(dividingBy:UInt32) in ' + this.constructor.name
}
/*Swift.(file).UInt32.addingReportingOverflow(_:UInt32)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt32.addingReportingOverflow(_:UInt32) in ' + this.constructor.name
}
/*Swift.(file).UInt32.subtractingReportingOverflow(_:UInt32)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt32.subtractingReportingOverflow(_:UInt32) in ' + this.constructor.name
}
/*Swift.(file).UInt32.multipliedReportingOverflow(by:UInt32)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt32.multipliedReportingOverflow(by:UInt32) in ' + this.constructor.name
}
static /*Swift.(file).UInt32.%=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).UInt32.init(_:Int32)*/
/*Swift.(file).UInt32.init(_:Int32)*/
initInt32(_value, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(_:Int32) in ' + this.constructor.name
}
static /*Swift.(file).UInt32.&=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).UInt32.|=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).UInt32.^=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).UInt32.&>>=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).UInt32.&<<=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).UInt32.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).UInt32.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt32.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).UInt32.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt32.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).UInt32.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt32.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).UInt32.Words.init(_:UInt32)*/
/*Swift.(file).UInt32.Words.init(_:UInt32)*/
initUInt32(value, $info?) {
throw 'unsupported method Swift.(file).UInt32.Words.init(_:UInt32) in ' + this.constructor.name
}

/*Swift.(file).UInt32.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).UInt32.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UInt32.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UInt32.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UInt32.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).UInt32.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).UInt32.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).UInt32.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt32.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).UInt32.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt32.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).UInt32.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).UInt32.words*/
words$get() {
throw 'unsupported variable Swift.(file).UInt32.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).UInt32.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(_truncatingBits:UInt) in ' + this.constructor.name
}

/*Swift.(file).UInt32.multipliedFullWidth(by:UInt32)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt32.multipliedFullWidth(by:UInt32) in ' + this.constructor.name
}
/*Swift.(file).UInt32.dividingFullWidth(_:(high: UInt32, low: UInt32.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).UInt32.dividingFullWidth(_:(high: UInt32, low: UInt32.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).UInt32.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).UInt32.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).UInt32.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}

/*Swift.(file).UInt32.init(_:Unicode.Scalar)*/
/*Swift.(file).UInt32.init(_:Unicode.Scalar)*/
initUnicodeScalar(v, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(_:Unicode.Scalar) in ' + this.constructor.name
}



/*Swift.(file).UInt32.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).UInt32.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).UInt32.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).UInt32.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).UInt32.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).UInt32.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).UInt32.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UInt32.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).UInt32.&infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).UInt32.|infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).UInt32.^infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).UInt32.&>>infix(_:UInt32,_:UInt32)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).UInt32.&<<infix(_:UInt32,_:UInt32)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).UInt32./infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).UInt32.%infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).UInt32.+infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).UInt32.-infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).UInt32.*infix(_:UInt32,_:UInt32)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).UInt32.<=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).UInt32.>=infix(_:UInt32,_:UInt32)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).UInt32.>infix(_:UInt32,_:UInt32)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).UInt32.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).UInt32.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).UInt32.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).UInt32.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt32.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt32.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt32.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt32.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt32.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt32.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt32.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt32.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt32.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt32.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt32.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt32.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt32.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt32.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt32.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt32.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt32.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt32.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt32.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt32.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt32.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt32.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt32.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt32.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt32.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_UInt32.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt32.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt32.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt32.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt32.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt32.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt32.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, FixedWidthInteger$implementation, false)
if(typeof UnsignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, UnsignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_UInt32, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_UInt32, true)
class UInt32{}
_mixin(UInt32, MIO_Mixin_UInt32, true)














class MIO_Mixin_Int32 implements FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).Int32.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).Int32.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Int32.init(bitPattern:UInt32)*/
/*Swift.(file).Int32.init(bitPattern:UInt32)*/
initBitPatternUInt32(x, $info?) {
throw 'unsupported method Swift.(file).Int32.init(bitPattern:UInt32) in ' + this.constructor.name
}
/*Swift.(file).Int32.init(bitPattern:Float)*/
/*Swift.(file).Int32.init(bitPattern:Float)*/
initBitPatternFloat(x, $info?) {
throw 'unsupported method Swift.(file).Int32.init(bitPattern:Float) in ' + this.constructor.name
}
/*Swift.(file).Int32.init(_:Float)*/
/*Swift.(file).Int32.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int32.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Int32.init(exactly:Float)*/
/*Swift.(file).Int32.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int32.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Int32.init(_:Double)*/
/*Swift.(file).Int32.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int32.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).Int32.init(exactly:Double)*/
/*Swift.(file).Int32.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int32.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Int32.init(_:Float80)*/
/*Swift.(file).Int32.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int32.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Int32.init(exactly:Float80)*/
/*Swift.(file).Int32.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int32.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Int32.==infix(_:Int32,_:Int32)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Int32.<infix(_:Int32,_:Int32)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).Int32.+=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Int32.-=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Int32.*=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Int32./=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).Int32.dividedReportingOverflow(by:Int32)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int32.dividedReportingOverflow(by:Int32) in ' + this.constructor.name
}
/*Swift.(file).Int32.remainderReportingOverflow(dividingBy:Int32)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Int32.remainderReportingOverflow(dividingBy:Int32) in ' + this.constructor.name
}
/*Swift.(file).Int32.addingReportingOverflow(_:Int32)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int32.addingReportingOverflow(_:Int32) in ' + this.constructor.name
}
/*Swift.(file).Int32.subtractingReportingOverflow(_:Int32)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int32.subtractingReportingOverflow(_:Int32) in ' + this.constructor.name
}
/*Swift.(file).Int32.multipliedReportingOverflow(by:Int32)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int32.multipliedReportingOverflow(by:Int32) in ' + this.constructor.name
}
static /*Swift.(file).Int32.%=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).Int32.init(_:Int32)*/
/*Swift.(file).Int32.init(_:Int32)*/
initInt32(_value, $info?) {
throw 'unsupported method Swift.(file).Int32.init(_:Int32) in ' + this.constructor.name
}
static /*Swift.(file).Int32.&=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).Int32.|=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).Int32.^=infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).Int32.&>>=infix(_:Int32,_:Int32)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).Int32.&<<=infix(_:Int32,_:Int32)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).Int32.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).Int32.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int32.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).Int32.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int32.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).Int32.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int32.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).Int32.Words.init(_:Int32)*/
/*Swift.(file).Int32.Words.init(_:Int32)*/
initInt32(value, $info?) {
throw 'unsupported method Swift.(file).Int32.Words.init(_:Int32) in ' + this.constructor.name
}

/*Swift.(file).Int32.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).Int32.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Int32.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Int32.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Int32.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).Int32.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).Int32.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Int32.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).Int32.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).Int32.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).Int32.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Int32.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).Int32.words*/
words$get() {
throw 'unsupported variable Swift.(file).Int32.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).Int32.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).Int32.init(_truncatingBits:UInt) in ' + this.constructor.name
}


/*Swift.(file).Int32.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Int32.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



/*Swift.(file).Int32.multipliedFullWidth(by:Int32)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).Int32.multipliedFullWidth(by:Int32) in ' + this.constructor.name
}
/*Swift.(file).Int32.dividingFullWidth(_:(high: Int32, low: Int32.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).Int32.dividingFullWidth(_:(high: Int32, low: Int32.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).Int32.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).Int32.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).Int32.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}




/*Swift.(file).Int32.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Int32.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Int32.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Int32.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Int32.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Int32.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Int32.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Int32.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).Int32.&infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).Int32.|infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).Int32.^infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).Int32.&>>infix(_:Int32,_:Int32)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).Int32.&<<infix(_:Int32,_:Int32)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).Int32./infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).Int32.%infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).Int32.+infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Int32.-infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Int32.*infix(_:Int32,_:Int32)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Int32.<=infix(_:Int32,_:Int32)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).Int32.>=infix(_:Int32,_:Int32)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).Int32.>infix(_:Int32,_:Int32)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).Int32.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Int32.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Int32.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Int32.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int32.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int32.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int32.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int32.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int32.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int32.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int32.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int32.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int32.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int32.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int32.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int32.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int32.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int32.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int32.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int32.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int32.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int32.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int32.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int32.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int32.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int32.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int32.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int32.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int32.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int32.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int32.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int32.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int32.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int32.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int32.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_Int32.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int32.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int32.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int32.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int32.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int32.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int32.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int32, FixedWidthInteger$implementation, false)
if(typeof SignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int32, SignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Int32, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_Int32, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Int32, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Int32, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Int32, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Int32, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Int32, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_Int32, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_Int32, true)
class Int32{}
_mixin(Int32, MIO_Mixin_Int32, true)














class MIO_Mixin_UInt64 implements FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral, CVarArg, _CVarArgAligned, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).UInt64.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).UInt64.init(bitPattern:Int64)*/
/*Swift.(file).UInt64.init(bitPattern:Int64)*/
initBitPatternInt64(x, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(bitPattern:Int64) in ' + this.constructor.name
}
/*Swift.(file).UInt64.init(_:Float)*/
/*Swift.(file).UInt64.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).UInt64.init(exactly:Float)*/
/*Swift.(file).UInt64.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).UInt64.init(_:Double)*/
/*Swift.(file).UInt64.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).UInt64.init(exactly:Double)*/
/*Swift.(file).UInt64.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).UInt64.init(_:Float80)*/
/*Swift.(file).UInt64.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).UInt64.init(exactly:Float80)*/
/*Swift.(file).UInt64.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).UInt64.==infix(_:UInt64,_:UInt64)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).UInt64.<infix(_:UInt64,_:UInt64)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).UInt64.+=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).UInt64.-=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).UInt64.*=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).UInt64./=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).UInt64.dividedReportingOverflow(by:UInt64)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt64.dividedReportingOverflow(by:UInt64) in ' + this.constructor.name
}
/*Swift.(file).UInt64.remainderReportingOverflow(dividingBy:UInt64)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt64.remainderReportingOverflow(dividingBy:UInt64) in ' + this.constructor.name
}
/*Swift.(file).UInt64.addingReportingOverflow(_:UInt64)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt64.addingReportingOverflow(_:UInt64) in ' + this.constructor.name
}
/*Swift.(file).UInt64.subtractingReportingOverflow(_:UInt64)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt64.subtractingReportingOverflow(_:UInt64) in ' + this.constructor.name
}
/*Swift.(file).UInt64.multipliedReportingOverflow(by:UInt64)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt64.multipliedReportingOverflow(by:UInt64) in ' + this.constructor.name
}
static /*Swift.(file).UInt64.%=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).UInt64.init(_:Int64)*/
/*Swift.(file).UInt64.init(_:Int64)*/
initInt64(_value, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(_:Int64) in ' + this.constructor.name
}
static /*Swift.(file).UInt64.&=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).UInt64.|=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).UInt64.^=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).UInt64.&>>=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).UInt64.&<<=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).UInt64.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).UInt64.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt64.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).UInt64.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt64.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).UInt64.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt64.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).UInt64.Words.init(_:UInt64)*/
/*Swift.(file).UInt64.Words.init(_:UInt64)*/
initUInt64(value, $info?) {
throw 'unsupported method Swift.(file).UInt64.Words.init(_:UInt64) in ' + this.constructor.name
}

/*Swift.(file).UInt64.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).UInt64.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UInt64.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UInt64.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UInt64.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).UInt64.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).UInt64.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).UInt64.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt64.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).UInt64.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt64.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).UInt64.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).UInt64.words*/
words$get() {
throw 'unsupported variable Swift.(file).UInt64.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).UInt64.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(_truncatingBits:UInt) in ' + this.constructor.name
}

/*Swift.(file).UInt64.multipliedFullWidth(by:UInt64)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt64.multipliedFullWidth(by:UInt64) in ' + this.constructor.name
}
/*Swift.(file).UInt64.dividingFullWidth(_:(high: UInt64, low: UInt64.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).UInt64.dividingFullWidth(_:(high: UInt64, low: UInt64.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).UInt64.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).UInt64.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).UInt64.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}

/*Swift.(file).UInt64.init(_:Unicode.Scalar)*/
/*Swift.(file).UInt64.init(_:Unicode.Scalar)*/
initUnicodeScalar(v, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(_:Unicode.Scalar) in ' + this.constructor.name
}








/*Swift.(file).UInt64.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).UInt64.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).UInt64.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).UInt64.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).UInt64.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).UInt64.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).UInt64.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UInt64.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).UInt64.&infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).UInt64.|infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).UInt64.^infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).UInt64.&>>infix(_:UInt64,_:UInt64)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).UInt64.&<<infix(_:UInt64,_:UInt64)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).UInt64./infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).UInt64.%infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).UInt64.+infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).UInt64.-infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).UInt64.*infix(_:UInt64,_:UInt64)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).UInt64.<=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).UInt64.>=infix(_:UInt64,_:UInt64)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).UInt64.>infix(_:UInt64,_:UInt64)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).UInt64.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).UInt64.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).UInt64.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).UInt64.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt64.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt64.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt64.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt64.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt64.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt64.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt64.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt64.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt64.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt64.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt64.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt64.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt64.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt64.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt64.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt64.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt64.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt64.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt64.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt64.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt64.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt64.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt64.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt64.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt64.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_UInt64.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt64.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt64.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt64.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt64.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt64.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt64.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, FixedWidthInteger$implementation, false)
if(typeof UnsignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, UnsignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, CVarArg$implementation, false)
if(typeof _CVarArgAligned$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, _CVarArgAligned$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_UInt64, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_UInt64, true)
class UInt64{}
_mixin(UInt64, MIO_Mixin_UInt64, true)














class MIO_Mixin_Int64 implements FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral, CVarArg, _CVarArgAligned, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).Int64.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).Int64.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Int64.init(bitPattern:UInt64)*/
/*Swift.(file).Int64.init(bitPattern:UInt64)*/
initBitPatternUInt64(x, $info?) {
throw 'unsupported method Swift.(file).Int64.init(bitPattern:UInt64) in ' + this.constructor.name
}
/*Swift.(file).Int64.init(bitPattern:Double)*/
/*Swift.(file).Int64.init(bitPattern:Double)*/
initBitPatternDouble(x, $info?) {
throw 'unsupported method Swift.(file).Int64.init(bitPattern:Double) in ' + this.constructor.name
}
/*Swift.(file).Int64.init(_:Float)*/
/*Swift.(file).Int64.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int64.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Int64.init(exactly:Float)*/
/*Swift.(file).Int64.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int64.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Int64.init(_:Double)*/
/*Swift.(file).Int64.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int64.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).Int64.init(exactly:Double)*/
/*Swift.(file).Int64.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int64.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Int64.init(_:Float80)*/
/*Swift.(file).Int64.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int64.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Int64.init(exactly:Float80)*/
/*Swift.(file).Int64.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int64.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Int64.==infix(_:Int64,_:Int64)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Int64.<infix(_:Int64,_:Int64)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).Int64.+=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Int64.-=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Int64.*=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Int64./=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).Int64.dividedReportingOverflow(by:Int64)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int64.dividedReportingOverflow(by:Int64) in ' + this.constructor.name
}
/*Swift.(file).Int64.remainderReportingOverflow(dividingBy:Int64)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Int64.remainderReportingOverflow(dividingBy:Int64) in ' + this.constructor.name
}
/*Swift.(file).Int64.addingReportingOverflow(_:Int64)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int64.addingReportingOverflow(_:Int64) in ' + this.constructor.name
}
/*Swift.(file).Int64.subtractingReportingOverflow(_:Int64)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int64.subtractingReportingOverflow(_:Int64) in ' + this.constructor.name
}
/*Swift.(file).Int64.multipliedReportingOverflow(by:Int64)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int64.multipliedReportingOverflow(by:Int64) in ' + this.constructor.name
}
static /*Swift.(file).Int64.%=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).Int64.init(_:Int64)*/
/*Swift.(file).Int64.init(_:Int64)*/
initInt64(_value, $info?) {
throw 'unsupported method Swift.(file).Int64.init(_:Int64) in ' + this.constructor.name
}
static /*Swift.(file).Int64.&=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).Int64.|=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).Int64.^=infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).Int64.&>>=infix(_:Int64,_:Int64)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).Int64.&<<=infix(_:Int64,_:Int64)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).Int64.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).Int64.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int64.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).Int64.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int64.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).Int64.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int64.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).Int64.Words.init(_:Int64)*/
/*Swift.(file).Int64.Words.init(_:Int64)*/
initInt64(value, $info?) {
throw 'unsupported method Swift.(file).Int64.Words.init(_:Int64) in ' + this.constructor.name
}

/*Swift.(file).Int64.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).Int64.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Int64.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Int64.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Int64.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).Int64.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).Int64.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Int64.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).Int64.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).Int64.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).Int64.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Int64.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).Int64.words*/
words$get() {
throw 'unsupported variable Swift.(file).Int64.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).Int64.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).Int64.init(_truncatingBits:UInt) in ' + this.constructor.name
}


/*Swift.(file).Int64.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Int64.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



/*Swift.(file).Int64.multipliedFullWidth(by:Int64)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).Int64.multipliedFullWidth(by:Int64) in ' + this.constructor.name
}
/*Swift.(file).Int64.dividingFullWidth(_:(high: Int64, low: Int64.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).Int64.dividingFullWidth(_:(high: Int64, low: Int64.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).Int64.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).Int64.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).Int64.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}







/*Swift.(file).Int64.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Int64.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Int64.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Int64.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Int64.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Int64.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Int64.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Int64.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).Int64.&infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).Int64.|infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).Int64.^infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).Int64.&>>infix(_:Int64,_:Int64)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).Int64.&<<infix(_:Int64,_:Int64)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).Int64./infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).Int64.%infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).Int64.+infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Int64.-infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Int64.*infix(_:Int64,_:Int64)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Int64.<=infix(_:Int64,_:Int64)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).Int64.>=infix(_:Int64,_:Int64)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).Int64.>infix(_:Int64,_:Int64)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).Int64.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Int64.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Int64.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Int64.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int64.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int64.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int64.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int64.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int64.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int64.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int64.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int64.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int64.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int64.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int64.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int64.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int64.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int64.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int64.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int64.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int64.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int64.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int64.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int64.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int64.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int64.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int64.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int64.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int64.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int64.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int64.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int64.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int64.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int64.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int64.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_Int64.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int64.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int64.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int64.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int64.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int64.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int64.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int64, FixedWidthInteger$implementation, false)
if(typeof SignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int64, SignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Int64, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_Int64, CVarArg$implementation, false)
if(typeof _CVarArgAligned$implementation != 'undefined') _mixin(MIO_Mixin_Int64, _CVarArgAligned$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Int64, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Int64, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Int64, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Int64, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Int64, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_Int64, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_Int64, true)
class Int64{}
_mixin(Int64, MIO_Mixin_Int64, true)














class MIO_Mixin_UInt implements FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).UInt.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).UInt.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).UInt.init(bitPattern:Int)*/
/*Swift.(file).UInt.init(bitPattern:Int)*/
initBitPatternInt(x, $info?) {
throw 'unsupported method Swift.(file).UInt.init(bitPattern:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt.init(_:Float)*/
/*Swift.(file).UInt.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).UInt.init(exactly:Float)*/
/*Swift.(file).UInt.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).UInt.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).UInt.init(_:Double)*/
/*Swift.(file).UInt.init(_:Double)*/
initDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt.init(_:Double) in ' + this.constructor.name
}
/*Swift.(file).UInt.init(exactly:Double)*/
/*Swift.(file).UInt.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).UInt.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).UInt.init(_:Float80)*/
/*Swift.(file).UInt.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).UInt.init(exactly:Float80)*/
/*Swift.(file).UInt.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).UInt.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).UInt.==infix(_:UInt,_:UInt)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).UInt.<infix(_:UInt,_:UInt)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).UInt.+=infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).UInt.-=infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).UInt.*=infix(_:UInt,_:UInt)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).UInt./=infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).UInt.dividedReportingOverflow(by:UInt)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt.dividedReportingOverflow(by:UInt) in ' + this.constructor.name
}
/*Swift.(file).UInt.remainderReportingOverflow(dividingBy:UInt)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt.remainderReportingOverflow(dividingBy:UInt) in ' + this.constructor.name
}
/*Swift.(file).UInt.addingReportingOverflow(_:UInt)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt.addingReportingOverflow(_:UInt) in ' + this.constructor.name
}
/*Swift.(file).UInt.subtractingReportingOverflow(_:UInt)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).UInt.subtractingReportingOverflow(_:UInt) in ' + this.constructor.name
}
/*Swift.(file).UInt.multipliedReportingOverflow(by:UInt)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt.multipliedReportingOverflow(by:UInt) in ' + this.constructor.name
}
static /*Swift.(file).UInt.%=infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).UInt.init(_:Int64)*/
/*Swift.(file).UInt.init(_:Int64)*/
initInt64(_value, $info?) {
throw 'unsupported method Swift.(file).UInt.init(_:Int64) in ' + this.constructor.name
}
static /*Swift.(file).UInt.&=infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).UInt.|=infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).UInt.^=infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).UInt.&>>=infix(_:UInt,_:UInt)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).UInt.&<<=infix(_:UInt,_:UInt)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).UInt.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).UInt.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).UInt.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).UInt.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).UInt.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).UInt.Words.init(_:UInt)*/
/*Swift.(file).UInt.Words.init(_:UInt)*/
initUInt(value, $info?) {
throw 'unsupported method Swift.(file).UInt.Words.init(_:UInt) in ' + this.constructor.name
}

/*Swift.(file).UInt.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).UInt.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UInt.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UInt.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UInt.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).UInt.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).UInt.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).UInt.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).UInt.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).UInt.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).UInt.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).UInt.words*/
words$get() {
throw 'unsupported variable Swift.(file).UInt.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).UInt.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).UInt.init(_truncatingBits:UInt) in ' + this.constructor.name
}

/*Swift.(file).UInt.multipliedFullWidth(by:UInt)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).UInt.multipliedFullWidth(by:UInt) in ' + this.constructor.name
}
/*Swift.(file).UInt.dividingFullWidth(_:(high: UInt, low: UInt.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).UInt.dividingFullWidth(_:(high: UInt, low: UInt.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).UInt.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).UInt.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).UInt.init(_:Word)*/
/*Swift.(file).UInt.init(_:Word)*/
initWord(_v, $info?) {
throw 'unsupported method Swift.(file).UInt.init(_:Word) in ' + this.constructor.name
}



/*Swift.(file).UInt.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}

/*Swift.(file).UInt.init(bitPattern:OpaquePointer?)*/
/*Swift.(file).UInt.init(bitPattern:OpaquePointer?)*/
initBitPatternOptional(pointer, $info?) {
let _this = this;
_this.initBitPatternOptional(_create(UnsafeRawPointer, 'initOptional', pointer, {}));
return
}
/*Swift.(file).UInt.init(bitPattern:ObjectIdentifier)*/
/*Swift.(file).UInt.init(bitPattern:ObjectIdentifier)*/
initBitPatternObjectIdentifier(objectID, $info?) {
throw 'unsupported method Swift.(file).UInt.init(bitPattern:ObjectIdentifier) in ' + this.constructor.name
}
/*Swift.(file).UInt.init(bitPattern:P?)*/
/*Swift.(file).UInt.init(bitPattern:P?)*/
/*!!!DUPLICATE NAME*/
initBitPatternOptional<P>(pointer, $info?) {
throw 'unsupported method Swift.(file).UInt.init(bitPattern:P?) in ' + this.constructor.name
}



/*Swift.(file).UInt.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).UInt.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).UInt.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).UInt.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).UInt.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).UInt.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).UInt.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).UInt.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).UInt.&infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).UInt.|infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).UInt.^infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).UInt.&>>infix(_:UInt,_:UInt)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).UInt.&<<infix(_:UInt,_:UInt)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).UInt./infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).UInt.%infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).UInt.+infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).UInt.-infix(_:UInt,_:UInt)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).UInt.*infix(_:UInt,_:UInt)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).UInt.<=infix(_:UInt,_:UInt)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).UInt.>=infix(_:UInt,_:UInt)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).UInt.>infix(_:UInt,_:UInt)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}

/*Swift.(file).UInt.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).UInt.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).UInt.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).UInt.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).UInt.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).UInt.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).UInt.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).UInt.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UInt.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).UInt.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_UInt.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_UInt.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt, FixedWidthInteger$implementation, false)
if(typeof UnsignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_UInt, UnsignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_UInt, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_UInt, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_UInt, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_UInt, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_UInt, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_UInt, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_UInt, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_UInt, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_UInt, true)
class UInt{}
_mixin(UInt, MIO_Mixin_UInt, true)














class MIO_Mixin_Int implements FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral, MirrorPath, CVarArg, Codable, Hashable, _HasCustomAnyHashableRepresentation, CustomReflectable, _CustomPlaygroundQuickLookable, SIMDScalar{
static readonly $struct = true
static readonly $mixin = true

/*Swift.(file).Int.init(_builtinIntegerLiteral:IntLiteral)*/
/*Swift.(file)._ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:IntLiteral)*/
init_builtinIntegerLiteralIntLiteral(x, $info?) {
throw 'unsupported method Swift.(file).Int.init(_builtinIntegerLiteral:IntLiteral) in ' + this.constructor.name
}
/*Swift.(file).Int.init(bitPattern:UInt)*/
/*Swift.(file).Int.init(bitPattern:UInt)*/
initBitPatternUInt(x, $info?) {
throw 'unsupported method Swift.(file).Int.init(bitPattern:UInt) in ' + this.constructor.name
}
/*Swift.(file).Int.init(_:Float)*/
/*Swift.(file).Int.init(_:Float)*/
initFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int.init(_:Float) in ' + this.constructor.name
}
/*Swift.(file).Int.init(exactly:Float)*/
/*Swift.(file).Int.init(exactly:Float)*/
initExactlyFloat(source, $info?) {
throw 'unsupported method Swift.(file).Int.init(exactly:Float) in ' + this.constructor.name
}
static readonly initExactlyFloat$failable = true
/*Swift.(file).Int.init(_:Double)*/
/*Swift.(file).Int.init(_:Double)*/
initDouble(source, $info?) {
return source | 0
}
/*Swift.(file).Int.init(exactly:Double)*/
/*Swift.(file).Int.init(exactly:Double)*/
initExactlyDouble(source, $info?) {
throw 'unsupported method Swift.(file).Int.init(exactly:Double) in ' + this.constructor.name
}
static readonly initExactlyDouble$failable = true
/*Swift.(file).Int.init(_:Float80)*/
/*Swift.(file).Int.init(_:Float80)*/
initFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int.init(_:Float80) in ' + this.constructor.name
}
/*Swift.(file).Int.init(exactly:Float80)*/
/*Swift.(file).Int.init(exactly:Float80)*/
initExactlyFloat80(source, $info?) {
throw 'unsupported method Swift.(file).Int.init(exactly:Float80) in ' + this.constructor.name
}
static readonly initExactlyFloat80$failable = true
static /*Swift.(file).Int.==infix(_:Int,_:Int)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).Int.<infix(_:Int,_:Int)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
static /*Swift.(file).Int.+=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)*/
$addAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() + rhs)
}
static /*Swift.(file).Int.-=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)*/
$subtractAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() - rhs)
}
static /*Swift.(file).Int.*=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*=infix(_:Self,_:Self)*/
$multiplyAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() * rhs)
}
static /*Swift.(file).Int./=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger./=infix(_:Self,_:Self)*/
$divideAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set((lhs$inout.get() / rhs) | 0)
}
/*Swift.(file).Int.dividedReportingOverflow(by:Int)*/
/*Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)*/
dividedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int.dividedReportingOverflow(by:Int) in ' + this.constructor.name
}
/*Swift.(file).Int.remainderReportingOverflow(dividingBy:Int)*/
/*Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)*/
remainderReportingOverflowDividingBy(other, $info?) {
throw 'unsupported method Swift.(file).Int.remainderReportingOverflow(dividingBy:Int) in ' + this.constructor.name
}
/*Swift.(file).Int.addingReportingOverflow(_:Int)*/
/*Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)*/
addingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int.addingReportingOverflow(_:Int) in ' + this.constructor.name
}
/*Swift.(file).Int.subtractingReportingOverflow(_:Int)*/
/*Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)*/
subtractingReportingOverflow(other, $info?) {
throw 'unsupported method Swift.(file).Int.subtractingReportingOverflow(_:Int) in ' + this.constructor.name
}
/*Swift.(file).Int.multipliedReportingOverflow(by:Int)*/
/*Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)*/
multipliedReportingOverflowBy(other, $info?) {
throw 'unsupported method Swift.(file).Int.multipliedReportingOverflow(by:Int) in ' + this.constructor.name
}
static /*Swift.(file).Int.%=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)*/
$remainderAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() % rhs)
}
/*Swift.(file).Int.init(_:Int64)*/
/*Swift.(file).Int.init(_:Int64)*/
initInt64(_value, $info?) {
throw 'unsupported method Swift.(file).Int.init(_:Int64) in ' + this.constructor.name
}
static /*Swift.(file).Int.&=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)*/
$bitwiseANDAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() & rhs)
}
static /*Swift.(file).Int.|=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)*/
$bitwiseORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() | rhs)
}
static /*Swift.(file).Int.^=infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)*/
$bitwiseXORAndAssign(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() ^ rhs)
}
static /*Swift.(file).Int.&>>=infix(_:Int,_:Int)*/
/*Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)*/
infix_38_62_62_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() >> rhs)
}
static /*Swift.(file).Int.&<<=infix(_:Int,_:Int)*/
/*Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)*/
infix_38_60_60_61(lhs$inout, rhs, $info?) {
lhs$inout.set(lhs$inout.get() << rhs)
}

/*Swift.(file).Int.bitWidth*/
static bitWidth$get() {
let _this = this;
return _this.constructor.bitWidth
}
static get bitWidth() { return this.bitWidth$get() };




/*Swift.(file).Int.leadingZeroBitCount*/
leadingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int.leadingZeroBitCount in ' + this.constructor.name
}
get leadingZeroBitCount() { return this.leadingZeroBitCount$get() };




/*Swift.(file).Int.trailingZeroBitCount*/
trailingZeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int.trailingZeroBitCount in ' + this.constructor.name
}
get trailingZeroBitCount() { return this.trailingZeroBitCount$get() };




/*Swift.(file).Int.nonzeroBitCount*/
nonzeroBitCount$get() {
throw 'unsupported variable Swift.(file).Int.nonzeroBitCount in ' + this.constructor.name
}
get nonzeroBitCount() { return this.nonzeroBitCount$get() };



static Words = class implements RandomAccessCollection{
static readonly $struct = true







/*Swift.(file).Int.Words.init(_:Int)*/
/*Swift.(file).Int.Words.init(_:Int)*/
initInt(value, $info?) {
throw 'unsupported method Swift.(file).Int.Words.init(_:Int) in ' + this.constructor.name
}

/*Swift.(file).Int.Words.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).Int.Words.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).Int.Words.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Int.Words.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).Int.Words.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).Int.Words.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).Int.Words.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).Int.Words.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).Int.Words.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).Int.Words.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).Int.Words.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).Int.Words.subscript(_:Int) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}

/*Swift.(file).Int.words*/
words$get() {
throw 'unsupported variable Swift.(file).Int.words in ' + this.constructor.name
}
get words() { return this.words$get() };






/*Swift.(file).Int.init(_truncatingBits:UInt)*/
/*Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)*/
init_truncatingBitsUInt(bits, $info?) {
throw 'unsupported method Swift.(file).Int.init(_truncatingBits:UInt) in ' + this.constructor.name
}


/*Swift.(file).Int.magnitude*/
magnitude$get() {
throw 'unsupported variable Swift.(file).Int.magnitude in ' + this.constructor.name
}
get magnitude() { return this.magnitude$get() };



/*Swift.(file).Int.multipliedFullWidth(by:Int)*/
/*Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)*/
multipliedFullWidthBy(other, $info?) {
throw 'unsupported method Swift.(file).Int.multipliedFullWidth(by:Int) in ' + this.constructor.name
}
/*Swift.(file).Int.dividingFullWidth(_:(high: Int, low: Int.Magnitude))*/
/*Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))*/
dividingFullWidth(dividend, $info?) {
throw 'unsupported method Swift.(file).Int.dividingFullWidth(_:(high: Int, low: Int.Magnitude)) in ' + this.constructor.name
}

/*Swift.(file).Int.byteSwapped*/
byteSwapped$get() {
throw 'unsupported variable Swift.(file).Int.byteSwapped in ' + this.constructor.name
}
get byteSwapped() { return this.byteSwapped$get() };








/*Swift.(file).Int.init(_:Word)*/
/*Swift.(file).Int.init(_:Word)*/
initWord(_v, $info?) {
throw 'unsupported method Swift.(file).Int.init(_:Word) in ' + this.constructor.name
}



/*Swift.(file).Int.signum()*/
/*Swift.(file).BinaryInteger.signum()*/
signum($info?) {
let _this = this;
return _this.constructor.$subtract((_this.constructor.$greaterThan(_this, 0) ? 1 : 0), (_this.constructor.$lessThan(_this, 0) ? 1 : 0))
}

/*Swift.(file).Int.init(bitPattern:OpaquePointer?)*/
/*Swift.(file).Int.init(bitPattern:OpaquePointer?)*/
initBitPatternOptional(pointer, $info?) {
let _this = this;
_this.initBitPatternOptional(_create(UnsafeRawPointer, 'initOptional', pointer, {}));
return
}
/*Swift.(file).Int.init(bitPattern:ObjectIdentifier)*/
/*Swift.(file).Int.init(bitPattern:ObjectIdentifier)*/
initBitPatternObjectIdentifier(objectID, $info?) {
let _this = this;
_this.initBitPatternUInt(_create(UInt, 'initBitPatternObjectIdentifier', objectID, {}));
return
}
/*Swift.(file).Int.init(bitPattern:P?)*/
/*Swift.(file).Int.init(bitPattern:P?)*/
/*!!!DUPLICATE NAME*/
initBitPatternOptional<P>(pointer, $info?) {
throw 'unsupported method Swift.(file).Int.init(bitPattern:P?) in ' + this.constructor.name
}



/*Swift.(file).Int.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Int.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).Int.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Int.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Int.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).Int.hash(into:Hasher) in ' + this.constructor.name
}




/*Swift.(file).Int.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Int.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


static /*Swift.(file).Int.&infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.&infix(_:Self,_:Self)*/
$bitwiseAND(lhs, rhs, $info?) {
return lhs & rhs
}
static /*Swift.(file).Int.|infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.|infix(_:Self,_:Self)*/
$bitwiseOR(lhs, rhs, $info?) {
return lhs | rhs
}
static /*Swift.(file).Int.^infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.^infix(_:Self,_:Self)*/
$bitwiseXOR(lhs, rhs, $info?) {
return lhs ^ rhs
}
static /*Swift.(file).Int.&>>infix(_:Int,_:Int)*/
/*Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)*/
infix_38_62_62(lhs, rhs, $info?) {
return lhs >> rhs
}
static /*Swift.(file).Int.&<<infix(_:Int,_:Int)*/
/*Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)*/
infix_38_60_60(lhs, rhs, $info?) {
return lhs << rhs
}
static /*Swift.(file).Int./infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger./infix(_:Self,_:Self)*/
$divide(lhs, rhs, $info?) {
return (lhs / rhs) | 0
}
static /*Swift.(file).Int.%infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.%infix(_:Self,_:Self)*/
$remainder(lhs, rhs, $info?) {
return lhs % rhs
}
static /*Swift.(file).Int.+infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.+infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)*/
$add(lhs, rhs, $info?) {
return lhs + rhs
}
static /*Swift.(file).Int.-infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.-infix(_:Self,_:Self)*/
/*Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)*/
$subtract(lhs, rhs, $info?) {
return lhs - rhs
}
static /*Swift.(file).Int.*infix(_:Int,_:Int)*/
/*Swift.(file).BinaryInteger.*infix(_:Self,_:Self)*/
/*Swift.(file).Numeric.*infix(_:Self,_:Self)*/
$multiply(lhs, rhs, $info?) {
return lhs * rhs
}
static /*Swift.(file).Int.<=infix(_:Int,_:Int)*/
/*Swift.(file).Comparable.<=infix(_:Self,_:Self)*/
$lessThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs))
}
static /*Swift.(file).Int.>=infix(_:Int,_:Int)*/
/*Swift.(file).Comparable.>=infix(_:Self,_:Self)*/
$greaterThanOrEqual(lhs, rhs, $info?) {
let _this = this;
return Bool.$not((_.arg0 = lhs).constructor.$lessThan(_.arg0, rhs))
}
static /*Swift.(file).Int.>infix(_:Int,_:Int)*/
/*Swift.(file).Comparable.>infix(_:Self,_:Self)*/
$greaterThan(lhs, rhs, $info?) {
let _this = this;
return (_.arg0 = rhs).constructor.$lessThan(_.arg0, lhs)
}
/*Swift.(file).Int.distance(to:Int)*/
/*Swift.(file).Strideable.distance(to:Self)*/
distanceTo(other, $info?) {
let _this = this;
return Int.$subtract(other, _this)
}
/*Swift.(file).Int.advanced(by:Int)*/
/*Swift.(file).Strideable.advanced(by:Self.Stride)*/
advancedBy(n, $info?) {
let _this = this;
return Int.$add(_this, n)
}

/*Swift.(file).Int.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).Int.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Int.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).Int.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };




static SIMD2Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int.SIMD2Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int.SIMD2Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int.SIMD2Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int.SIMD2Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD2Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD4Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int.SIMD4Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int.SIMD4Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int.SIMD4Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int.SIMD4Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD4Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD8Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int.SIMD8Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int.SIMD8Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int.SIMD8Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int.SIMD8Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD8Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD16Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int.SIMD16Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int.SIMD16Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int.SIMD16Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int.SIMD16Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD16Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD32Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int.SIMD32Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int.SIMD32Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int.SIMD32Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int.SIMD32Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD32Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
static SIMD64Storage = class implements SIMDStorage{
static readonly $struct = true






/*Swift.(file).Int.SIMD64Storage.scalarCount*/
scalarCount$get() {
let _this = this;
return _create(_this, 'init', {}).scalarCount;
}
static get scalarCount() { return this.scalarCount$get()
}
get scalarCount() { return this.scalarCount$get() };



/*Swift.(file).Int.SIMD64Storage.init()*/
/*Swift.(file).SIMDStorage.init()*/
init($info?) {
throw 'unsupported method Swift.(file).Int.SIMD64Storage.init() in ' + this.constructor.name
}
/*Swift.(file).Int.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).Int.SIMD64Storage.subscript(_:Int)*/
/*Swift.(file).SIMDStorage.subscript(_:Int)*/
subscript$set(newValue, index, $info?) {
throw 'unsupported method Swift.(file).Int.SIMD64Storage.subscript(_:Int) in ' + this.constructor.name
}




init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_Int.Words, RandomAccessCollection$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int.SIMD2Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int.SIMD4Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int.SIMD8Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int.SIMD16Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int.SIMD32Storage, SIMDStorage$implementation, false)
if(typeof SIMDStorage$implementation != 'undefined') _mixin(MIO_Mixin_Int.SIMD64Storage, SIMDStorage$implementation, false)
if(typeof FixedWidthInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int, FixedWidthInteger$implementation, false)
if(typeof SignedInteger$implementation != 'undefined') _mixin(MIO_Mixin_Int, SignedInteger$implementation, false)
if(typeof _ExpressibleByBuiltinIntegerLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Int, _ExpressibleByBuiltinIntegerLiteral$implementation, false)
if(typeof MirrorPath$implementation != 'undefined') _mixin(MIO_Mixin_Int, MirrorPath$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(MIO_Mixin_Int, CVarArg$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_Int, Codable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Int, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Int, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Int, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_Int, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof SIMDScalar$implementation != 'undefined') _mixin(MIO_Mixin_Int, SIMDScalar$implementation, false)
_mixin(Number, MIO_Mixin_Int, true)
class Int{}
_mixin(Int, MIO_Mixin_Int, true)
















class UnsafeMutableBufferPointer<Element> implements _HasContiguousBytes, Sequence, MutableCollection, RandomAccessCollection, CustomDebugStringConvertible{
static readonly $struct = true




/*Swift.(file).UnsafeMutableBufferPointer.count*/
readonly count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
readonly get count() { return this.count$get() };



/*Swift.(file).UnsafeMutableBufferPointer.init(_position:UnsafeMutablePointer<Element>?,count:Int)*/
/*Swift.(file).UnsafeMutableBufferPointer.init(_position:UnsafeMutablePointer<Element>?,count:Int)*/
init_positionOptionalCountInt(_position, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.init(_position:UnsafeMutablePointer<Element>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
const ptr = _create(UnsafeRawPointer, 'initOptional', _this.baseAddress, {});
const len = Int.$multiplyIgnoringOverflow(_this.count, MemoryLayout.stride);
return body(_create(UnsafeRawBufferPointer, 'initStartOptionalCountInt', ptr, len, {}))
}





/*Swift.(file).UnsafeMutableBufferPointer.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}




/*Swift.(file).UnsafeMutableBufferPointer.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableBufferPointer.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UnsafeMutableBufferPointer.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableBufferPointer.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).UnsafeMutableBufferPointer.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.formIndex(after:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).UnsafeMutableBufferPointer.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.formIndex(before:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).UnsafeMutableBufferPointer.index(_:Int,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).UnsafeMutableBufferPointer.index(_:Int,offsetBy:Int,limitedBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
const l = _this.distanceFromTo(i, limit);
if(((Int.$greaterThan(distance, 0) ? Bool.$logicalAND(Int.$greaterThanOrEqual(l, 0), () => Int.$lessThan(l, distance)) : Bool.$logicalAND(Int.$lessThanOrEqual(l, 0), () => Int.$lessThan(distance, l))))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.indexOffsetBy(i, distance))
}
/*Swift.(file).UnsafeMutableBufferPointer.distance(from:Int,to:Int)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}



/*Swift.(file).UnsafeMutableBufferPointer.indices*/
indices$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex)
}
get indices() { return this.indices$get() };



/*Swift.(file).UnsafeMutableBufferPointer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UnsafeMutableBufferPointer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$_modify(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.subscript(_:Int) in ' + this.constructor.name
}




/*Swift.(file).UnsafeMutableBufferPointer.subscript(_unchecked:Int)*/
/*Swift.(file).UnsafeMutableBufferPointer.subscript(_unchecked:Int)*/
subscript_unchecked$get(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.subscript(_unchecked:Int) in ' + this.constructor.name
}/*Swift.(file).UnsafeMutableBufferPointer.subscript(_unchecked:Int)*/
/*Swift.(file).UnsafeMutableBufferPointer.subscript(_unchecked:Int)*/
subscript_unchecked$_modify(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.subscript(_unchecked:Int) in ' + this.constructor.name
}



/*Swift.(file).UnsafeMutableBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}/*Swift.(file).UnsafeMutableBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(newValue, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}



/*Swift.(file).UnsafeMutableBufferPointer.swapAt(_:Int,_:Int)*/
/*Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)*/
swapAt(i, j, $info?) {
let _this = this;
if(!(((_.arg0 = i).constructor.$notEqual(_.arg0, j)))) {
return ;
};
const tmp = _this.subscript$get(i);
_this.subscript$set(_this.subscript$get(j), i, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.subscript$set(tmp, j, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}


/*Swift.(file).UnsafeMutableBufferPointer.init(start:UnsafeMutablePointer<Element>?,count:Int)*/
/*Swift.(file).UnsafeMutableBufferPointer.init(start:UnsafeMutablePointer<Element>?,count:Int)*/
initStartOptionalCountInt(start, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.init(start:UnsafeMutablePointer<Element>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.init(_empty:())*/
/*Swift.(file).UnsafeMutableBufferPointer.init(_empty:())*/
init_emptytuple_type(_empty, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.init(_empty:()) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.init(mutating:UnsafeBufferPointer<Element>)*/
/*Swift.(file).UnsafeMutableBufferPointer.init(mutating:UnsafeBufferPointer<Element>)*/
initMutatingUnsafeBufferPointer(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.init(mutating:UnsafeBufferPointer<Element>) in ' + this.constructor.name
}

/*Swift.(file).UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withContiguousMutableStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(null)
}
/*Swift.(file).UnsafeMutableBufferPointer.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(null)
}
/*Swift.(file).UnsafeMutableBufferPointer.init(rebasing:Slice<UnsafeMutableBufferPointer<Element>>)*/
/*Swift.(file).UnsafeMutableBufferPointer.init(rebasing:Slice<UnsafeMutableBufferPointer<Element>>)*/
initRebasingSlice(slice, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.init(rebasing:Slice<UnsafeMutableBufferPointer<Element>>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.deallocate()*/
/*Swift.(file).UnsafeMutableBufferPointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.deallocate() in ' + this.constructor.name
}
static /*Swift.(file).UnsafeMutableBufferPointer.allocate(capacity:Int)*/
/*Swift.(file).UnsafeMutableBufferPointer.allocate(capacity:Int)*/
allocateCapacity(count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.allocate(capacity:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.initialize(repeating:Element)*/
/*Swift.(file).UnsafeMutableBufferPointer.initialize(repeating:Element)*/
initializeRepeating(repeatedValue, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.initialize(repeating:Element) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.assign(repeating:Element)*/
/*Swift.(file).UnsafeMutableBufferPointer.assign(repeating:Element)*/
assignRepeating(repeatedValue, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.assign(repeating:Element) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableBufferPointer.withMemoryRebound(to:T.Type,_:(UnsafeMutableBufferPointer<T>) throws -> Result)*/
/*Swift.(file).UnsafeMutableBufferPointer.withMemoryRebound(to:T.Type,_:(UnsafeMutableBufferPointer<T>) throws -> Result)*/
withMemoryReboundTo<T, Result>(type, body, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.withMemoryRebound(to:T.Type,_:(UnsafeMutableBufferPointer<T>) throws -> Result) in ' + this.constructor.name
}

/*Swift.(file).UnsafeMutableBufferPointer.baseAddress*/
baseAddress$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableBufferPointer.baseAddress in ' + this.constructor.name
}
get baseAddress() { return this.baseAddress$get() };




/*Swift.(file).UnsafeMutableBufferPointer.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableBufferPointer.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).UnsafeMutableBufferPointer.initialize(from:S)*/
/*Swift.(file).UnsafeMutableBufferPointer.initialize(from:S)*/
initializeFrom<S>(source, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableBufferPointer.initialize(from:S) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(UnsafeMutableBufferPointer, _HasContiguousBytes$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(UnsafeMutableBufferPointer, Sequence$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(UnsafeMutableBufferPointer, MutableCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(UnsafeMutableBufferPointer, RandomAccessCollection$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(UnsafeMutableBufferPointer, CustomDebugStringConvertible$implementation, false)














class UnsafeBufferPointer<Element> implements _HasContiguousBytes, Sequence, Collection, RandomAccessCollection, CustomDebugStringConvertible{
static readonly $struct = true




/*Swift.(file).UnsafeBufferPointer.count*/
readonly count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
readonly get count() { return this.count$get() };



/*Swift.(file).UnsafeBufferPointer.init(_position:UnsafePointer<Element>?,count:Int)*/
/*Swift.(file).UnsafeBufferPointer.init(_position:UnsafePointer<Element>?,count:Int)*/
init_positionOptionalCountInt(_position, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.init(_position:UnsafePointer<Element>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
const ptr = _create(UnsafeRawPointer, 'initOptional', _injectIntoOptional(((_.tmp0 = _this.baseAddress).rawValue === 'some') ? (_.tmp0[0]) : null), {});
const len = Int.$multiplyIgnoringOverflow(_this.count, MemoryLayout.stride);
return body(_create(UnsafeRawBufferPointer, 'initStartOptionalCountInt', ptr, len, {}))
}
/*Swift.(file).UnsafeBufferPointer.hasNormalizationBoundary(before:Int)*/
/*Swift.(file).UnsafeBufferPointer.hasNormalizationBoundary(before:Int)*/
hasNormalizationBoundaryBefore(index, $info?) {
let _this = this;
if((Bool.$logicalOR(Int.$equal(index, 0), () => Int.$equal(index, _this.count)))) {
return true;
};
assertFileLine(() => Bool.$not(UTF8.isContinuation(_this.subscript_unchecked$get(index))), null, null, null);
if((UInt8.$lessThan(_this.subscript_unchecked$get(index), 0xCC))) {
return true;
};
const cu = _cloneStruct(_decodeScalarStartingAt(_this, index)["0"]);
return cu._hasNormalizationBoundaryBefore
}
/*Swift.(file).UnsafeBufferPointer.isOnUnicodeScalarBoundary(_:Int)*/
/*Swift.(file).UnsafeBufferPointer.isOnUnicodeScalarBoundary(_:Int)*/
isOnUnicodeScalarBoundary(index, $info?) {
let _this = this;
if(!((Int.$lessThan(index, _this.count)))) {
return true;
};
return Bool.$not(UTF8.isContinuation(_this.subscript$get(index)))
}
static Iterator = class implements IteratorProtocol{
static readonly $struct = true









/*Swift.(file).UnsafeBufferPointer.Iterator.init(_position:UnsafePointer<UnsafeBufferPointer<Element>.Iterator.Element>?,_end:UnsafePointer<UnsafeBufferPointer<Element>.Iterator.Element>?)*/
/*Swift.(file).UnsafeBufferPointer.Iterator.init(_position:UnsafePointer<UnsafeBufferPointer<Element>.Iterator.Element>?,_end:UnsafePointer<UnsafeBufferPointer<Element>.Iterator.Element>?)*/
init_positionOptional_endOptional(_position, _end, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.Iterator.init(_position:UnsafePointer<UnsafeBufferPointer<Element>.Iterator.Element>?,_end:UnsafePointer<UnsafeBufferPointer<Element>.Iterator.Element>?) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
/*Swift.(file).UnsafeBufferPointer.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}




/*Swift.(file).UnsafeBufferPointer.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeBufferPointer.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UnsafeBufferPointer.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeBufferPointer.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).UnsafeBufferPointer.index(after:Int)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.index(after:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.formIndex(after:Int)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).UnsafeBufferPointer.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.index(before:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.formIndex(before:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).UnsafeBufferPointer.index(_:Int,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).UnsafeBufferPointer.index(_:Int,offsetBy:Int,limitedBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).UnsafeBufferPointer.distance(from:Int,to:Int)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}



/*Swift.(file).UnsafeBufferPointer.indices*/
indices$get() {
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this, _this.startIndex, _this.endIndex, {})
}
get indices() { return this.indices$get() };



/*Swift.(file).UnsafeBufferPointer.subscript(_:Int)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.subscript(_:Int) in ' + this.constructor.name
}


/*Swift.(file).UnsafeBufferPointer.subscript(_unchecked:Int)*/
/*Swift.(file).UnsafeBufferPointer.subscript(_unchecked:Int)*/
subscript_unchecked$get(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.subscript(_unchecked:Int) in ' + this.constructor.name
}

/*Swift.(file).UnsafeBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}



/*Swift.(file).UnsafeBufferPointer.init(start:UnsafePointer<Element>?,count:Int)*/
/*Swift.(file).UnsafeBufferPointer.init(start:UnsafePointer<Element>?,count:Int)*/
initStartOptionalCountInt(start, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.init(start:UnsafePointer<Element>?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.init(_empty:())*/
/*Swift.(file).UnsafeBufferPointer.init(_empty:())*/
init_emptytuple_type(_empty, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.init(_empty:()) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.init(_:UnsafeMutableBufferPointer<Element>)*/
/*Swift.(file).UnsafeBufferPointer.init(_:UnsafeMutableBufferPointer<Element>)*/
initUnsafeMutableBufferPointer(other, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.init(_:UnsafeMutableBufferPointer<Element>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(null)
}
/*Swift.(file).UnsafeBufferPointer.init(rebasing:Slice<UnsafeBufferPointer<Element>>)*/
/*Swift.(file).UnsafeBufferPointer.init(rebasing:Slice<UnsafeBufferPointer<Element>>)*/
initRebasingSlice(slice, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.init(rebasing:Slice<UnsafeBufferPointer<Element>>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.init(rebasing:Slice<UnsafeMutableBufferPointer<Element>>)*/
/*Swift.(file).UnsafeBufferPointer.init(rebasing:Slice<UnsafeMutableBufferPointer<Element>>)*/
/*!!!DUPLICATE NAME*/
initRebasingSlice(slice, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.init(rebasing:Slice<UnsafeMutableBufferPointer<Element>>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.deallocate()*/
/*Swift.(file).UnsafeBufferPointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.deallocate() in ' + this.constructor.name
}
/*Swift.(file).UnsafeBufferPointer.withMemoryRebound(to:T.Type,_:(UnsafeBufferPointer<T>) throws -> Result)*/
/*Swift.(file).UnsafeBufferPointer.withMemoryRebound(to:T.Type,_:(UnsafeBufferPointer<T>) throws -> Result)*/
withMemoryReboundTo<T, Result>(type, body, $info?) {
throw 'unsupported method Swift.(file).UnsafeBufferPointer.withMemoryRebound(to:T.Type,_:(UnsafeBufferPointer<T>) throws -> Result) in ' + this.constructor.name
}

/*Swift.(file).UnsafeBufferPointer.baseAddress*/
baseAddress$get() {
throw 'unsupported variable Swift.(file).UnsafeBufferPointer.baseAddress in ' + this.constructor.name
}
get baseAddress() { return this.baseAddress$get() };




/*Swift.(file).UnsafeBufferPointer.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).UnsafeBufferPointer.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(UnsafeBufferPointer.Iterator, IteratorProtocol$implementation, false)
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(UnsafeBufferPointer, _HasContiguousBytes$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(UnsafeBufferPointer, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(UnsafeBufferPointer, Collection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(UnsafeBufferPointer, RandomAccessCollection$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(UnsafeBufferPointer, CustomDebugStringConvertible$implementation, false)












class UnsafeMutableRawBufferPointer implements _HasContiguousBytes, Sequence, MutableCollection, RandomAccessCollection, CustomDebugStringConvertible{
static readonly $struct = true





/*Swift.(file).UnsafeMutableRawBufferPointer.init(_position:UnsafeMutableRawPointer?,_end:UnsafeMutableRawPointer?)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.init(_position:UnsafeMutableRawPointer?,_end:UnsafeMutableRawPointer?)*/
init_positionOptional_endOptional(_position, _end, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.init(_position:UnsafeMutableRawPointer?,_end:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
return body(_create(UnsafeRawBufferPointer, 'initUnsafeMutableRawBufferPointer', _this, {}))
}
static /*Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)*/
allocateCount(count, $info?) {
let _this = this;
return UnsafeMutableRawBufferPointer.allocateByteCountAlignment(count, MemoryLayout.alignment)
}
/*Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)*/
copyBytesFrom(source, $info?) {
let _this = this;
_this.copyMemoryFrom(source)
}


/*Swift.(file).UnsafeMutableRawBufferPointer.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}




/*Swift.(file).UnsafeMutableRawBufferPointer.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableRawBufferPointer.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UnsafeMutableRawBufferPointer.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableRawBufferPointer.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).UnsafeMutableRawBufferPointer.indices*/
indices$get() {
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this, _this.startIndex, _this.endIndex, {})
}
get indices() { return this.indices$get() };



/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$set(newValue, i, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Int) in ' + this.constructor.name
}




/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(newValue, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}



/*Swift.(file).UnsafeMutableRawBufferPointer.swapAt(_:Int,_:Int)*/
/*Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)*/
swapAt(i, j, $info?) {
let _this = this;
if(!(((_.arg0 = i).constructor.$notEqual(_.arg0, j)))) {
return ;
};
const tmp = _this.subscript$get(i);
_this.subscript$set(_this.subscript$get(j), i, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.subscript$set(tmp, j, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}

/*Swift.(file).UnsafeMutableRawBufferPointer.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };



static /*Swift.(file).UnsafeMutableRawBufferPointer.allocate(byteCount:Int,alignment:Int)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.allocate(byteCount:Int,alignment:Int)*/
allocateByteCountAlignment(byteCount, alignment, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.allocate(byteCount:Int,alignment:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.deallocate()*/
/*Swift.(file).UnsafeMutableRawBufferPointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.deallocate() in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.load(fromByteOffset:Int,as:T.Type)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.load(fromByteOffset:Int,as:T.Type)*/
loadFromByteOffsetAs<T>(offset, type, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.load(fromByteOffset:Int,as:T.Type) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type)*/
storeBytesOfToByteOffsetAs<T>(value, offset, as, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.copyMemory(from:UnsafeRawBufferPointer)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.copyMemory(from:UnsafeRawBufferPointer)*/
copyMemoryFrom(source, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.copyMemory(from:UnsafeRawBufferPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:C)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:C)*/
/*!!!DUPLICATE NAME*/
copyBytesFrom<C>(source, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:C) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.init(start:UnsafeMutableRawPointer?,count:Int)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.init(start:UnsafeMutableRawPointer?,count:Int)*/
initStartOptionalCountInt(start, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.init(start:UnsafeMutableRawPointer?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.init(_:UnsafeMutableRawBufferPointer)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.init(_:UnsafeMutableRawBufferPointer)*/
initUnsafeMutableRawBufferPointer(bytes, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.init(_:UnsafeMutableRawBufferPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.init(mutating:UnsafeRawBufferPointer)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.init(mutating:UnsafeRawBufferPointer)*/
initMutatingUnsafeRawBufferPointer(bytes, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.init(mutating:UnsafeRawBufferPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.init(_:UnsafeMutableBufferPointer<T>)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.init(_:UnsafeMutableBufferPointer<T>)*/
initUnsafeMutableBufferPointer<T>(buffer, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.init(_:UnsafeMutableBufferPointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.init(rebasing:Slice<UnsafeMutableRawBufferPointer>)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.init(rebasing:Slice<UnsafeMutableRawBufferPointer>)*/
initRebasingSlice(slice, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.init(rebasing:Slice<UnsafeMutableRawBufferPointer>) in ' + this.constructor.name
}

/*Swift.(file).UnsafeMutableRawBufferPointer.baseAddress*/
baseAddress$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableRawBufferPointer.baseAddress in ' + this.constructor.name
}
get baseAddress() { return this.baseAddress$get() };



/*Swift.(file).UnsafeMutableRawBufferPointer.initializeMemory(as:T.Type,repeating:T)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.initializeMemory(as:T.Type,repeating:T)*/
initializeMemoryAsRepeating<T>(type, repeatedValue, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.initializeMemory(as:T.Type,repeating:T) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.initializeMemory(as:S.Element.Type,from:S)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.initializeMemory(as:S.Element.Type,from:S)*/
initializeMemoryAsFrom<S>(type, source, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.initializeMemory(as:S.Element.Type,from:S) in ' + this.constructor.name
}
/*Swift.(file).UnsafeMutableRawBufferPointer.bindMemory(to:T.Type)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.bindMemory(to:T.Type)*/
bindMemoryTo<T>(type, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.bindMemory(to:T.Type) in ' + this.constructor.name
}

/*Swift.(file).UnsafeMutableRawBufferPointer.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).UnsafeMutableRawBufferPointer.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*!!!DUPLICATE NAME*/
subscript$get(bounds, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>) in ' + this.constructor.name
}/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, bounds, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>) in ' + this.constructor.name
}



/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*!!!DUPLICATE NAME*/
subscript$get(bounds, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>) in ' + this.constructor.name
}/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, bounds, $info?) {
throw 'unsupported method Swift.(file).UnsafeMutableRawBufferPointer.subscript(_:Range<Int>) in ' + this.constructor.name
}



init$vars() {let _this = this;

}
}
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(UnsafeMutableRawBufferPointer, _HasContiguousBytes$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(UnsafeMutableRawBufferPointer, Sequence$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(UnsafeMutableRawBufferPointer, MutableCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(UnsafeMutableRawBufferPointer, RandomAccessCollection$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(UnsafeMutableRawBufferPointer, CustomDebugStringConvertible$implementation, false)
















class UnsafeRawBufferPointer implements _HasContiguousBytes, Sequence, Collection, RandomAccessCollection, CustomDebugStringConvertible{
static readonly $struct = true





/*Swift.(file).UnsafeRawBufferPointer.init(_position:UnsafeRawPointer?,_end:UnsafeRawPointer?)*/
/*Swift.(file).UnsafeRawBufferPointer.init(_position:UnsafeRawPointer?,_end:UnsafeRawPointer?)*/
init_positionOptional_endOptional(_position, _end, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(_position:UnsafeRawPointer?,_end:UnsafeRawPointer?) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
return body(_this)
}
static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true









/*Swift.(file).UnsafeRawBufferPointer.Iterator.init(_position:UnsafeRawPointer?,_end:UnsafeRawPointer?)*/
/*Swift.(file).UnsafeRawBufferPointer.Iterator.init(_position:UnsafeRawPointer?,_end:UnsafeRawPointer?)*/
init_positionOptional_endOptional(_position, _end, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.Iterator.init(_position:UnsafeRawPointer?,_end:UnsafeRawPointer?) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.Iterator.next() in ' + this.constructor.name
}


init$vars() {let _this = this;

}
}

/*Swift.(file).UnsafeRawBufferPointer.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this
}




/*Swift.(file).UnsafeRawBufferPointer.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeRawBufferPointer.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).UnsafeRawBufferPointer.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).UnsafeRawBufferPointer.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).UnsafeRawBufferPointer.indices*/
indices$get() {
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this, _this.startIndex, _this.endIndex, {})
}
get indices() { return this.indices$get() };



/*Swift.(file).UnsafeRawBufferPointer.subscript(_:Int)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.subscript(_:Int) in ' + this.constructor.name
}


/*Swift.(file).UnsafeRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}


/*Swift.(file).UnsafeRawBufferPointer.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };



/*Swift.(file).UnsafeRawBufferPointer.deallocate()*/
/*Swift.(file).UnsafeRawBufferPointer.deallocate()*/
deallocate($info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.deallocate() in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.load(fromByteOffset:Int,as:T.Type)*/
/*Swift.(file).UnsafeRawBufferPointer.load(fromByteOffset:Int,as:T.Type)*/
loadFromByteOffsetAs<T>(offset, type, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.load(fromByteOffset:Int,as:T.Type) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.init(start:UnsafeRawPointer?,count:Int)*/
/*Swift.(file).UnsafeRawBufferPointer.init(start:UnsafeRawPointer?,count:Int)*/
initStartOptionalCountInt(start, count, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(start:UnsafeRawPointer?,count:Int) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeMutableRawBufferPointer)*/
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeMutableRawBufferPointer)*/
initUnsafeMutableRawBufferPointer(bytes, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeMutableRawBufferPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeRawBufferPointer)*/
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeRawBufferPointer)*/
initUnsafeRawBufferPointer(bytes, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeRawBufferPointer) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeMutableBufferPointer<T>)*/
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeMutableBufferPointer<T>)*/
initUnsafeMutableBufferPointer<T>(buffer, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeMutableBufferPointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeBufferPointer<T>)*/
/*Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeBufferPointer<T>)*/
initUnsafeBufferPointer<T>(buffer, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(_:UnsafeBufferPointer<T>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.init(rebasing:Slice<UnsafeRawBufferPointer>)*/
/*Swift.(file).UnsafeRawBufferPointer.init(rebasing:Slice<UnsafeRawBufferPointer>)*/
initRebasingSlice(slice, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(rebasing:Slice<UnsafeRawBufferPointer>) in ' + this.constructor.name
}
/*Swift.(file).UnsafeRawBufferPointer.init(rebasing:Slice<UnsafeMutableRawBufferPointer>)*/
/*Swift.(file).UnsafeRawBufferPointer.init(rebasing:Slice<UnsafeMutableRawBufferPointer>)*/
/*!!!DUPLICATE NAME*/
initRebasingSlice(slice, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.init(rebasing:Slice<UnsafeMutableRawBufferPointer>) in ' + this.constructor.name
}

/*Swift.(file).UnsafeRawBufferPointer.baseAddress*/
baseAddress$get() {
throw 'unsupported variable Swift.(file).UnsafeRawBufferPointer.baseAddress in ' + this.constructor.name
}
get baseAddress() { return this.baseAddress$get() };



/*Swift.(file).UnsafeRawBufferPointer.bindMemory(to:T.Type)*/
/*Swift.(file).UnsafeRawBufferPointer.bindMemory(to:T.Type)*/
bindMemoryTo<T>(type, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.bindMemory(to:T.Type) in ' + this.constructor.name
}

/*Swift.(file).UnsafeRawBufferPointer.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).UnsafeRawBufferPointer.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).UnsafeRawBufferPointer.subscript(_:Range<Int>)*/
/*Swift.(file).UnsafeRawBufferPointer.subscript(_:Range<Int>)*/
/*!!!DUPLICATE NAME*/
subscript$get(bounds, $info?) {
throw 'unsupported method Swift.(file).UnsafeRawBufferPointer.subscript(_:Range<Int>) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(UnsafeRawBufferPointer.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(UnsafeRawBufferPointer.Iterator, Sequence$implementation, false)
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(UnsafeRawBufferPointer, _HasContiguousBytes$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(UnsafeRawBufferPointer, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(UnsafeRawBufferPointer, Collection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(UnsafeRawBufferPointer, RandomAccessCollection$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(UnsafeRawBufferPointer, CustomDebugStringConvertible$implementation, false)
















class AnyBidirectionalCollection<Element> implements BidirectionalCollection, _AnyCollectionProtocol{
static readonly $struct = true



/*Swift.(file).AnyBidirectionalCollection.init(_box:_AnyBidirectionalCollectionBox<Element>)*/
/*Swift.(file).AnyBidirectionalCollection.init(_box:_AnyBidirectionalCollectionBox<Element>)*/
init_box_AnyBidirectionalCollectionBox(_box, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.init(_box:_AnyBidirectionalCollectionBox<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}
/*Swift.(file).AnyBidirectionalCollection.dropLast(_:Int)*/
/*Swift.(file).AnyBidirectionalCollection.dropLast(_:Int)*/
dropLast(n, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.dropLast(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.prefix(while:(Element) throws -> Bool)*/
/*Swift.(file).AnyBidirectionalCollection.prefix(while:(Element) throws -> Bool)*/
prefixWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.prefix(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.suffix(_:Int)*/
/*Swift.(file).AnyBidirectionalCollection.suffix(_:Int)*/
suffix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.suffix(_:Int) in ' + this.constructor.name
}

/*Swift.(file).AnyBidirectionalCollection.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return 0
}
get underestimatedCount() { return this.underestimatedCount$get() };



/*Swift.(file).AnyBidirectionalCollection.map(_:(Element) throws -> T)*/
/*Swift.(file).AnyBidirectionalCollection.map(_:(Element) throws -> T)*/
mapSwift<T>(transform, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.map(_:(Element) throws -> T) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.filter(_:(Element) throws -> Bool)*/
/*Swift.(file).AnyBidirectionalCollection.filter(_:(Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.filter(_:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.forEach(_:(Element) throws -> Void)*/
/*Swift.(file).AnyBidirectionalCollection.forEach(_:(Element) throws -> Void)*/
forEachSwift(body, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.forEach(_:(Element) throws -> Void) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.drop(while:(Element) throws -> Bool)*/
/*Swift.(file).AnyBidirectionalCollection.drop(while:(Element) throws -> Bool)*/
dropWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.drop(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.dropFirst(_:Int)*/
/*Swift.(file).AnyBidirectionalCollection.dropFirst(_:Int)*/
dropFirst(n, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.dropFirst(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.prefix(_:Int)*/
/*Swift.(file).AnyBidirectionalCollection.prefix(_:Int)*/
prefix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.prefix(_:Int) in ' + this.constructor.name
}







/*Swift.(file).AnyBidirectionalCollection.init(_:C)*/
/*Swift.(file).AnyBidirectionalCollection.init(_:C)*/
init<C>(base, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.init(_:C) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.init(_:AnyBidirectionalCollection<Element>)*/
/*Swift.(file).AnyBidirectionalCollection.init(_:AnyBidirectionalCollection<Element>)*/
initAnyBidirectionalCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.init(_:AnyBidirectionalCollection<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.init(_:C)*/
/*Swift.(file).AnyBidirectionalCollection.init(_:C)*/
init<C>(base, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.init(_:C) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.init(_:AnyRandomAccessCollection<Element>)*/
/*Swift.(file).AnyBidirectionalCollection.init(_:AnyRandomAccessCollection<Element>)*/
initAnyRandomAccessCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.init(_:AnyRandomAccessCollection<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.init(_:AnyCollection<Element>)*/
/*Swift.(file).AnyBidirectionalCollection.init(_:AnyCollection<Element>)*/
initAnyCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.init(_:AnyCollection<Element>) in ' + this.constructor.name
}
static readonly initAnyCollection$failable = true

/*Swift.(file).AnyBidirectionalCollection.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).AnyBidirectionalCollection.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).AnyBidirectionalCollection.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).AnyBidirectionalCollection.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).AnyBidirectionalCollection.subscript(_:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.subscript(_:AnyBidirectionalCollection<Element>.Index) in ' + this.constructor.name
}


/*Swift.(file).AnyBidirectionalCollection.subscript(_:Range<AnyBidirectionalCollection<Element>.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}



/*Swift.(file).AnyBidirectionalCollection.index(after:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.index(after:AnyBidirectionalCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.formIndex(after:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).AnyBidirectionalCollection.index(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._indexOffsetBy(i, distance)
}
/*Swift.(file).AnyBidirectionalCollection.index(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int,limitedBy:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._indexOffsetByLimitedBy(i, distance, limit)
}
/*Swift.(file).AnyBidirectionalCollection.formIndex(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int)*/
/*Swift.(file).AnyBidirectionalCollection.formIndex(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int)*/
formIndexOffsetBy(i$inout, n, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.formIndex(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.formIndex(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int,limitedBy:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).AnyBidirectionalCollection.formIndex(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int,limitedBy:AnyBidirectionalCollection<Element>.Index)*/
formIndexOffsetByLimitedBy(i$inout, n, limit, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.formIndex(_:AnyBidirectionalCollection<Element>.Index,offsetBy:Int,limitedBy:AnyBidirectionalCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.distance(from:AnyBidirectionalCollection<Element>.Index,to:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._distanceFromTo(start, end)
}

/*Swift.(file).AnyBidirectionalCollection.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };



/*Swift.(file).AnyBidirectionalCollection.index(before:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).AnyBidirectionalCollection.index(before:AnyBidirectionalCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyBidirectionalCollection.formIndex(before:AnyBidirectionalCollection<Element>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}




init$vars() {let _this = this;

}
}
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(AnyBidirectionalCollection, BidirectionalCollection$implementation, false)
if(typeof _AnyCollectionProtocol$implementation != 'undefined') _mixin(AnyBidirectionalCollection, _AnyCollectionProtocol$implementation, false)






class AnyRandomAccessCollection<Element> implements RandomAccessCollection, _AnyCollectionProtocol{
static readonly $struct = true



/*Swift.(file).AnyRandomAccessCollection.init(_box:_AnyRandomAccessCollectionBox<Element>)*/
/*Swift.(file).AnyRandomAccessCollection.init(_box:_AnyRandomAccessCollectionBox<Element>)*/
init_box_AnyRandomAccessCollectionBox(_box, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.init(_box:_AnyRandomAccessCollectionBox<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}
/*Swift.(file).AnyRandomAccessCollection.dropLast(_:Int)*/
/*Swift.(file).AnyRandomAccessCollection.dropLast(_:Int)*/
dropLast(n, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.dropLast(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.prefix(while:(Element) throws -> Bool)*/
/*Swift.(file).AnyRandomAccessCollection.prefix(while:(Element) throws -> Bool)*/
prefixWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.prefix(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.suffix(_:Int)*/
/*Swift.(file).AnyRandomAccessCollection.suffix(_:Int)*/
suffix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.suffix(_:Int) in ' + this.constructor.name
}

/*Swift.(file).AnyRandomAccessCollection.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return 0
}
get underestimatedCount() { return this.underestimatedCount$get() };



/*Swift.(file).AnyRandomAccessCollection.map(_:(Element) throws -> T)*/
/*Swift.(file).AnyRandomAccessCollection.map(_:(Element) throws -> T)*/
mapSwift<T>(transform, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.map(_:(Element) throws -> T) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.filter(_:(Element) throws -> Bool)*/
/*Swift.(file).AnyRandomAccessCollection.filter(_:(Element) throws -> Bool)*/
filterSwift(isIncluded, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.filter(_:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.forEach(_:(Element) throws -> Void)*/
/*Swift.(file).AnyRandomAccessCollection.forEach(_:(Element) throws -> Void)*/
forEachSwift(body, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.forEach(_:(Element) throws -> Void) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.drop(while:(Element) throws -> Bool)*/
/*Swift.(file).AnyRandomAccessCollection.drop(while:(Element) throws -> Bool)*/
dropWhile(predicate, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.drop(while:(Element) throws -> Bool) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.dropFirst(_:Int)*/
/*Swift.(file).AnyRandomAccessCollection.dropFirst(_:Int)*/
dropFirst(n, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.dropFirst(_:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.prefix(_:Int)*/
/*Swift.(file).AnyRandomAccessCollection.prefix(_:Int)*/
prefix(maxLength, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.prefix(_:Int) in ' + this.constructor.name
}







/*Swift.(file).AnyRandomAccessCollection.init(_:C)*/
/*Swift.(file).AnyRandomAccessCollection.init(_:C)*/
init<C>(base, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.init(_:C) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.init(_:AnyRandomAccessCollection<Element>)*/
/*Swift.(file).AnyRandomAccessCollection.init(_:AnyRandomAccessCollection<Element>)*/
initAnyRandomAccessCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.init(_:AnyRandomAccessCollection<Element>) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.init(_:AnyCollection<Element>)*/
/*Swift.(file).AnyRandomAccessCollection.init(_:AnyCollection<Element>)*/
initAnyCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.init(_:AnyCollection<Element>) in ' + this.constructor.name
}
static readonly initAnyCollection$failable = true
/*Swift.(file).AnyRandomAccessCollection.init(_:AnyBidirectionalCollection<Element>)*/
/*Swift.(file).AnyRandomAccessCollection.init(_:AnyBidirectionalCollection<Element>)*/
initAnyBidirectionalCollection(other, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.init(_:AnyBidirectionalCollection<Element>) in ' + this.constructor.name
}
static readonly initAnyBidirectionalCollection$failable = true

/*Swift.(file).AnyRandomAccessCollection.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).AnyRandomAccessCollection.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).AnyRandomAccessCollection.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).AnyRandomAccessCollection.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).AnyRandomAccessCollection.subscript(_:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.subscript(_:AnyRandomAccessCollection<Element>.Index) in ' + this.constructor.name
}


/*Swift.(file).AnyRandomAccessCollection.subscript(_:Range<AnyRandomAccessCollection<Element>.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}



/*Swift.(file).AnyRandomAccessCollection.index(after:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.index(after:AnyRandomAccessCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.formIndex(after:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).AnyRandomAccessCollection.index(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._indexOffsetBy(i, distance)
}
/*Swift.(file).AnyRandomAccessCollection.index(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int,limitedBy:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
const l = _this.distanceFromTo(i, limit);
if(((Int.$greaterThan(distance, 0) ? Bool.$logicalAND(Int.$greaterThanOrEqual(l, 0), () => Int.$lessThan(l, distance)) : Bool.$logicalAND(Int.$lessThanOrEqual(l, 0), () => Int.$lessThan(distance, l))))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(_this.indexOffsetBy(i, distance))
}
/*Swift.(file).AnyRandomAccessCollection.formIndex(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int)*/
/*Swift.(file).AnyRandomAccessCollection.formIndex(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int)*/
formIndexOffsetBy(i$inout, n, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.formIndex(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.formIndex(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int,limitedBy:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).AnyRandomAccessCollection.formIndex(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int,limitedBy:AnyRandomAccessCollection<Element>.Index)*/
formIndexOffsetByLimitedBy(i$inout, n, limit, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.formIndex(_:AnyRandomAccessCollection<Element>.Index,offsetBy:Int,limitedBy:AnyRandomAccessCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.distance(from:AnyRandomAccessCollection<Element>.Index,to:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._distanceFromTo(start, end)
}

/*Swift.(file).AnyRandomAccessCollection.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };



/*Swift.(file).AnyRandomAccessCollection.index(before:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).AnyRandomAccessCollection.index(before:AnyRandomAccessCollection<Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).AnyRandomAccessCollection.formIndex(before:AnyRandomAccessCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}




init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(AnyRandomAccessCollection, RandomAccessCollection$implementation, false)
if(typeof _AnyCollectionProtocol$implementation != 'undefined') _mixin(AnyRandomAccessCollection, _AnyCollectionProtocol$implementation, false)






interface _ArrayBufferProtocol extends MutableCollection, RandomAccessCollection{
/*Swift.(file)._ArrayBufferProtocol.init()*/
/*Swift.(file)._ArrayBufferProtocol.init()*/
init($info?)
/*Swift.(file)._ArrayBufferProtocol.init(_buffer:_ContiguousArrayBuffer<Self.Element>,shiftedToStartIndex:Int)*/
/*Swift.(file)._ArrayBufferProtocol.init(_buffer:_ContiguousArrayBuffer<Self.Element>,shiftedToStartIndex:Int)*/
init_buffer_ContiguousArrayBufferShiftedToStartIndexInt(_buffer, shiftedToStartIndex, $info?)
/*Swift.(file)._ArrayBufferProtocol.init(copying:Self)*/
/*Swift.(file)._ArrayBufferProtocol.init(copying:Self)*/
initCopying(buffer, $info?)

/*Swift.(file)._ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
/*Swift.(file)._ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
requestUniqueMutableBackingBufferMinimumCapacity(minimumCapacity, $info?)
/*Swift.(file)._ArrayBufferProtocol.isMutableAndUniquelyReferenced()*/
/*Swift.(file)._ArrayBufferProtocol.isMutableAndUniquelyReferenced()*/
isMutableAndUniquelyReferenced($info?)
/*Swift.(file)._ArrayBufferProtocol.requestNativeBuffer()*/
/*Swift.(file)._ArrayBufferProtocol.requestNativeBuffer()*/
requestNativeBuffer($info?)
/*Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)*/
/*Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)*/
replaceSubrangeWithElementsOf<C>(subrange, newCount, newValues, $info?)
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
subscript$get(bounds, $info?)

/*Swift.(file)._ArrayBufferProtocol.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?)
/*Swift.(file)._ArrayBufferProtocol.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?)

/*Swift.(file)._ArrayBufferProtocol.count*/;






/*Swift.(file)._ArrayBufferProtocol.capacity*/
capacity;




/*Swift.(file)._ArrayBufferProtocol.owner*/
owner;




/*Swift.(file)._ArrayBufferProtocol.firstElementAddress*/
firstElementAddress;




/*Swift.(file)._ArrayBufferProtocol.firstElementAddressIfContiguous*/
firstElementAddressIfContiguous;




/*Swift.(file)._ArrayBufferProtocol.subscriptBaseAddress*/
subscriptBaseAddress;




/*Swift.(file)._ArrayBufferProtocol.identity*/
identity;



}
class _ArrayBufferProtocol$implementation{

/*Swift.(file)._ArrayBufferProtocol.subscriptBaseAddress*/
subscriptBaseAddress$get() {
let _this = this;
return _this.firstElementAddress
}
get subscriptBaseAddress() { return this.subscriptBaseAddress$get() };



/*Swift.(file)._ArrayBufferProtocol.init(copying:Self)*/
/*Swift.(file)._ArrayBufferProtocol.init(copying:Self)*/
initCopying(buffer, $info?) {
throw 'unsupported method Swift.(file)._ArrayBufferProtocol.init(copying:Self) in ' + this.constructor.name
}
/*Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)*/
/*Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)*/
replaceSubrangeWithElementsOf<C>(subrange, newCount, newValues, $info?) {
let _this = this;
const oldCount = _this.count;
const eraseCount = subrange.count;
const growth = Int.$subtract(newCount, eraseCount);
_this.count = Int.$add(oldCount, growth);
const _elements = _cloneStruct(_this.subscriptBaseAddress);
const oldTailIndex = subrange.upperBound;
const oldTailStart = _cloneStruct(UnsafeMutablePointer.$add(_elements, oldTailIndex));
const newTailIndex = Int.$add(oldTailIndex, growth);
const newTailStart = _cloneStruct(UnsafeMutablePointer.$add(oldTailStart, growth));
const tailCount = Int.$subtract(oldCount, subrange.upperBound);
if((Int.$greaterThan(growth, 0))) {
newTailStart.moveInitializeFromCount(oldTailStart, tailCount);
let i = newValues.startIndex;
{
let $j$generator = _cloneStruct(subrange.makeIterator( {}));
while(true) {
const $ifLet0, j_1;
if(!((($ifLet0 = $j$generator.next( {$setThis: $val => $j$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((j_1 = $ifLet0[0])||true))) break
_elements.subscript$set(newValues.subscript$get(i), j_1, {$setThis: $val => _elements = _cloneStruct($val)});
newValues.formIndexAfter({get: () => i, set: $val => i = $val});
}
};
{
let $j$generator = _cloneStruct(Int.$halfOpenRange(oldTailIndex, newTailIndex).makeIterator( {}));
while(true) {
const $ifLet2, j_3;
if(!((($ifLet2 = $j$generator.next( {$setThis: $val => $j$generator = $val}))||true) && $ifLet2.rawValue == 'some' && ((j_3 = $ifLet2[0])||true))) break
UnsafeMutablePointer.$add(_elements, j_3).initializeTo(newValues.subscript$get(i));
newValues.formIndexAfter({get: () => i, set: $val => i = $val});
}
};
}
else {
let i = subrange.lowerBound;
let j = newValues.startIndex;
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, newCount).makeIterator( {}));
while(true) {
const $ifLet4;
if(!((($ifLet4 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet4.rawValue == 'some')) break
_elements.subscript$set(newValues.subscript$get(j), i, {$setThis: $val => _elements = _cloneStruct($val)});
Int.$addAndAssign({get: () => i, set: $val => i = $val}, 1);
newValues.formIndexAfter({get: () => j, set: $val => j = $val});
}
};
if((Int.$equal(growth, 0))) {
return ;
};
const shrinkage = Int.$negate(growth);
if((Int.$greaterThan(tailCount, shrinkage))) {
newTailStart.moveAssignFromCount(oldTailStart, shrinkage);
oldTailStart.moveInitializeFromCount(UnsafeMutablePointer.$add(oldTailStart, shrinkage), Int.$subtract(tailCount, shrinkage));
}
else {
newTailStart.moveAssignFromCount(oldTailStart, tailCount);
UnsafeMutablePointer.$add(newTailStart, tailCount).deinitializeCount(Int.$subtract(shrinkage, tailCount));
};
}
}







}
if(typeof MutableCollection$implementation != 'undefined') _mixin(_ArrayBufferProtocol$implementation, MutableCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_ArrayBufferProtocol$implementation, RandomAccessCollection$implementation, false)












class MIO_Mixin_Array<Element> implements _DestructorSafeContainer, _ArrayProtocol, RandomAccessCollection, MutableCollection, ExpressibleByArrayLiteral, RangeReplaceableCollection, CustomReflectable, CustomStringConvertible, CustomDebugStringConvertible, Equatable, Hashable, _HasCustomAnyHashableRepresentation, _HasContiguousBytes, Encodable, Decodable{
static readonly $struct = true
static readonly $mixin = true






/*Swift.(file).Array.init(_buffer:Array<Element>._Buffer)*/
/*Swift.(file).Array.init(_buffer:Array<Element>._Buffer)*/
init_bufferArray_Buffer(_buffer, $info?) {
throw 'unsupported method Swift.(file).Array.init(_buffer:Array<Element>._Buffer) in ' + this.constructor.name
}










/*Swift.(file).Array.capacity*/
capacity$get() {
let _this = this;
return _this._getCapacity( {})
}
get capacity() { return this.capacity$get() };













/*Swift.(file).Array.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).Array.endIndex*/
endIndex$get() {
let _this = this;
return _this.count;
}
get endIndex() { return this.endIndex$get()
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).Array.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return Int.$add(i, 1)
}
/*Swift.(file).Array.formIndex(after:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.$addAndAssign({get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Array.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return Int.$subtract(i, 1)
}
/*Swift.(file).Array.formIndex(before:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
}
/*Swift.(file).Array.index(_:Int,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?) {
let _this = this;
return Int.$add(i, distance)
}
/*Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?) {
let _this = this;
const l = Int.$subtract(limit, i);
if(((Int.$greaterThan(distance, 0) ? Bool.$logicalAND(Int.$greaterThanOrEqual(l, 0), () => Int.$lessThan(l, distance)) : Bool.$logicalAND(Int.$lessThanOrEqual(l, 0), () => Int.$lessThan(distance, l))))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(Int.$add(i, distance))
}
/*Swift.(file).Array.distance(from:Int,to:Int)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return Int.$subtract(end, start)
}


/*Swift.(file).Array.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(index, $info?) {
return this[index]
}/*Swift.(file).Array.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$_modify(index, $info?) {
return this[index]
}




/*Swift.(file).Array.subscript(_:Range<Int>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
let result = _create(Array, 'init', {});
{
let $index$generator = _cloneStruct(bounds.makeIterator( {}));
while(true) {
const $ifLet0, index_1;
if(!((($ifLet0 = $index$generator.next( {$setThis: $val => $index$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) break
result.append(_this.subscript$get(index_1), {$setThis: $val => result = $val});
}
};
return result;

}/*Swift.(file).Array.subscript(_:Range<Int>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(rhs, bounds, $info?) {
let _this = this;
_this.replaceSubrangeWith(bounds, rhs, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}




/*Swift.(file).Array.count*/
count$get() {
return this.length
}
get count() { return this.count$get() };





/*Swift.(file).Array.init(arrayLiteral:[Element])*/
/*Swift.(file).ExpressibleByArrayLiteral.init(arrayLiteral:[Self.ArrayLiteralElement])*/
initArrayLiteralArray(_elements, $info?) {
let _this = this;
return _cloneStruct(_cloneStruct(_elements));
return
}

/*Swift.(file).Array.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
return []
}
/*Swift.(file).Array.init(_:S)*/
/*Swift.(file)._ArrayProtocol.init(_:Self._Buffer)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
initBuffer<S>(s, $info?) {
let _this = this;
let result = _create(Array, 'init', {});
let iterator = s.makeIterator( {});
while(true){
const $ifLet0, _element_1
if(!((($ifLet0 = iterator.next( {$setThis: $val => iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
result.append(_element_1, {$setThis: $val => result = $val});
};
return result
}
/*Swift.(file).Array.init(repeating:Element,count:Int)*/
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
initRepeatingCountInt(repeatedValue, count, $info?) {
let _this = this;
let result = _create(Array, 'init', {});
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, count).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
result.append(repeatedValue, {$setThis: $val => result = $val});
}
};
return result
}

/*Swift.(file).Array.init(_uninitializedCount:Int)*/
/*Swift.(file).Array.init(_uninitializedCount:Int)*/
init_uninitializedCountInt(count, $info?) {
throw 'unsupported method Swift.(file).Array.init(_uninitializedCount:Int) in ' + this.constructor.name
}



/*Swift.(file).Array.reserveCapacity(_:Int)*/
/*Swift.(file)._ArrayProtocol.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
reserveCapacity(minimumCapacity, $info?) {

}




/*Swift.(file).Array.append(_:Element)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(newElement, $info?) {
let _this = this;
_this.replaceSubrangeWith(Int.$halfOpenRange(_this.count, _this.count), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).Array.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
appendContentsOf<S>(newElements, $info?) {
let _this = this;
{
let $el$generator = newElements.makeIterator( {});
while(true) {
const $ifLet0, el_1;
if(!((($ifLet0 = $el$generator.next( {$setThis: $val => $el$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((el_1 = $ifLet0[0])||true))) break
_this.append(el_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file).Array.reserveCapacityForAppend(newElementsCount:Int)*/
/*Swift.(file).Array.reserveCapacityForAppend(newElementsCount:Int)*/
reserveCapacityForAppendNewElementsCount(newElementsCount, $info?) {
throw 'unsupported method Swift.(file).Array.reserveCapacityForAppend(newElementsCount:Int) in ' + this.constructor.name
}

/*Swift.(file).Array.remove(at:Int)*/
/*Swift.(file)._ArrayProtocol.remove(at:Int)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
removeAt(index, $info?) {
return this.splice(index, 1)[0]
}
/*Swift.(file).Array.insert(_:Element,at:Int)*/
/*Swift.(file)._ArrayProtocol.insert(_:Self.Element,at:Int)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
insertAt(newElement, i, $info?) {
this.splice(i, 0, _cloneStruct(newElement))
}
/*Swift.(file).Array.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
let _this = this;
_this.replaceSubrangeWith(_this.indices, _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}

/*Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withContiguousMutableStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(_this.withUnsafeMutableBufferPointer(((bufferPointer$inout, $info?) => body({get: () => bufferPointer, set: $val => bufferPointer = $val})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
}
/*Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(_this.withUnsafeBufferPointer(((bufferPointer, $info?) => body(bufferPointer))))
}

static /*Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)*/
/*Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)*/
$add(lhs, rhs, $info?) {
let _this = this;
let lhs_dupl = _cloneStruct(lhs);
lhs_dupl.appendContentsOf(rhs, {$setThis: $val => lhs_dupl = $val});
return lhs_dupl
}
static /*Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)*/
/*Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)*/
$addAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf(rhs, {$setThis: $val => lhs = $val});})()
lhs$inout.set(lhs)
return $result
}

/*Swift.(file).Array.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, _injectIntoOptional(Mirror.DisplayStyle.collection), , {})
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).Array.description*/
description$get() {
let _this = this;
let result = "";
String.$addAndAssign({get: () => result, set: $val => result = $val}, "[");
let first = true;
{
let $item$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, item_1;
if(!((($ifLet0 = $item$generator.next( {$setThis: $val => $item$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((item_1 = $ifLet0[0])||true))) break
if((first)) {
first = false;
}
else {
String.$addAndAssign({get: () => result, set: $val => result = $val}, ", ");
};
String.$addAndAssign({get: () => result, set: $val => result = $val}, (("") + (item_1) + ("")));
}
};
String.$addAndAssign({get: () => result, set: $val => result = $val}, "]");
return result;
}
get description() { return this.description$get()
}
get description() { return this.description$get() };




/*Swift.(file).Array.debugDescription*/
debugDescription$get() {
let _this = this;
return _this._makeCollectionDescriptionWithTypeName( null)
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).Array.init(_unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)*/
/*Swift.(file).Array.init(_unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)*/
init_unsafeUninitializedCapacityIntInitializingWithfunction_type(_unsafeUninitializedCapacity, initializer, $info?) {
throw 'unsupported method Swift.(file).Array.init(_unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void) in ' + this.constructor.name
}
/*Swift.(file).Array.init(unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)*/
/*Swift.(file).Array.init(unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)*/
initUnsafeUninitializedCapacityIntInitializingWithfunction_type(unsafeUninitializedCapacity, initializer, $info?) {
let _this = this;
return _cloneStruct(_cloneStruct(_create(Array, 'init_unsafeUninitializedCapacityIntInitializingWithfunction_type', unsafeUninitializedCapacity, initializer, {})));
return
}
/*Swift.(file).Array.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).Array.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file).Array.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file).Array.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file).Array.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file).Array.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}

/*Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(subrange, newElements, $info?) {
let _this = this;
{
let $generator = _cloneStruct(subrange.makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
_this.removeAt(subrange.startIndex, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
let i = subrange.startIndex;
{
let $el$generator = newElements.makeIterator( {});
while(true) {
const $ifLet1, el_2;
if(!((($ifLet1 = $el$generator.next( {$setThis: $val => $el$generator = $val}))||true) && $ifLet1.rawValue == 'some' && ((el_2 = $ifLet1[0])||true))) break
_this.insertAt(el_2, i, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
Int.$addAndAssign({get: () => i, set: $val => i = $val}, 1);
}
}
}
static /*Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
const lhsCount = lhs.count;
if((Int.$notEqual(lhsCount, rhs.count))) {
return false;
};
if((Int.$equal(lhsCount, 0))) {
return true;
};
{
let $idx$generator = _cloneStruct(Int.$halfOpenRange(0, lhsCount).makeIterator( {}));
while(true) {
const $ifLet0, idx_1;
if(!((($ifLet0 = $idx$generator.next( {$setThis: $val => $idx$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((idx_1 = $ifLet0[0])||true))) break
if(((_.arg0 = lhs.subscript$get(idx_1)).constructor.$notEqual(_.arg0, rhs.subscript$get(idx_1)))) {
return false;
};
}
};
return true
}
/*Swift.(file).Array.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.count, {$setThis: $val => hasher = $val});
{
let $element$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
hasher.combine(_element_1, {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).Array.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).Array.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)*/
/*Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)*/
withUnsafeMutableBytes<R>(body, $info?) {
let _this = this;
return _this.withUnsafeMutableBufferPointer((($0$inout, $info?) => body(_create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', $0, {}))), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
return _this.withUnsafeBufferPointer((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}))))
}


/*Swift.(file).Array.init(_immutableCocoaArray:AnyObject)*/
/*Swift.(file).Array.init(_immutableCocoaArray:AnyObject)*/
init_immutableCocoaArrayAnyObject(_immutableCocoaArray, $info?) {
let _this = this;
return _cloneStruct(_cloneStruct(_bridgeCocoaArray(_immutableCocoaArray)));
return
}




/*Swift.(file).Array.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).Array.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).Array.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).Array.init(from:Decoder) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
subscript$set(el, index, $info) {
    this[index] = _cloneStruct(el)
}
}
if(typeof _DestructorSafeContainer$implementation != 'undefined') _mixin(MIO_Mixin_Array, _DestructorSafeContainer$implementation, false)
if(typeof _ArrayProtocol$implementation != 'undefined') _mixin(MIO_Mixin_Array, _ArrayProtocol$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(MIO_Mixin_Array, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(MIO_Mixin_Array, MutableCollection$implementation, false)
if(typeof ExpressibleByArrayLiteral$implementation != 'undefined') _mixin(MIO_Mixin_Array, ExpressibleByArrayLiteral$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(MIO_Mixin_Array, RangeReplaceableCollection$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_Array, CustomReflectable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Array, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_Array, CustomDebugStringConvertible$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_Array, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_Array, Hashable$implementation, false)
if(typeof _HasCustomAnyHashableRepresentation$implementation != 'undefined') _mixin(MIO_Mixin_Array, _HasCustomAnyHashableRepresentation$implementation, false)
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(MIO_Mixin_Array, _HasContiguousBytes$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(MIO_Mixin_Array, Encodable$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(MIO_Mixin_Array, Decodable$implementation, false)
_mixin(Array, MIO_Mixin_Array, true)








































class ArraySlice<Element> implements _DestructorSafeContainer, _ArrayProtocol, RandomAccessCollection, MutableCollection, ExpressibleByArrayLiteral, RangeReplaceableCollection, CustomReflectable, CustomStringConvertible, CustomDebugStringConvertible, Equatable, Hashable{
static readonly $struct = true






/*Swift.(file).ArraySlice.init(_buffer:ArraySlice<Element>._Buffer)*/
/*Swift.(file).ArraySlice.init(_buffer:ArraySlice<Element>._Buffer)*/
init_bufferArraySlice_Buffer(_buffer, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.init(_buffer:ArraySlice<Element>._Buffer) in ' + this.constructor.name
}
/*Swift.(file).ArraySlice.init(_buffer:_ContiguousArrayBuffer<Element>)*/
/*Swift.(file).ArraySlice.init(_buffer:_ContiguousArrayBuffer<Element>)*/
init_buffer_ContiguousArrayBuffer(buffer, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.init(_buffer:_ContiguousArrayBuffer<Element>) in ' + this.constructor.name
}










/*Swift.(file).ArraySlice.capacity*/
capacity$get() {
let _this = this;
return _this._getCapacity( {})
}
get capacity() { return this.capacity$get() };
















/*Swift.(file).ArraySlice.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).ArraySlice.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).ArraySlice.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).ArraySlice.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).ArraySlice.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return Int.$add(i, 1)
}
/*Swift.(file).ArraySlice.formIndex(after:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.$addAndAssign({get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
}
/*Swift.(file).ArraySlice.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return Int.$subtract(i, 1)
}
/*Swift.(file).ArraySlice.formIndex(before:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
}
/*Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?) {
let _this = this;
return Int.$add(i, distance)
}
/*Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?) {
let _this = this;
const l = Int.$subtract(limit, i);
if(((Int.$greaterThan(distance, 0) ? Bool.$logicalAND(Int.$greaterThanOrEqual(l, 0), () => Int.$lessThan(l, distance)) : Bool.$logicalAND(Int.$lessThanOrEqual(l, 0), () => Int.$lessThan(distance, l))))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(Int.$add(i, distance))
}
/*Swift.(file).ArraySlice.distance(from:Int,to:Int)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return Int.$subtract(end, start)
}


/*Swift.(file).ArraySlice.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).ArraySlice.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$_modify(index, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.subscript(_:Int) in ' + this.constructor.name
}




/*Swift.(file).ArraySlice.subscript(_:Range<Int>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}/*Swift.(file).ArraySlice.subscript(_:Range<Int>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(rhs, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}




/*Swift.(file).ArraySlice.count*/
count$get() {
let _this = this;
return _this._getCount( {})
}
get count() { return this.count$get() };





/*Swift.(file).ArraySlice.init(arrayLiteral:[Element])*/
/*Swift.(file).ExpressibleByArrayLiteral.init(arrayLiteral:[Self.ArrayLiteralElement])*/
initArrayLiteralArray(_elements, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.init(arrayLiteral:[Element]) in ' + this.constructor.name
}

/*Swift.(file).ArraySlice.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
throw 'unsupported method Swift.(file).ArraySlice.init() in ' + this.constructor.name
}
/*Swift.(file).ArraySlice.init(_:S)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
/*Swift.(file)._ArrayProtocol.init(_:Self._Buffer)*/
initBuffer<S>(s, $info?) {
let _this = this;
_this.init( {});
_this.appendContentsOf(_elements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return
}
/*Swift.(file).ArraySlice.init(repeating:Element,count:Int)*/
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
initRepeatingCountInt(repeatedValue, count, $info?) {
let _this = this;
let p;
let $tuple = ArraySlice._allocateUninitialized(count)
$info.$setThis(_this = _cloneStruct($tuple[0]))
p = $tuple[1];
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, count).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
p.initializeTo(repeatedValue);
UnsafeMutablePointer.$addAndAssign({get: () => p, set: $val => p = $val}, 1);
}
};
return
}

/*Swift.(file).ArraySlice.init(_uninitializedCount:Int)*/
/*Swift.(file).ArraySlice.init(_uninitializedCount:Int)*/
init_uninitializedCountInt(count, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.init(_uninitializedCount:Int) in ' + this.constructor.name
}

/*Swift.(file).ArraySlice.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
/*Swift.(file)._ArrayProtocol.reserveCapacity(_:Int)*/
reserveCapacity(minimumCapacity, $info?) {

}




/*Swift.(file).ArraySlice.append(_:Element)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(newElement, $info?) {
let _this = this;
_this._makeUniqueAndReserveCapacityIfNotUnique( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const oldCount = _this._getCount( {});
_this._appendElementAssumeUniqueAndCapacityNewElement(oldCount, newElement, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).ArraySlice.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
appendContentsOf<S>(newElements, $info?) {
let _this = this;
const approximateCapacity = Int.$add(_this.count, numericCast(newElements.underestimatedCount, {T: Int, U: Int}));
{
let $element$generator = newElements.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
_this.append(_element_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file).ArraySlice.reserveCapacityForAppend(newElementsCount:Int)*/
/*Swift.(file).ArraySlice.reserveCapacityForAppend(newElementsCount:Int)*/
reserveCapacityForAppendNewElementsCount(newElementsCount, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.reserveCapacityForAppend(newElementsCount:Int) in ' + this.constructor.name
}

/*Swift.(file).ArraySlice.remove(at:Int)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
/*Swift.(file)._ArrayProtocol.remove(at:Int)*/
removeAt(index, $info?) {
let _this = this;
const result = _this.subscript$get(index);
_this.replaceSubrangeWith(Int.$halfOpenRange(index, Int.$add(index, 1)), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return result
}
/*Swift.(file).ArraySlice.insert(_:Element,at:Int)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
/*Swift.(file)._ArrayProtocol.insert(_:Self.Element,at:Int)*/
insertAt(newElement, i, $info?) {
let _this = this;
_this.replaceSubrangeWith(Int.$halfOpenRange(i, i), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).ArraySlice.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
let _this = this;
if((Bool.$not(keepCapacity))) {
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'init', {})));
}
else {
_this.replaceSubrangeWith((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}

/*Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withContiguousMutableStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(_this.withUnsafeMutableBufferPointer(((bufferPointer$inout, $info?) => body({get: () => bufferPointer, set: $val => bufferPointer = $val})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
}
/*Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(_this.withUnsafeBufferPointer(((bufferPointer, $info?) => body(bufferPointer))))
}


/*Swift.(file).ArraySlice.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, _injectIntoOptional(Mirror.DisplayStyle.collection), , {})
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).ArraySlice.description*/
description$get() {
let _this = this;
return _this._makeCollectionDescriptionWithTypeName( null)
}
get description() { return this.description$get() };




/*Swift.(file).ArraySlice.debugDescription*/
debugDescription$get() {
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(_injectIntoOptional("ArraySlice"))
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).ArraySlice.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).ArraySlice.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file).ArraySlice.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file).ArraySlice.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}

/*Swift.(file).ArraySlice.replaceSubrange(_:Range<Int>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(subrange, newElements, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.replaceSubrange(_:Range<Int>,with:C) in ' + this.constructor.name
}
static /*Swift.(file).ArraySlice.==infix(_:ArraySlice<Element>,_:ArraySlice<Element>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
/*Swift.(file).ArraySlice.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.count, {$setThis: $val => hasher = $val});
{
let $element$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
hasher.combine(_element_1, {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).ArraySlice.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).ArraySlice.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)*/
/*Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)*/
withUnsafeMutableBytes<R>(body, $info?) {
let _this = this;
return _this.withUnsafeMutableBufferPointer((($0$inout, $info?) => body(_create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', $0, {}))), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
return _this.withUnsafeBufferPointer((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}))))
}
/*Swift.(file).ArraySlice.init(_startIndex:Int)*/
/*Swift.(file).ArraySlice.init(_startIndex:Int)*/
init_startIndexInt(_startIndex, $info?) {
throw 'unsupported method Swift.(file).ArraySlice.init(_startIndex:Int) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof _DestructorSafeContainer$implementation != 'undefined') _mixin(ArraySlice, _DestructorSafeContainer$implementation, false)
if(typeof _ArrayProtocol$implementation != 'undefined') _mixin(ArraySlice, _ArrayProtocol$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(ArraySlice, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(ArraySlice, MutableCollection$implementation, false)
if(typeof ExpressibleByArrayLiteral$implementation != 'undefined') _mixin(ArraySlice, ExpressibleByArrayLiteral$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(ArraySlice, RangeReplaceableCollection$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(ArraySlice, CustomReflectable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(ArraySlice, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(ArraySlice, CustomDebugStringConvertible$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(ArraySlice, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(ArraySlice, Hashable$implementation, false)






























class AutoreleasingUnsafeMutablePointer<Pointee> implements _Pointer, CVarArg{
static readonly $struct = true



/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:RawPointer)*/
/*Swift.(file)._Pointer.init(_:RawPointer)*/
initRawPointer(_rawValue, $info?) {
throw 'unsupported method Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:RawPointer) in ' + this.constructor.name
}

/*Swift.(file).AutoreleasingUnsafeMutablePointer.pointee*/
pointee$get() {
throw 'unsupported variable Swift.(file).AutoreleasingUnsafeMutablePointer.pointee in ' + this.constructor.name
}
get pointee() { return this.pointee$get() };






/*Swift.(file).AutoreleasingUnsafeMutablePointer.subscript(_:Int)*/
/*Swift.(file).AutoreleasingUnsafeMutablePointer.subscript(_:Int)*/
subscript$_read(i, $info?) {
let _this = this;
/*yield*/
}


/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafeMutablePointer<U>)*/
/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafeMutablePointer<U>)*/
initUnsafeMutablePointer<U>(from, $info?) {
throw 'unsupported method Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafeMutablePointer<U>) in ' + this.constructor.name
}
/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafeMutablePointer<U>?)*/
/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafeMutablePointer<U>?)*/
initOptional<U>(from, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeMutablePointer(unwrapped_1);
return
}
static readonly initOptional$failable = true
/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>)*/
/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>)*/
initUnsafePointer<U>(from, $info?) {
throw 'unsupported method Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>) in ' + this.constructor.name
}
/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>?)*/
/*Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>?)*/
/*!!!DUPLICATE NAME*/
initOptional<U>(from, $info?) {
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafePointer(unwrapped_1);
return
}
static readonly initOptional$failable = true




/*Swift.(file).AutoreleasingUnsafeMutablePointer.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).AutoreleasingUnsafeMutablePointer.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };





init$vars() {let _this = this;

}
}
if(typeof _Pointer$implementation != 'undefined') _mixin(AutoreleasingUnsafeMutablePointer, _Pointer$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(AutoreleasingUnsafeMutablePointer, CVarArg$implementation, false)




class _CocoaArrayWrapper implements RandomAccessCollection{
static readonly $struct = true


/*Swift.(file)._CocoaArrayWrapper.buffer*/
buffer$get() {
throw 'unsupported variable Swift.(file)._CocoaArrayWrapper.buffer in ' + this.constructor.name
}
get buffer() { return this.buffer$get() };





/*Swift.(file)._CocoaArrayWrapper.init(_:AnyObject)*/
/*Swift.(file)._CocoaArrayWrapper.init(_:AnyObject)*/
initAnyObject(buffer, $info?) {
throw 'unsupported method Swift.(file)._CocoaArrayWrapper.init(_:AnyObject) in ' + this.constructor.name
}

/*Swift.(file)._CocoaArrayWrapper.core*/
core$get() {
throw 'unsupported variable Swift.(file)._CocoaArrayWrapper.core in ' + this.constructor.name
}
get core() { return this.core$get() };




/*Swift.(file)._CocoaArrayWrapper.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file)._CocoaArrayWrapper.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._CocoaArrayWrapper.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file)._CocoaArrayWrapper.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file)._CocoaArrayWrapper.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._CocoaArrayWrapper.subscript(_:Int) in ' + this.constructor.name
}


/*Swift.(file)._CocoaArrayWrapper.subscript(_:Range<Int>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}

/*Swift.(file)._CocoaArrayWrapper.contiguousStorage(_:Range<Int>)*/
/*Swift.(file)._CocoaArrayWrapper.contiguousStorage(_:Range<Int>)*/
contiguousStorage(subRange, $info?) {
throw 'unsupported method Swift.(file)._CocoaArrayWrapper.contiguousStorage(_:Range<Int>) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_CocoaArrayWrapper, RandomAccessCollection$implementation, false)


class ContiguousArray<Element> implements _DestructorSafeContainer, _ArrayProtocol, RandomAccessCollection, MutableCollection, ExpressibleByArrayLiteral, RangeReplaceableCollection, CustomReflectable, CustomStringConvertible, CustomDebugStringConvertible, Equatable, Hashable, _HasContiguousBytes, Encodable, Decodable{
static readonly $struct = true






/*Swift.(file).ContiguousArray.init(_buffer:ContiguousArray<Element>._Buffer)*/
/*Swift.(file).ContiguousArray.init(_buffer:ContiguousArray<Element>._Buffer)*/
init_bufferContiguousArray_Buffer(_buffer, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.init(_buffer:ContiguousArray<Element>._Buffer) in ' + this.constructor.name
}







/*Swift.(file).ContiguousArray.capacity*/
capacity$get() {
let _this = this;
return _this._getCapacity( {})
}
get capacity() { return this.capacity$get() };
















/*Swift.(file).ContiguousArray.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).ContiguousArray.endIndex*/
endIndex$get() {
let _this = this;
return _this._getCount( {})
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).ContiguousArray.index(after:Int)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return Int.$add(i, 1)
}
/*Swift.(file).ContiguousArray.formIndex(after:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.$addAndAssign({get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
}
/*Swift.(file).ContiguousArray.index(before:Int)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return Int.$subtract(i, 1)
}
/*Swift.(file).ContiguousArray.formIndex(before:Int)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.$subtractAndAssign({get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
}
/*Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?) {
let _this = this;
return Int.$add(i, distance)
}
/*Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, distance, limit, $info?) {
let _this = this;
const l = Int.$subtract(limit, i);
if(((Int.$greaterThan(distance, 0) ? Bool.$logicalAND(Int.$greaterThanOrEqual(l, 0), () => Int.$lessThan(l, distance)) : Bool.$logicalAND(Int.$lessThanOrEqual(l, 0), () => Int.$lessThan(distance, l))))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional(Int.$add(i, distance))
}
/*Swift.(file).ContiguousArray.distance(from:Int,to:Int)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return Int.$subtract(end, start)
}


/*Swift.(file).ContiguousArray.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(index, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file).ContiguousArray.subscript(_:Int)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$_modify(index, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.subscript(_:Int) in ' + this.constructor.name
}




/*Swift.(file).ContiguousArray.subscript(_:Range<Int>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}/*Swift.(file).ContiguousArray.subscript(_:Range<Int>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(rhs, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}




/*Swift.(file).ContiguousArray.count*/
count$get() {
let _this = this;
return _this._getCount( {})
}
get count() { return this.count$get() };




/*Swift.(file).ContiguousArray.init(arrayLiteral:[Element])*/
/*Swift.(file).ExpressibleByArrayLiteral.init(arrayLiteral:[Self.ArrayLiteralElement])*/
initArrayLiteralArray(_elements, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.init(arrayLiteral:[Element]) in ' + this.constructor.name
}

/*Swift.(file).ContiguousArray.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
throw 'unsupported method Swift.(file).ContiguousArray.init() in ' + this.constructor.name
}
/*Swift.(file).ContiguousArray.init(_:S)*/
/*Swift.(file)._ArrayProtocol.init(_:Self._Buffer)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
initBuffer<S>(s, $info?) {
let _this = this;
_this.init( {});
_this.appendContentsOf(_elements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return
}
/*Swift.(file).ContiguousArray.init(repeating:Element,count:Int)*/
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
initRepeatingCountInt(repeatedValue, count, $info?) {
let _this = this;
let p;
let $tuple = ContiguousArray._allocateUninitialized(count)
$info.$setThis(_this = _cloneStruct($tuple[0]))
p = $tuple[1];
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, count).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
p.initializeTo(repeatedValue);
UnsafeMutablePointer.$addAndAssign({get: () => p, set: $val => p = $val}, 1);
}
};
return
}

/*Swift.(file).ContiguousArray.init(_uninitializedCount:Int)*/
/*Swift.(file).ContiguousArray.init(_uninitializedCount:Int)*/
init_uninitializedCountInt(count, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.init(_uninitializedCount:Int) in ' + this.constructor.name
}

/*Swift.(file).ContiguousArray.reserveCapacity(_:Int)*/
/*Swift.(file)._ArrayProtocol.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
reserveCapacity(minimumCapacity, $info?) {

}




/*Swift.(file).ContiguousArray.append(_:Element)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(newElement, $info?) {
let _this = this;
_this._makeUniqueAndReserveCapacityIfNotUnique( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const oldCount = _this._getCount( {});
_this._appendElementAssumeUniqueAndCapacityNewElement(oldCount, newElement, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).ContiguousArray.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
appendContentsOf<S>(newElements, $info?) {
let _this = this;
const approximateCapacity = Int.$add(_this.count, numericCast(newElements.underestimatedCount, {T: Int, U: Int}));
{
let $element$generator = newElements.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
_this.append(_element_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file).ContiguousArray.reserveCapacityForAppend(newElementsCount:Int)*/
/*Swift.(file).ContiguousArray.reserveCapacityForAppend(newElementsCount:Int)*/
reserveCapacityForAppendNewElementsCount(newElementsCount, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.reserveCapacityForAppend(newElementsCount:Int) in ' + this.constructor.name
}

/*Swift.(file).ContiguousArray.remove(at:Int)*/
/*Swift.(file)._ArrayProtocol.remove(at:Int)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
removeAt(index, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove from an empty collection", null, null);
const result = _this.subscript$get(position);
_this.replaceSubrangeWith((_.arg0 = position).constructor.$halfOpenRange(_.arg0, _this.indexAfter(position)), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return result
}
/*Swift.(file).ContiguousArray.insert(_:Element,at:Int)*/
/*Swift.(file)._ArrayProtocol.insert(_:Self.Element,at:Int)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
insertAt(newElement, i, $info?) {
let _this = this;
_this.replaceSubrangeWith(Int.$halfOpenRange(i, i), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).ContiguousArray.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
let _this = this;
if((Bool.$not(keepCapacity))) {
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'init', {})));
}
else {
_this.replaceSubrangeWith((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}

/*Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withContiguousMutableStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(_this.withUnsafeMutableBufferPointer(((bufferPointer$inout, $info?) => body({get: () => bufferPointer, set: $val => bufferPointer = $val})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
}
/*Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(_this.withUnsafeBufferPointer(((bufferPointer, $info?) => body(bufferPointer))))
}



/*Swift.(file).ContiguousArray.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, _injectIntoOptional(Mirror.DisplayStyle.collection), , {})
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).ContiguousArray.description*/
description$get() {
let _this = this;
return _this._makeCollectionDescriptionWithTypeName( null)
}
get description() { return this.description$get() };




/*Swift.(file).ContiguousArray.debugDescription*/
debugDescription$get() {
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(_injectIntoOptional("ContiguousArray"))
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).ContiguousArray.init(unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)*/
/*Swift.(file).ContiguousArray.init(unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)*/
initUnsafeUninitializedCapacityIntInitializingWithfunction_type(unsafeUninitializedCapacity, initializer, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(_create(ContiguousArray, 'initBuffer', _create(Array, 'init_unsafeUninitializedCapacityIntInitializingWithfunction_type', unsafeUninitializedCapacity, initializer, {}), {}))));
return
}
/*Swift.(file).ContiguousArray.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file).ContiguousArray.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file).ContiguousArray.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file).ContiguousArray.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}

/*Swift.(file).ContiguousArray.replaceSubrange(_:Range<Int>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(subrange, newElements, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.replaceSubrange(_:Range<Int>,with:C) in ' + this.constructor.name
}
static /*Swift.(file).ContiguousArray.==infix(_:ContiguousArray<Element>,_:ContiguousArray<Element>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
/*Swift.(file).ContiguousArray.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.count, {$setThis: $val => hasher = $val});
{
let $element$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
hasher.combine(_element_1, {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).ContiguousArray.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).ContiguousArray.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)*/
/*Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)*/
withUnsafeMutableBytes<R>(body, $info?) {
let _this = this;
return _this.withUnsafeMutableBufferPointer((($0$inout, $info?) => body(_create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', $0, {}))), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
return _this.withUnsafeBufferPointer((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}))))
}
/*Swift.(file).ContiguousArray.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).ContiguousArray.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).ContiguousArray.init(from:Decoder) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof _DestructorSafeContainer$implementation != 'undefined') _mixin(ContiguousArray, _DestructorSafeContainer$implementation, false)
if(typeof _ArrayProtocol$implementation != 'undefined') _mixin(ContiguousArray, _ArrayProtocol$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(ContiguousArray, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(ContiguousArray, MutableCollection$implementation, false)
if(typeof ExpressibleByArrayLiteral$implementation != 'undefined') _mixin(ContiguousArray, ExpressibleByArrayLiteral$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(ContiguousArray, RangeReplaceableCollection$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(ContiguousArray, CustomReflectable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(ContiguousArray, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(ContiguousArray, CustomDebugStringConvertible$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(ContiguousArray, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(ContiguousArray, Hashable$implementation, false)
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(ContiguousArray, _HasContiguousBytes$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(ContiguousArray, Encodable$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(ContiguousArray, Decodable$implementation, false)


































class ClosedRange<Bound> implements RangeExpression, Sequence, Collection, BidirectionalCollection, RandomAccessCollection, Equatable, Hashable, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable, Decodable, Encodable{
static readonly $struct = true

/*Swift.(file).ClosedRange.lowerBound*/
readonly lowerBound$get() {
return this.lowerBound$internal
}
readonly get lowerBound() { return this.lowerBound$get() };




/*Swift.(file).ClosedRange.upperBound*/
readonly upperBound$get() {
return this.upperBound$internal
}
readonly get upperBound() { return this.upperBound$get() };



/*Swift.(file).ClosedRange.init(uncheckedBounds:(lower: Bound, upper: Bound))*/
/*Swift.(file).ClosedRange.init(uncheckedBounds:(lower: Bound, upper: Bound))*/
initUncheckedBoundstuple_type(bounds, $info?) {
this.lowerBound$internal = bounds[0]
this.upperBound$internal = bounds[1]
}

/*Swift.(file).ClosedRange.isEmpty*/
isEmpty$get() {
let _this = this;
return false
}
get isEmpty() { return this.isEmpty$get() };



/*Swift.(file).ClosedRange.relative(to:C)*/
/*Swift.(file).RangeExpression.relative(to:C)*/
relativeTo<C>(collection, $info?) {
let _this = this;
return _create(Range, 'initUncheckedBoundstuple_type', {0: _this.lowerBound, 1: collection.indexAfter(_this.upperBound)}, {})
}
/*Swift.(file).ClosedRange.contains(_:Bound)*/
/*Swift.(file).RangeExpression.contains(_:Self.Bound)*/
contains(_element, $info?) {
let _this = this;
return Bool.$logicalAND((_.arg0 = _element).constructor.$greaterThanOrEqual(_.arg0, _this.lowerBound), () => (_.arg1 = _element).constructor.$lessThanOrEqual(_.arg1, _this.upperBound))
}



static Index = class implements Comparable, Hashable{

static get pastEnd() {return Object.assign(new ClosedRange.Index(), {rawValue: "pastEnd", ...Array.from(arguments)})}

static inRange() {return Object.assign(new ClosedRange.Index(), {rawValue: "inRange", ...Array.from(arguments)})}
static /*Swift.(file).ClosedRange.Index.==infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Bound'})()).$equal(l, r);
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
}
static /*Swift.(file).ClosedRange.Index.<infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
let _this = this;
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Bound'})()).$lessThan(l, r);
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
}
/*Swift.(file).ClosedRange.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
const $match = _this
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const value = $match[0]
hasher.combine(0, {$setThis: $val => hasher = $val});
hasher.combine(value, {$setThis: $val => hasher = $val});
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
hasher.combine(1, {$setThis: $val => hasher = $val});
};})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).ClosedRange.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).ClosedRange.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}


/*Swift.(file).ClosedRange.startIndex*/
startIndex$get() {
let _this = this;
return ClosedRange.Index.inRange(_this.lowerBound)
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).ClosedRange.endIndex*/
endIndex$get() {
let _this = this;
return ClosedRange.Index.pastEnd
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return ((_.arg0 = _this.upperBound).constructor.$equal(x, _.arg0) ? ClosedRange.Index.pastEnd : ClosedRange.Index.inRange(x.advancedBy(1)));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine(() => "Incrementing past end index", null, null);
}
}
/*Swift.(file).ClosedRange.index(before:ClosedRange<Bound>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
preconditionFileLine(() => (_.arg0 = _this.lowerBound).constructor.$greaterThan(x, _.arg0), () => "Incrementing past start index", null, null);
return ClosedRange.Index.inRange(x.advancedBy(-1));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFileLine(() => (_.arg1 = _this.upperBound).constructor.$greaterThanOrEqual(_.arg1, _this.lowerBound), () => "Incrementing past start index", null, null);
return ClosedRange.Index.inRange(_this.upperBound);
}
}
/*Swift.(file).ClosedRange.index(_:ClosedRange<Bound>.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, distance, $info?) {
let _this = this;
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
const d = x.distanceTo(_this.upperBound);
if((Int.$lessThanOrEqual(distance, d))) {
const newPosition = x.advancedBy(numericCast(distance, {T: Int, U: Int}));
preconditionFileLine(() => (_.arg0 = _this.lowerBound).constructor.$greaterThanOrEqual(newPosition, _.arg0), () => "Advancing past start index", null, null);
return ClosedRange.Index.inRange(newPosition);
};
if((Int.$equal(Int.$subtract(d, -1), distance))) {
return ClosedRange.Index.pastEnd;
};
preconditionFailureFileLine(() => "Advancing past end index", null, null);
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
if((Int.$equal(distance, 0))) {
return i;
};
if((Int.$lessThan(distance, 0))) {
return _this.indexOffsetBy(ClosedRange.Index.inRange(_this.upperBound), numericCast(Int.$add(distance, 1), {T: Int, U: Int}));
};
preconditionFailureFileLine(() => "Advancing past end index", null, null);
}
}
/*Swift.(file).ClosedRange.distance(from:ClosedRange<Bound>.Index,to:ClosedRange<Bound>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
const $match = {0: start, 1: end}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const left = $match[0][0]
const right = $match[1][0]
return numericCast(left.distanceTo(right), {T: Int, U: Int});
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
const left = $match[0][0]
return numericCast(Int.$add(1, left.distanceTo(_this.upperBound)), {T: Int, U: Int});
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const right = $match[1][0]
return numericCast(Int.$subtract(_this.upperBound.distanceTo(right), 1), {T: Int, U: Int});
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return 0;
}
}
/*Swift.(file).ClosedRange.subscript(_:ClosedRange<Bound>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
const $match = position
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return x;
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine(() => "Index out of range", null, null);
}
}


/*Swift.(file).ClosedRange.subscript(_:Range<ClosedRange<Bound>.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}





static /*Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return Bool.$logicalAND((_.arg0 = lhs.lowerBound).constructor.$equal(_.arg0, rhs.lowerBound), () => (_.arg1 = lhs.upperBound).constructor.$equal(_.arg1, rhs.upperBound))
}
/*Swift.(file).ClosedRange.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.lowerBound, {$setThis: $val => hasher = $val});
hasher.combine(_this.upperBound, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}



/*Swift.(file).ClosedRange.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).ClosedRange.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };


/*Swift.(file).ClosedRange.description*/
description$get() {
let _this = this;
return (("") + (_this.lowerBound) + ("...") + (_this.upperBound) + (""))
}
get description() { return this.description$get() };




/*Swift.(file).ClosedRange.debugDescription*/
debugDescription$get() {
let _this = this;
return String.$add((("ClosedRange(") + (_create(String, 'initReflecting', _this.lowerBound, {})) + ("")), (("...") + (_create(String, 'initReflecting', _this.upperBound, {})) + (")")))
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).ClosedRange.customMirror*/
customMirror$get() {
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["lowerBound", _this.lowerBound], ["upperBound", _this.upperBound]]), , , {})
}
get customMirror() { return this.customMirror$get() };



/*Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)*/
/*Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)*/
clampedTo(limits, $info?) {
let _this = this;
const lower = ((_.arg0 = limits.lowerBound).constructor.$greaterThan(_.arg0, _this.lowerBound) ? limits.lowerBound : ((_.arg1 = limits.upperBound).constructor.$lessThan(_.arg1, _this.lowerBound) ? limits.upperBound : _this.lowerBound));
const upper = ((_.arg2 = limits.upperBound).constructor.$lessThan(_.arg2, _this.upperBound) ? limits.upperBound : ((_.arg3 = limits.lowerBound).constructor.$greaterThan(_.arg3, _this.upperBound) ? limits.lowerBound : _this.upperBound));
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {0: lower, 1: upper}, {})
}
/*Swift.(file).ClosedRange.init(_:Range<Bound>)*/
/*Swift.(file).ClosedRange.init(_:Range<Bound>)*/
initRange(other, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(other.isEmpty), () => "Can't form an empty closed range", null, null);
const upperBound = other.upperBound.advancedBy(-1);
_this.initUncheckedBoundstuple_type({0: other.lowerBound, 1: upperBound});
return
}
/*Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)*/
/*Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)*/
overlaps(other, $info?) {
let _this = this;
const isDisjoint = Bool.$logicalOR((_.arg0 = other.upperBound).constructor.$lessThan(_.arg0, _this.lowerBound), () => (_.arg1 = _this.upperBound).constructor.$lessThan(_.arg1, other.lowerBound));
return Bool.$not(isDisjoint)
}
/*Swift.(file).ClosedRange.overlaps(_:Range<Bound>)*/
/*Swift.(file).ClosedRange.overlaps(_:Range<Bound>)*/
/*!!!DUPLICATE NAME*/
overlaps(other, $info?) {
let _this = this;
return other.overlaps(_this)
}
/*Swift.(file).ClosedRange.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
const lowerBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
const upperBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
if(!(((_.arg0 = lowerBound).constructor.$lessThanOrEqual(_.arg0, upperBound)))) {
throw DecodingError.dataCorrupted(_create(DecodingError.Context, 'initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional', decoder.codingPath, (("Cannot initialize ") + (ClosedRange) + (" with a lowerBound (") + (lowerBound) + (") greater than upperBound (") + (upperBound) + (")")), , {}));
};
_this.initUncheckedBoundstuple_type({0: lowerBound, 1: upperBound});
return
}
/*Swift.(file).ClosedRange.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.lowerBound, {$setThis: $val => container = $val});
container.encode(_this.upperBound, {$setThis: $val => container = $val})
}
/*Swift.(file).ClosedRange.init(_:ClosedRange<Bound>)*/
/*Swift.(file).ClosedRange.init(_:ClosedRange<Bound>)*/
initClosedRange(other, $info?) {
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(other)));
return
}
init$vars() {let _this = this;

}
}
if(typeof Comparable$implementation != 'undefined') _mixin(ClosedRange.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(ClosedRange.Index, Hashable$implementation, false)
_mixin(ClosedRange.Index, _DefaultEnumImplementation, false)
if(typeof RangeExpression$implementation != 'undefined') _mixin(ClosedRange, RangeExpression$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(ClosedRange, Sequence$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(ClosedRange, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(ClosedRange, BidirectionalCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(ClosedRange, RandomAccessCollection$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(ClosedRange, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(ClosedRange, Hashable$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(ClosedRange, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(ClosedRange, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(ClosedRange, CustomReflectable$implementation, false)
if(typeof Decodable$implementation != 'undefined') _mixin(ClosedRange, Decodable$implementation, false)
if(typeof Encodable$implementation != 'undefined') _mixin(ClosedRange, Encodable$implementation, false)


































class _ContiguousArrayBuffer<Element> implements _ArrayBufferProtocol, RandomAccessCollection{
static readonly $struct = true
/*Swift.(file)._ContiguousArrayBuffer.init(_uninitializedCount:Int,minimumCapacity:Int)*/
/*Swift.(file)._ContiguousArrayBuffer.init(_uninitializedCount:Int,minimumCapacity:Int)*/
init_uninitializedCountIntMinimumCapacityInt(uninitializedCount, minimumCapacity, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.init(_uninitializedCount:Int,minimumCapacity:Int) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.init(count:Int,storage:_ContiguousArrayStorage<Element>)*/
/*Swift.(file)._ContiguousArrayBuffer.init(count:Int,storage:_ContiguousArrayStorage<Element>)*/
initCountIntStorage_ContiguousArrayStorage(count, storage, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.init(count:Int,storage:_ContiguousArrayStorage<Element>) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.init(_:__ContiguousArrayStorageBase)*/
/*Swift.(file)._ContiguousArrayBuffer.init(_:__ContiguousArrayStorageBase)*/
init__ContiguousArrayStorageBase(storage, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.init(_:__ContiguousArrayStorageBase) in ' + this.constructor.name
}


/*Swift.(file)._ContiguousArrayBuffer.arrayPropertyIsNativeTypeChecked*/
arrayPropertyIsNativeTypeChecked$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayBuffer.arrayPropertyIsNativeTypeChecked in ' + this.constructor.name
}
get arrayPropertyIsNativeTypeChecked() { return this.arrayPropertyIsNativeTypeChecked$get() };




/*Swift.(file)._ContiguousArrayBuffer.firstElementAddress*/
firstElementAddress$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayBuffer.firstElementAddress in ' + this.constructor.name
}
get firstElementAddress() { return this.firstElementAddress$get() };




/*Swift.(file)._ContiguousArrayBuffer.firstElementAddressIfContiguous*/
firstElementAddressIfContiguous$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayBuffer.firstElementAddressIfContiguous in ' + this.constructor.name
}
get firstElementAddressIfContiguous() { return this.firstElementAddressIfContiguous$get() };



/*Swift.(file)._ContiguousArrayBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.init()*/
/*Swift.(file)._ArrayBufferProtocol.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.init() in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.init(_buffer:_ContiguousArrayBuffer<Element>,shiftedToStartIndex:Int)*/
/*Swift.(file)._ArrayBufferProtocol.init(_buffer:_ContiguousArrayBuffer<Self.Element>,shiftedToStartIndex:Int)*/
init_buffer_ContiguousArrayBufferShiftedToStartIndexInt(buffer, shiftedToStartIndex, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.init(_buffer:_ContiguousArrayBuffer<Element>,shiftedToStartIndex:Int) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
/*Swift.(file)._ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
requestUniqueMutableBackingBufferMinimumCapacity(minimumCapacity, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.isMutableAndUniquelyReferenced()*/
/*Swift.(file)._ArrayBufferProtocol.isMutableAndUniquelyReferenced()*/
isMutableAndUniquelyReferenced($info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.isMutableAndUniquelyReferenced() in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.requestNativeBuffer()*/
/*Swift.(file)._ArrayBufferProtocol.requestNativeBuffer()*/
requestNativeBuffer($info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.requestNativeBuffer() in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.getElement(_:Int)*/
/*Swift.(file)._ContiguousArrayBuffer.getElement(_:Int)*/
getElement(i, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.getElement(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file)._ContiguousArrayBuffer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, i, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.subscript(_:Int) in ' + this.constructor.name
}





/*Swift.(file)._ContiguousArrayBuffer.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };







/*Swift.(file)._ContiguousArrayBuffer.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayBuffer.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };





/*Swift.(file)._ContiguousArrayBuffer.subscript(_:Range<Int>)*/
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*!!!DUPLICATE NAME*/
subscript$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}
subscriptRange$get(bounds, $info?){
this.subscript$get.apply(this,arguments)
}/*Swift.(file)._ContiguousArrayBuffer.subscript(_:Range<Int>)*/
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}
subscriptRange$set(newValue, bounds, $info?){
this.subscript$set.apply(this,arguments)
}



/*Swift.(file)._ContiguousArrayBuffer.isUniquelyReferenced()*/
/*Swift.(file)._ContiguousArrayBuffer.isUniquelyReferenced()*/
isUniquelyReferenced($info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.isUniquelyReferenced() in ' + this.constructor.name
}


/*Swift.(file)._ContiguousArrayBuffer.owner*/
owner$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayBuffer.owner in ' + this.constructor.name
}
get owner() { return this.owner$get() };




/*Swift.(file)._ContiguousArrayBuffer.nativeOwner*/
nativeOwner$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayBuffer.nativeOwner in ' + this.constructor.name
}
get nativeOwner() { return this.nativeOwner$get() };




/*Swift.(file)._ContiguousArrayBuffer.identity*/
identity$get() {
throw 'unsupported variable Swift.(file)._ContiguousArrayBuffer.identity in ' + this.constructor.name
}
get identity() { return this.identity$get() };



/*Swift.(file)._ContiguousArrayBuffer.canStoreElements(ofDynamicType:Any.Type)*/
/*Swift.(file)._ContiguousArrayBuffer.canStoreElements(ofDynamicType:Any.Type)*/
canStoreElementsOfDynamicType(proposedElementType, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.canStoreElements(ofDynamicType:Any.Type) in ' + this.constructor.name
}
/*Swift.(file)._ContiguousArrayBuffer.storesOnlyElementsOfType(_:U.Type)*/
/*Swift.(file)._ContiguousArrayBuffer.storesOnlyElementsOfType(_:U.Type)*/
storesOnlyElementsOfType<U>(_, $info?) {
throw 'unsupported method Swift.(file)._ContiguousArrayBuffer.storesOnlyElementsOfType(_:U.Type) in ' + this.constructor.name
}






/*Swift.(file)._ContiguousArrayBuffer.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._ContiguousArrayBuffer.endIndex*/
endIndex$get() {
let _this = this;
return _this.count
}
get endIndex() { return this.endIndex$get() };









init$vars() {let _this = this;

}
}
if(typeof _ArrayBufferProtocol$implementation != 'undefined') _mixin(_ContiguousArrayBuffer, _ArrayBufferProtocol$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_ContiguousArrayBuffer, RandomAccessCollection$implementation, false)






class LazyDropWhileSequence<Base> implements Sequence, LazySequenceProtocol, Collection, BidirectionalCollection, LazyCollectionProtocol{
static readonly $struct = true

/*Swift.(file).LazyDropWhileSequence.init(_base:Base,predicate:(LazyDropWhileSequence<Base>.Element) -> Bool)*/
/*Swift.(file).LazyDropWhileSequence.init(_base:Base,predicate:(LazyDropWhileSequence<Base>.Element) -> Bool)*/
init_basePredicatefunction_type(_base, predicate, $info?) {
throw 'unsupported method Swift.(file).LazyDropWhileSequence.init(_base:Base,predicate:(LazyDropWhileSequence<Base>.Element) -> Bool) in ' + this.constructor.name
}








static Iterator = class implements IteratorProtocol{
static readonly $struct = true

/*Swift.(file).LazyDropWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyDropWhileSequence<Base>.Iterator.Element) -> Bool)*/
/*Swift.(file).LazyDropWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyDropWhileSequence<Base>.Iterator.Element) -> Bool)*/
init_basePredicatefunction_type(_base, predicate, $info?) {
throw 'unsupported method Swift.(file).LazyDropWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyDropWhileSequence<Base>.Iterator.Element) -> Bool) in ' + this.constructor.name
}













/*Swift.(file).LazyDropWhileSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
if((_this._predicateHasFailed)) {
return _this._base.next( {$setThis: $val => _this._base = $val});
};
while(true){
const $ifLet0, nextElement_1
if(!((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((nextElement_1 = $ifLet0[0])||true))) break
if((Bool.$not(_this._predicate(nextElement_1)))) {
_this._predicateHasFailed = true;
return _injectIntoOptional(nextElement_1);
};
};
return _injectIntoOptional(null)
}
init$vars() {let _this = this;

}
}
/*Swift.(file).LazyDropWhileSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(LazyDropWhileSequence.Iterator, 'init_basePredicatefunction_type', _this._base.makeIterator( {}), _this._predicate, {})
}




/*Swift.(file).LazyDropWhileSequence.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).LazyDropWhileSequence.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).LazyDropWhileSequence.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).LazyDropWhileSequence.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).LazyDropWhileSequence.index(after:LazyDropWhileSequence<Base>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).LazyDropWhileSequence.index(after:LazyDropWhileSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyDropWhileSequence.subscript(_:LazyDropWhileSequence<Base>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).LazyDropWhileSequence.subscript(_:LazyDropWhileSequence<Base>.Index) in ' + this.constructor.name
}



/*Swift.(file).LazyDropWhileSequence.index(before:LazyDropWhileSequence<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).LazyDropWhileSequence.index(before:LazyDropWhileSequence<Base>.Index) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(LazyDropWhileSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(LazyDropWhileSequence, Sequence$implementation, false)
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(LazyDropWhileSequence, LazySequenceProtocol$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(LazyDropWhileSequence, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(LazyDropWhileSequence, BidirectionalCollection$implementation, false)
if(typeof LazyCollectionProtocol$implementation != 'undefined') _mixin(LazyDropWhileSequence, LazyCollectionProtocol$implementation, false)














class EmptyCollection<Element> implements Sequence, RandomAccessCollection, MutableCollection, Equatable{
static readonly $struct = true
/*Swift.(file).EmptyCollection.init()*/
/*Swift.(file).EmptyCollection.init()*/
init($info?) {
let _this = this;
return
}
static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true
/*Swift.(file).EmptyCollection.Iterator.init()*/
/*Swift.(file).EmptyCollection.Iterator.init()*/
init($info?) {
let _this = this;
return
}
/*Swift.(file).EmptyCollection.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
return _injectIntoOptional(null)
}


init$vars() {let _this = this;

}
}
/*Swift.(file).EmptyCollection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(EmptyCollection.Iterator, 'init', {})
}





/*Swift.(file).EmptyCollection.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).EmptyCollection.endIndex*/
endIndex$get() {
let _this = this;
return 0
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).EmptyCollection.index(after:EmptyCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
preconditionFailureFileLine(() => "EmptyCollection can't advance indices", null, null)
}
/*Swift.(file).EmptyCollection.index(before:EmptyCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
preconditionFailureFileLine(() => "EmptyCollection can't advance indices", null, null)
}
/*Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
preconditionFailureFileLine(() => "Index out of range", null, null);

}/*Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$set(newValue, position, $info?) {
let _this = this;
preconditionFailureFileLine(() => "Index out of range", null, null)
}




/*Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$logicalAND(Int.$equal(bounds.lowerBound, 0), () => Int.$equal(bounds.upperBound, 0)), () => "Index out of range", null, null);
return _this;

}/*Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$set(newValue, bounds, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$logicalAND(Int.$equal(bounds.lowerBound, 0), () => Int.$equal(bounds.upperBound, 0)), () => "Index out of range", null, null)
}




/*Swift.(file).EmptyCollection.count*/
count$get() {
let _this = this;
return 0
}
get count() { return this.count$get() };



/*Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$logicalAND(Int.$equal(i, _this.startIndex), () => Int.$equal(n, 0)), () => "Index out of range", null, null);
return i
}
/*Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int,limitedBy:EmptyCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$logicalAND(Int.$equal(i, _this.startIndex), () => Int.$equal(limit, _this.startIndex)), () => "Index out of range", null, null);
return (Int.$equal(n, 0) ? _injectIntoOptional(i) : _injectIntoOptional(null))
}
/*Swift.(file).EmptyCollection.distance(from:EmptyCollection<Element>.Index,to:EmptyCollection<Element>.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => Int.$equal(start, 0), () => "From must be startIndex (or endIndex)", null, null);
preconditionFileLine(() => Int.$equal(end, 0), () => "To must be endIndex (or startIndex)", null, null);
return 0
}


static /*Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
let _this = this;
return true
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(EmptyCollection.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(EmptyCollection.Iterator, Sequence$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(EmptyCollection, Sequence$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(EmptyCollection, RandomAccessCollection$implementation, false)
if(typeof MutableCollection$implementation != 'undefined') _mixin(EmptyCollection, MutableCollection$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(EmptyCollection, Equatable$implementation, false)










class LazyFilterSequence<Base> implements Sequence, LazySequenceProtocol, Collection, LazyCollectionProtocol, BidirectionalCollection{
static readonly $struct = true








/*Swift.(file).LazyFilterSequence.init(_base:Base,_:(Base.Element) -> Bool)*/
/*Swift.(file).LazyFilterSequence.init(_base:Base,_:(Base.Element) -> Bool)*/
init_basefunction_type(base, isIncluded, $info?) {
throw 'unsupported method Swift.(file).LazyFilterSequence.init(_base:Base,_:(Base.Element) -> Bool) in ' + this.constructor.name
}
static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true

/*Swift.(file).LazyFilterSequence.Iterator.base*/
base$get() {
let _this = this;
return _this._base
}
get base() { return this.base$get() };











/*Swift.(file).LazyFilterSequence.Iterator.init(_base:Base.Iterator,_:(Base.Element) -> Bool)*/
/*Swift.(file).LazyFilterSequence.Iterator.init(_base:Base.Iterator,_:(Base.Element) -> Bool)*/
init_basefunction_type(_base, isIncluded, $info?) {
throw 'unsupported method Swift.(file).LazyFilterSequence.Iterator.init(_base:Base.Iterator,_:(Base.Element) -> Bool) in ' + this.constructor.name
}

/*Swift.(file).LazyFilterSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
while(true){
const $ifLet0, n_1
if(!((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((n_1 = $ifLet0[0])||true))) break
if((_this._predicate(n_1))) {
return _injectIntoOptional(n_1);
};
};
return _injectIntoOptional(null)
}

init$vars() {let _this = this;

}
}

/*Swift.(file).LazyFilterSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(LazyFilterSequence.Iterator, 'init_basefunction_type', _this._base.makeIterator( {}), _this._predicate, {})
}




/*Swift.(file).LazyFilterSequence.underestimatedCount*/
underestimatedCount$get() {
throw 'unsupported variable Swift.(file).LazyFilterSequence.underestimatedCount in ' + this.constructor.name
}
get underestimatedCount() { return this.underestimatedCount$get() };





/*Swift.(file).LazyFilterSequence.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).LazyFilterSequence.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).LazyFilterSequence.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).LazyFilterSequence.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).LazyFilterSequence.index(after:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).LazyFilterSequence.index(after:LazyFilterSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyFilterSequence.formIndex(after:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}


/*Swift.(file).LazyFilterSequence.distance(from:LazyFilterSequence<Base>.Index,to:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}
/*Swift.(file).LazyFilterSequence.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)*/
/*Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)*/
formIndexOffsetBy(i$inout, n, $info?) {
throw 'unsupported method Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int) in ' + this.constructor.name
}
/*Swift.(file).LazyFilterSequence.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)*/
formIndexOffsetByLimitedBy(i$inout, n, limit, $info?) {
throw 'unsupported method Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyFilterSequence.subscript(_:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).LazyFilterSequence.subscript(_:LazyFilterSequence<Base>.Index) in ' + this.constructor.name
}


/*Swift.(file).LazyFilterSequence.subscript(_:Range<LazyFilterSequence<Base>.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}



/*Swift.(file).LazyFilterSequence.index(before:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).LazyFilterSequence.index(before:LazyFilterSequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyFilterSequence.formIndex(before:LazyFilterSequence<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).LazyFilterSequence.filter(_:(LazyFilterSequence<Base>.Element) -> Bool)*/
/*Swift.(file).LazyFilterSequence.filter(_:(LazyFilterSequence<Base>.Element) -> Bool)*/
filterSwift(isIncluded, $info?) {
let _this = this;
return _create(LazyFilterSequence, 'init_basefunction_type', _this._base, (($0, $info?) => Bool.$logicalAND(isIncluded($0), () => _this._predicate($0))), {})
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(LazyFilterSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(LazyFilterSequence.Iterator, Sequence$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(LazyFilterSequence, Sequence$implementation, false)
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(LazyFilterSequence, LazySequenceProtocol$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(LazyFilterSequence, Collection$implementation, false)
if(typeof LazyCollectionProtocol$implementation != 'undefined') _mixin(LazyFilterSequence, LazyCollectionProtocol$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(LazyFilterSequence, BidirectionalCollection$implementation, false)
















class FloatingPointSign{

static get plus() {return Object.assign(new FloatingPointSign(), {rawValue: "plus", ...Array.from(arguments)})}

static get minus() {return Object.assign(new FloatingPointSign(), {rawValue: "minus", ...Array.from(arguments)})}
/*Swift.(file).FloatingPointSign.init(rawValue:Int)*/
/*Swift.(file).RawRepresentable.init(rawValue:Self.RawValue)*/
initRawValue(rawValue, $info?) {
let _this = this;
const $match = rawValue
if(((($patternMatch(0, $match))))) {
$info.$setThis(_this = _cloneStruct(FloatingPointSign.plus));
}
else if(((($patternMatch(1, $match))))) {
$info.$setThis(_this = _cloneStruct(FloatingPointSign.minus));
}
else if(((true))) {
return (this.$failed = true);
};
return
}
static readonly initRawValue$failable = true

/*Swift.(file).FloatingPointSign.rawValue*/
rawValue$get() {
let _this = this;
const $match = _this
if((($match.rawValue == FloatingPointSign.plus.rawValue))) {
return 0;
}
else if((($match.rawValue == FloatingPointSign.minus.rawValue))) {
return 1;
}
}
get rawValue() { return this.rawValue$get() };



static /*Swift.(file).FloatingPointSign.==infix(_:FloatingPointSign,_:FloatingPointSign)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}

/*Swift.(file).FloatingPointSign.hashValue*/
hashValue$get() {
let _this = this;
return Int.prototype.hashValue$get.call(_this.rawValue)
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).FloatingPointSign.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
}


init$vars() {let _this = this;

}
}
_mixin(FloatingPointSign, _DefaultEnumImplementation, false)


class DefaultIndices<Elements> implements Collection, BidirectionalCollection, RandomAccessCollection{
static readonly $struct = true















/*Swift.(file).DefaultIndices.init(_elements:Elements,startIndex:Elements.Index,endIndex:Elements.Index)*/
/*Swift.(file).DefaultIndices.init(_elements:Elements,startIndex:Elements.Index,endIndex:Elements.Index)*/
init_elementsStartIndexEndIndex(_elements, startIndex, endIndex, $info?) {
let _this = this;
_this._elements = _elements;
_this._startIndex = startIndex;
_this._endIndex = endIndex;
return
}






/*Swift.(file).DefaultIndices.startIndex*/
startIndex$get() {
let _this = this;
return _this._startIndex
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).DefaultIndices.endIndex*/
endIndex$get() {
let _this = this;
return _this._endIndex
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).DefaultIndices.subscript(_:DefaultIndices<Elements>.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
let _this = this;
return i
}


/*Swift.(file).DefaultIndices.subscript(_:Range<DefaultIndices<Elements>.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this._elements, bounds.lowerBound, bounds.upperBound, {})
}

/*Swift.(file).DefaultIndices.index(after:DefaultIndices<Elements>.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
let _this = this;
return _this._elements.indexAfter(i)
}
/*Swift.(file).DefaultIndices.formIndex(after:DefaultIndices<Elements>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._elements.formIndexAfter({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}

/*Swift.(file).DefaultIndices.indices*/
indices$get() {
let _this = this;
return _this
}
get indices() { return this.indices$get() };



/*Swift.(file).DefaultIndices.index(before:DefaultIndices<Elements>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
let _this = this;
return _this._elements.indexBefore(i)
}
/*Swift.(file).DefaultIndices.formIndex(before:DefaultIndices<Elements>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._elements.formIndexBefore({get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
}
init$vars() {let _this = this;

}
}
if(typeof Collection$implementation != 'undefined') _mixin(DefaultIndices, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(DefaultIndices, BidirectionalCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(DefaultIndices, RandomAccessCollection$implementation, false)








class KeyValuePairs<Key, Value> implements ExpressibleByDictionaryLiteral, RandomAccessCollection, CustomStringConvertible, CustomDebugStringConvertible{
static readonly $struct = true



/*Swift.(file).KeyValuePairs.init(dictionaryLiteral:[(Key, Value)])*/
/*Swift.(file).ExpressibleByDictionaryLiteral.init(dictionaryLiteral:[(Self.Key, Self.Value)])*/
initDictionaryLiteralArray(_elements, $info?) {
throw 'unsupported method Swift.(file).KeyValuePairs.init(dictionaryLiteral:[(Key, Value)]) in ' + this.constructor.name
}







/*Swift.(file).KeyValuePairs.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).KeyValuePairs.endIndex*/
endIndex$get() {
let _this = this;
return _this._elements.endIndex
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).KeyValuePairs.subscript(_:KeyValuePairs<Key, Value>.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
let _this = this;
return _this._elements.subscript$get(position)
}




/*Swift.(file).KeyValuePairs.description*/
description$get() {
let _this = this;
return _this._makeKeyValuePairDescriptionWithTypeName( null)
}
get description() { return this.description$get() };




/*Swift.(file).KeyValuePairs.debugDescription*/
debugDescription$get() {
let _this = this;
return _this._makeKeyValuePairDescriptionWithTypeName( null)
}
get debugDescription() { return this.debugDescription$get() };



init$vars() {let _this = this;

}
}
if(typeof ExpressibleByDictionaryLiteral$implementation != 'undefined') _mixin(KeyValuePairs, ExpressibleByDictionaryLiteral$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(KeyValuePairs, RandomAccessCollection$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(KeyValuePairs, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(KeyValuePairs, CustomDebugStringConvertible$implementation, false)








class LazySequence<Base> implements Collection, LazyCollectionProtocol, BidirectionalCollection, RandomAccessCollection, Sequence, LazySequenceProtocol{
static readonly $struct = true





/*Swift.(file).LazySequence.init(_base:Base)*/
/*Swift.(file).LazySequence.init(_base:Base)*/
init_base(_base, $info?) {
let _this = this;
_this._base = _base;
return
}




/*Swift.(file).LazySequence.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).LazySequence.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).LazySequence.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).LazySequence.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).LazySequence.indices*/
indices$get() {
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this, _this.startIndex, _this.endIndex, {})
}
get indices() { return this.indices$get() };



/*Swift.(file).LazySequence.index(after:LazySequence<Base>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).LazySequence.index(after:LazySequence<Base>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazySequence.subscript(_:LazySequence<Base>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).LazySequence.subscript(_:LazySequence<Base>.Index) in ' + this.constructor.name
}



/*Swift.(file).LazySequence.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };




/*Swift.(file).LazySequence.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };





/*Swift.(file).LazySequence.index(_:LazySequence<Base>.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).LazySequence.index(_:LazySequence<Base>.Index,offsetBy:Int,limitedBy:LazySequence<Base>.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).LazySequence.distance(from:LazySequence<Base>.Index,to:LazySequence<Base>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}
/*Swift.(file).LazySequence.index(before:LazySequence<Base>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).LazySequence.index(before:LazySequence<Base>.Index) in ' + this.constructor.name
}


/*Swift.(file).LazySequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _this._base.makeIterator( {})
}

/*Swift.(file).LazySequence.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return _this._base.underestimatedCount
}
get underestimatedCount() { return this.underestimatedCount$get() };










init$vars() {let _this = this;

}
}
if(typeof Collection$implementation != 'undefined') _mixin(LazySequence, Collection$implementation, false)
if(typeof LazyCollectionProtocol$implementation != 'undefined') _mixin(LazySequence, LazyCollectionProtocol$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(LazySequence, BidirectionalCollection$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(LazySequence, RandomAccessCollection$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(LazySequence, Sequence$implementation, false)
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(LazySequence, LazySequenceProtocol$implementation, false)






class LazyMapSequence<Base, Element> implements LazySequenceProtocol, Collection, BidirectionalCollection, LazyCollectionProtocol, RandomAccessCollection{
static readonly $struct = true









/*Swift.(file).LazyMapSequence.init(_base:Base,transform:(Base.Element) -> Element)*/
/*Swift.(file).LazyMapSequence.init(_base:Base,transform:(Base.Element) -> Element)*/
init_baseTransformfunction_type(_base, transform, $info?) {
throw 'unsupported method Swift.(file).LazyMapSequence.init(_base:Base,transform:(Base.Element) -> Element) in ' + this.constructor.name
}
static Iterator = class implements IteratorProtocol, Sequence{
static readonly $struct = true









/*Swift.(file).LazyMapSequence.Iterator.base*/
base$get() {
let _this = this;
return _this._base
}
get base() { return this.base$get() };



/*Swift.(file).LazyMapSequence.Iterator.init(_base:Base.Iterator,_transform:(Base.Element) -> LazyMapSequence<Base, Element>.Iterator.Element)*/
/*Swift.(file).LazyMapSequence.Iterator.init(_base:Base.Iterator,_transform:(Base.Element) -> LazyMapSequence<Base, Element>.Iterator.Element)*/
init_base_transformfunction_type(_base, _transform, $info?) {
throw 'unsupported method Swift.(file).LazyMapSequence.Iterator.init(_base:Base.Iterator,_transform:(Base.Element) -> LazyMapSequence<Base, Element>.Iterator.Element) in ' + this.constructor.name
}
/*Swift.(file).LazyMapSequence.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
let _this = this;
return _this._base.next( {$setThis: $val => _this._base = $val}).mapSwift(_this._transform)
}


init$vars() {let _this = this;

}
}
/*Swift.(file).LazyMapSequence.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(LazyMapSequence.Iterator, 'init_base_transformfunction_type', _this._base.makeIterator( {}), _this._transform, {})
}

/*Swift.(file).LazyMapSequence.underestimatedCount*/
underestimatedCount$get() {
let _this = this;
return _this._base.underestimatedCount
}
get underestimatedCount() { return this.underestimatedCount$get() };








/*Swift.(file).LazyMapSequence.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).LazyMapSequence.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).LazyMapSequence.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).LazyMapSequence.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).LazyMapSequence.index(after:LazyMapSequence<Base, Element>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).LazyMapSequence.index(after:LazyMapSequence<Base, Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyMapSequence.formIndex(after:LazyMapSequence<Base, Element>.Index)*/
/*Swift.(file).Collection.formIndex(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)*/
formIndexAfter(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).LazyMapSequence.subscript(_:Base.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).LazyMapSequence.subscript(_:Base.Index) in ' + this.constructor.name
}


/*Swift.(file).LazyMapSequence.subscript(_:Range<Base.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}


/*Swift.(file).LazyMapSequence.indices*/
indices$get() {
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this, _this.startIndex, _this.endIndex, {})
}
get indices() { return this.indices$get() };




/*Swift.(file).LazyMapSequence.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };




/*Swift.(file).LazyMapSequence.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };



/*Swift.(file).LazyMapSequence.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).LazyMapSequence.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int,limitedBy:LazyMapSequence<Base, Element>.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).LazyMapSequence.distance(from:LazyMapSequence<Base, Element>.Index,to:LazyMapSequence<Base, Element>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}
/*Swift.(file).LazyMapSequence.index(before:LazyMapSequence<Base, Element>.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).LazyMapSequence.index(before:LazyMapSequence<Base, Element>.Index) in ' + this.constructor.name
}
/*Swift.(file).LazyMapSequence.formIndex(before:LazyMapSequence<Base, Element>.Index)*/
/*Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)*/
/*Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)*/
formIndexBefore(i$inout, $info?) {
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i);})()
i$inout.set(i)
return $result
}
/*Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)*/
/*Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)*/
mapSwift<ElementOfResult>(transform, $info?) {
let _this = this;
return _create(LazyMapSequence, 'init_baseTransformfunction_type', _this._base, (($0, $info?) => transform(_this._transform($0))), {})
}
/*Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)*/
/*Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)*/
mapSwift<ElementOfResult>(transform, $info?) {
let _this = this;
return _create(LazyMapSequence, 'init_baseTransformfunction_type', _this._base, (($0, $info?) => transform(_this._transform($0))), {})
}
init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(LazyMapSequence.Iterator, IteratorProtocol$implementation, false)
if(typeof Sequence$implementation != 'undefined') _mixin(LazyMapSequence.Iterator, Sequence$implementation, false)
if(typeof LazySequenceProtocol$implementation != 'undefined') _mixin(LazyMapSequence, LazySequenceProtocol$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(LazyMapSequence, Collection$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(LazyMapSequence, BidirectionalCollection$implementation, false)
if(typeof LazyCollectionProtocol$implementation != 'undefined') _mixin(LazyMapSequence, LazyCollectionProtocol$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(LazyMapSequence, RandomAccessCollection$implementation, false)


















class MIO_Mixin_String implements _HasContiguousBytes, TextOutputStream, TextOutputStreamable, Hashable, _ExpressibleByBuiltinUnicodeScalarLiteral, _ExpressibleByBuiltinExtendedGraphemeClusterLiteral, _ExpressibleByBuiltinStringLiteral, ExpressibleByStringLiteral, CustomDebugStringConvertible, CustomStringConvertible, BidirectionalCollection, Equatable, Comparable, StringProtocol, RangeReplaceableCollection, MirrorPath, Codable, CustomReflectable, _CustomPlaygroundQuickLookable{
static readonly $struct = true
static readonly $mixin = true





/*Swift.(file).String.init(_:_StringGuts)*/
/*Swift.(file).String.init(_:_StringGuts)*/
init_StringGuts(_guts, $info?) {
throw 'unsupported method Swift.(file).String.init(_:_StringGuts) in ' + this.constructor.name
}
/*Swift.(file).String.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
return ""
}
/*Swift.(file).String.init(_:Character)*/
/*Swift.(file).String.init(_:Character)*/
initCharacter(c, $info?) {
return c
}



/*Swift.(file).String.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
/*Swift.(file)._HasContiguousBytes.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)*/
withUnsafeBytes<R>(body, $info?) {
let _this = this;
let copy = _this;
return copy.withUTF8((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}))), {$setThis: $val => copy = $val})
}
/*Swift.(file).String.init(cString:UnsafePointer<CChar>)*/
/*Swift.(file).StringProtocol.init(cString:UnsafePointer<CChar>)*/
initCStringUnsafePointer(cString, $info?) {
let _this = this;
const len = UTF8._nullCodeUnitOffsetIn(cString);
return _cloneStruct(String._fromUTF8Repairing(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(cString._asUInt8), len, {}))["0"]);
return
}
/*Swift.(file).String.init(cString:UnsafePointer<UInt8>)*/
/*Swift.(file).String.init(cString:UnsafePointer<UInt8>)*/
/*!!!DUPLICATE NAME*/
initCStringUnsafePointer(cString, $info?) {
let _this = this;
const len = UTF8._nullCodeUnitOffsetIn(cString);
return _cloneStruct(String._fromUTF8Repairing(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(cString), len, {}))["0"]);
return
}
/*Swift.(file).String.init(validatingUTF8:UnsafePointer<CChar>)*/
/*Swift.(file).String.init(validatingUTF8:UnsafePointer<CChar>)*/
initValidatingUTF8UnsafePointer(cString, $info?) {
let _this = this;
const len = UTF8._nullCodeUnitOffsetIn(cString);
const $ifLet0, str_1
if(!((($ifLet0 = String._tryFromUTF8(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(cString._asUInt8), len, {})))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
return _cloneStruct(str_1);
return
}
static readonly initValidatingUTF8UnsafePointer$failable = true
static /*Swift.(file).String.decodeCString(_:UnsafePointer<Encoding.CodeUnit>?,as:Encoding.Type,repairingInvalidCodeUnits:Bool)*/
/*Swift.(file).String.decodeCString(_:UnsafePointer<Encoding.CodeUnit>?,as:Encoding.Type,repairingInvalidCodeUnits:Bool)*/
decodeCStringAsRepairingInvalidCodeUnits<Encoding>(cString, encoding, isRepairing, $info?) {
let _this = this;
const $ifLet0, cPtr_1
if(!((($ifLet0 = cString)||true) && $ifLet0.rawValue == 'some' && ((cPtr_1 = $ifLet0[0])||true))) {
return _injectIntoOptional(null);
};
if((_fastPath($equal(_injectIntoOptional(encoding), _injectIntoOptional(Unicode.UTF8))))) {
const ptr = _cloneStruct(_create(UnsafeRawPointer, 'init', cPtr_1, {}).assumingMemoryBoundTo(UInt8));
const len = UTF8._nullCodeUnitOffsetIn(ptr);
const codeUnits = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(ptr), len, {});
if((isRepairing)) {
return _injectIntoOptional(String._fromUTF8Repairing(codeUnits));
}
else {
const $ifLet2, str_3
if(!((($ifLet2 = String._tryFromUTF8(codeUnits))||true) && $ifLet2.rawValue == 'some' && ((str_3 = $ifLet2[0])||true))) {
return _injectIntoOptional(null);
};
return _injectIntoOptional({0: str_3, 1: false});
};
};
let end = _cloneStruct(cPtr_1);
while(true){
if(!((((function(){throw '!unclarifiedGeneric:Encoding.CodeUnit'})()).$notEqual(end.pointee, 0)))) break
UnsafePointer.$addAndAssign({get: () => end, set: $val => end = $val}, 1);
};
const len = UnsafePointer.$subtract(end, cPtr_1);
const codeUnits = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(cPtr_1), len, {});
return _injectIntoOptional(((_.tmp0 = String._fromCodeUnitsEncodingRepair(codeUnits, encoding, isRepairing)).rawValue === 'some') ? (_.tmp0[0]) : null)
}
/*Swift.(file).String.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)*/
/*Swift.(file).StringProtocol.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)*/
initDecodingCStringUnsafePointerAs<Encoding>(ptr, sourceEncoding, $info?) {
let _this = this;
return _cloneStruct(String.decodeCStringAsRepairingInvalidCodeUnits(_injectIntoOptional(ptr), sourceEncoding, null)[0]["0"]);
return
}

/*Swift.(file).String.withCString(_:(UnsafePointer<Int8>) throws -> Result)*/
/*Swift.(file).StringProtocol.withCString(_:(UnsafePointer<CChar>) throws -> Result)*/
withCString<Result>(body, $info?) {
throw 'unsupported method Swift.(file).String.withCString(_:(UnsafePointer<Int8>) throws -> Result) in ' + this.constructor.name
}
/*Swift.(file).String.write(_:String)*/
/*Swift.(file).TextOutputStream.write(_:String)*/
write(other, $info?) {
let _this = this;
String.$addAndAssign({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, other)
}

/*Swift.(file).String.write(to:Target)*/
/*Swift.(file).TextOutputStreamable.write(to:Target)*/
writeTo<Target>(target$inout, $info?) {
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_this, {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
}
/*Swift.(file).String.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).String.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).String.hashValue*/
hashValue$get() {
//FIXME compute proper hash, e.g. by xoring
return this.length
}
get hashValue() { return this.hashValue$get() };



/*Swift.(file).String.init(decoding:C,as:Encoding.Type)*/
/*Swift.(file).StringProtocol.init(decoding:C,as:Encoding.Type)*/
initDecodingAs<C, Encoding>(codeUnits, sourceEncoding, $info?) {
let _this = this;
if(!((_fastPath($equal(_injectIntoOptional(sourceEncoding), _injectIntoOptional(UTF8)))))) {
return _cloneStruct(String._fromCodeUnitsEncodingRepair(codeUnits, sourceEncoding, true)[0]["0"]);
return ;
};
const $ifLet0, contigBytes_1
if((($ifLet0 = _injectIntoOptional(codeUnits))||true) && $ifLet0.rawValue == 'some' && ((contigBytes_1 = $ifLet0[0])||true) && (contigBytes_1._providesContiguousBytesNoCopy)) {
return _cloneStruct(contigBytes_1.withUnsafeBytes(((rawBufPtr, $info?) => String._fromUTF8Repairing(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(((_.tmp0 = rawBufPtr.baseAddress).rawValue === 'some') ? (_.tmp0[0].assumingMemoryBoundTo(UInt8)) : null), rawBufPtr.count, {}))["0"])));
return ;
};
return _cloneStruct(_create(Array, 'initBuffer', codeUnits, {}).withUnsafeBufferPointer((($0, $info?) => { 
const raw = _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {});
return String._fromUTF8Repairing(raw.bindMemoryTo(UInt8))["0"]; })));
return
}
/*Swift.(file).String.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)*/
/*Swift.(file).StringProtocol.withCString(encodedAs:Encoding.Type,_:(UnsafePointer<Encoding.CodeUnit>) throws -> Result)*/
withCStringEncodedAs<Result, TargetEncoding>(targetEncoding, body, $info?) {
let _this = this;
if(($equal(_injectIntoOptional(targetEncoding), _injectIntoOptional(UTF8)))) {
return _this.withCString(((cPtr, $info?) => { 
const ptr = _cloneStruct(_create(UnsafeRawPointer, 'init', cPtr, {}).assumingMemoryBoundTo(((function(){throw '!unclarifiedGeneric:TargetEncoding.CodeUnit'})())));
return body(ptr); }));
};
return _this._slowWithCStringEncodedAs(targetEncoding, body)
}

/*Swift.(file).String.init(_builtinUnicodeScalarLiteral:Int32)*/
/*Swift.(file)._ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:Int32)*/
init_builtinUnicodeScalarLiteralInt32(value, $info?) {
throw 'unsupported method Swift.(file).String.init(_builtinUnicodeScalarLiteral:Int32) in ' + this.constructor.name
}
/*Swift.(file).String.init(_:Unicode.Scalar)*/
/*Swift.(file).String.init(_:Unicode.Scalar)*/
initUnicodeScalar(scalar, $info?) {
let _this = this;
return _cloneStruct(scalar.withUTF8CodeUnits((($0, $info?) => String._uncheckedFromUTF8($0))));
return
}
/*Swift.(file).String.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinExtendedGraphemeClusterLiteral.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_builtinExtendedGraphemeClusterLiteralRawPointerUtf8CodeUnitCountWordIsASCIIInt1(start, utf8CodeUnitCount, isASCII, $info?) {
throw 'unsupported method Swift.(file).String.init(_builtinExtendedGraphemeClusterLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1) in ' + this.constructor.name
}
/*Swift.(file).String.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
/*Swift.(file)._ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1)*/
init_builtinStringLiteralRawPointerUtf8CodeUnitCountWordIsASCIIInt1(start, utf8CodeUnitCount, isASCII, $info?) {
throw 'unsupported method Swift.(file).String.init(_builtinStringLiteral:RawPointer,utf8CodeUnitCount:Word,isASCII:Int1) in ' + this.constructor.name
}
/*Swift.(file).String.init(stringLiteral:String)*/
/*Swift.(file).ExpressibleByStringLiteral.init(stringLiteral:Self.StringLiteralType)*/
initStringLiteral(value, $info?) {
let _this = this;
return _cloneStruct(value);
return
}




/*Swift.(file).String.debugDescription*/
debugDescription$get() {
let _this = this;
let result = "\"";
{
let $us$generator = _cloneStruct(_this.unicodeScalars.makeIterator( {}));
while(true) {
const $ifLet0, us_1;
if(!((($ifLet0 = $us$generator.next( {$setThis: $val => $us$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((us_1 = $ifLet0[0])||true))) break
String.$addAndAssign({get: () => result, set: $val => result = $val}, us_1.escapedAsASCII(false));
}
};
String.$addAndAssign({get: () => result, set: $val => result = $val}, "\"");
return result
}
get debugDescription() { return this.debugDescription$get() };



static /*Swift.(file).String.+infix(_:String,_:String)*/
/*Swift.(file).String.+infix(_:String,_:String)*/
$add(lhs, rhs, $info?) {
let _this = this;
let result = lhs;
result.append(rhs, {$setThis: $val => result = $val});
return result
}
static /*Swift.(file).String.+=infix(_:String,_:String)*/
/*Swift.(file).String.+=infix(_:String,_:String)*/
$addAndAssign(lhs$inout, rhs, $info?) {
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs.append(rhs, {$setThis: $val => lhs = $val});})()
lhs$inout.set(lhs)
return $result
}


/*Swift.(file).String.lowercased()*/
/*Swift.(file).StringProtocol.lowercased()*/
lowercased($info?) {
throw 'unsupported method Swift.(file).String.lowercased() in ' + this.constructor.name
}
/*Swift.(file).String.uppercased()*/
/*Swift.(file).StringProtocol.uppercased()*/
uppercased($info?) {
throw 'unsupported method Swift.(file).String.uppercased() in ' + this.constructor.name
}
/*Swift.(file).String.init(_:T)*/
/*Swift.(file).String.init(_:T)*/
initT<T>(value, $info?) {
let _this = this;
return _cloneStruct(value.description);
return
}

/*Swift.(file).String.description*/
description$get() {
let _this = this;
return _this
}
get description() { return this.description$get() };







/*Swift.(file).String.init(_cocoaString:AnyObject)*/
/*Swift.(file).String.init(_cocoaString:AnyObject)*/
init_cocoaStringAnyObject(_cocoaString, $info?) {
throw 'unsupported method Swift.(file).String.init(_cocoaString:AnyObject) in ' + this.constructor.name
}






/*Swift.(file).String.startIndex*/
startIndex$get() {
//TODO change once we know what String.Index is about
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).String.endIndex*/
endIndex$get() {
return this.length
}
get endIndex() { return this.endIndex$get() };




/*Swift.(file).String.count*/
count$get() {
return this.length
}
get count() { return this.count$get() };



/*Swift.(file).String.index(after:String.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
return i + 1
}
/*Swift.(file).String.index(before:String.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
return i - 1
}
/*Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
return i + n
}
/*Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance,limitedBy:String.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._indexOffsetByLimitedBy(i, n, limit)
}
/*Swift.(file).String.distance(from:String.Index,to:String.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._distanceFromTo(start, end)
}
/*Swift.(file).String.subscript(_:String.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file).String.subscript(_:String.Index) in ' + this.constructor.name
}





static Iterator = class implements IteratorProtocol{
static readonly $struct = true















/*Swift.(file).String.Iterator.init(_:_StringGuts)*/
/*Swift.(file).String.Iterator.init(_:_StringGuts)*/
init_StringGuts(guts, $info?) {
throw 'unsupported method Swift.(file).String.Iterator.init(_:_StringGuts) in ' + this.constructor.name
}
/*Swift.(file).String.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).String.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
/*Swift.(file).String.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}
static /*Swift.(file).String.==infix(_:String,_:String)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).String.<infix(_:String,_:String)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}













/*Swift.(file).String.isContiguousUTF8*/
isContiguousUTF8$get() {
throw 'unsupported variable Swift.(file).String.isContiguousUTF8 in ' + this.constructor.name
}
get isContiguousUTF8() { return this.isContiguousUTF8$get() };



/*Swift.(file).String.makeContiguousUTF8()*/
/*Swift.(file).String.makeContiguousUTF8()*/
makeContiguousUTF8($info?) {
let _this = this;
if((_fastPath(_this.isContiguousUTF8))) {
return ;
};
$info.$setThis(_this = _cloneStruct(String._copying(_this)))
}
/*Swift.(file).String.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
/*Swift.(file).String.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)*/
withUTF8<R>(body, $info?) {
throw 'unsupported method Swift.(file).String.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R) in ' + this.constructor.name
}
static Index = class implements Equatable, Comparable, Hashable{
static readonly $struct = true





/*Swift.(file).String.Index.init(_:UInt64)*/
/*Swift.(file).String.Index.init(_:UInt64)*/
initUInt64(raw, $info?) {
let _this = this;
_this._rawBits = raw;
_this._invariantCheck( {});
return
}

/*Swift.(file).String.Index.orderingValue*/
orderingValue$get() {
throw 'unsupported variable Swift.(file).String.Index.orderingValue in ' + this.constructor.name
}
get orderingValue() { return this.orderingValue$get() };




/*Swift.(file).String.Index.isZeroPosition*/
isZeroPosition$get() {
throw 'unsupported variable Swift.(file).String.Index.isZeroPosition in ' + this.constructor.name
}
get isZeroPosition() { return this.isZeroPosition$get() };



/*Swift.(file).String.Index.utf16Offset(in:S)*/
/*Swift.(file).String.Index.utf16Offset(in:S)*/
utf16OffsetIn<S>(s, $info?) {
throw 'unsupported method Swift.(file).String.Index.utf16Offset(in:S) in ' + this.constructor.name
}

/*Swift.(file).String.Index.encodedOffset*/
encodedOffset$get() {
throw 'unsupported variable Swift.(file).String.Index.encodedOffset in ' + this.constructor.name
}
get encodedOffset() { return this.encodedOffset$get() };







/*Swift.(file).String.Index.transcodedOffset*/
transcodedOffset$get() {
throw 'unsupported variable Swift.(file).String.Index.transcodedOffset in ' + this.constructor.name
}
get transcodedOffset() { return this.transcodedOffset$get() };




/*Swift.(file).String.Index.characterStride*/
characterStride$get() {
throw 'unsupported variable Swift.(file).String.Index.characterStride in ' + this.constructor.name
}
get characterStride() { return this.characterStride$get() };



/*Swift.(file).String.Index.init(encodedOffset:Int,transcodedOffset:Int)*/
/*Swift.(file).String.Index.init(encodedOffset:Int,transcodedOffset:Int)*/
initEncodedOffsetIntTranscodedOffsetInt(encodedOffset, transcodedOffset, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(encodedOffset:Int,transcodedOffset:Int) in ' + this.constructor.name
}
/*Swift.(file).String.Index.init(utf16Offset:Int,in:S)*/
/*Swift.(file).String.Index.init(utf16Offset:Int,in:S)*/
initUtf16OffsetIntIn<S>(offset, s, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(utf16Offset:Int,in:S) in ' + this.constructor.name
}
/*Swift.(file).String.Index.init(encodedOffset:Int)*/
/*Swift.(file).String.Index.init(encodedOffset:Int)*/
initEncodedOffsetInt(offset, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(encodedOffset:Int) in ' + this.constructor.name
}
/*Swift.(file).String.Index.init(_encodedOffset:Int)*/
/*Swift.(file).String.Index.init(_encodedOffset:Int)*/
init_encodedOffsetInt(offset, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(_encodedOffset:Int) in ' + this.constructor.name
}
/*Swift.(file).String.Index.init(encodedOffset:Int,transcodedOffset:Int,characterStride:Int)*/
/*Swift.(file).String.Index.init(encodedOffset:Int,transcodedOffset:Int,characterStride:Int)*/
initEncodedOffsetIntTranscodedOffsetIntCharacterStrideInt(encodedOffset, transcodedOffset, characterStride, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(encodedOffset:Int,transcodedOffset:Int,characterStride:Int) in ' + this.constructor.name
}
/*Swift.(file).String.Index.init(encodedOffset:Int,characterStride:Int)*/
/*Swift.(file).String.Index.init(encodedOffset:Int,characterStride:Int)*/
initEncodedOffsetIntCharacterStrideInt(pos, char, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(encodedOffset:Int,characterStride:Int) in ' + this.constructor.name
}


/*Swift.(file).String.Index.strippingTranscoding*/
strippingTranscoding$get() {
throw 'unsupported variable Swift.(file).String.Index.strippingTranscoding in ' + this.constructor.name
}
get strippingTranscoding() { return this.strippingTranscoding$get() };




/*Swift.(file).String.Index.nextEncoded*/
nextEncoded$get() {
throw 'unsupported variable Swift.(file).String.Index.nextEncoded in ' + this.constructor.name
}
get nextEncoded() { return this.nextEncoded$get() };




/*Swift.(file).String.Index.priorEncoded*/
priorEncoded$get() {
throw 'unsupported variable Swift.(file).String.Index.priorEncoded in ' + this.constructor.name
}
get priorEncoded() { return this.priorEncoded$get() };




/*Swift.(file).String.Index.nextTranscoded*/
nextTranscoded$get() {
throw 'unsupported variable Swift.(file).String.Index.nextTranscoded in ' + this.constructor.name
}
get nextTranscoded() { return this.nextTranscoded$get() };




/*Swift.(file).String.Index.priorTranscoded*/
priorTranscoded$get() {
throw 'unsupported variable Swift.(file).String.Index.priorTranscoded in ' + this.constructor.name
}
get priorTranscoded() { return this.priorTranscoded$get() };



/*Swift.(file).String.Index.encoded(offsetBy:Int)*/
/*Swift.(file).String.Index.encoded(offsetBy:Int)*/
encodedOffsetBy(n, $info?) {
throw 'unsupported method Swift.(file).String.Index.encoded(offsetBy:Int) in ' + this.constructor.name
}
/*Swift.(file).String.Index.transcoded(withOffset:Int)*/
/*Swift.(file).String.Index.transcoded(withOffset:Int)*/
transcodedWithOffset(n, $info?) {
throw 'unsupported method Swift.(file).String.Index.transcoded(withOffset:Int) in ' + this.constructor.name
}
static /*Swift.(file).String.Index.==infix(_:String.Index,_:String.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).String.Index.<infix(_:String.Index,_:String.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
/*Swift.(file).String.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).String.Index.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).String.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).String.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).String.Index.init(_:String.Index,_genericWithin:S)*/
/*Swift.(file).String.Index.init(_:String.Index,_genericWithin:S)*/
initStringIndex_genericWithin<S>(idx, target, $info?) {
let _this = this;
if(!((target._wholeGuts.isOnGraphemeClusterBoundary(idx)) && (Bool.$logicalAND(String.Index.$greaterThanOrEqual(idx, target.startIndex), () => String.Index.$lessThanOrEqual(idx, target.endIndex))))) {
return (this.$failed = true);
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(idx)));
return
}
static readonly initStringIndex_genericWithin$failable = true
/*Swift.(file).String.Index.init(_:String.Index,within:String)*/
/*Swift.(file).String.Index.init(_:String.Index,within:String)*/
initStringIndexWithinString(sourcePosition, target, $info?) {
let _this = this;
_this.initStringIndex_genericWithin(sourcePosition, target);
return
}
static readonly initStringIndexWithinString$failable = true
/*Swift.(file).String.Index.init(_:String.Index,within:S)*/
/*Swift.(file).String.Index.init(_:String.Index,within:S)*/
initStringIndexWithin<S>(sourcePosition, target, $info?) {
let _this = this;
_this.initStringIndex_genericWithin(sourcePosition, target);
return
}
static readonly initStringIndexWithin$failable = true
/*Swift.(file).String.Index.samePosition(in:String.UTF8View)*/
/*Swift.(file).String.Index.samePosition(in:String.UTF8View)*/
samePositionIn(utf8, $info?) {
let _this = this;
return _create(String.UTF8View.Index, 'initStringIndexWithinStringUTF8View', _this, utf8, {})
}
/*Swift.(file).String.Index.samePosition(in:String.UTF16View)*/
/*Swift.(file).String.Index.samePosition(in:String.UTF16View)*/
/*!!!DUPLICATE NAME*/
samePositionIn(utf16, $info?) {
let _this = this;
return _create(String.UTF16View.Index, 'initStringIndexWithinStringUTF16View', _this, utf16, {})
}
/*Swift.(file).String.Index.init(_:String.Index,within:String.UnicodeScalarView)*/
/*Swift.(file).String.Index.init(_:String.Index,within:String.UnicodeScalarView)*/
initStringIndexWithinStringUnicodeScalarView(sourcePosition, unicodeScalars, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(_:String.Index,within:String.UnicodeScalarView) in ' + this.constructor.name
}
static readonly initStringIndexWithinStringUnicodeScalarView$failable = true
/*Swift.(file).String.Index.samePosition(in:String)*/
/*Swift.(file).String.Index.samePosition(in:String)*/
/*!!!DUPLICATE NAME*/
samePositionIn(characters, $info?) {
throw 'unsupported method Swift.(file).String.Index.samePosition(in:String) in ' + this.constructor.name
}
/*Swift.(file).String.Index.init(_:String.Index,within:String.UTF16View)*/
/*Swift.(file).String.Index.init(_:String.Index,within:String.UTF16View)*/
initStringIndexWithinStringUTF16View(idx, target, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(_:String.Index,within:String.UTF16View) in ' + this.constructor.name
}
static readonly initStringIndexWithinStringUTF16View$failable = true
/*Swift.(file).String.Index.samePosition(in:String.UnicodeScalarView)*/
/*Swift.(file).String.Index.samePosition(in:String.UnicodeScalarView)*/
/*!!!DUPLICATE NAME*/
samePositionIn(unicodeScalars, $info?) {
throw 'unsupported method Swift.(file).String.Index.samePosition(in:String.UnicodeScalarView) in ' + this.constructor.name
}

/*Swift.(file).String.Index.init(_:String.Index,within:String.UTF8View)*/
/*Swift.(file).String.Index.init(_:String.Index,within:String.UTF8View)*/
initStringIndexWithinStringUTF8View(idx, target, $info?) {
throw 'unsupported method Swift.(file).String.Index.init(_:String.Index,within:String.UTF8View) in ' + this.constructor.name
}
static readonly initStringIndexWithinStringUTF8View$failable = true

init$vars() {let _this = this;

}
}
/*Swift.(file).String.init(stringInterpolation:DefaultStringInterpolation)*/
/*Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:Self.StringInterpolation)*/
initStringInterpolation(stringInterpolation, $info?) {
let _this = this;
return _cloneStruct(stringInterpolation.make( {}));
return
}
/*Swift.(file).String.init(repeating:String,count:Int)*/
/*Swift.(file).String.init(repeating:String,count:Int)*/
initRepeatingStringCountInt(repeatedValue, count, $info?) {
let _this = this;
preconditionFileLine(() => Int.$greaterThanOrEqual(count, 0), () => "Negative count not allowed", null, null);
if(!((Int.$greaterThan(count, 1)))) {
return _cloneStruct((Int.$equal(count, 0) ? "" : repeatedValue));
return ;
};
let result = _create(String, 'init', {});
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, count).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
String.$addAndAssign({get: () => result, set: $val => result = $val}, repeatedValue);
}
};
return _cloneStruct(result);
return
}

/*Swift.(file).String.isEmpty*/
isEmpty$get() {
let _this = this;
return (_.arg0 = _this.startIndex).constructor.$equal(_.arg0, _this.endIndex)
}
get isEmpty() { return this.isEmpty$get() };



/*Swift.(file).String.hasPrefix(_:String)*/
/*Swift.(file).StringProtocol.hasPrefix(_:String)*/
hasPrefix(prefix, $info?) {
throw 'unsupported method Swift.(file).String.hasPrefix(_:String) in ' + this.constructor.name
}
/*Swift.(file).String.hasSuffix(_:String)*/
/*Swift.(file).StringProtocol.hasSuffix(_:String)*/
hasSuffix(suffix, $info?) {
throw 'unsupported method Swift.(file).String.hasSuffix(_:String) in ' + this.constructor.name
}
/*Swift.(file).String.init(_:T,radix:Int,uppercase:Bool)*/
/*Swift.(file).String.init(_:T,radix:Int,uppercase:Bool)*/
initRadixIntUppercaseBool<T>(value, radix, uppercase, $info?) {
let _this = this;
return _cloneStruct(((function(){throw '!unclarifiedGeneric:T'})()).prototype._descriptionRadixUppercase.call(value, radix, uppercase));
return
}

/*Swift.(file).String.init(repeating:Character,count:Int)*/
/*Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)*/
initRepeatingCountInt(repeatedValue, count, $info?) {
let _this = this;
_this.initRepeatingStringCountInt(repeatedValue._str, count);
return
}
/*Swift.(file).String.init(_:S)*/
/*Swift.(file).LosslessStringConvertible.init(_:String)*/
initString<S>(other, $info?) {
return String(other)
}
/*Swift.(file).String.init(_:S)*/
/*Swift.(file).RangeReplaceableCollection.init(_:S)*/
initBuffer<S>(characters, $info?) {
return String(other)
}
/*Swift.(file).String.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
reserveCapacity(n, $info?) {

}
/*Swift.(file).String.append(_:String)*/
/*Swift.(file).String.append(_:String)*/
append(other, $info?) {
throw 'unsupported method Swift.(file).String.append(_:String) in ' + this.constructor.name
}
/*Swift.(file).String.append(_:Character)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
/*!!!DUPLICATE NAME*/
append(c, $info?) {
$info.$setThis(this + c)
}
/*Swift.(file).String.append(contentsOf:String)*/
/*Swift.(file).String.append(contentsOf:String)*/
appendContentsOf(newElements, $info?) {
let _this = this;
_this.append(newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).String.append(contentsOf:Substring)*/
/*Swift.(file).String.append(contentsOf:Substring)*/
/*!!!DUPLICATE NAME*/
appendContentsOf(newElements, $info?) {
throw 'unsupported method Swift.(file).String.append(contentsOf:Substring) in ' + this.constructor.name
}
/*Swift.(file).String.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
/*!!!DUPLICATE NAME*/
appendContentsOf<S>(newElements, $info?) {
let _this = this;
const $ifLet0, str_1
if((($ifLet0 = _injectIntoOptional(newElements))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true)) {
_this.append(str_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return ;
};
const $ifLet2, substr_3
if((($ifLet2 = _injectIntoOptional(newElements))||true) && $ifLet2.rawValue == 'some' && ((substr_3 = $ifLet2[0])||true)) {
_this.appendContentsOf(substr_3, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return ;
};
{
let $c$generator = newElements.makeIterator( {});
while(true) {
const $ifLet4, c_5;
if(!((($ifLet4 = $c$generator.next( {$setThis: $val => $c$generator = $val}))||true) && $ifLet4.rawValue == 'some' && ((c_5 = $ifLet4[0])||true))) break
_this.append(c_5._str, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file).String.replaceSubrange(_:Range<String.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(bounds, newElements, $info?) {
throw 'unsupported method Swift.(file).String.replaceSubrange(_:Range<String.Index>,with:C) in ' + this.constructor.name
}
/*Swift.(file).String.insert(_:Character,at:String.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)*/
insertAt(newElement, i, $info?) {
let _this = this;
_this.replaceSubrangeWith(String.Index.$halfOpenRange(i, i), newElement._str, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).String.insert(contentsOf:S,at:String.Index)*/
/*Swift.(file).RangeReplaceableCollection.insert(contentsOf:S,at:Self.Index)*/
insertContentsOfAt<S>(newElements, i, $info?) {
let _this = this;
_this.replaceSubrangeWith(String.Index.$halfOpenRange(i, i), newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).String.remove(at:String.Index)*/
/*Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)*/
removeAt(i, $info?) {
let _this = this;
preconditionFileLine(() => Bool.$not(_this.isEmpty), () => "Can't remove from an empty collection", null, null);
const result = _this.subscript$get(position);
_this.replaceSubrangeWith((_.arg0 = position).constructor.$halfOpenRange(_.arg0, _this.indexAfter(position)), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return result
}
/*Swift.(file).String.removeSubrange(_:Range<String.Index>)*/
/*Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)*/
removeSubrangeRange(bounds, $info?) {
let _this = this;
_this.replaceSubrangeWith(bounds, _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).String.removeAll(keepingCapacity:Bool)*/
/*Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)*/
removeAllKeepingCapacity(keepCapacity, $info?) {
let _this = this;
if((Bool.$not(keepCapacity))) {
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'init', {})));
}
else {
_this.replaceSubrangeWith((_.arg0 = _this.startIndex).constructor.$halfOpenRange(_.arg0, _this.endIndex), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}



/*Swift.(file).String.max(_:T,_:T)*/
/*Swift.(file).String.max(_:T,_:T)*/
max<T>(x, y, $info?) {
let _this = this;
return max(x, y)
}
/*Swift.(file).String.min(_:T,_:T)*/
/*Swift.(file).String.min(_:T,_:T)*/
min<T>(x, y, $info?) {
let _this = this;
return min(x, y)
}

static UnicodeScalarView = class implements BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible, RangeReplaceableCollection, CustomReflectable, _CustomPlaygroundQuickLookable{
static readonly $struct = true





/*Swift.(file).String.UnicodeScalarView.init(_:_StringGuts)*/
/*Swift.(file).String.UnicodeScalarView.init(_:_StringGuts)*/
init_StringGuts(_guts, $info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.init(_:_StringGuts) in ' + this.constructor.name
}



/*Swift.(file).String.UnicodeScalarView.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).String.UnicodeScalarView.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).String.UnicodeScalarView.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).String.UnicodeScalarView.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).String.UnicodeScalarView.index(after:String.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.index(after:String.UnicodeScalarView.Index) in ' + this.constructor.name
}
/*Swift.(file).String.UnicodeScalarView.index(before:String.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.index(before:String.UnicodeScalarView.Index) in ' + this.constructor.name
}
/*Swift.(file).String.UnicodeScalarView.subscript(_:String.UnicodeScalarView.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.subscript(_:String.UnicodeScalarView.Index) in ' + this.constructor.name
}




static Iterator = class implements IteratorProtocol{
static readonly $struct = true















/*Swift.(file).String.UnicodeScalarView.Iterator.init(_:_StringGuts)*/
/*Swift.(file).String.UnicodeScalarView.Iterator.init(_:_StringGuts)*/
init_StringGuts(guts, $info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.Iterator.init(_:_StringGuts) in ' + this.constructor.name
}
/*Swift.(file).String.UnicodeScalarView.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
/*Swift.(file).String.UnicodeScalarView.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}

/*Swift.(file).String.UnicodeScalarView.description*/
description$get() {
throw 'unsupported variable Swift.(file).String.UnicodeScalarView.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).String.UnicodeScalarView.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).String.UnicodeScalarView.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };



/*Swift.(file).String.UnicodeScalarView.init()*/
/*Swift.(file).RangeReplaceableCollection.init()*/
init($info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.init() in ' + this.constructor.name
}
/*Swift.(file).String.UnicodeScalarView.reserveCapacity(_:Int)*/
/*Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)*/
reserveCapacity(n, $info?) {

}
/*Swift.(file).String.UnicodeScalarView.append(_:Unicode.Scalar)*/
/*Swift.(file).RangeReplaceableCollection.append(_:Self.Element)*/
append(c, $info?) {
let _this = this;
_this.insertAt(newElement, _this.endIndex, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).String.UnicodeScalarView.append(contentsOf:S)*/
/*Swift.(file).RangeReplaceableCollection.append(contentsOf:S)*/
appendContentsOf<S>(newElements, $info?) {
let _this = this;
const approximateCapacity = Int.$add(_this.count, numericCast(newElements.underestimatedCount, {T: Int, U: Int}));
{
let $element$generator = newElements.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
_this.append(_element_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
}
/*Swift.(file).String.UnicodeScalarView.replaceSubrange(_:Range<String.UnicodeScalarView.Index>,with:C)*/
/*Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)*/
replaceSubrangeWith<C>(bounds, newElements, $info?) {
throw 'unsupported method Swift.(file).String.UnicodeScalarView.replaceSubrange(_:Range<String.UnicodeScalarView.Index>,with:C) in ' + this.constructor.name
}

/*Swift.(file).String.UnicodeScalarView.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).String.UnicodeScalarView.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).String.UnicodeScalarView.subscript(_:Range<String.UnicodeScalarView.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}




/*Swift.(file).String.UnicodeScalarView.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return _PlaygroundQuickLook.text(_this.description)
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}
/*Swift.(file).String.init(_:String.UnicodeScalarView)*/
/*Swift.(file).String.init(_:String.UnicodeScalarView)*/
initStringUnicodeScalarView(unicodeScalars, $info?) {
throw 'unsupported method Swift.(file).String.init(_:String.UnicodeScalarView) in ' + this.constructor.name
}


/*Swift.(file).String.unicodeScalars*/
unicodeScalars$get() {
throw 'unsupported variable Swift.(file).String.unicodeScalars in ' + this.constructor.name
}
get unicodeScalars() { return this.unicodeScalars$get() };





static UTF16View = class implements BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable, _CustomPlaygroundQuickLookable{
static readonly $struct = true





/*Swift.(file).String.UTF16View.init(_:_StringGuts)*/
/*Swift.(file).String.UTF16View.init(_:_StringGuts)*/
init_StringGuts(guts, $info?) {
throw 'unsupported method Swift.(file).String.UTF16View.init(_:_StringGuts) in ' + this.constructor.name
}



/*Swift.(file).String.UTF16View.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).String.UTF16View.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).String.UTF16View.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).String.UTF16View.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).String.UTF16View.index(after:String.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).String.UTF16View.index(after:String.UTF16View.Index) in ' + this.constructor.name
}
/*Swift.(file).String.UTF16View.index(before:String.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).String.UTF16View.index(before:String.UTF16View.Index) in ' + this.constructor.name
}
/*Swift.(file).String.UTF16View.index(_:String.UTF16View.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._indexOffsetBy(i, distance)
}
/*Swift.(file).String.UTF16View.index(_:String.UTF16View.Index,offsetBy:Int,limitedBy:String.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._indexOffsetByLimitedBy(i, distance, limit)
}
/*Swift.(file).String.UTF16View.distance(from:String.UTF16View.Index,to:String.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
return _this._distanceFromTo(start, end)
}

/*Swift.(file).String.UTF16View.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };



/*Swift.(file).String.UTF16View.subscript(_:String.UTF16View.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file).String.UTF16View.subscript(_:String.UTF16View.Index) in ' + this.constructor.name
}




static Iterator = class implements IteratorProtocol{
static readonly $struct = true




















/*Swift.(file).String.UTF16View.Iterator.init(_:_StringGuts)*/
/*Swift.(file).String.UTF16View.Iterator.init(_:_StringGuts)*/
init_StringGuts(guts, $info?) {
throw 'unsupported method Swift.(file).String.UTF16View.Iterator.init(_:_StringGuts) in ' + this.constructor.name
}
/*Swift.(file).String.UTF16View.Iterator.next()*/
/*Swift.(file).IteratorProtocol.next()*/
next($info?) {
throw 'unsupported method Swift.(file).String.UTF16View.Iterator.next() in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
/*Swift.(file).String.UTF16View.makeIterator()*/
/*Swift.(file).Collection.makeIterator()*/
/*Swift.(file).Sequence.makeIterator()*/
makeIterator($info?) {
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
}

/*Swift.(file).String.UTF16View.description*/
description$get() {
throw 'unsupported variable Swift.(file).String.UTF16View.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).String.UTF16View.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).String.UTF16View.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).String.UTF16View.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).String.UTF16View.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).String.UTF16View.subscript(_:Range<String.UTF16View.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}














/*Swift.(file).String.UTF16View.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return _PlaygroundQuickLook.text(_this.description)
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}

/*Swift.(file).String.utf16*/
utf16$get() {
throw 'unsupported variable Swift.(file).String.utf16 in ' + this.constructor.name
}
get utf16() { return this.utf16$get() };





/*Swift.(file).String.init(_:String.UTF16View)*/
/*Swift.(file).String.init(_:String.UTF16View)*/
initStringUTF16View(utf16, $info?) {
throw 'unsupported method Swift.(file).String.init(_:String.UTF16View) in ' + this.constructor.name
}

static UTF8View = class implements BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable, _CustomPlaygroundQuickLookable{
static readonly $struct = true





/*Swift.(file).String.UTF8View.init(_:_StringGuts)*/
/*Swift.(file).String.UTF8View.init(_:_StringGuts)*/
init_StringGuts(guts, $info?) {
throw 'unsupported method Swift.(file).String.UTF8View.init(_:_StringGuts) in ' + this.constructor.name
}




/*Swift.(file).String.UTF8View.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).String.UTF8View.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).String.UTF8View.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).String.UTF8View.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).String.UTF8View.index(after:String.UTF8View.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(after:Self.Index)*/
indexAfter(i, $info?) {
throw 'unsupported method Swift.(file).String.UTF8View.index(after:String.UTF8View.Index) in ' + this.constructor.name
}
/*Swift.(file).String.UTF8View.index(before:String.UTF8View.Index)*/
/*Swift.(file).BidirectionalCollection.index(before:Self.Index)*/
indexBefore(i, $info?) {
throw 'unsupported method Swift.(file).String.UTF8View.index(before:String.UTF8View.Index) in ' + this.constructor.name
}
/*Swift.(file).String.UTF8View.index(_:String.UTF8View.Index,offsetBy:Int)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)*/
indexOffsetBy(i, n, $info?) {
let _this = this;
return _this._advanceForwardBy(i, distance)
}
/*Swift.(file).String.UTF8View.index(_:String.UTF8View.Index,offsetBy:Int,limitedBy:String.UTF8View.Index)*/
/*Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
/*Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)*/
indexOffsetByLimitedBy(i, n, limit, $info?) {
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit)
}
/*Swift.(file).String.UTF8View.distance(from:String.UTF8View.Index,to:String.UTF8View.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
/*Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(i, j, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}
/*Swift.(file).String.UTF8View.subscript(_:String.UTF8View.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(i, $info?) {
throw 'unsupported method Swift.(file).String.UTF8View.subscript(_:String.UTF8View.Index) in ' + this.constructor.name
}





/*Swift.(file).String.UTF8View.description*/
description$get() {
throw 'unsupported variable Swift.(file).String.UTF8View.description in ' + this.constructor.name
}
get description() { return this.description$get() };




/*Swift.(file).String.UTF8View.debugDescription*/
debugDescription$get() {
throw 'unsupported variable Swift.(file).String.UTF8View.debugDescription in ' + this.constructor.name
}
get debugDescription() { return this.debugDescription$get() };




/*Swift.(file).String.UTF8View.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };




/*Swift.(file).String.UTF8View.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).String.UTF8View.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).String.UTF8View.subscript(_:Range<String.UTF8View.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
}









/*Swift.(file).String.UTF8View.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<String.UTF8View.Element>) throws -> R)*/
/*Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withContiguousStorageIfAvailable<R>(body, $info?) {
let _this = this;
return _injectIntoOptional(null)
}

/*Swift.(file).String.UTF8View.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
let _this = this;
return _PlaygroundQuickLook.text(_this.description)
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



init$vars() {let _this = this;

}
}

/*Swift.(file).String.utf8*/
utf8$get() {
throw 'unsupported variable Swift.(file).String.utf8 in ' + this.constructor.name
}
get utf8() { return this.utf8$get() };






/*Swift.(file).String.utf8CString*/
utf8CString$get() {
throw 'unsupported variable Swift.(file).String.utf8CString in ' + this.constructor.name
}
get utf8CString() { return this.utf8CString$get() };




/*Swift.(file).String.init(_:String.UTF8View)*/
/*Swift.(file).String.init(_:String.UTF8View)*/
initStringUTF8View(utf8, $info?) {
throw 'unsupported method Swift.(file).String.init(_:String.UTF8View) in ' + this.constructor.name
}
/*Swift.(file).String.init(_:Substring)*/
/*Swift.(file).String.init(_:Substring)*/
initSubstring(substring, $info?) {
let _this = this;
return _cloneStruct(String._fromSubstring(substring));
return
}
/*Swift.(file).String.init(_:Substring.UTF8View)*/
/*Swift.(file).String.init(_:Substring.UTF8View)*/
initSubstringUTF8View(codeUnits, $info?) {
throw 'unsupported method Swift.(file).String.init(_:Substring.UTF8View) in ' + this.constructor.name
}
static readonly initSubstringUTF8View$failable = true
/*Swift.(file).String.init(_:Substring.UTF16View)*/
/*Swift.(file).String.init(_:Substring.UTF16View)*/
initSubstringUTF16View(codeUnits, $info?) {
throw 'unsupported method Swift.(file).String.init(_:Substring.UTF16View) in ' + this.constructor.name
}
static readonly initSubstringUTF16View$failable = true
/*Swift.(file).String.init(_:Substring.UnicodeScalarView)*/
/*Swift.(file).String.init(_:Substring.UnicodeScalarView)*/
initSubstringUnicodeScalarView(content, $info?) {
let _this = this;
return _cloneStruct(_create(String, 'initSubstring', _create(Substring, 'initSubstringUnicodeScalarView', content, {}), {}));
return
}
/*Swift.(file).String.subscript(_:Range<String.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)*/
subscriptRange$get(r, $info?) {
let _this = this;
_this._boundsCheck(r);
return _create(Substring, 'initSlice', _create(Slice, 'initBaseBoundsRange', _this, r, {}), {})
}



/*Swift.(file).String.characters*/
characters$get() {
let _this = this;
return _this
}
get characters() { return this.characters$get() };





/*Swift.(file).String.withMutableCharacters(_:(inout String) -> R)*/
/*Swift.(file).String.withMutableCharacters(_:(inout String) -> R)*/
withMutableCharacters<R>(body, $info?) {
let _this = this;
return body({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file).String.init(describing:Subject)*/
/*Swift.(file).String.init(describing:Subject)*/
initDescribing<Subject>(instance, $info?) {
let _this = this;
_this.init( {});
_print_unlocked(instance, {get: () => _this, set: $val => return _cloneStruct($val)});
return
}
/*Swift.(file).String.init(describing:Subject)*/
/*Swift.(file).String.init(describing:Subject)*/
initDescribing<Subject>(instance, $info?) {
let _this = this;
_this.init( {});
_print_unlocked(instance, {get: () => _this, set: $val => return _cloneStruct($val)});
return
}
/*Swift.(file).String.init(describing:Subject)*/
/*Swift.(file).String.init(describing:Subject)*/
initDescribing<Subject>(instance, $info?) {
let _this = this;
_this.init( {});
_print_unlocked(instance, {get: () => _this, set: $val => return _cloneStruct($val)});
return
}
/*Swift.(file).String.init(describing:Subject)*/
/*Swift.(file).String.init(describing:Subject)*/
initDescribing<Subject>(instance, $info?) {
let _this = this;
_this.init( {});
_print_unlocked(instance, {get: () => _this, set: $val => return _cloneStruct($val)});
return
}
/*Swift.(file).String.init(reflecting:Subject)*/
/*Swift.(file).String.init(reflecting:Subject)*/
initReflecting<Subject>(subject, $info?) {
let _this = this;
_this.init( {});
_debugPrint_unlocked(subject, {get: () => _this, set: $val => return _cloneStruct($val)});
return
}
/*Swift.(file).String.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).String.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).String.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).String.encode(to:Encoder) in ' + this.constructor.name
}

/*Swift.(file).String.customMirror*/
customMirror$get() {
throw 'unsupported variable Swift.(file).String.customMirror in ' + this.constructor.name
}
get customMirror() { return this.customMirror$get() };




/*Swift.(file).String.customPlaygroundQuickLook*/
customPlaygroundQuickLook$get() {
throw 'unsupported variable Swift.(file).String.customPlaygroundQuickLook in ' + this.constructor.name
}
get customPlaygroundQuickLook() { return this.customPlaygroundQuickLook$get() };



/*Swift.(file).String.subscript(_:Int)*/
/*Swift.(file).String.subscript(_:Int)*/
/*!!!DUPLICATE NAME*/
subscript$get(i, $info?) {
return this[i]
}

/*Swift.(file).String.subscript(_:R)*/
/*Swift.(file).String.subscript(_:R)*/
/*!!!DUPLICATE NAME*/
subscriptRange$get<R>(bounds, $info?) {
return this.slice(bounds.lowerBound, bounds.upperBound)
}

init$vars() {let _this = this;

}
}
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(MIO_Mixin_String.Iterator, IteratorProtocol$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_String.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(MIO_Mixin_String.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_String.Index, Hashable$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(MIO_Mixin_String.UnicodeScalarView.Iterator, IteratorProtocol$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(MIO_Mixin_String.UnicodeScalarView, BidirectionalCollection$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String.UnicodeScalarView, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String.UnicodeScalarView, CustomDebugStringConvertible$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(MIO_Mixin_String.UnicodeScalarView, RangeReplaceableCollection$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_String.UnicodeScalarView, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_String.UnicodeScalarView, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof IteratorProtocol$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF16View.Iterator, IteratorProtocol$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF16View, BidirectionalCollection$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF16View, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF16View, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF16View, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF16View, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF8View, BidirectionalCollection$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF8View, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF8View, CustomDebugStringConvertible$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF8View, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_String.UTF8View, _CustomPlaygroundQuickLookable$implementation, false)
if(typeof _HasContiguousBytes$implementation != 'undefined') _mixin(MIO_Mixin_String, _HasContiguousBytes$implementation, false)
if(typeof TextOutputStream$implementation != 'undefined') _mixin(MIO_Mixin_String, TextOutputStream$implementation, false)
if(typeof TextOutputStreamable$implementation != 'undefined') _mixin(MIO_Mixin_String, TextOutputStreamable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(MIO_Mixin_String, Hashable$implementation, false)
if(typeof _ExpressibleByBuiltinUnicodeScalarLiteral$implementation != 'undefined') _mixin(MIO_Mixin_String, _ExpressibleByBuiltinUnicodeScalarLiteral$implementation, false)
if(typeof _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation != 'undefined') _mixin(MIO_Mixin_String, _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation, false)
if(typeof _ExpressibleByBuiltinStringLiteral$implementation != 'undefined') _mixin(MIO_Mixin_String, _ExpressibleByBuiltinStringLiteral$implementation, false)
if(typeof ExpressibleByStringLiteral$implementation != 'undefined') _mixin(MIO_Mixin_String, ExpressibleByStringLiteral$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String, CustomDebugStringConvertible$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(MIO_Mixin_String, CustomStringConvertible$implementation, false)
if(typeof BidirectionalCollection$implementation != 'undefined') _mixin(MIO_Mixin_String, BidirectionalCollection$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(MIO_Mixin_String, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(MIO_Mixin_String, Comparable$implementation, false)
if(typeof StringProtocol$implementation != 'undefined') _mixin(MIO_Mixin_String, StringProtocol$implementation, false)
if(typeof RangeReplaceableCollection$implementation != 'undefined') _mixin(MIO_Mixin_String, RangeReplaceableCollection$implementation, false)
if(typeof MirrorPath$implementation != 'undefined') _mixin(MIO_Mixin_String, MirrorPath$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(MIO_Mixin_String, Codable$implementation, false)
if(typeof CustomReflectable$implementation != 'undefined') _mixin(MIO_Mixin_String, CustomReflectable$implementation, false)
if(typeof _CustomPlaygroundQuickLookable$implementation != 'undefined') _mixin(MIO_Mixin_String, _CustomPlaygroundQuickLookable$implementation, false)
_mixin(String, MIO_Mixin_String, true)




































































































class CollectionDifference<ChangeElement> implements Collection, Equatable, Hashable, Codable{
static readonly $struct = true
static Change = class implements Equatable, Hashable, Codable{

static insert() {return Object.assign(new CollectionDifference.Change(), {rawValue: "insert", ...Array.from(arguments)})}

static remove() {return Object.assign(new CollectionDifference.Change(), {rawValue: "remove", ...Array.from(arguments)})}









static /*Swift.(file).CollectionDifference.Change.==(_:CollectionDifference<ChangeElement>.Change,_:CollectionDifference<ChangeElement>.Change)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).CollectionDifference.Change.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.Change.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).CollectionDifference.Change.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Change.hash(into:Hasher) in ' + this.constructor.name
}
static _CodingKeys = class implements CodingKey{

static get offset() {return Object.assign(new CollectionDifference.Change._CodingKeys(), {rawValue: "offset", ...Array.from(arguments)})}

static get _element() {return Object.assign(new CollectionDifference.Change._CodingKeys(), {rawValue: "_element", ...Array.from(arguments)})}

static get associatedOffset() {return Object.assign(new CollectionDifference.Change._CodingKeys(), {rawValue: "associatedOffset", ...Array.from(arguments)})}

static get isRemove() {return Object.assign(new CollectionDifference.Change._CodingKeys(), {rawValue: "isRemove", ...Array.from(arguments)})}

/*Swift.(file).CollectionDifference.Change._CodingKeys.init(rawValue:String)*/
/*Swift.(file).RawRepresentable.init(rawValue:Self.RawValue)*/
initRawValue(rawValue, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Change._CodingKeys.init(rawValue:String) in ' + this.constructor.name
}
static readonly initRawValue$failable = true



/*Swift.(file).CollectionDifference.Change._CodingKeys.rawValue*/
rawValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.Change._CodingKeys.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };




/*Swift.(file).CollectionDifference.Change._CodingKeys.stringValue*/
stringValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.Change._CodingKeys.stringValue in ' + this.constructor.name
}
get stringValue() { return this.stringValue$get() };

/*Swift.(file).CollectionDifference.Change._CodingKeys.init(stringValue:String)*/
/*Swift.(file).CodingKey.init(stringValue:String)*/
initStringValueString(stringValue, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Change._CodingKeys.init(stringValue:String) in ' + this.constructor.name
}
static readonly initStringValueString$failable = true



/*Swift.(file).CollectionDifference.Change._CodingKeys.intValue*/
intValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.Change._CodingKeys.intValue in ' + this.constructor.name
}
get intValue() { return this.intValue$get() };

/*Swift.(file).CollectionDifference.Change._CodingKeys.init(intValue:Int)*/
/*Swift.(file).CodingKey.init(intValue:Int)*/
initIntValueInt(intValue, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Change._CodingKeys.init(intValue:Int) in ' + this.constructor.name
}
static readonly initIntValueInt$failable = true
init$vars() {let _this = this;

}
}
/*Swift.(file).CollectionDifference.Change.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Change.init(from:Decoder) in ' + this.constructor.name
}
/*Swift.(file).CollectionDifference.Change.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Change.encode(to:Encoder) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}

/*Swift.(file).CollectionDifference.insertions*/
readonly insertions$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.insertions in ' + this.constructor.name
}
readonly get insertions() { return this.insertions$get() };




/*Swift.(file).CollectionDifference.removals*/
readonly removals$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.removals in ' + this.constructor.name
}
readonly get removals() { return this.removals$get() };




/*Swift.(file).CollectionDifference.init(_:Changes)*/
/*Swift.(file).CollectionDifference.init(_:Changes)*/
init<Changes>(changes, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.init(_:Changes) in ' + this.constructor.name
}
static readonly init$failable = true
/*Swift.(file).CollectionDifference.init(_validatedChanges:Changes)*/
/*Swift.(file).CollectionDifference.init(_validatedChanges:Changes)*/
init_validatedChanges<Changes>(changes, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.init(_validatedChanges:Changes) in ' + this.constructor.name
}
static CodingKeys = class implements CodingKey{

static get insertions() {return Object.assign(new CollectionDifference.CodingKeys(), {rawValue: "insertions", ...Array.from(arguments)})}

static get removals() {return Object.assign(new CollectionDifference.CodingKeys(), {rawValue: "removals", ...Array.from(arguments)})}
static /*Swift.(file).CollectionDifference.CodingKeys.==(_:CollectionDifference<ChangeElement>.CodingKeys,_:CollectionDifference<ChangeElement>.CodingKeys)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).CollectionDifference.CodingKeys.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.CodingKeys.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).CollectionDifference.CodingKeys.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.CodingKeys.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).CollectionDifference.CodingKeys.stringValue*/
stringValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.CodingKeys.stringValue in ' + this.constructor.name
}
get stringValue() { return this.stringValue$get() };

/*Swift.(file).CollectionDifference.CodingKeys.init(stringValue:String)*/
/*Swift.(file).CodingKey.init(stringValue:String)*/
initStringValueString(stringValue, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.CodingKeys.init(stringValue:String) in ' + this.constructor.name
}
static readonly initStringValueString$failable = true



/*Swift.(file).CollectionDifference.CodingKeys.intValue*/
intValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.CodingKeys.intValue in ' + this.constructor.name
}
get intValue() { return this.intValue$get() };

/*Swift.(file).CollectionDifference.CodingKeys.init(intValue:Int)*/
/*Swift.(file).CodingKey.init(intValue:Int)*/
initIntValueInt(intValue, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.CodingKeys.init(intValue:Int) in ' + this.constructor.name
}
static readonly initIntValueInt$failable = true
init$vars() {let _this = this;

}
}

static Index = class implements Equatable, Comparable, Hashable{
static readonly $struct = true



/*Swift.(file).CollectionDifference.Index.init(_offset:Int)*/
/*Swift.(file).CollectionDifference.Index.init(_offset:Int)*/
init_offsetInt(offset, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Index.init(_offset:Int) in ' + this.constructor.name
}
static /*Swift.(file).CollectionDifference.Index.==infix(_:CollectionDifference<ChangeElement>.Index,_:CollectionDifference<ChangeElement>.Index)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}
static /*Swift.(file).CollectionDifference.Index.<infix(_:CollectionDifference<ChangeElement>.Index,_:CollectionDifference<ChangeElement>.Index)*/
/*Swift.(file).Comparable.<infix(_:Self,_:Self)*/
$lessThan(lhs, rhs, $info?) {
return lhs < rhs
}
/*Swift.(file).CollectionDifference.Index.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.Index.hash(into:Hasher) in ' + this.constructor.name
}



/*Swift.(file).CollectionDifference.Index.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.Index.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

init$vars() {let _this = this;

}
}

/*Swift.(file).CollectionDifference.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file).CollectionDifference.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };



/*Swift.(file).CollectionDifference.index(after:CollectionDifference<ChangeElement>.Index)*/
/*Swift.(file).Collection.index(after:Self.Index)*/
indexAfter(index, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.index(after:CollectionDifference<ChangeElement>.Index) in ' + this.constructor.name
}
/*Swift.(file).CollectionDifference.subscript(_:CollectionDifference<ChangeElement>.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.subscript(_:CollectionDifference<ChangeElement>.Index) in ' + this.constructor.name
}


/*Swift.(file).CollectionDifference.index(before:CollectionDifference<ChangeElement>.Index)*/
/*Swift.(file).CollectionDifference.index(before:CollectionDifference<ChangeElement>.Index)*/
indexBefore(index, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.index(before:CollectionDifference<ChangeElement>.Index) in ' + this.constructor.name
}
/*Swift.(file).CollectionDifference.formIndex(_:CollectionDifference<ChangeElement>.Index,offsetBy:Int)*/
/*Swift.(file).CollectionDifference.formIndex(_:CollectionDifference<ChangeElement>.Index,offsetBy:Int)*/
formIndexOffsetBy(index$inout, distance, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.formIndex(_:CollectionDifference<ChangeElement>.Index,offsetBy:Int) in ' + this.constructor.name
}
/*Swift.(file).CollectionDifference.distance(from:CollectionDifference<ChangeElement>.Index,to:CollectionDifference<ChangeElement>.Index)*/
/*Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)*/
distanceFromTo(start, end, $info?) {
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.$lessThanOrEqual(_.arg0, end), () => "Only BidirectionalCollections can have end come before start", null, null);
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.$notEqual(_.arg1, end)))) break
count = Int.$add(count, 1);
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
}



static /*Swift.(file).CollectionDifference.==(_:CollectionDifference<ChangeElement>,_:CollectionDifference<ChangeElement>)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(a, b, $info?) {
return a == b
}



/*Swift.(file).CollectionDifference.hashValue*/
hashValue$get() {
throw 'unsupported variable Swift.(file).CollectionDifference.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };

/*Swift.(file).CollectionDifference.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.hash(into:Hasher) in ' + this.constructor.name
}
/*Swift.(file).CollectionDifference.inferringMoves()*/
/*Swift.(file).CollectionDifference.inferringMoves()*/
inferringMoves($info?) {
throw 'unsupported method Swift.(file).CollectionDifference.inferringMoves() in ' + this.constructor.name
}
/*Swift.(file).CollectionDifference.encode(to:Encoder)*/
/*Swift.(file).Encodable.encode(to:Encoder)*/
encodeTo(encoder, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.encode(to:Encoder) in ' + this.constructor.name
}
/*Swift.(file).CollectionDifference.init(from:Decoder)*/
/*Swift.(file).Decodable.init(from:Decoder)*/
initFromDecoder(decoder, $info?) {
throw 'unsupported method Swift.(file).CollectionDifference.init(from:Decoder) in ' + this.constructor.name
}

init$vars() {let _this = this;

}
}
if(typeof CodingKey$implementation != 'undefined') _mixin(CollectionDifference.Change._CodingKeys, CodingKey$implementation, false)
_mixin(CollectionDifference.Change._CodingKeys, _DefaultEnumImplementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(CollectionDifference.Change, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(CollectionDifference.Change, Hashable$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(CollectionDifference.Change, Codable$implementation, false)
_mixin(CollectionDifference.Change, _DefaultEnumImplementation, false)
if(typeof CodingKey$implementation != 'undefined') _mixin(CollectionDifference.CodingKeys, CodingKey$implementation, false)
_mixin(CollectionDifference.CodingKeys, _DefaultEnumImplementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(CollectionDifference.Index, Equatable$implementation, false)
if(typeof Comparable$implementation != 'undefined') _mixin(CollectionDifference.Index, Comparable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(CollectionDifference.Index, Hashable$implementation, false)
if(typeof Collection$implementation != 'undefined') _mixin(CollectionDifference, Collection$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(CollectionDifference, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(CollectionDifference, Hashable$implementation, false)
if(typeof Codable$implementation != 'undefined') _mixin(CollectionDifference, Codable$implementation, false)














class _SliceBuffer<Element> implements _ArrayBufferProtocol, RandomAccessCollection{
static readonly $struct = true



/*Swift.(file)._SliceBuffer.owner*/
owner$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.owner in ' + this.constructor.name
}
get owner() { return this.owner$get() };






/*Swift.(file)._SliceBuffer.subscriptBaseAddress*/
readonly subscriptBaseAddress$get() {
let _this = this;
return _this.firstElementAddress
}
readonly get subscriptBaseAddress() { return this.subscriptBaseAddress$get() };




/*Swift.(file)._SliceBuffer.startIndex*/
startIndex$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.startIndex in ' + this.constructor.name
}
get startIndex() { return this.startIndex$get() };






/*Swift.(file)._SliceBuffer.endIndexAndFlags*/
endIndexAndFlags$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.endIndexAndFlags in ' + this.constructor.name
}
get endIndexAndFlags() { return this.endIndexAndFlags$get() };





/*Swift.(file)._SliceBuffer.init(owner:AnyObject,subscriptBaseAddress:UnsafeMutablePointer<Element>,startIndex:Int,endIndexAndFlags:UInt)*/
/*Swift.(file)._SliceBuffer.init(owner:AnyObject,subscriptBaseAddress:UnsafeMutablePointer<Element>,startIndex:Int,endIndexAndFlags:UInt)*/
initOwnerAnyObjectSubscriptBaseAddressUnsafeMutablePointerStartIndexIntEndIndexAndFlagsUInt(owner, subscriptBaseAddress, startIndex, endIndexAndFlags, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.init(owner:AnyObject,subscriptBaseAddress:UnsafeMutablePointer<Element>,startIndex:Int,endIndexAndFlags:UInt) in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.init(owner:AnyObject,subscriptBaseAddress:UnsafeMutablePointer<Element>,indices:Range<Int>,hasNativeBuffer:Bool)*/
/*Swift.(file)._SliceBuffer.init(owner:AnyObject,subscriptBaseAddress:UnsafeMutablePointer<Element>,indices:Range<Int>,hasNativeBuffer:Bool)*/
initOwnerAnyObjectSubscriptBaseAddressUnsafeMutablePointerIndicesRangeHasNativeBufferBool(owner, subscriptBaseAddress, indices, hasNativeBuffer, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.init(owner:AnyObject,subscriptBaseAddress:UnsafeMutablePointer<Element>,indices:Range<Int>,hasNativeBuffer:Bool) in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.init()*/
/*Swift.(file)._ArrayBufferProtocol.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.init() in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.init(_buffer:_SliceBuffer<Element>.NativeBuffer,shiftedToStartIndex:Int)*/
/*Swift.(file)._ArrayBufferProtocol.init(_buffer:_ContiguousArrayBuffer<Self.Element>,shiftedToStartIndex:Int)*/
init_buffer_ContiguousArrayBufferShiftedToStartIndexInt(buffer, shiftedToStartIndex, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.init(_buffer:_SliceBuffer<Element>.NativeBuffer,shiftedToStartIndex:Int) in ' + this.constructor.name
}





/*Swift.(file)._SliceBuffer.nativeBuffer*/
nativeBuffer$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.nativeBuffer in ' + this.constructor.name
}
get nativeBuffer() { return this.nativeBuffer$get() };




/*Swift.(file)._SliceBuffer.nativeOwner*/
nativeOwner$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.nativeOwner in ' + this.constructor.name
}
get nativeOwner() { return this.nativeOwner$get() };



/*Swift.(file)._SliceBuffer.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)*/
/*Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)*/
replaceSubrangeWithElementsOf<C>(subrange, insertCount, newValues, $info?) {
let _this = this;
const oldCount = _this.count;
const eraseCount = subrange.count;
const growth = Int.$subtract(newCount, eraseCount);
_this.count = Int.$add(oldCount, growth);
const _elements = _cloneStruct(_this.subscriptBaseAddress);
const oldTailIndex = subrange.upperBound;
const oldTailStart = _cloneStruct(UnsafeMutablePointer.$add(_elements, oldTailIndex));
const newTailIndex = Int.$add(oldTailIndex, growth);
const newTailStart = _cloneStruct(UnsafeMutablePointer.$add(oldTailStart, growth));
const tailCount = Int.$subtract(oldCount, subrange.upperBound);
if((Int.$greaterThan(growth, 0))) {
newTailStart.moveInitializeFromCount(oldTailStart, tailCount);
let i = newValues.startIndex;
{
let $j$generator = _cloneStruct(subrange.makeIterator( {}));
while(true) {
const $ifLet0, j_1;
if(!((($ifLet0 = $j$generator.next( {$setThis: $val => $j$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((j_1 = $ifLet0[0])||true))) break
_elements.subscript$set(newValues.subscript$get(i), j_1, {$setThis: $val => _elements = _cloneStruct($val)});
newValues.formIndexAfter({get: () => i, set: $val => i = $val});
}
};
{
let $j$generator = _cloneStruct(Int.$halfOpenRange(oldTailIndex, newTailIndex).makeIterator( {}));
while(true) {
const $ifLet2, j_3;
if(!((($ifLet2 = $j$generator.next( {$setThis: $val => $j$generator = $val}))||true) && $ifLet2.rawValue == 'some' && ((j_3 = $ifLet2[0])||true))) break
UnsafeMutablePointer.$add(_elements, j_3).initializeTo(newValues.subscript$get(i));
newValues.formIndexAfter({get: () => i, set: $val => i = $val});
}
};
}
else {
let i = subrange.lowerBound;
let j = newValues.startIndex;
{
let $generator = _cloneStruct(Int.$halfOpenRange(0, newCount).makeIterator( {}));
while(true) {
const $ifLet4;
if(!((($ifLet4 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet4.rawValue == 'some')) break
_elements.subscript$set(newValues.subscript$get(j), i, {$setThis: $val => _elements = _cloneStruct($val)});
Int.$addAndAssign({get: () => i, set: $val => i = $val}, 1);
newValues.formIndexAfter({get: () => j, set: $val => j = $val});
}
};
if((Int.$equal(growth, 0))) {
return ;
};
const shrinkage = Int.$negate(growth);
if((Int.$greaterThan(tailCount, shrinkage))) {
newTailStart.moveAssignFromCount(oldTailStart, shrinkage);
oldTailStart.moveInitializeFromCount(UnsafeMutablePointer.$add(oldTailStart, shrinkage), Int.$subtract(tailCount, shrinkage));
}
else {
newTailStart.moveAssignFromCount(oldTailStart, tailCount);
UnsafeMutablePointer.$add(newTailStart, tailCount).deinitializeCount(Int.$subtract(shrinkage, tailCount));
};
}
}

/*Swift.(file)._SliceBuffer.identity*/
identity$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.identity in ' + this.constructor.name
}
get identity() { return this.identity$get() };




/*Swift.(file)._SliceBuffer.firstElementAddress*/
firstElementAddress$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.firstElementAddress in ' + this.constructor.name
}
get firstElementAddress() { return this.firstElementAddress$get() };




/*Swift.(file)._SliceBuffer.firstElementAddressIfContiguous*/
firstElementAddressIfContiguous$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.firstElementAddressIfContiguous in ' + this.constructor.name
}
get firstElementAddressIfContiguous() { return this.firstElementAddressIfContiguous$get() };



/*Swift.(file)._SliceBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
/*Swift.(file)._ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
requestUniqueMutableBackingBufferMinimumCapacity(minimumCapacity, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int) in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.isMutableAndUniquelyReferenced()*/
/*Swift.(file)._ArrayBufferProtocol.isMutableAndUniquelyReferenced()*/
isMutableAndUniquelyReferenced($info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.isMutableAndUniquelyReferenced() in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.requestNativeBuffer()*/
/*Swift.(file)._ArrayBufferProtocol.requestNativeBuffer()*/
requestNativeBuffer($info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.requestNativeBuffer() in ' + this.constructor.name
}



/*Swift.(file)._SliceBuffer.arrayPropertyIsNativeTypeChecked*/
arrayPropertyIsNativeTypeChecked$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.arrayPropertyIsNativeTypeChecked in ' + this.constructor.name
}
get arrayPropertyIsNativeTypeChecked() { return this.arrayPropertyIsNativeTypeChecked$get() };




/*Swift.(file)._SliceBuffer.count*/
count$get() {
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex)
}
get count() { return this.count$get() };







/*Swift.(file)._SliceBuffer.capacity*/
capacity$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.capacity in ' + this.constructor.name
}
get capacity() { return this.capacity$get() };



/*Swift.(file)._SliceBuffer.isUniquelyReferenced()*/
/*Swift.(file)._SliceBuffer.isUniquelyReferenced()*/
isUniquelyReferenced($info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.isUniquelyReferenced() in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.getElement(_:Int)*/
/*Swift.(file)._SliceBuffer.getElement(_:Int)*/
getElement(i, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.getElement(_:Int) in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$get(position, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.subscript(_:Int) in ' + this.constructor.name
}/*Swift.(file)._SliceBuffer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
subscript$set(newValue, position, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.subscript(_:Int) in ' + this.constructor.name
}




/*Swift.(file)._SliceBuffer.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
subscriptRange$get(bounds, $info?) {
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

}
subscript$get(bounds, $info?){
this.subscriptRange$get.apply(this,arguments)
}/*Swift.(file)._SliceBuffer.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
subscriptRange$set(newValue, bounds, $info?) {
let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue)
}
subscript$set(newValue, bounds, $info?){
this.subscriptRange$set.apply(this,arguments)
}




/*Swift.(file)._SliceBuffer.endIndex*/
endIndex$get() {
throw 'unsupported variable Swift.(file)._SliceBuffer.endIndex in ' + this.constructor.name
}
get endIndex() { return this.endIndex$get() };






/*Swift.(file)._SliceBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}
/*Swift.(file)._SliceBuffer.unsafeCastElements(to:T.Type)*/
/*Swift.(file)._SliceBuffer.unsafeCastElements(to:T.Type)*/
unsafeCastElementsTo<T>(type, $info?) {
throw 'unsupported method Swift.(file)._SliceBuffer.unsafeCastElements(to:T.Type) in ' + this.constructor.name
}





init$vars() {let _this = this;

}
}
if(typeof _ArrayBufferProtocol$implementation != 'undefined') _mixin(_SliceBuffer, _ArrayBufferProtocol$implementation, false)
if(typeof RandomAccessCollection$implementation != 'undefined') _mixin(_SliceBuffer, RandomAccessCollection$implementation, false)




class _ArrayBuffer<Element> implements _ArrayBufferProtocol{
static readonly $struct = true
/*Swift.(file)._ArrayBuffer.init()*/
/*Swift.(file)._ArrayBufferProtocol.init()*/
init($info?) {
throw 'unsupported method Swift.(file)._ArrayBuffer.init() in ' + this.constructor.name
}
/*Swift.(file)._ArrayBuffer.init(nsArray:AnyObject)*/
/*Swift.(file)._ArrayBuffer.init(nsArray:AnyObject)*/
initNsArrayAnyObject(nsArray, $info?) {
throw 'unsupported method Swift.(file)._ArrayBuffer.init(nsArray:AnyObject) in ' + this.constructor.name
}
/*Swift.(file)._ArrayBuffer.cast(toBufferOf:U.Type)*/
/*Swift.(file)._ArrayBuffer.cast(toBufferOf:U.Type)*/
castToBufferOf<U>(_, $info?) {
throw 'unsupported method Swift.(file)._ArrayBuffer.cast(toBufferOf:U.Type) in ' + this.constructor.name
}
/*Swift.(file)._ArrayBuffer.downcast(toBufferWithDeferredTypeCheckOf:U.Type)*/
/*Swift.(file)._ArrayBuffer.downcast(toBufferWithDeferredTypeCheckOf:U.Type)*/
downcastToBufferWithDeferredTypeCheckOf<U>(_, $info?) {
throw 'unsupported method Swift.(file)._ArrayBuffer.downcast(toBufferWithDeferredTypeCheckOf:U.Type) in ' + this.constructor.name
}

/*Swift.(file)._ArrayBuffer.needsElementTypeCheck*/
needsElementTypeCheck$get() {
throw 'unsupported variable Swift.(file)._ArrayBuffer.needsElementTypeCheck in ' + this.constructor.name
}
get needsElementTypeCheck() { return this.needsElementTypeCheck$get() };



/*Swift.(file)._ArrayBuffer.init(storage:_ArrayBridgeStorage)*/
/*Swift.(file)._ArrayBuffer.init(storage:_ArrayBridgeStorage)*/
initStorage_ArrayBridgeStorage(storage, $info?) {
throw 'unsupported method Swift.(file)._ArrayBuffer.init(storage:_ArrayBridgeStorage) in ' + this.constructor.name
}









/*Swift.(file)._ArrayBuffer.init(_buffer:_ArrayBuffer<Element>.NativeBuffer,shiftedToStartIndex:Int)*/
/*Swift.(file)._ArrayBufferProtocol.init(_buffer:_ContiguousArrayBuffer<Self.Element>,shiftedToStartIndex:Int)*/
init_buffer_ContiguousArrayBufferShiftedToStartIndexInt(source, shiftedToStartIndex, $info?) {
throw 'unsupported method Swift.(file)._ArrayBuffer.init(_buffer:_ArrayBuffer<Element>.NativeBuffer,shiftedToStartIndex:Int) in ' + this.constructor.name
}

/*Swift.(file)._ArrayBuffer.arrayPropertyIsNativeTypeChecked*/
arrayPropertyIsNativeTypeChecked$get() {
let _this = this;
return _this._isNativeTypeChecked
}
get arrayPropertyIsNativeTypeChecked() { return this.arrayPropertyIsNativeTypeChecked$get() };



/*Swift.(file)._ArrayBuffer.isUniquelyReferenced()*/
/*Swift.(file)._ArrayBuffer.isUniquelyReferenced()*/
isUniquelyReferenced($info?) {
let _this = this;
if((Bool.$not(_isClassOrObjCExistential(((function(){throw '!unclarifiedGeneric:Element'})()))))) {
return _this._storage.isUniquelyReferencedUnflaggedNative( {$setThis: $val => _this._storage = $val});
};
if((Bool.$not(_this._storage.isUniquelyReferencedNative( {$setThis: $val => _this._storage = $val})))) {
return false;
};
return _this._isNative
}

/*Swift.(file)._ArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
/*Swift.(file)._ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:Int)*/
requestUniqueMutableBackingBufferMinimumCapacity(minimumCapacity, $info?) {
let _this = this;
if((_fastPath(_this.isUniquelyReferenced( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})))) {
const b = _cloneStruct(_this._native);
if((_fastPath(Int.$greaterThanOrEqual(b.capacity, minimumCapacity)))) {
return _injectIntoOptional(b);
};
};
return _injectIntoOptional(null)
}
/*Swift.(file)._ArrayBuffer.isMutableAndUniquelyReferenced()*/
/*Swift.(file)._ArrayBufferProtocol.isMutableAndUniquelyReferenced()*/
isMutableAndUniquelyReferenced($info?) {
let _this = this;
return _this.isUniquelyReferenced( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
}
/*Swift.(file)._ArrayBuffer.requestNativeBuffer()*/
/*Swift.(file)._ArrayBufferProtocol.requestNativeBuffer()*/
requestNativeBuffer($info?) {
let _this = this;
if((Bool.$not(_isClassOrObjCExistential(((function(){throw '!unclarifiedGeneric:Element'})()))))) {
return _injectIntoOptional(_this._native);
};
return (_fastPath(_this._storage.isNative) ? _injectIntoOptional(_this._native) : _injectIntoOptional(null))
}




/*Swift.(file)._ArrayBuffer.subscript(_:Range<Int>)*/
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscript$get(bounds, $info?) {
let _this = this;
_this._typeCheck(bounds);
if((_fastPath(_this._isNative))) {
return _this._native.subscript$get(bounds);
};
return _this._nonNative.subscriptRange$get(bounds).unsafeCastElementsTo(((function(){throw '!unclarifiedGeneric:Element'})()));

}
subscriptRange$get(bounds, $info?){
this.subscript$get.apply(this,arguments)
}/*Swift.(file)._ArrayBuffer.subscript(_:Range<Int>)*/
/*Swift.(file)._ArrayBufferProtocol.subscript(_:Range<Int>)*/
/*Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).Collection.subscript(_:Range<Self.Index>)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)*/
subscript$set(newValue, bounds, $info?) {
let _this = this;
fatalErrorFileLine(() => "not implemented", null, null)
}
subscriptRange$set(newValue, bounds, $info?){
this.subscript$set.apply(this,arguments)
}




/*Swift.(file)._ArrayBuffer.firstElementAddress*/
firstElementAddress$get() {
let _this = this;
return _this._native.firstElementAddress
}
get firstElementAddress() { return this.firstElementAddress$get() };




/*Swift.(file)._ArrayBuffer.firstElementAddressIfContiguous*/
firstElementAddressIfContiguous$get() {
let _this = this;
return (_fastPath(_this._isNative) ? _injectIntoOptional(_this.firstElementAddress) : _injectIntoOptional(null))
}
get firstElementAddressIfContiguous() { return this.firstElementAddressIfContiguous$get() };




/*Swift.(file)._ArrayBuffer.count*/
count$get() {
let _this = this;
return (_fastPath(_this._isNative) ? _this._native.count : _this._nonNative.count)
}
get count() { return this.count$get() };








/*Swift.(file)._ArrayBuffer.capacity*/
capacity$get() {
let _this = this;
return (_fastPath(_this._isNative) ? _this._native.capacity : _this._nonNative.count)
}
get capacity() { return this.capacity$get() };



/*Swift.(file)._ArrayBuffer.getElement(_:Int,wasNativeTypeChecked:Bool)*/
/*Swift.(file)._ArrayBuffer.getElement(_:Int,wasNativeTypeChecked:Bool)*/
getElementWasNativeTypeChecked(i, wasNativeTypeChecked, $info?) {
let _this = this;
if((_fastPath(wasNativeTypeChecked))) {
return _this._nativeTypeChecked.subscript$get(i);
};
return unsafeBitCastTo(_this._getElementSlowPath(i), ((function(){throw '!unclarifiedGeneric:Element'})()))
}

/*Swift.(file)._ArrayBuffer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*!!!DUPLICATE NAME*/
subscript$get(i, $info?) {
let _this = this;
return _this.getElementWasNativeTypeChecked(i, _this._isNativeTypeChecked);

}/*Swift.(file)._ArrayBuffer.subscript(_:Int)*/
/*Swift.(file).MutableCollection.subscript(_:Self.Index)*/
/*Swift.(file).RandomAccessCollection.subscript(_:Self.Index)*/
/*Swift.(file).Collection.subscript(_:Self.Index)*/
/*Swift.(file).BidirectionalCollection.subscript(_:Self.Index)*/
/*!!!DUPLICATE NAME*/
subscript$set(newValue, i, $info?) {
let _this = this;
if((_fastPath(_this._isNative))) {
_this._native.subscript$set(newValue, i, {$setThis: $val => _this._native = _cloneStruct($val)});
}
else {
let refCopy = _cloneStruct(_this);
refCopy.replaceSubrangeWithElementsOf(Int.$halfOpenRange(i, Int.$add(i, 1)), 1, _create(CollectionOfOne, 'init', newValue, {}), {$setThis: $val => refCopy = $val});
}
}




/*Swift.(file)._ArrayBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Self.Element>) throws -> R)*/
withUnsafeBufferPointer<R>(body, $info?) {
let _this = this;
if((_fastPath(_this._isNative))) {
let $defer = () => {
_fixLifetime(_this);
}
const $result = (() => {
try {;
return body(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(_this.firstElementAddress), _this.count, {}));}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
};
return _create(ContiguousArray, 'initBuffer', _this, {}).withUnsafeBufferPointer(body)
}
/*Swift.(file)._ArrayBuffer.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Element>) throws -> R)*/
/*Swift.(file)._ArrayBufferProtocol.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Self.Element>) throws -> R)*/
withUnsafeMutableBufferPointer<R>(body, $info?) {
throw 'unsupported method Swift.(file)._ArrayBuffer.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Element>) throws -> R) in ' + this.constructor.name
}

/*Swift.(file)._ArrayBuffer.owner*/
owner$get() {
let _this = this;
return (_fastPath(_this._isNative) ? _this._native._storage : _this._nonNative.buffer)
}
get owner() { return this.owner$get() };




/*Swift.(file)._ArrayBuffer.nativeOwner*/
nativeOwner$get() {
let _this = this;
return _this._native._storage
}
get nativeOwner() { return this.nativeOwner$get() };




/*Swift.(file)._ArrayBuffer.identity*/
identity$get() {
let _this = this;
if((_this._isNative)) {
return _this._native.identity;
}
else {
return _create(UnsafeRawPointer, 'initUnsafeMutableRawPointer', Unmanaged.passUnretained(_this._nonNative.buffer).toOpaque( {}), {});
}
}
get identity() { return this.identity$get() };




/*Swift.(file)._ArrayBuffer.startIndex*/
startIndex$get() {
let _this = this;
return 0
}
get startIndex() { return this.startIndex$get() };




/*Swift.(file)._ArrayBuffer.endIndex*/
endIndex$get() {
let _this = this;
return _this.count
}
get endIndex() { return this.endIndex$get() };





















init$vars() {let _this = this;

}
}
if(typeof _ArrayBufferProtocol$implementation != 'undefined') _mixin(_ArrayBuffer, _ArrayBufferProtocol$implementation, false)




const _ArrayBridgeStorage = _BridgeStorage


const _BridgingBuffer = ManagedBufferPointer


const CountableClosedRange = ClosedRange


const CChar = Int8


const CUnsignedChar = UInt8


const CUnsignedShort = UInt16


const CUnsignedInt = UInt32


const CUnsignedLong = UInt


const CUnsignedLongLong = UInt64


const CSignedChar = Int8


const CShort = Int16


const CInt = Int32


const CLong = Int


const CLongLong = Int64


const CFloat = Float


const CDouble = Double


const CLongDouble = Float80


const CWideChar = Unicode.Scalar


const CChar16 = UInt16


const CChar32 = Unicode.Scalar


const CBool = Bool


const DictionaryIndex = Dictionary.Index


const DictionaryIterator = Dictionary.Iterator


const LazyDropWhileCollection = LazyDropWhileSequence


const LazyFilterCollection = LazyFilterSequence


const FlattenCollection = FlattenSequence


const KeyPathComputedArgumentLayoutFn = '?function_type'


const KeyPathComputedArgumentInitializerFn = '?function_type'


const MetadataReference = UnsafeRawPointer


const LazyCollection = LazySequence


//const _HeapObject = HeapObject


const LazyMapCollection = LazyMapSequence


const Void = '?tuple_type'


const Float32 = Float


const Float64 = Double


const IntegerLiteralType = Int


const FloatLiteralType = Double


const BooleanLiteralType = Bool


const UnicodeScalarType = String


const ExtendedGraphemeClusterType = String


const StringLiteralType = String


//const _MaxBuiltinFloatType = FPIEEE80


const AnyObject = AnyObject


const AnyClass = AnyObject


const LazyPrefixWhileCollection = LazyPrefixWhileSequence


const UnboundedRange = '?function_type'


const CountableRange = Range


const CountablePartialRangeFrom = PartialRangeFrom


const NameFreeFunc = '?function_type'


const SetIndex = Set.Index


const SetIterator = Set.Iterator


const _SwiftNSZone = OpaquePointer


const _CocoaString = AnyObject


const CountAndFlags = _StringObject.CountAndFlags


const _StringSwitchCache = Dictionary


const BidirectionalIndexable = BidirectionalCollection$implementation


const IndexableBase = Collection$implementation


const Indexable = Collection$implementation


const MutableIndexable = MutableCollection$implementation


const RandomAccessIndexable = RandomAccessCollection$implementation


const RangeReplaceableIndexable = RangeReplaceableCollection$implementation


const EnumeratedIterator = EnumeratedSequence.Iterator


const IteratorOverOne = CollectionOfOne.Iterator


const EmptyIterator = EmptyCollection.Iterator


const LazyFilterIterator = LazyFilterSequence.Iterator


const LazyFilterIndex = {$genericType: 'Base', $subchain: 'Index'}


const LazyDropWhileIterator = LazyDropWhileSequence.Iterator


const LazyDropWhileIndex = LazyDropWhileCollection.Index


const LazyDropWhileBidirectionalCollection = LazyDropWhileCollection


const LazyFilterBidirectionalCollection = LazyFilterCollection


const LazyMapIterator = LazyMapSequence.Iterator


const LazyMapBidirectionalCollection = LazyMapCollection


const LazyMapRandomAccessCollection = LazyMapCollection


const LazyBidirectionalCollection = LazyCollection


const LazyRandomAccessCollection = LazyCollection


const FlattenCollectionIndex = FlattenCollection.Index


const FlattenBidirectionalCollectionIndex = FlattenCollection.Index


const FlattenBidirectionalCollection = FlattenCollection


const JoinedIterator = JoinedSequence.Iterator


const Zip2Iterator = Zip2Sequence.Iterator


const LazyPrefixWhileIterator = LazyPrefixWhileSequence.Iterator


const LazyPrefixWhileIndex = LazyPrefixWhileCollection.Index


const LazyPrefixWhileBidirectionalCollection = LazyPrefixWhileCollection


const ReversedRandomAccessCollection = ReversedCollection


const ReversedIndex = ReversedCollection.Index


const BidirectionalSlice = Slice


const RandomAccessSlice = Slice


const RangeReplaceableSlice = Slice


const RangeReplaceableBidirectionalSlice = Slice


const RangeReplaceableRandomAccessSlice = Slice


const MutableSlice = Slice


const MutableBidirectionalSlice = Slice


const MutableRandomAccessSlice = Slice


const MutableRangeReplaceableSlice = Slice


const MutableRangeReplaceableBidirectionalSlice = Slice


const MutableRangeReplaceableRandomAccessSlice = Slice


const DefaultBidirectionalIndices = DefaultIndices


const DefaultRandomAccessIndices = DefaultIndices


const NilLiteralConvertible = ExpressibleByNilLiteral$implementation


const _BuiltinIntegerLiteralConvertible = _ExpressibleByBuiltinIntegerLiteral$implementation


const IntegerLiteralConvertible = ExpressibleByIntegerLiteral$implementation


const _BuiltinFloatLiteralConvertible = _ExpressibleByBuiltinFloatLiteral$implementation


const FloatLiteralConvertible = ExpressibleByFloatLiteral$implementation


const _BuiltinBooleanLiteralConvertible = _ExpressibleByBuiltinBooleanLiteral$implementation


const BooleanLiteralConvertible = ExpressibleByBooleanLiteral$implementation


const _BuiltinUnicodeScalarLiteralConvertible = _ExpressibleByBuiltinUnicodeScalarLiteral$implementation


const UnicodeScalarLiteralConvertible = ExpressibleByUnicodeScalarLiteral$implementation


const _BuiltinExtendedGraphemeClusterLiteralConvertible = _ExpressibleByBuiltinExtendedGraphemeClusterLiteral$implementation


const ExtendedGraphemeClusterLiteralConvertible = ExpressibleByExtendedGraphemeClusterLiteral$implementation


const _BuiltinStringLiteralConvertible = _ExpressibleByBuiltinStringLiteral$implementation


const StringLiteralConvertible = ExpressibleByStringLiteral$implementation


const ArrayLiteralConvertible = ExpressibleByArrayLiteral$implementation


const DictionaryLiteralConvertible = ExpressibleByDictionaryLiteral$implementation


const StringInterpolationConvertible = ExpressibleByStringInterpolation$implementation


const _ColorLiteralConvertible = _ExpressibleByColorLiteral$implementation


const _ImageLiteralConvertible = _ExpressibleByImageLiteral$implementation


const _FileReferenceLiteralConvertible = _ExpressibleByFileReferenceLiteral$implementation


const ClosedRangeIndex = ClosedRange.Index


const ImplicitlyUnwrappedOptional = Optional


const DictionaryLiteral = KeyValuePairs


const UTF8 = Unicode.UTF8


const UTF16 = Unicode.UTF16


const UTF32 = Unicode.UTF32


const UnicodeScalar = Unicode.Scalar


const UnsafeBufferPointerIterator = UnsafeBufferPointer.Iterator


const UnsafeRawBufferPointerIterator = UnsafeBufferPointer.Iterator


const UnsafeMutableRawBufferPointerIterator = UnsafeBufferPointer.Iterator


const PlaygroundQuickLook = _PlaygroundQuickLook


const CustomPlaygroundQuickLookable = _CustomPlaygroundQuickLookable$implementation


const _DefaultCustomPlaygroundQuickLookable = __DefaultCustomPlaygroundQuickLookable$implementation


const UnfoldFirstSequence = UnfoldSequence


const _VAUInt = CUnsignedInt


const _VAInt = Int32


const Codable = '?protocol_composition_type'



EnumeratedSequence.Iterator.Element = '?tuple_type'
EnumeratedSequence.Iterator.Iterator = EnumeratedSequence.Iterator
EnumeratedSequence.Element = '?tuple_type'
_ArrayBuffer.Element = {$genericType: 'Element'}
_ArrayBuffer.Index = Int
_ArrayBuffer.Iterator = IndexingIterator
_ArrayBuffer.SubSequence = _SliceBuffer
_ArrayBuffer.Indices = Range
_ArrayBuffer.Storage = _ContiguousArrayStorage
_ArrayBuffer.NativeBuffer = _ContiguousArrayBuffer
Array._Buffer = _ArrayBuffer
Array.Index = Int
Array.Indices = Range
Array.Iterator = IndexingIterator
Array.Element = {$genericType: 'Element'}
Array.SubSequence = ArraySlice
Array.ArrayLiteralElement = {$genericType: 'Element'}
ArraySlice._Buffer = _SliceBuffer
ArraySlice.Index = Int
ArraySlice.Indices = Range
ArraySlice.Iterator = IndexingIterator
ArraySlice.Element = {$genericType: 'Element'}
ArraySlice.SubSequence = ArraySlice
ArraySlice.ArrayLiteralElement = {$genericType: 'Element'}
_UnsafeBitset.Element = Int
_UnsafeBitset.Iterator.Element = Int
_UnsafeBitset.Word.Element = Int
_UnsafeBitset.Word.Iterator = _UnsafeBitset.Word
Bool.BooleanLiteralType = Bool
_BridgeableMetatype._ObjectiveCType = AnyObject
AutoreleasingUnsafeMutablePointer.Pointee = {$genericType: 'Pointee'}
AutoreleasingUnsafeMutablePointer.Stride = Int
_BridgeStorage.Native = {$genericType: 'NativeClass'}
_BridgeStorage.ObjC = AnyObject
Character.UTF8View = String.UTF8View
Character.UTF16View = String.UTF16View
Character.UnicodeScalarView = String.UnicodeScalarView
Character.ExtendedGraphemeClusterLiteralType = Character
Character.UnicodeScalarLiteralType = Character
_CocoaArrayWrapper.Indices = Range
_CocoaArrayWrapper.Element = AnyObject
_CocoaArrayWrapper.Index = Int
_CocoaArrayWrapper.Iterator = IndexingIterator
_CocoaArrayWrapper.SubSequence = _SliceBuffer
IndexingIterator.Element = {$genericType: 'Elements', $subchain: 'Element'}
IndexingIterator.Iterator = IndexingIterator
IndexingIterator.SubSequence = AnySequence
Collection$implementation.IndexDistance = Int
Collection$implementation.Generator = {$genericType: 'Self', $subchain: 'Iterator'}
Collection$implementation._Element = {$genericType: 'Self', $subchain: 'Element'}
ContiguousArray._Buffer = _ContiguousArrayBuffer
ContiguousArray.Index = Int
ContiguousArray.Indices = Range
ContiguousArray.Iterator = IndexingIterator
ContiguousArray.Element = {$genericType: 'Element'}
ContiguousArray.ArrayLiteralElement = {$genericType: 'Element'}
ContiguousArray.SubSequence = ArraySlice
ClosedRange.Bound = {$genericType: 'Bound'}
ClosedRange.Element = {$genericType: 'Bound'}
ClosedRange.Iterator = IndexingIterator
ClosedRange.SubSequence = Slice
ClosedRange.Indices = DefaultIndices
_ContiguousArrayBuffer.Indices = Range
_ContiguousArrayBuffer.Element = {$genericType: 'Element'}
_ContiguousArrayBuffer.Index = Int
_ContiguousArrayBuffer.SubSequence = _SliceBuffer
_ContiguousArrayBuffer.Iterator = IndexingIterator
Dictionary.Element = '?tuple_type'
Dictionary.SubSequence = Slice
Dictionary.Indices = DefaultIndices
Dictionary.Key = {$genericType: 'Key'}
Dictionary.Value = {$genericType: 'Value'}
Dictionary.Keys.Element = {$genericType: 'Key'}
Dictionary.Keys.SubSequence = Slice
Dictionary.Keys.Index = Dictionary.Index
Dictionary.Keys.Indices = DefaultIndices
Dictionary.Keys.Iterator.Element = {$genericType: 'Key'}
Dictionary.Values.Element = {$genericType: 'Value'}
Dictionary.Values.Index = Dictionary.Index
Dictionary.Values.SubSequence = Slice
Dictionary.Values.Indices = DefaultIndices
Dictionary.Values.Iterator.Element = {$genericType: 'Value'}
Dictionary.Iterator.Element = '?tuple_type'
Dictionary._Variant.Element = '?tuple_type'
Dictionary._Variant.Index = Dictionary.Index
Dictionary._Variant.Key = {$genericType: 'Key'}
Dictionary._Variant.Value = {$genericType: 'Value'}
_SwiftDeferredNSDictionary.Bucket = _HashTable.Bucket
__CocoaDictionary.Key = AnyObject
__CocoaDictionary.Value = AnyObject
__CocoaDictionary.Iterator.Element = '?tuple_type'
__CocoaDictionary.Element = __CocoaDictionary.Iterator.Element
LazyDropWhileSequence.Element = {$genericType: 'Base', $subchain: 'Element'}
LazyDropWhileSequence.Iterator.Element = {$genericType: 'Base', $subchain: 'Element'}
LazyDropWhileSequence.Elements = LazyDropWhileSequence
LazyDropWhileSequence.SubSequence = Slice
LazyDropWhileSequence.Index = {$genericType: 'Base', $subchain: 'Index'}
LazyDropWhileSequence.Indices = DefaultIndices
EmptyCollection.Iterator.Element = {$genericType: 'Element'}
EmptyCollection.Iterator.Iterator = EmptyCollection.Iterator
EmptyCollection.Element = {$genericType: 'Element'}
EmptyCollection.Index = Int
EmptyCollection.Indices = Range
EmptyCollection.SubSequence = EmptyCollection
LazyFilterSequence.Iterator.Element = {$genericType: 'Base', $subchain: 'Element'}
LazyFilterSequence.Iterator.Iterator = LazyFilterSequence.Iterator
LazyFilterSequence.Element = {$genericType: 'Base', $subchain: 'Element'}
LazyFilterSequence.Elements = LazyFilterSequence
LazyFilterSequence.SubSequence = LazyFilterCollection
LazyFilterSequence.Index = {$genericType: 'Base', $subchain: 'Index'}
LazyFilterSequence.Indices = DefaultIndices
FlattenSequence.Iterator.Element = {$genericType: 'Base', $subchain: 'Element.Element'}
FlattenSequence.Iterator.Iterator = FlattenSequence.Iterator
FlattenSequence.Element = {$genericType: 'Base', $subchain: 'Element.Element'}
FlattenSequence.SubSequence = Slice
FlattenSequence.Indices = DefaultIndices
FloatingPointSign.RawValue = Int
_HashTable.Word = _UnsafeBitset.Word
_HashTable.Iterator.Element = _HashTable.Bucket
_HashTable.Element = _HashTable.Bucket
DefaultIndices.Index = {$genericType: 'Elements', $subchain: 'Index'}
DefaultIndices.Element = {$genericType: 'Elements', $subchain: 'Index'}
DefaultIndices.Indices = DefaultIndices
DefaultIndices.SubSequence = DefaultIndices
DefaultIndices.Iterator = IndexingIterator
JoinedSequence.Element = {$genericType: 'Base', $subchain: 'Element.Element'}
JoinedSequence.Iterator.Element = {$genericType: 'Base', $subchain: 'Element.Element'}
KeyPath.Kind = KeyPathKind
ComputedArgumentWitnesses.Destroy = '?function_type'
ComputedArgumentWitnesses.Copy = '?function_type'
ComputedArgumentWitnesses.Equals = '?function_type'
ComputedArgumentWitnesses.Hash = '?function_type'
//ClassHolder.AccessRecord = UnsafeValueBuffer
KeyValuePairs.Key = {$genericType: 'Key'}
KeyValuePairs.Value = {$genericType: 'Value'}
KeyValuePairs.Element = '?tuple_type'
KeyValuePairs.Index = Int
KeyValuePairs.Indices = Range
KeyValuePairs.SubSequence = Slice
KeyValuePairs.Iterator = IndexingIterator
LazySequence.Index = {$genericType: 'Base', $subchain: 'Index'}
LazySequence.Indices = {$genericType: 'Base', $subchain: 'Indices'}
LazySequence.SubSequence = Slice
LazySequence.Element = {$genericType: 'Base', $subchain: 'Element'}
LazySequence.Iterator = {$genericType: 'Base', $subchain: 'Iterator'}
LazySequence.Elements = {$genericType: 'Base'}
LazyMapSequence.Elements = LazyMapSequence
LazyMapSequence.Iterator.Element = {$genericType: 'Element'}
LazyMapSequence.Iterator.Iterator = LazyMapSequence.Iterator
LazyMapSequence.Element = {$genericType: 'Element'}
LazyMapSequence.Index = {$genericType: 'Base', $subchain: 'Index'}
LazyMapSequence.Indices = {$genericType: 'Base', $subchain: 'Indices'}
LazyMapSequence.SubSequence = LazyMapCollection
_NativeDictionary.Element = '?tuple_type'
_NativeDictionary.Bucket = _HashTable.Bucket
_NativeDictionary.Index = Dictionary.Index
_NativeDictionary.Key = {$genericType: 'Key'}
_NativeDictionary.Value = {$genericType: 'Value'}
_NativeDictionary.Iterator.Element = '?tuple_type'
_NativeSet.Bucket = _HashTable.Bucket
_NativeSet.Index = Set.Index
_NativeSet.Iterator.Element = {$genericType: 'Element'}
_NativeSet.Element = {$genericType: 'Element'}
_SwiftNewtypeWrapper$implementation._ObjectiveCType = {$genericType: 'Self', $subchain: 'RawValue._ObjectiveCType'}
Optional._ObjectiveCType = AnyObject
_Pointer$implementation.Distance = Int
LazyPrefixWhileSequence.Element = {$genericType: 'Base', $subchain: 'Element'}
LazyPrefixWhileSequence.Iterator.Element = {$genericType: 'Base', $subchain: 'Element'}
LazyPrefixWhileSequence.Iterator.Iterator = LazyPrefixWhileSequence.Iterator
LazyPrefixWhileSequence.Elements = LazyPrefixWhileSequence
LazyPrefixWhileSequence.SubSequence = Slice
LazyPrefixWhileSequence.Indices = DefaultIndices
RandomAccessCollection$implementation._Default_Indices = Range
Range.Element = {$genericType: 'Bound'}
Range.Iterator = IndexingIterator
Range.Index = {$genericType: 'Bound'}
Range.Indices = Range
Range.SubSequence = Range
Range.Bound = {$genericType: 'Bound'}
PartialRangeUpTo.Bound = {$genericType: 'Bound'}
PartialRangeThrough.Bound = {$genericType: 'Bound'}
PartialRangeFrom.Bound = {$genericType: 'Bound'}
PartialRangeFrom.Element = {$genericType: 'Bound'}
PartialRangeFrom.Iterator.Element = {$genericType: 'Bound'}
Repeated.Indices = Range
Repeated.Index = Int
Repeated.Element = {$genericType: 'Element'}
Repeated.Iterator = IndexingIterator
Repeated.SubSequence = Slice
ReversedCollection.Elements = ReversedCollection
ReversedCollection.Iterator.Element = {$genericType: 'Base', $subchain: 'Element'}
ReversedCollection.Iterator.Iterator = ReversedCollection.Iterator
ReversedCollection.Element = {$genericType: 'Base', $subchain: 'Element'}
ReversedCollection.SubSequence = Slice
ReversedCollection.Indices = DefaultIndices
_RuntimeFunctionCounters.RuntimeFunctionCountersUpdateHandler = '?function_type'
_RuntimeFunctionCountersStats$implementation.Counters = _RuntimeFunctionCounters
_RuntimeFunctionCountersState.Counters = '?tuple_type'
Sequence$implementation._Default_Iterator = {$genericType: 'Self'}
DropFirstSequence.Element = {$genericType: 'Base', $subchain: 'Element'}
DropFirstSequence.Iterator = {$genericType: 'Base', $subchain: 'Iterator'}
DropFirstSequence.SubSequence = AnySequence
PrefixSequence.Iterator.Element = {$genericType: 'Base', $subchain: 'Element'}
PrefixSequence.Element = {$genericType: 'Base', $subchain: 'Element'}
DropWhileSequence.Element = {$genericType: 'Base', $subchain: 'Element'}
DropWhileSequence.Iterator.Element = {$genericType: 'Base', $subchain: 'Element'}
IteratorSequence.Element = {$genericType: 'Base', $subchain: 'Element'}
IteratorSequence.Iterator = IteratorSequence
Set.ArrayLiteralElement = {$genericType: 'Element'}
Set.Element = {$genericType: 'Element'}
Set.SubSequence = Slice
Set.Indices = DefaultIndices
Set.Iterator.Element = {$genericType: 'Element'}
Set._Variant.Index = Set.Index
Set._Variant.Element = {$genericType: 'Element'}
__CocoaSet.Element = AnyObject
__CocoaSet.Iterator.Element = AnyObject
Slice.Elements = Slice
Slice.Index = {$genericType: 'Base', $subchain: 'Index'}
Slice.Indices = {$genericType: 'Base', $subchain: 'Indices'}
Slice.Element = {$genericType: 'Base', $subchain: 'Element'}
Slice.SubSequence = Slice
Slice.Iterator = IndexingIterator
_SmallString.RawBitPattern = '?tuple_type'
_SmallString.Index = Int
_SmallString.Element = UInt8
_SmallString.SubSequence = _SmallString
_SmallString.Indices = Range
_SmallString.Iterator = IndexingIterator
StaticString.StringLiteralType = StaticString
StaticString.ExtendedGraphemeClusterLiteralType = StaticString
StaticString.UnicodeScalarLiteralType = StaticString
StrideToIterator.Element = {$genericType: 'Element'}
StrideTo.Element = {$genericType: 'Element'}
StrideTo.Iterator = StrideToIterator
StrideThroughIterator.Element = {$genericType: 'Element'}
StrideThrough.Element = {$genericType: 'Element'}
StrideThrough.Iterator = StrideThroughIterator
String.StringLiteralType = String
String.ExtendedGraphemeClusterLiteralType = String
String.UnicodeScalarLiteralType = String
String.IndexDistance = Int
String.SubSequence = Substring
String.Element = Character
String.Indices = DefaultIndices
String.Iterator.Element = Character
String.StringInterpolation = DefaultStringInterpolation
String.UnicodeScalarView.Index = String.Index
String.UnicodeScalarView.Element = Unicode.Scalar
String.UnicodeScalarView.Indices = DefaultIndices
String.UnicodeScalarView.Iterator.Element = Unicode.Scalar
String.UnicodeScalarView.SubSequence = Substring.UnicodeScalarView
String.UnicodeScalarIndex = String.UnicodeScalarView.Index
String.UTF16View.Index = String.Index
String.UTF16View.Element = UTF16.CodeUnit
String.UTF16View.Indices = DefaultIndices
String.UTF16View.Iterator.Element = UInt16
String.UTF16View.SubSequence = Substring.UTF16View
String.UTF8View.Index = String.Index
String.UTF8View.Element = UTF8.CodeUnit
String.UTF8View.Indices = DefaultIndices
String.UTF8View.Iterator = IndexingIterator
String.UTF8View.SubSequence = Substring.UTF8View
String.CharacterView = String
_StringGuts.Index = String.Index
_StringObject.CountAndFlags.RawBitPattern = UInt64
_StringObject.RawBitPattern = '?tuple_type'
DefaultStringInterpolation.StringLiteralType = String
_Normalization._SegmentOutputBuffer = _FixedArray16
Substring.Index = String.Index
Substring.SubSequence = Substring
Substring.Element = Character
Substring.Iterator = IndexingIterator
Substring.Indices = DefaultIndices
Substring.StringInterpolation = DefaultStringInterpolation
Substring.UTF8View.Index = String.UTF8View.Index
Substring.UTF8View.Indices = String.UTF8View.Indices
Substring.UTF8View.Element = String.UTF8View.Element
Substring.UTF8View.SubSequence = Substring.UTF8View
Substring.UTF8View.Iterator = IndexingIterator
Substring.UTF16View.Index = String.UTF16View.Index
Substring.UTF16View.Indices = String.UTF16View.Indices
Substring.UTF16View.Element = String.UTF16View.Element
Substring.UTF16View.SubSequence = Substring.UTF16View
Substring.UTF16View.Iterator = IndexingIterator
Substring.UnicodeScalarView.Index = String.UnicodeScalarView.Index
Substring.UnicodeScalarView.Indices = String.UnicodeScalarView.Indices
Substring.UnicodeScalarView.Element = String.UnicodeScalarView.Element
Substring.UnicodeScalarView.SubSequence = Substring.UnicodeScalarView
Substring.UnicodeScalarView.Iterator = IndexingIterator
Substring.UnicodeScalarLiteralType = String
Substring.ExtendedGraphemeClusterLiteralType = String
Substring.StringLiteralType = String
Substring.CharacterView = Substring
_UIntBuffer.Storage = UInt32
_UIntBuffer.SubSequence = Slice
_UIntBuffer.Iterator.Element = {$genericType: 'Element'}
_UIntBuffer.Iterator.Iterator = _UIntBuffer.Iterator
_UIntBuffer.Element = {$genericType: 'Element'}
_UIntBuffer.Indices = DefaultIndices
UnsafePointer.Distance = Int
UnsafePointer.Pointee = {$genericType: 'Pointee'}
UnsafePointer.Stride = Int
UnsafeMutablePointer.Distance = Int
UnsafeMutablePointer.Stride = Int
UnsafeMutablePointer.Pointee = {$genericType: 'Pointee'}
UnsafeRawPointer.Pointee = UInt8
UnsafeRawPointer.Stride = Int
UnsafeMutableRawPointer.Pointee = UInt8
UnsafeMutableRawPointer.Stride = Int
Unicode.Scalar.UnicodeScalarLiteralType = Unicode.Scalar
Unicode.Scalar.UTF16View.Indices = Range
Unicode.Scalar.UTF16View.Element = UTF16.CodeUnit
Unicode.Scalar.UTF16View.Index = Int
Unicode.Scalar.UTF16View.SubSequence = Slice
Unicode.Scalar.UTF16View.Iterator = IndexingIterator
Unicode.Scalar.UTF8View.Indices = Range
Unicode.Scalar.UTF8View.Element = UTF8.CodeUnit
Unicode.Scalar.UTF8View.Index = Int
Unicode.Scalar.UTF8View.SubSequence = Slice
Unicode.Scalar.UTF8View.Iterator = IndexingIterator
Unicode.Scalar.Properties._U_StrToX = '?function_type'
Unicode.ASCII.CodeUnit = UInt8
Unicode.ASCII.EncodedScalar = CollectionOfOne
Unicode.ASCII.Parser.Encoding = Unicode.ASCII
Unicode.ASCII.ForwardParser = Unicode.ASCII.Parser
Unicode.ASCII.ReverseParser = Unicode.ASCII.Parser
Unicode.Encoding = _UnicodeEncoding$implementation
Unicode.Parser = _UnicodeParser$implementation
Unicode.UTF16.CodeUnit = UInt16
Unicode.UTF16.EncodedScalar = _UIntBuffer
Unicode.UTF16.ForwardParser._Buffer = _UIntBuffer
Unicode.UTF16.ForwardParser.Encoding = Unicode.UTF16
Unicode.UTF16.ReverseParser._Buffer = _UIntBuffer
Unicode.UTF16.ReverseParser.Encoding = Unicode.UTF16
Unicode.Version = '?tuple_type'
Unicode.CanonicalCombiningClass.RawValue = UInt8
Unicode.UTF8.CodeUnit = UInt8
Unicode.UTF8.EncodedScalar = _ValidUTF8Buffer
Unicode.UTF8.ForwardParser._Buffer = _UIntBuffer
Unicode.UTF8.ForwardParser.Encoding = Unicode.UTF8
Unicode.UTF8.ReverseParser._Buffer = _UIntBuffer
Unicode.UTF8.ReverseParser.Encoding = Unicode.UTF8
Unicode.UTF32.CodeUnit = UInt32
Unicode.UTF32.EncodedScalar = CollectionOfOne
Unicode.UTF32.Parser.Encoding = Unicode.UTF32
Unicode.UTF32.ForwardParser = Unicode.UTF32.Parser
Unicode.UTF32.ReverseParser = Unicode.UTF32.Parser
_ValidUTF8Buffer.Element = Unicode.UTF8.CodeUnit
_ValidUTF8Buffer.SubSequence = Slice
_ValidUTF8Buffer.Iterator.Element = UInt8
_ValidUTF8Buffer.Iterator.Iterator = _ValidUTF8Buffer.Iterator
_ValidUTF8Buffer.Indices = DefaultIndices
CollectionDifference.Change._CodingKeys.RawValue = String
CollectionDifference.Element = CollectionDifference.Change
CollectionDifference.Iterator = IndexingIterator
CollectionDifference.SubSequence = Slice
CollectionDifference.Indices = DefaultIndices
CollectionOfOne.Iterator.Element = {$genericType: 'Element'}
CollectionOfOne.Index = Int
CollectionOfOne.Indices = Range
CollectionOfOne.SubSequence = Slice
CollectionOfOne.Element = {$genericType: 'Element'}
_CollectionChanges.Endpoint = '?tuple_type'
_CollectionChanges.Index = Int
_CollectionChanges.SubSequence = Slice
_CollectionChanges.Indices = Range
_CollectionChanges.Iterator = IndexingIterator
_SearchState.Endpoint = '?tuple_type'
_CountingIndexCollection.Index = _CountingIndex
_CountingIndexCollection.Element = {$genericType: 'Base', $subchain: 'Element'}
_CountingIndexCollection.SubSequence = Slice
_CountingIndexCollection.Indices = DefaultIndices
_CountingIndexCollection.Iterator = IndexingIterator
_LowerTriangularMatrix.RowMajorOrder.Element = {$genericType: 'Element'}
_LowerTriangularMatrix.RowMajorOrder.Index = Int
_LowerTriangularMatrix.RowMajorOrder.SubSequence = Slice
_LowerTriangularMatrix.RowMajorOrder.Indices = Range
_LowerTriangularMatrix.RowMajorOrder.Iterator = IndexingIterator
Mirror.Child = '?tuple_type'
Mirror.Children = AnyCollection
_SliceBuffer.NativeStorage = _ContiguousArrayStorage
_SliceBuffer.NativeBuffer = _ContiguousArrayBuffer
_SliceBuffer.Indices = Range
_SliceBuffer.Element = {$genericType: 'Element'}
_SliceBuffer.Index = Int
_SliceBuffer.Iterator = IndexingIterator
_SliceBuffer.SubSequence = _SliceBuffer
SIMDMask.MaskStorage = {$genericType: 'Storage'}
SIMDMask.Scalar = Bool
SIMDMask.ArrayLiteralElement = SIMDMask.Scalar
UnfoldSequence.Element = {$genericType: 'Element'}
UnfoldSequence.Iterator = UnfoldSequence
Zip2Sequence.Iterator.Element = '?tuple_type'
Zip2Sequence.Stream1 = {$genericType: 'Sequence1', $subchain: 'Iterator'}
Zip2Sequence.Stream2 = {$genericType: 'Sequence2', $subchain: 'Iterator'}
Zip2Sequence.Element = '?tuple_type'
KeyedEncodingContainer.Key = {$genericType: 'K'}
KeyedDecodingContainer.Key = {$genericType: 'K'}
CodingUserInfoKey.RawValue = String
_KeyedEncodingContainerBox.Key = {$genericType: 'Concrete', $subchain: 'Key'}
_KeyedDecodingContainerBox.Key = {$genericType: 'Concrete', $subchain: 'Key'}
_FixedArray2.Index = Int
_FixedArray2.Element = {$genericType: 'T'}
_FixedArray2.SubSequence = Slice
_FixedArray2.Indices = Range
_FixedArray2.Iterator = IndexingIterator
_FixedArray4.Index = Int
_FixedArray4.Element = {$genericType: 'T'}
_FixedArray4.SubSequence = Slice
_FixedArray4.Indices = Range
_FixedArray4.Iterator = IndexingIterator
_FixedArray8.Index = Int
_FixedArray8.Element = {$genericType: 'T'}
_FixedArray8.SubSequence = Slice
_FixedArray8.Indices = Range
_FixedArray8.Iterator = IndexingIterator
_FixedArray16.Index = Int
_FixedArray16.Element = {$genericType: 'T'}
_FixedArray16.SubSequence = Slice
_FixedArray16.Indices = Range
_FixedArray16.Iterator = IndexingIterator
Float.Magnitude = Float
Float.Exponent = Int
Float.RawSignificand = UInt32
Float.RawExponent = UInt
Float.FloatLiteralType = Float
Float.IntegerLiteralType = Int64
Float.Stride = Float
Float.SIMDMaskScalar = Int32
Float.SIMD2Storage.Scalar = Float
Float.SIMD4Storage.Scalar = Float
Float.SIMD8Storage.Scalar = Float
Float.SIMD16Storage.Scalar = Float
Float.SIMD32Storage.Scalar = Float
Float.SIMD64Storage.Scalar = Float
_FloatAnyHashableBox.Base = Float
Double.Magnitude = Double
Double.Exponent = Int
Double.RawSignificand = UInt64
Double.RawExponent = UInt
Double.FloatLiteralType = Double
Double.IntegerLiteralType = Int64
Double.Stride = Double
Double.SIMDMaskScalar = Int64
Double.SIMD2Storage.Scalar = Double
Double.SIMD4Storage.Scalar = Double
Double.SIMD8Storage.Scalar = Double
Double.SIMD16Storage.Scalar = Double
Double.SIMD32Storage.Scalar = Double
Double.SIMD64Storage.Scalar = Double
_DoubleAnyHashableBox.Base = Double
Float80.Magnitude = Float80
Float80.Exponent = Int
Float80.RawSignificand = UInt64
Float80.RawExponent = UInt
Float80.FloatLiteralType = Float80
Float80.IntegerLiteralType = Int64
Float80.Stride = Float80
_Float80AnyHashableBox.Base = Float80
UInt8.IntegerLiteralType = UInt8
UInt8.Words.Indices = Range
UInt8.Words.SubSequence = Slice
UInt8.Words.Element = UInt
UInt8.Words.Index = Int
UInt8.Words.Iterator = IndexingIterator
UInt8.Magnitude = UInt8
UInt8.Stride = Int
UInt8.SIMDMaskScalar = Int8
UInt8.SIMD2Storage.Scalar = UInt8
UInt8.SIMD4Storage.Scalar = UInt8
UInt8.SIMD8Storage.Scalar = UInt8
UInt8.SIMD16Storage.Scalar = UInt8
UInt8.SIMD32Storage.Scalar = UInt8
UInt8.SIMD64Storage.Scalar = UInt8
Int8.IntegerLiteralType = Int8
Int8.Words.Indices = Range
Int8.Words.SubSequence = Slice
Int8.Words.Element = UInt
Int8.Words.Index = Int
Int8.Words.Iterator = IndexingIterator
Int8.Magnitude = UInt8
Int8.Stride = Int
Int8.SIMDMaskScalar = Int8
Int8.SIMD2Storage.Scalar = Int8
Int8.SIMD4Storage.Scalar = Int8
Int8.SIMD8Storage.Scalar = Int8
Int8.SIMD16Storage.Scalar = Int8
Int8.SIMD32Storage.Scalar = Int8
Int8.SIMD64Storage.Scalar = Int8
UInt16.IntegerLiteralType = UInt16
UInt16.Words.Indices = Range
UInt16.Words.SubSequence = Slice
UInt16.Words.Element = UInt
UInt16.Words.Index = Int
UInt16.Words.Iterator = IndexingIterator
UInt16.Magnitude = UInt16
UInt16.Stride = Int
UInt16.SIMDMaskScalar = Int16
UInt16.SIMD2Storage.Scalar = UInt16
UInt16.SIMD4Storage.Scalar = UInt16
UInt16.SIMD8Storage.Scalar = UInt16
UInt16.SIMD16Storage.Scalar = UInt16
UInt16.SIMD32Storage.Scalar = UInt16
UInt16.SIMD64Storage.Scalar = UInt16
Int16.IntegerLiteralType = Int16
Int16.Words.Indices = Range
Int16.Words.SubSequence = Slice
Int16.Words.Element = UInt
Int16.Words.Index = Int
Int16.Words.Iterator = IndexingIterator
Int16.Magnitude = UInt16
Int16.Stride = Int
Int16.SIMDMaskScalar = Int16
Int16.SIMD2Storage.Scalar = Int16
Int16.SIMD4Storage.Scalar = Int16
Int16.SIMD8Storage.Scalar = Int16
Int16.SIMD16Storage.Scalar = Int16
Int16.SIMD32Storage.Scalar = Int16
Int16.SIMD64Storage.Scalar = Int16
UInt32.IntegerLiteralType = UInt32
UInt32.Words.Indices = Range
UInt32.Words.SubSequence = Slice
UInt32.Words.Element = UInt
UInt32.Words.Index = Int
UInt32.Words.Iterator = IndexingIterator
UInt32.Magnitude = UInt32
UInt32.Stride = Int
UInt32.SIMDMaskScalar = Int32
UInt32.SIMD2Storage.Scalar = UInt32
UInt32.SIMD4Storage.Scalar = UInt32
UInt32.SIMD8Storage.Scalar = UInt32
UInt32.SIMD16Storage.Scalar = UInt32
UInt32.SIMD32Storage.Scalar = UInt32
UInt32.SIMD64Storage.Scalar = UInt32
Int32.IntegerLiteralType = Int32
Int32.Words.Indices = Range
Int32.Words.SubSequence = Slice
Int32.Words.Element = UInt
Int32.Words.Index = Int
Int32.Words.Iterator = IndexingIterator
Int32.Magnitude = UInt32
Int32.Stride = Int
Int32.SIMDMaskScalar = Int32
Int32.SIMD2Storage.Scalar = Int32
Int32.SIMD4Storage.Scalar = Int32
Int32.SIMD8Storage.Scalar = Int32
Int32.SIMD16Storage.Scalar = Int32
Int32.SIMD32Storage.Scalar = Int32
Int32.SIMD64Storage.Scalar = Int32
UInt64.IntegerLiteralType = UInt64
UInt64.Words.Indices = Range
UInt64.Words.SubSequence = Slice
UInt64.Words.Element = UInt
UInt64.Words.Index = Int
UInt64.Words.Iterator = IndexingIterator
UInt64.Magnitude = UInt64
UInt64.Stride = Int
UInt64.SIMDMaskScalar = Int64
UInt64.SIMD2Storage.Scalar = UInt64
UInt64.SIMD4Storage.Scalar = UInt64
UInt64.SIMD8Storage.Scalar = UInt64
UInt64.SIMD16Storage.Scalar = UInt64
UInt64.SIMD32Storage.Scalar = UInt64
UInt64.SIMD64Storage.Scalar = UInt64
Int64.IntegerLiteralType = Int64
Int64.Words.Indices = Range
Int64.Words.SubSequence = Slice
Int64.Words.Element = UInt
Int64.Words.Index = Int
Int64.Words.Iterator = IndexingIterator
Int64.Magnitude = UInt64
Int64.Stride = Int
Int64.SIMDMaskScalar = Int64
Int64.SIMD2Storage.Scalar = Int64
Int64.SIMD4Storage.Scalar = Int64
Int64.SIMD8Storage.Scalar = Int64
Int64.SIMD16Storage.Scalar = Int64
Int64.SIMD32Storage.Scalar = Int64
Int64.SIMD64Storage.Scalar = Int64
UInt.IntegerLiteralType = UInt
UInt.Words.Indices = Range
UInt.Words.SubSequence = Slice
UInt.Words.Element = UInt
UInt.Words.Index = Int
UInt.Words.Iterator = IndexingIterator
UInt.Magnitude = UInt
UInt.Stride = Int
UInt.SIMDMaskScalar = Int
UInt.SIMD2Storage.Scalar = UInt
UInt.SIMD4Storage.Scalar = UInt
UInt.SIMD8Storage.Scalar = UInt
UInt.SIMD16Storage.Scalar = UInt
UInt.SIMD32Storage.Scalar = UInt
UInt.SIMD64Storage.Scalar = UInt
Int.IntegerLiteralType = Int
Int.Words.Indices = Range
Int.Words.SubSequence = Slice
Int.Words.Element = UInt
Int.Words.Index = Int
Int.Words.Iterator = IndexingIterator
Int.Magnitude = UInt
Int.Stride = Int
Int.SIMDMaskScalar = Int
Int.SIMD2Storage.Scalar = Int
Int.SIMD4Storage.Scalar = Int
Int.SIMD8Storage.Scalar = Int
Int.SIMD16Storage.Scalar = Int
Int.SIMD32Storage.Scalar = Int
Int.SIMD64Storage.Scalar = Int
UnsafeMutableBufferPointer.Iterator = UnsafeBufferPointer.Iterator
UnsafeMutableBufferPointer.Index = Int
UnsafeMutableBufferPointer.Indices = Range
UnsafeMutableBufferPointer.Element = {$genericType: 'Element'}
UnsafeMutableBufferPointer.SubSequence = Slice
UnsafeBufferPointer.Iterator.Element = {$genericType: 'Element'}
UnsafeBufferPointer.Index = Int
UnsafeBufferPointer.Indices = Range
UnsafeBufferPointer.Element = {$genericType: 'Element'}
UnsafeBufferPointer.SubSequence = Slice
UnsafeMutableRawBufferPointer.Iterator = UnsafeRawBufferPointer.Iterator
UnsafeMutableRawBufferPointer.SubSequence = Slice
UnsafeMutableRawBufferPointer.Element = UInt8
UnsafeMutableRawBufferPointer.Index = Int
UnsafeMutableRawBufferPointer.Indices = Range
UnsafeRawBufferPointer.Iterator.Element = UInt8
UnsafeRawBufferPointer.Iterator.Iterator = UnsafeRawBufferPointer.Iterator
UnsafeRawBufferPointer.SubSequence = Slice
UnsafeRawBufferPointer.Element = UInt8
UnsafeRawBufferPointer.Index = Int
UnsafeRawBufferPointer.Indices = Range
AnyIterator.Element = {$genericType: 'Element'}
AnyIterator.Iterator = AnyIterator
_ClosureBasedIterator.Element = {$genericType: 'Element'}
_AnyIteratorBoxBase.Element = {$genericType: 'Element'}
_SequenceBox.Element = {$genericType: 'S', $subchain: 'Element'}
_CollectionBox.Element = {$genericType: 'S', $subchain: 'Element'}
_BidirectionalCollectionBox.Element = {$genericType: 'S', $subchain: 'Element'}
_RandomAccessCollectionBox.Element = {$genericType: 'S', $subchain: 'Element'}
_ClosureBasedSequence.Element = {$genericType: 'Iterator', $subchain: 'Element'}
_ClosureBasedSequence.Iterator = {$genericType: 'Iterator'}
AnySequence.Iterator = AnyIterator
AnySequence.Element = {$genericType: 'Element'}
AnyCollection.Indices = DefaultIndices
AnyCollection.Iterator = AnyIterator
AnyCollection.Index = AnyIndex
AnyCollection.SubSequence = AnyCollection
AnyCollection.Element = {$genericType: 'Element'}
AnyBidirectionalCollection.Indices = DefaultIndices
AnyBidirectionalCollection.Iterator = AnyIterator
AnyBidirectionalCollection.Index = AnyIndex
AnyBidirectionalCollection.SubSequence = AnyBidirectionalCollection
AnyBidirectionalCollection.Element = {$genericType: 'Element'}
AnyRandomAccessCollection.Indices = DefaultIndices
AnyRandomAccessCollection.Iterator = AnyIterator
AnyRandomAccessCollection.Index = AnyIndex
AnyRandomAccessCollection.SubSequence = AnyRandomAccessCollection
AnyRandomAccessCollection.Element = {$genericType: 'Element'}
SIMD2.MaskStorage = SIMD2
SIMD2.Scalar = {$genericType: 'Scalar'}
SIMD2.ArrayLiteralElement = {$genericType: 'Scalar'}
SIMD4.MaskStorage = SIMD4
SIMD4.Scalar = {$genericType: 'Scalar'}
SIMD4.ArrayLiteralElement = {$genericType: 'Scalar'}
SIMD8.MaskStorage = SIMD8
SIMD8.Scalar = {$genericType: 'Scalar'}
SIMD8.ArrayLiteralElement = {$genericType: 'Scalar'}
SIMD16.MaskStorage = SIMD16
SIMD16.Scalar = {$genericType: 'Scalar'}
SIMD16.ArrayLiteralElement = {$genericType: 'Scalar'}
SIMD32.MaskStorage = SIMD32
SIMD32.Scalar = {$genericType: 'Scalar'}
SIMD32.ArrayLiteralElement = {$genericType: 'Scalar'}
SIMD64.MaskStorage = SIMD64
SIMD64.Scalar = {$genericType: 'Scalar'}
SIMD64.ArrayLiteralElement = {$genericType: 'Scalar'}
SIMD3.MaskStorage = SIMD3
SIMD3.Scalar = {$genericType: 'Scalar'}
SIMD3.ArrayLiteralElement = {$genericType: 'Scalar'}
class NSObject implements NSObjectProtocol, Equatable, Hashable, CVarArg, CustomStringConvertible, CustomDebugStringConvertible, _KeyValueCodingAndObserving{

static /*ObjectiveC.(file).NSObject.load()*/
/*ObjectiveC.(file).NSObject.load()*/
load($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.load() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.initialize()*/
/*ObjectiveC.(file).NSObject.initialize()*/
initialize($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.initialize() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

static /*ObjectiveC.(file).NSObject.alloc(with:NSZone?)*/
/*ObjectiveC.(file).NSObject.alloc(with:NSZone?)*/
allocWith(zone, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.alloc(with:NSZone?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.allocWithZone(_:NSZone?)*/
/*ObjectiveC.(file).NSObject.allocWithZone(_:NSZone?)*/
allocWithZone(zone, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.allocWithZone(_:NSZone?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.alloc()*/
/*ObjectiveC.(file).NSObject.alloc()*/
alloc($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.alloc() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.finalize()*/
/*ObjectiveC.(file).NSObject.finalize()*/
finalize($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.finalize() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.finalize()*/
/*ObjectiveC.(file).NSObject.finalize()*/
finalize($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.finalize() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.copy()*/
/*ObjectiveC.(file).NSObject.copy()*/
copy($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.copy() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.copy()*/
/*ObjectiveC.(file).NSObject.copy()*/
copy($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.copy() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.mutableCopy()*/
/*ObjectiveC.(file).NSObject.mutableCopy()*/
mutableCopy($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.mutableCopy() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.mutableCopy()*/
/*ObjectiveC.(file).NSObject.mutableCopy()*/
mutableCopy($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.mutableCopy() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.copy(with:NSZone?)*/
/*ObjectiveC.(file).NSObject.copy(with:NSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.copy(with:NSZone?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.copyWithZone(_:NSZone?)*/
/*ObjectiveC.(file).NSObject.copyWithZone(_:NSZone?)*/
copyWithZone(zone, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.copyWithZone(_:NSZone?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.mutableCopy(with:NSZone?)*/
/*ObjectiveC.(file).NSObject.mutableCopy(with:NSZone?)*/
mutableCopyWith(zone, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.mutableCopy(with:NSZone?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.mutableCopyWithZone(_:NSZone?)*/
/*ObjectiveC.(file).NSObject.mutableCopyWithZone(_:NSZone?)*/
mutableCopyWithZone(zone, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.mutableCopyWithZone(_:NSZone?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.instancesRespond(to:Selector?)*/
/*ObjectiveC.(file).NSObject.instancesRespond(to:Selector?)*/
instancesRespondTo(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.instancesRespond(to:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.instancesRespondToSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.instancesRespondToSelector(_:Selector?)*/
instancesRespondToSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.instancesRespondToSelector(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.conforms(to:Protocol)*/
/*ObjectiveC.(file).NSObject.conforms(to:Protocol)*/
conformsTo(protocol, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.conforms(to:Protocol) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.conformsToProtocol(_:Protocol)*/
/*ObjectiveC.(file).NSObject.conformsToProtocol(_:Protocol)*/
conformsToProtocol(protocol, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.conformsToProtocol(_:Protocol) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.method(for:Selector?)*/
/*ObjectiveC.(file).NSObject.method(for:Selector?)*/
methodFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.method(for:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.method(for:Selector?)*/
/*ObjectiveC.(file).NSObject.method(for:Selector?)*/
methodFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.method(for:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.methodForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.methodForSelector(_:Selector?)*/
methodForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.methodForSelector(_:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.methodForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.methodForSelector(_:Selector?)*/
methodForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.methodForSelector(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.instanceMethod(for:Selector?)*/
/*ObjectiveC.(file).NSObject.instanceMethod(for:Selector?)*/
instanceMethodFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.instanceMethod(for:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.instanceMethodForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.instanceMethodForSelector(_:Selector?)*/
instanceMethodForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.instanceMethodForSelector(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.doesNotRecognizeSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.doesNotRecognizeSelector(_:Selector?)*/
doesNotRecognizeSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.doesNotRecognizeSelector(_:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.doesNotRecognizeSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.doesNotRecognizeSelector(_:Selector?)*/
doesNotRecognizeSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.doesNotRecognizeSelector(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.forwardingTarget(for:Selector?)*/
/*ObjectiveC.(file).NSObject.forwardingTarget(for:Selector?)*/
forwardingTargetFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.forwardingTarget(for:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.forwardingTarget(for:Selector?)*/
/*ObjectiveC.(file).NSObject.forwardingTarget(for:Selector?)*/
forwardingTargetFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.forwardingTarget(for:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.forwardingTargetForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.forwardingTargetForSelector(_:Selector?)*/
forwardingTargetForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.forwardingTargetForSelector(_:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.forwardingTargetForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.forwardingTargetForSelector(_:Selector?)*/
forwardingTargetForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.forwardingTargetForSelector(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.forwardInvocation(_:NSInvocation?)*/
/*ObjectiveC.(file).NSObject.forwardInvocation(_:NSInvocation?)*/
forwardInvocation(anInvocation, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.forwardInvocation(_:NSInvocation?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.forwardInvocation(_:NSInvocation?)*/
/*ObjectiveC.(file).NSObject.forwardInvocation(_:NSInvocation?)*/
forwardInvocation(anInvocation, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.forwardInvocation(_:NSInvocation?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.methodSignature(for:Selector?)*/
/*ObjectiveC.(file).NSObject.methodSignature(for:Selector?)*/
methodSignatureFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.methodSignature(for:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.methodSignature(for:Selector?)*/
/*ObjectiveC.(file).NSObject.methodSignature(for:Selector?)*/
methodSignatureFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.methodSignature(for:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.methodSignatureForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.methodSignatureForSelector(_:Selector?)*/
methodSignatureForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.methodSignatureForSelector(_:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.methodSignatureForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.methodSignatureForSelector(_:Selector?)*/
methodSignatureForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.methodSignatureForSelector(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.instanceMethodSignature(for:Selector?)*/
/*ObjectiveC.(file).NSObject.instanceMethodSignature(for:Selector?)*/
instanceMethodSignatureFor(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.instanceMethodSignature(for:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.instanceMethodSignatureForSelector(_:Selector?)*/
/*ObjectiveC.(file).NSObject.instanceMethodSignatureForSelector(_:Selector?)*/
instanceMethodSignatureForSelector(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.instanceMethodSignatureForSelector(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.allowsWeakReference()*/
/*ObjectiveC.(file).NSObject.allowsWeakReference()*/
allowsWeakReference($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.allowsWeakReference() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.allowsWeakReference()*/
/*ObjectiveC.(file).NSObject.allowsWeakReference()*/
allowsWeakReference($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.allowsWeakReference() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.retainWeakReference()*/
/*ObjectiveC.(file).NSObject.retainWeakReference()*/
retainWeakReference($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.retainWeakReference() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.retainWeakReference()*/
/*ObjectiveC.(file).NSObject.retainWeakReference()*/
retainWeakReference($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.retainWeakReference() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.isSubclass(of:AnyClass)*/
/*ObjectiveC.(file).NSObject.isSubclass(of:AnyClass)*/
isSubclassOf(aClass, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isSubclass(of:AnyClass) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.isSubclassOfClass(_:AnyClass)*/
/*ObjectiveC.(file).NSObject.isSubclassOfClass(_:AnyClass)*/
isSubclassOfClass(aClass, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isSubclassOfClass(_:AnyClass) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.resolveClassMethod(_:Selector?)*/
/*ObjectiveC.(file).NSObject.resolveClassMethod(_:Selector?)*/
resolveClassMethod(sel, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.resolveClassMethod(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.resolveInstanceMethod(_:Selector?)*/
/*ObjectiveC.(file).NSObject.resolveInstanceMethod(_:Selector?)*/
resolveInstanceMethod(sel, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.resolveInstanceMethod(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.hash()*/
/*ObjectiveC.(file).NSObject.hash()*/
hash($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.hash() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.superclass()*/
/*ObjectiveC.(file).NSObject.superclass()*/
superclass($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.superclass() in ' + this.constructor.name
}

static /*ObjectiveC.(file).NSObject.description()*/
/*ObjectiveC.(file).NSObject.description()*/
description($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.description() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.debugDescription()*/
/*ObjectiveC.(file).NSObject.debugDescription()*/
debugDescription($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.debugDescription() in ' + this.constructor.name
}

hash

superclass

description

debugDescription
/*ObjectiveC.(file).NSObject.isEqual(_:Any?)*/
/*ObjectiveC.(file).NSObject.isEqual(_:Any?)*/
isEqual(object, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isEqual(_:Any?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.isEqual(_:Any?)*/
/*ObjectiveC.(file).NSObject.isEqual(_:Any?)*/
isEqual(object, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isEqual(_:Any?) in ' + this.constructor.name
}


/*ObjectiveC.(file).NSObject.perform(_:Selector?)*/
/*ObjectiveC.(file).NSObject.perform(_:Selector?)*/
perform(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.perform(_:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.perform(_:Selector?)*/
/*ObjectiveC.(file).NSObject.perform(_:Selector?)*/
perform(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.perform(_:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?)*/
/*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?)*/
performWith(aSelector, object, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?)*/
/*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?)*/
performWith(aSelector, object, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?,with:Any?)*/
/*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?,with:Any?)*/
performWithWith(aSelector, object1, object2, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?,with:Any?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?,with:Any?)*/
/*ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?,with:Any?)*/
performWithWith(aSelector, object1, object2, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.perform(_:Selector?,with:Any?,with:Any?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.isProxy()*/
/*ObjectiveC.(file).NSObject.isProxy()*/
isProxy($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isProxy() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.isProxy()*/
/*ObjectiveC.(file).NSObject.isProxy()*/
isProxy($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isProxy() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.isKind(of:AnyClass)*/
/*ObjectiveC.(file).NSObject.isKind(of:AnyClass)*/
isKindOf(aClass, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isKind(of:AnyClass) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.isKind(of:AnyClass)*/
/*ObjectiveC.(file).NSObject.isKind(of:AnyClass)*/
isKindOf(aClass, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isKind(of:AnyClass) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.isMember(of:AnyClass)*/
/*ObjectiveC.(file).NSObject.isMember(of:AnyClass)*/
isMemberOf(aClass, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isMember(of:AnyClass) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.isMember(of:AnyClass)*/
/*ObjectiveC.(file).NSObject.isMember(of:AnyClass)*/
isMemberOf(aClass, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.isMember(of:AnyClass) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.conforms(to:Protocol)*/
/*ObjectiveC.(file).NSObject.conforms(to:Protocol)*/
conformsTo(aProtocol, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.conforms(to:Protocol) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.responds(to:Selector?)*/
/*ObjectiveC.(file).NSObject.responds(to:Selector?)*/
respondsTo(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.responds(to:Selector?) in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.responds(to:Selector?)*/
/*ObjectiveC.(file).NSObject.responds(to:Selector?)*/
respondsTo(aSelector, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.responds(to:Selector?) in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.retain()*/
/*ObjectiveC.(file).NSObject.retain()*/
retain($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.retain() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.release()*/
/*ObjectiveC.(file).NSObject.release()*/
release($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.release() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.release()*/
/*ObjectiveC.(file).NSObject.release()*/
release($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.release() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.autorelease()*/
/*ObjectiveC.(file).NSObject.autorelease()*/
autorelease($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.autorelease() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.retainCount()*/
/*ObjectiveC.(file).NSObject.retainCount()*/
retainCount($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.retainCount() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.retainCount()*/
/*ObjectiveC.(file).NSObject.retainCount()*/
retainCount($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.retainCount() in ' + this.constructor.name
}
/*ObjectiveC.(file).NSObject.zone()*/
/*ObjectiveC.(file).NSObject.zone()*/
zone($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.zone() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.zone()*/
/*ObjectiveC.(file).NSObject.zone()*/
zone($info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.zone() in ' + this.constructor.name
}
static /*ObjectiveC.(file).NSObject.==infix(_:NSObject,_:NSObject)*/
/*Swift.(file).Equatable.==infix(_:Self,_:Self)*/
$equal(lhs, rhs, $info?) {
return lhs == rhs
}

/*ObjectiveC.(file).NSObject.hashValue*/
hashValue$get() {
throw 'unsupported variable ObjectiveC.(file).NSObject.hashValue in ' + this.constructor.name
}
get hashValue() { return this.hashValue$get() };



/*ObjectiveC.(file).NSObject.hash(into:Hasher)*/
/*Swift.(file).Hashable.hash(into:Hasher)*/
hashInto(hasher$inout, $info?) {
throw 'unsupported method ObjectiveC.(file).NSObject.hash(into:Hasher) in ' + this.constructor.name
}






static /*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],to:NSPasteboard)*/
/*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],to:NSPasteboard)*/
tableView(tableView, rows, pboard, $info?) {
throw 'unsupported method AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],to:NSPasteboard) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],to:NSPasteboard)*/
/*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],to:NSPasteboard)*/
tableView(tableView, rows, pboard, $info?) {
throw 'unsupported method AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],to:NSPasteboard) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],toPasteboard:NSPasteboard)*/
/*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],toPasteboard:NSPasteboard)*/
tableView1(tableView, rows, pboard, $info?) {
throw 'unsupported method AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],toPasteboard:NSPasteboard) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],toPasteboard:NSPasteboard)*/
/*AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],toPasteboard:NSPasteboard)*/
tableView1(tableView, rows, pboard, $info?) {
throw 'unsupported method AppKit.(file).NSObject.tableView(_:NSTableView,writeRows:[Any],toPasteboard:NSPasteboard) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.textStorageWillProcessEditing(_:Notification)*/
/*AppKit.(file).NSObject.textStorageWillProcessEditing(_:Notification)*/
textStorageWillProcessEditing(notification, $info?) {
throw 'unsupported method AppKit.(file).NSObject.textStorageWillProcessEditing(_:Notification) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.textStorageWillProcessEditing(_:Notification)*/
/*AppKit.(file).NSObject.textStorageWillProcessEditing(_:Notification)*/
textStorageWillProcessEditing(notification, $info?) {
throw 'unsupported method AppKit.(file).NSObject.textStorageWillProcessEditing(_:Notification) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.textStorageDidProcessEditing(_:Notification)*/
/*AppKit.(file).NSObject.textStorageDidProcessEditing(_:Notification)*/
textStorageDidProcessEditing(notification, $info?) {
throw 'unsupported method AppKit.(file).NSObject.textStorageDidProcessEditing(_:Notification) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.textStorageDidProcessEditing(_:Notification)*/
/*AppKit.(file).NSObject.textStorageDidProcessEditing(_:Notification)*/
textStorageDidProcessEditing(notification, $info?) {
throw 'unsupported method AppKit.(file).NSObject.textStorageDidProcessEditing(_:Notification) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.panel(_:Any,isValidFilename:String)*/
/*AppKit.(file).NSObject.panel(_:Any,isValidFilename:String)*/
panel(sender, filename, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,isValidFilename:String) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.panel(_:Any,isValidFilename:String)*/
/*AppKit.(file).NSObject.panel(_:Any,isValidFilename:String)*/
panel(sender, filename, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,isValidFilename:String) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.panel(_:Any,directoryDidChange:String)*/
/*AppKit.(file).NSObject.panel(_:Any,directoryDidChange:String)*/
panel1(sender, path, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,directoryDidChange:String) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.panel(_:Any,directoryDidChange:String)*/
/*AppKit.(file).NSObject.panel(_:Any,directoryDidChange:String)*/
panel1(sender, path, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,directoryDidChange:String) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.panel(_:Any,compareFilename:String,with:String,caseSensitive:Bool)*/
/*AppKit.(file).NSObject.panel(_:Any,compareFilename:String,with:String,caseSensitive:Bool)*/
panel2(sender, name1, name2, caseSensitive, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,compareFilename:String,with:String,caseSensitive:Bool) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.panel(_:Any,compareFilename:String,with:String,caseSensitive:Bool)*/
/*AppKit.(file).NSObject.panel(_:Any,compareFilename:String,with:String,caseSensitive:Bool)*/
panel2(sender, name1, name2, caseSensitive, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,compareFilename:String,with:String,caseSensitive:Bool) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.panel(_:Any,shouldShowFilename:String)*/
/*AppKit.(file).NSObject.panel(_:Any,shouldShowFilename:String)*/
panel3(sender, filename, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,shouldShowFilename:String) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.panel(_:Any,shouldShowFilename:String)*/
/*AppKit.(file).NSObject.panel(_:Any,shouldShowFilename:String)*/
panel3(sender, filename, $info?) {
throw 'unsupported method AppKit.(file).NSObject.panel(_:Any,shouldShowFilename:String) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.awakeFromNib()*/
/*AppKit.(file).NSObject.awakeFromNib()*/
awakeFromNib($info?) {
throw 'unsupported method AppKit.(file).NSObject.awakeFromNib() in ' + this.constructor.name
}
/*AppKit.(file).NSObject.awakeFromNib()*/
/*AppKit.(file).NSObject.awakeFromNib()*/
awakeFromNib($info?) {
throw 'unsupported method AppKit.(file).NSObject.awakeFromNib() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.prepareForInterfaceBuilder()*/
/*AppKit.(file).NSObject.prepareForInterfaceBuilder()*/
prepareForInterfaceBuilder($info?) {
throw 'unsupported method AppKit.(file).NSObject.prepareForInterfaceBuilder() in ' + this.constructor.name
}
/*AppKit.(file).NSObject.prepareForInterfaceBuilder()*/
/*AppKit.(file).NSObject.prepareForInterfaceBuilder()*/
prepareForInterfaceBuilder($info?) {
throw 'unsupported method AppKit.(file).NSObject.prepareForInterfaceBuilder() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.fontManager(_:Any,willIncludeFont:String)*/
/*AppKit.(file).NSObject.fontManager(_:Any,willIncludeFont:String)*/
fontManager(sender, fontName, $info?) {
throw 'unsupported method AppKit.(file).NSObject.fontManager(_:Any,willIncludeFont:String) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.fontManager(_:Any,willIncludeFont:String)*/
/*AppKit.(file).NSObject.fontManager(_:Any,willIncludeFont:String)*/
fontManager(sender, fontName, $info?) {
throw 'unsupported method AppKit.(file).NSObject.fontManager(_:Any,willIncludeFont:String) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.setDefaultPlaceholder(_:Any?,for:Any?,with:NSBindingName)*/
/*AppKit.(file).NSObject.setDefaultPlaceholder(_:Any?,for:Any?,with:NSBindingName)*/
setDefaultPlaceholder(placeholder, marker, binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.setDefaultPlaceholder(_:Any?,for:Any?,with:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.setDefaultPlaceholder(_:Any?,forMarker:Any?,withBinding:NSBindingName)*/
/*AppKit.(file).NSObject.setDefaultPlaceholder(_:Any?,forMarker:Any?,withBinding:NSBindingName)*/
setDefaultPlaceholder1(placeholder, marker, binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.setDefaultPlaceholder(_:Any?,forMarker:Any?,withBinding:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.defaultPlaceholder(for:Any?,with:NSBindingName)*/
/*AppKit.(file).NSObject.defaultPlaceholder(for:Any?,with:NSBindingName)*/
defaultPlaceholder(marker, binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.defaultPlaceholder(for:Any?,with:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.defaultPlaceholder(forMarker:Any?,withBinding:NSBindingName)*/
/*AppKit.(file).NSObject.defaultPlaceholder(forMarker:Any?,withBinding:NSBindingName)*/
defaultPlaceholder1(marker, binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.defaultPlaceholder(forMarker:Any?,withBinding:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.defaultPlaceholderForMarker(_:Any?,withBinding:NSBindingName)*/
/*AppKit.(file).NSObject.defaultPlaceholderForMarker(_:Any?,withBinding:NSBindingName)*/
defaultPlaceholderForMarker(marker, binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.defaultPlaceholderForMarker(_:Any?,withBinding:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.exposeBinding(_:NSBindingName)*/
/*AppKit.(file).NSObject.exposeBinding(_:NSBindingName)*/
exposeBinding(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.exposeBinding(_:NSBindingName) in ' + this.constructor.name
}

exposedBindings
static /*AppKit.(file).NSObject.valueClassForBinding(_:NSBindingName)*/
/*AppKit.(file).NSObject.valueClassForBinding(_:NSBindingName)*/
valueClassForBinding(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.valueClassForBinding(_:NSBindingName) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.valueClassForBinding(_:NSBindingName)*/
/*AppKit.(file).NSObject.valueClassForBinding(_:NSBindingName)*/
valueClassForBinding(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.valueClassForBinding(_:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.bind(_:NSBindingName,to:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
/*AppKit.(file).NSObject.bind(_:NSBindingName,to:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
bind(binding, observable, keyPath, options, $info?) {
throw 'unsupported method AppKit.(file).NSObject.bind(_:NSBindingName,to:Any,withKeyPath:String,options:[NSBindingOption : Any]?) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.bind(_:NSBindingName,to:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
/*AppKit.(file).NSObject.bind(_:NSBindingName,to:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
bind(binding, observable, keyPath, options, $info?) {
throw 'unsupported method AppKit.(file).NSObject.bind(_:NSBindingName,to:Any,withKeyPath:String,options:[NSBindingOption : Any]?) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.bind(_:NSBindingName,toObject:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
/*AppKit.(file).NSObject.bind(_:NSBindingName,toObject:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
bind1(binding, observable, keyPath, options, $info?) {
throw 'unsupported method AppKit.(file).NSObject.bind(_:NSBindingName,toObject:Any,withKeyPath:String,options:[NSBindingOption : Any]?) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.bind(_:NSBindingName,toObject:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
/*AppKit.(file).NSObject.bind(_:NSBindingName,toObject:Any,withKeyPath:String,options:[NSBindingOption : Any]?)*/
bind1(binding, observable, keyPath, options, $info?) {
throw 'unsupported method AppKit.(file).NSObject.bind(_:NSBindingName,toObject:Any,withKeyPath:String,options:[NSBindingOption : Any]?) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.unbind(_:NSBindingName)*/
/*AppKit.(file).NSObject.unbind(_:NSBindingName)*/
unbind(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.unbind(_:NSBindingName) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.unbind(_:NSBindingName)*/
/*AppKit.(file).NSObject.unbind(_:NSBindingName)*/
unbind(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.unbind(_:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.infoForBinding(_:NSBindingName)*/
/*AppKit.(file).NSObject.infoForBinding(_:NSBindingName)*/
infoForBinding(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.infoForBinding(_:NSBindingName) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.infoForBinding(_:NSBindingName)*/
/*AppKit.(file).NSObject.infoForBinding(_:NSBindingName)*/
infoForBinding(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.infoForBinding(_:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.optionDescriptionsForBinding(_:NSBindingName)*/
/*AppKit.(file).NSObject.optionDescriptionsForBinding(_:NSBindingName)*/
optionDescriptionsForBinding(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.optionDescriptionsForBinding(_:NSBindingName) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.optionDescriptionsForBinding(_:NSBindingName)*/
/*AppKit.(file).NSObject.optionDescriptionsForBinding(_:NSBindingName)*/
optionDescriptionsForBinding(binding, $info?) {
throw 'unsupported method AppKit.(file).NSObject.optionDescriptionsForBinding(_:NSBindingName) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.exposedBindings()*/
/*AppKit.(file).NSObject.exposedBindings()*/
exposedBindings($info?) {
throw 'unsupported method AppKit.(file).NSObject.exposedBindings() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.namesOfPromisedFilesDropped(atDestination:URL)*/
/*AppKit.(file).NSObject.namesOfPromisedFilesDropped(atDestination:URL)*/
namesOfPromisedFilesDropped(dropDestination, $info?) {
throw 'unsupported method AppKit.(file).NSObject.namesOfPromisedFilesDropped(atDestination:URL) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.namesOfPromisedFilesDropped(atDestination:URL)*/
/*AppKit.(file).NSObject.namesOfPromisedFilesDropped(atDestination:URL)*/
namesOfPromisedFilesDropped(dropDestination, $info?) {
throw 'unsupported method AppKit.(file).NSObject.namesOfPromisedFilesDropped(atDestination:URL) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.namesOfPromisedFilesDroppedAtDestination(_:URL)*/
/*AppKit.(file).NSObject.namesOfPromisedFilesDroppedAtDestination(_:URL)*/
namesOfPromisedFilesDroppedAtDestination(dropDestination, $info?) {
throw 'unsupported method AppKit.(file).NSObject.namesOfPromisedFilesDroppedAtDestination(_:URL) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.namesOfPromisedFilesDroppedAtDestination(_:URL)*/
/*AppKit.(file).NSObject.namesOfPromisedFilesDroppedAtDestination(_:URL)*/
namesOfPromisedFilesDroppedAtDestination(dropDestination, $info?) {
throw 'unsupported method AppKit.(file).NSObject.namesOfPromisedFilesDroppedAtDestination(_:URL) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.draggingSourceOperationMask(forLocal:Bool)*/
/*AppKit.(file).NSObject.draggingSourceOperationMask(forLocal:Bool)*/
draggingSourceOperationMask(flag, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggingSourceOperationMask(forLocal:Bool) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.draggingSourceOperationMask(forLocal:Bool)*/
/*AppKit.(file).NSObject.draggingSourceOperationMask(forLocal:Bool)*/
draggingSourceOperationMask(flag, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggingSourceOperationMask(forLocal:Bool) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.draggingSourceOperationMaskForLocal(_:Bool)*/
/*AppKit.(file).NSObject.draggingSourceOperationMaskForLocal(_:Bool)*/
draggingSourceOperationMaskForLocal(flag, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggingSourceOperationMaskForLocal(_:Bool) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.draggingSourceOperationMaskForLocal(_:Bool)*/
/*AppKit.(file).NSObject.draggingSourceOperationMaskForLocal(_:Bool)*/
draggingSourceOperationMaskForLocal(flag, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggingSourceOperationMaskForLocal(_:Bool) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.draggedImage(_:NSImage?,beganAt:NSPoint)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,beganAt:NSPoint)*/
draggedImage(_image, screenPoint, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,beganAt:NSPoint) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,beganAt:NSPoint)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,beganAt:NSPoint)*/
draggedImage(_image, screenPoint, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,beganAt:NSPoint) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,operation:NSDragOperation)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,operation:NSDragOperation)*/
draggedImage1(_image, screenPoint, operation, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,operation:NSDragOperation) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,operation:NSDragOperation)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,operation:NSDragOperation)*/
draggedImage1(_image, screenPoint, operation, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,operation:NSDragOperation) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.draggedImage(_:NSImage?,movedTo:NSPoint)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,movedTo:NSPoint)*/
draggedImage2(_image, screenPoint, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,movedTo:NSPoint) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,movedTo:NSPoint)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,movedTo:NSPoint)*/
draggedImage2(_image, screenPoint, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,movedTo:NSPoint) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.ignoreModifierKeysWhileDragging()*/
/*AppKit.(file).NSObject.ignoreModifierKeysWhileDragging()*/
ignoreModifierKeysWhileDragging($info?) {
throw 'unsupported method AppKit.(file).NSObject.ignoreModifierKeysWhileDragging() in ' + this.constructor.name
}
/*AppKit.(file).NSObject.ignoreModifierKeysWhileDragging()*/
/*AppKit.(file).NSObject.ignoreModifierKeysWhileDragging()*/
ignoreModifierKeysWhileDragging($info?) {
throw 'unsupported method AppKit.(file).NSObject.ignoreModifierKeysWhileDragging() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,deposited:Bool)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,deposited:Bool)*/
draggedImage3(_image, screenPoint, flag, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,deposited:Bool) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,deposited:Bool)*/
/*AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,deposited:Bool)*/
draggedImage3(_image, screenPoint, flag, $info?) {
throw 'unsupported method AppKit.(file).NSObject.draggedImage(_:NSImage?,endedAt:NSPoint,deposited:Bool) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilitySetOverrideValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilitySetOverrideValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
accessibilitySetOverrideValue(value, attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilitySetOverrideValue(_:Any?,forAttribute:NSAccessibility.Attribute) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilitySetOverrideValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilitySetOverrideValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
accessibilitySetOverrideValue(value, attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilitySetOverrideValue(_:Any?,forAttribute:NSAccessibility.Attribute) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityAttributeNames()*/
/*AppKit.(file).NSObject.accessibilityAttributeNames()*/
accessibilityAttributeNames($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityAttributeNames() in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityAttributeNames()*/
/*AppKit.(file).NSObject.accessibilityAttributeNames()*/
accessibilityAttributeNames($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityAttributeNames() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.Attribute)*/
accessibilityAttributeValue(attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.Attribute) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.Attribute)*/
accessibilityAttributeValue(attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.Attribute) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityIsAttributeSettable(_:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilityIsAttributeSettable(_:NSAccessibility.Attribute)*/
accessibilityIsAttributeSettable(attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIsAttributeSettable(_:NSAccessibility.Attribute) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityIsAttributeSettable(_:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilityIsAttributeSettable(_:NSAccessibility.Attribute)*/
accessibilityIsAttributeSettable(attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIsAttributeSettable(_:NSAccessibility.Attribute) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilitySetValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilitySetValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
accessibilitySetValue(value, attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilitySetValue(_:Any?,forAttribute:NSAccessibility.Attribute) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilitySetValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilitySetValue(_:Any?,forAttribute:NSAccessibility.Attribute)*/
accessibilitySetValue(value, attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilitySetValue(_:Any?,forAttribute:NSAccessibility.Attribute) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityParameterizedAttributeNames()*/
/*AppKit.(file).NSObject.accessibilityParameterizedAttributeNames()*/
accessibilityParameterizedAttributeNames($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityParameterizedAttributeNames() in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityParameterizedAttributeNames()*/
/*AppKit.(file).NSObject.accessibilityParameterizedAttributeNames()*/
accessibilityParameterizedAttributeNames($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityParameterizedAttributeNames() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.ParameterizedAttribute,forParameter:Any?)*/
/*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.ParameterizedAttribute,forParameter:Any?)*/
accessibilityAttributeValue1(attribute, parameter, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.ParameterizedAttribute,forParameter:Any?) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.ParameterizedAttribute,forParameter:Any?)*/
/*AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.ParameterizedAttribute,forParameter:Any?)*/
accessibilityAttributeValue1(attribute, parameter, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityAttributeValue(_:NSAccessibility.ParameterizedAttribute,forParameter:Any?) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityActionNames()*/
/*AppKit.(file).NSObject.accessibilityActionNames()*/
accessibilityActionNames($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityActionNames() in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityActionNames()*/
/*AppKit.(file).NSObject.accessibilityActionNames()*/
accessibilityActionNames($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityActionNames() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityActionDescription(_:NSAccessibility.Action)*/
/*AppKit.(file).NSObject.accessibilityActionDescription(_:NSAccessibility.Action)*/
accessibilityActionDescription(action, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityActionDescription(_:NSAccessibility.Action) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityActionDescription(_:NSAccessibility.Action)*/
/*AppKit.(file).NSObject.accessibilityActionDescription(_:NSAccessibility.Action)*/
accessibilityActionDescription(action, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityActionDescription(_:NSAccessibility.Action) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityPerformAction(_:NSAccessibility.Action)*/
/*AppKit.(file).NSObject.accessibilityPerformAction(_:NSAccessibility.Action)*/
accessibilityPerformAction(action, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityPerformAction(_:NSAccessibility.Action) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityPerformAction(_:NSAccessibility.Action)*/
/*AppKit.(file).NSObject.accessibilityPerformAction(_:NSAccessibility.Action)*/
accessibilityPerformAction(action, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityPerformAction(_:NSAccessibility.Action) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityIsIgnored()*/
/*AppKit.(file).NSObject.accessibilityIsIgnored()*/
accessibilityIsIgnored($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIsIgnored() in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityIsIgnored()*/
/*AppKit.(file).NSObject.accessibilityIsIgnored()*/
accessibilityIsIgnored($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIsIgnored() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityHitTest(_:NSPoint)*/
/*AppKit.(file).NSObject.accessibilityHitTest(_:NSPoint)*/
accessibilityHitTest(point, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityHitTest(_:NSPoint) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityHitTest(_:NSPoint)*/
/*AppKit.(file).NSObject.accessibilityHitTest(_:NSPoint)*/
accessibilityHitTest(point, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityHitTest(_:NSPoint) in ' + this.constructor.name
}

accessibilityFocusedUIElement
static /*AppKit.(file).NSObject.accessibilityIndex(ofChild:Any)*/
/*AppKit.(file).NSObject.accessibilityIndex(ofChild:Any)*/
accessibilityIndex(child, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIndex(ofChild:Any) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityIndex(ofChild:Any)*/
/*AppKit.(file).NSObject.accessibilityIndex(ofChild:Any)*/
accessibilityIndex(child, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIndex(ofChild:Any) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityIndexOfChild(_:Any)*/
/*AppKit.(file).NSObject.accessibilityIndexOfChild(_:Any)*/
accessibilityIndexOfChild(child, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIndexOfChild(_:Any) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityIndexOfChild(_:Any)*/
/*AppKit.(file).NSObject.accessibilityIndexOfChild(_:Any)*/
accessibilityIndexOfChild(child, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityIndexOfChild(_:Any) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityArrayAttributeCount(_:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilityArrayAttributeCount(_:NSAccessibility.Attribute)*/
accessibilityArrayAttributeCount(attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityArrayAttributeCount(_:NSAccessibility.Attribute) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityArrayAttributeCount(_:NSAccessibility.Attribute)*/
/*AppKit.(file).NSObject.accessibilityArrayAttributeCount(_:NSAccessibility.Attribute)*/
accessibilityArrayAttributeCount(attribute, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityArrayAttributeCount(_:NSAccessibility.Attribute) in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityArrayAttributeValues(_:NSAccessibility.Attribute,index:Int,maxCount:Int)*/
/*AppKit.(file).NSObject.accessibilityArrayAttributeValues(_:NSAccessibility.Attribute,index:Int,maxCount:Int)*/
accessibilityArrayAttributeValues(attribute, index, maxCount, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityArrayAttributeValues(_:NSAccessibility.Attribute,index:Int,maxCount:Int) in ' + this.constructor.name
}
/*AppKit.(file).NSObject.accessibilityArrayAttributeValues(_:NSAccessibility.Attribute,index:Int,maxCount:Int)*/
/*AppKit.(file).NSObject.accessibilityArrayAttributeValues(_:NSAccessibility.Attribute,index:Int,maxCount:Int)*/
accessibilityArrayAttributeValues(attribute, index, maxCount, $info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityArrayAttributeValues(_:NSAccessibility.Attribute,index:Int,maxCount:Int) in ' + this.constructor.name
}

accessibilityNotifiesWhenDestroyed
static /*AppKit.(file).NSObject.accessibilityFocusedUIElement()*/
/*AppKit.(file).NSObject.accessibilityFocusedUIElement()*/
accessibilityFocusedUIElement($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityFocusedUIElement() in ' + this.constructor.name
}
static /*AppKit.(file).NSObject.accessibilityNotifiesWhenDestroyed()*/
/*AppKit.(file).NSObject.accessibilityNotifiesWhenDestroyed()*/
accessibilityNotifiesWhenDestroyed($info?) {
throw 'unsupported method AppKit.(file).NSObject.accessibilityNotifiesWhenDestroyed() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsEqual(to:Any)*/
/*Foundation.(file).NSObject.scriptingIsEqual(to:Any)*/
scriptingIsEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsEqual(to:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsEqual(to:Any)*/
/*Foundation.(file).NSObject.scriptingIsEqual(to:Any)*/
scriptingIsEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsEqual(to:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsEqualTo(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsEqualTo(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingIsEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsEqualTo(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsEqualTo(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsEqualTo(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingIsEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsEqualTo(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsLessThanOrEqual(to:Any)*/
/*Foundation.(file).NSObject.scriptingIsLessThanOrEqual(to:Any)*/
scriptingIsLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsLessThanOrEqual(to:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsLessThanOrEqual(to:Any)*/
/*Foundation.(file).NSObject.scriptingIsLessThanOrEqual(to:Any)*/
scriptingIsLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsLessThanOrEqual(to:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsLessThanOrEqualTo(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsLessThanOrEqualTo(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingIsLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsLessThanOrEqualTo(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsLessThanOrEqualTo(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsLessThanOrEqualTo(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingIsLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsLessThanOrEqualTo(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsLessThan(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsLessThan(_:Any)*/
scriptingIsLessThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsLessThan(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsLessThan(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsLessThan(_:Any)*/
scriptingIsLessThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsLessThan(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqual(to:Any)*/
/*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqual(to:Any)*/
scriptingIsGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsGreaterThanOrEqual(to:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqual(to:Any)*/
/*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqual(to:Any)*/
scriptingIsGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsGreaterThanOrEqual(to:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqualTo(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqualTo(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingIsGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsGreaterThanOrEqualTo(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqualTo(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsGreaterThanOrEqualTo(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingIsGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsGreaterThanOrEqualTo(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingIsGreaterThan(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsGreaterThan(_:Any)*/
scriptingIsGreaterThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsGreaterThan(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingIsGreaterThan(_:Any)*/
/*Foundation.(file).NSObject.scriptingIsGreaterThan(_:Any)*/
scriptingIsGreaterThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingIsGreaterThan(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingBegins(with:Any)*/
/*Foundation.(file).NSObject.scriptingBegins(with:Any)*/
scriptingBeginsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingBegins(with:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingBegins(with:Any)*/
/*Foundation.(file).NSObject.scriptingBegins(with:Any)*/
scriptingBeginsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingBegins(with:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingBeginsWith(_:Any)*/
/*Foundation.(file).NSObject.scriptingBeginsWith(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingBeginsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingBeginsWith(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingBeginsWith(_:Any)*/
/*Foundation.(file).NSObject.scriptingBeginsWith(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingBeginsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingBeginsWith(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingEnds(with:Any)*/
/*Foundation.(file).NSObject.scriptingEnds(with:Any)*/
scriptingEndsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingEnds(with:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingEnds(with:Any)*/
/*Foundation.(file).NSObject.scriptingEnds(with:Any)*/
scriptingEndsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingEnds(with:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingEndsWith(_:Any)*/
/*Foundation.(file).NSObject.scriptingEndsWith(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingEndsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingEndsWith(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingEndsWith(_:Any)*/
/*Foundation.(file).NSObject.scriptingEndsWith(_:Any)*/
/*!!!DUPLICATE NAME*/
scriptingEndsWith(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingEndsWith(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingContains(_:Any)*/
/*Foundation.(file).NSObject.scriptingContains(_:Any)*/
scriptingContains(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingContains(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingContains(_:Any)*/
/*Foundation.(file).NSObject.scriptingContains(_:Any)*/
scriptingContains(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingContains(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isEqual(to:Any?)*/
/*Foundation.(file).NSObject.isEqual(to:Any?)*/
isEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isEqual(to:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isEqual(to:Any?)*/
/*Foundation.(file).NSObject.isEqual(to:Any?)*/
isEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isEqual(to:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isEqualTo(_:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isEqualTo(_:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isLessThanOrEqual(to:Any?)*/
/*Foundation.(file).NSObject.isLessThanOrEqual(to:Any?)*/
isLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLessThanOrEqual(to:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isLessThanOrEqual(to:Any?)*/
/*Foundation.(file).NSObject.isLessThanOrEqual(to:Any?)*/
isLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLessThanOrEqual(to:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isLessThanOrEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isLessThanOrEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLessThanOrEqualTo(_:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isLessThanOrEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isLessThanOrEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isLessThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLessThanOrEqualTo(_:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isLessThan(_:Any?)*/
/*Foundation.(file).NSObject.isLessThan(_:Any?)*/
isLessThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLessThan(_:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isLessThan(_:Any?)*/
/*Foundation.(file).NSObject.isLessThan(_:Any?)*/
isLessThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLessThan(_:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isGreaterThanOrEqual(to:Any?)*/
/*Foundation.(file).NSObject.isGreaterThanOrEqual(to:Any?)*/
isGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isGreaterThanOrEqual(to:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isGreaterThanOrEqual(to:Any?)*/
/*Foundation.(file).NSObject.isGreaterThanOrEqual(to:Any?)*/
isGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isGreaterThanOrEqual(to:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isGreaterThanOrEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isGreaterThanOrEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isGreaterThanOrEqualTo(_:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isGreaterThanOrEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isGreaterThanOrEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isGreaterThanOrEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isGreaterThanOrEqualTo(_:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isGreaterThan(_:Any?)*/
/*Foundation.(file).NSObject.isGreaterThan(_:Any?)*/
isGreaterThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isGreaterThan(_:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isGreaterThan(_:Any?)*/
/*Foundation.(file).NSObject.isGreaterThan(_:Any?)*/
isGreaterThan(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isGreaterThan(_:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isNotEqual(to:Any?)*/
/*Foundation.(file).NSObject.isNotEqual(to:Any?)*/
isNotEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isNotEqual(to:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isNotEqual(to:Any?)*/
/*Foundation.(file).NSObject.isNotEqual(to:Any?)*/
isNotEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isNotEqual(to:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isNotEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isNotEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isNotEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isNotEqualTo(_:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isNotEqualTo(_:Any?)*/
/*Foundation.(file).NSObject.isNotEqualTo(_:Any?)*/
/*!!!DUPLICATE NAME*/
isNotEqualTo(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isNotEqualTo(_:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.doesContain(_:Any)*/
/*Foundation.(file).NSObject.doesContain(_:Any)*/
doesContain(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.doesContain(_:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.doesContain(_:Any)*/
/*Foundation.(file).NSObject.doesContain(_:Any)*/
doesContain(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.doesContain(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isLike(_:String)*/
/*Foundation.(file).NSObject.isLike(_:String)*/
isLike(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLike(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isLike(_:String)*/
/*Foundation.(file).NSObject.isLike(_:String)*/
isLike(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isLike(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.isCaseInsensitiveLike(_:String)*/
/*Foundation.(file).NSObject.isCaseInsensitiveLike(_:String)*/
isCaseInsensitiveLike(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isCaseInsensitiveLike(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.isCaseInsensitiveLike(_:String)*/
/*Foundation.(file).NSObject.isCaseInsensitiveLike(_:String)*/
isCaseInsensitiveLike(object, $info?) {
throw 'unsupported method Foundation.(file).NSObject.isCaseInsensitiveLike(_:String) in ' + this.constructor.name
}

objectSpecifier
static /*Foundation.(file).NSObject.indicesOfObjects(byEvaluatingObjectSpecifier:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.indicesOfObjects(byEvaluatingObjectSpecifier:NSScriptObjectSpecifier)*/
indicesOfObjectsByEvaluatingObjectSpecifier(specifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.indicesOfObjects(byEvaluatingObjectSpecifier:NSScriptObjectSpecifier) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.indicesOfObjects(byEvaluatingObjectSpecifier:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.indicesOfObjects(byEvaluatingObjectSpecifier:NSScriptObjectSpecifier)*/
indicesOfObjectsByEvaluatingObjectSpecifier(specifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.indicesOfObjects(byEvaluatingObjectSpecifier:NSScriptObjectSpecifier) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.indicesOfObjectsByEvaluatingObjectSpecifier(_:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.indicesOfObjectsByEvaluatingObjectSpecifier(_:NSScriptObjectSpecifier)*/
/*!!!DUPLICATE NAME*/
indicesOfObjectsByEvaluatingObjectSpecifier(specifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.indicesOfObjectsByEvaluatingObjectSpecifier(_:NSScriptObjectSpecifier) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.indicesOfObjectsByEvaluatingObjectSpecifier(_:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.indicesOfObjectsByEvaluatingObjectSpecifier(_:NSScriptObjectSpecifier)*/
/*!!!DUPLICATE NAME*/
indicesOfObjectsByEvaluatingObjectSpecifier(specifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.indicesOfObjectsByEvaluatingObjectSpecifier(_:NSScriptObjectSpecifier) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.objectSpecifier()*/
/*Foundation.(file).NSObject.objectSpecifier()*/
objectSpecifier($info?) {
throw 'unsupported method Foundation.(file).NSObject.objectSpecifier() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.value(at:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.value(at:Int,inPropertyWithKey:String)*/
valueAtInPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(at:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.value(at:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.value(at:Int,inPropertyWithKey:String)*/
valueAtInPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(at:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.valueAtIndex(_:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.valueAtIndex(_:Int,inPropertyWithKey:String)*/
valueAtIndexInPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueAtIndex(_:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.valueAtIndex(_:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.valueAtIndex(_:Int,inPropertyWithKey:String)*/
valueAtIndexInPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueAtIndex(_:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.value(withName:String,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.value(withName:String,inPropertyWithKey:String)*/
valueWithNameInPropertyWithKey(_name, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(withName:String,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.value(withName:String,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.value(withName:String,inPropertyWithKey:String)*/
valueWithNameInPropertyWithKey(_name, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(withName:String,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.valueWithName(_:String,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.valueWithName(_:String,inPropertyWithKey:String)*/
/*!!!DUPLICATE NAME*/
valueWithNameInPropertyWithKey(_name, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueWithName(_:String,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.valueWithName(_:String,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.valueWithName(_:String,inPropertyWithKey:String)*/
/*!!!DUPLICATE NAME*/
valueWithNameInPropertyWithKey(_name, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueWithName(_:String,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.value(withUniqueID:Any,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.value(withUniqueID:Any,inPropertyWithKey:String)*/
valueWithUniqueIDInPropertyWithKey(uniqueID, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(withUniqueID:Any,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.value(withUniqueID:Any,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.value(withUniqueID:Any,inPropertyWithKey:String)*/
valueWithUniqueIDInPropertyWithKey(uniqueID, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(withUniqueID:Any,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.valueWithUniqueID(_:Any,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.valueWithUniqueID(_:Any,inPropertyWithKey:String)*/
/*!!!DUPLICATE NAME*/
valueWithUniqueIDInPropertyWithKey(uniqueID, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueWithUniqueID(_:Any,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.valueWithUniqueID(_:Any,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.valueWithUniqueID(_:Any,inPropertyWithKey:String)*/
/*!!!DUPLICATE NAME*/
valueWithUniqueIDInPropertyWithKey(uniqueID, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueWithUniqueID(_:Any,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.insertValue(_:Any,at:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.insertValue(_:Any,at:Int,inPropertyWithKey:String)*/
insertValueAtInPropertyWithKey(value, index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.insertValue(_:Any,at:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.insertValue(_:Any,at:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.insertValue(_:Any,at:Int,inPropertyWithKey:String)*/
insertValueAtInPropertyWithKey(value, index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.insertValue(_:Any,at:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.insertValue(_:Any,atIndex:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.insertValue(_:Any,atIndex:Int,inPropertyWithKey:String)*/
insertValueAtIndexInPropertyWithKey(value, index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.insertValue(_:Any,atIndex:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.insertValue(_:Any,atIndex:Int,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.insertValue(_:Any,atIndex:Int,inPropertyWithKey:String)*/
insertValueAtIndexInPropertyWithKey(value, index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.insertValue(_:Any,atIndex:Int,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.removeValue(at:Int,fromPropertyWithKey:String)*/
/*Foundation.(file).NSObject.removeValue(at:Int,fromPropertyWithKey:String)*/
removeValueAtFromPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeValue(at:Int,fromPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.removeValue(at:Int,fromPropertyWithKey:String)*/
/*Foundation.(file).NSObject.removeValue(at:Int,fromPropertyWithKey:String)*/
removeValueAtFromPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeValue(at:Int,fromPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.removeValueAtIndex(_:Int,fromPropertyWithKey:String)*/
/*Foundation.(file).NSObject.removeValueAtIndex(_:Int,fromPropertyWithKey:String)*/
removeValueAtIndexFromPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeValueAtIndex(_:Int,fromPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.removeValueAtIndex(_:Int,fromPropertyWithKey:String)*/
/*Foundation.(file).NSObject.removeValueAtIndex(_:Int,fromPropertyWithKey:String)*/
removeValueAtIndexFromPropertyWithKey(index, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeValueAtIndex(_:Int,fromPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.replaceValue(at:Int,inPropertyWithKey:String,withValue:Any)*/
/*Foundation.(file).NSObject.replaceValue(at:Int,inPropertyWithKey:String,withValue:Any)*/
replaceValueAtInPropertyWithKeyWithValue(index, key, value, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replaceValue(at:Int,inPropertyWithKey:String,withValue:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replaceValue(at:Int,inPropertyWithKey:String,withValue:Any)*/
/*Foundation.(file).NSObject.replaceValue(at:Int,inPropertyWithKey:String,withValue:Any)*/
replaceValueAtInPropertyWithKeyWithValue(index, key, value, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replaceValue(at:Int,inPropertyWithKey:String,withValue:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.replaceValueAtIndex(_:Int,inPropertyWithKey:String,withValue:Any)*/
/*Foundation.(file).NSObject.replaceValueAtIndex(_:Int,inPropertyWithKey:String,withValue:Any)*/
replaceValueAtIndexInPropertyWithKeyWithValue(index, key, value, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replaceValueAtIndex(_:Int,inPropertyWithKey:String,withValue:Any) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replaceValueAtIndex(_:Int,inPropertyWithKey:String,withValue:Any)*/
/*Foundation.(file).NSObject.replaceValueAtIndex(_:Int,inPropertyWithKey:String,withValue:Any)*/
replaceValueAtIndexInPropertyWithKeyWithValue(index, key, value, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replaceValueAtIndex(_:Int,inPropertyWithKey:String,withValue:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.insertValue(_:Any,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.insertValue(_:Any,inPropertyWithKey:String)*/
insertValueInPropertyWithKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.insertValue(_:Any,inPropertyWithKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.insertValue(_:Any,inPropertyWithKey:String)*/
/*Foundation.(file).NSObject.insertValue(_:Any,inPropertyWithKey:String)*/
insertValueInPropertyWithKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.insertValue(_:Any,inPropertyWithKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.coerceValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.coerceValue(_:Any?,forKey:String)*/
coerceValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.coerceValue(_:Any?,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.coerceValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.coerceValue(_:Any?,forKey:String)*/
coerceValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.coerceValue(_:Any?,forKey:String) in ' + this.constructor.name
}

classCode

className
static /*Foundation.(file).NSObject.classCode()*/
/*Foundation.(file).NSObject.classCode()*/
classCode($info?) {
throw 'unsupported method Foundation.(file).NSObject.classCode() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.className()*/
/*Foundation.(file).NSObject.className()*/
className($info?) {
throw 'unsupported method Foundation.(file).NSObject.className() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingValue(for:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.scriptingValue(for:NSScriptObjectSpecifier)*/
scriptingValueFor(objectSpecifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingValue(for:NSScriptObjectSpecifier) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingValue(for:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.scriptingValue(for:NSScriptObjectSpecifier)*/
scriptingValueFor(objectSpecifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingValue(for:NSScriptObjectSpecifier) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingValueForSpecifier(_:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.scriptingValueForSpecifier(_:NSScriptObjectSpecifier)*/
scriptingValueForSpecifier(objectSpecifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingValueForSpecifier(_:NSScriptObjectSpecifier) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.scriptingValueForSpecifier(_:NSScriptObjectSpecifier)*/
/*Foundation.(file).NSObject.scriptingValueForSpecifier(_:NSScriptObjectSpecifier)*/
scriptingValueForSpecifier(objectSpecifier, $info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingValueForSpecifier(_:NSScriptObjectSpecifier) in ' + this.constructor.name
}

scriptingProperties
static /*Foundation.(file).NSObject.copyScriptingValue(_:Any,forKey:String,withProperties:[String : Any])*/
/*Foundation.(file).NSObject.copyScriptingValue(_:Any,forKey:String,withProperties:[String : Any])*/
copyScriptingValueForKeyWithProperties(value, key, properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.copyScriptingValue(_:Any,forKey:String,withProperties:[String : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.copyScriptingValue(_:Any,forKey:String,withProperties:[String : Any])*/
/*Foundation.(file).NSObject.copyScriptingValue(_:Any,forKey:String,withProperties:[String : Any])*/
copyScriptingValueForKeyWithProperties(value, key, properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.copyScriptingValue(_:Any,forKey:String,withProperties:[String : Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.newScriptingObject(of:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
/*Foundation.(file).NSObject.newScriptingObject(of:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
newScriptingObjectOfForValueForKeyWithContentsValueProperties(objectClass, key, contentsValue, properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.newScriptingObject(of:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.newScriptingObject(of:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
/*Foundation.(file).NSObject.newScriptingObject(of:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
newScriptingObjectOfForValueForKeyWithContentsValueProperties(objectClass, key, contentsValue, properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.newScriptingObject(of:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.newScriptingObjectOfClass(_:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
/*Foundation.(file).NSObject.newScriptingObjectOfClass(_:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
newScriptingObjectOfClassForValueForKeyWithContentsValueProperties(objectClass, key, contentsValue, properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.newScriptingObjectOfClass(_:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.newScriptingObjectOfClass(_:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
/*Foundation.(file).NSObject.newScriptingObjectOfClass(_:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any])*/
newScriptingObjectOfClassForValueForKeyWithContentsValueProperties(objectClass, key, contentsValue, properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.newScriptingObjectOfClass(_:AnyClass,forValueForKey:String,withContentsValue:Any?,properties:[String : Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.scriptingProperties()*/
/*Foundation.(file).NSObject.scriptingProperties()*/
scriptingProperties($info?) {
throw 'unsupported method Foundation.(file).NSObject.scriptingProperties() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setScriptingProperties(_:[String : Any]?)*/
/*Foundation.(file).NSObject.setScriptingProperties(_:[String : Any]?)*/
setScriptingProperties(scriptingProperties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setScriptingProperties(_:[String : Any]?) in ' + this.constructor.name
}

classDescription

attributeKeys

toOneRelationshipKeys

toManyRelationshipKeys
static /*Foundation.(file).NSObject.inverse(forRelationshipKey:String)*/
/*Foundation.(file).NSObject.inverse(forRelationshipKey:String)*/
inverseForRelationshipKey(relationshipKey, $info?) {
throw 'unsupported method Foundation.(file).NSObject.inverse(forRelationshipKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.inverse(forRelationshipKey:String)*/
/*Foundation.(file).NSObject.inverse(forRelationshipKey:String)*/
inverseForRelationshipKey(relationshipKey, $info?) {
throw 'unsupported method Foundation.(file).NSObject.inverse(forRelationshipKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.inverseForRelationshipKey(_:String)*/
/*Foundation.(file).NSObject.inverseForRelationshipKey(_:String)*/
/*!!!DUPLICATE NAME*/
inverseForRelationshipKey(relationshipKey, $info?) {
throw 'unsupported method Foundation.(file).NSObject.inverseForRelationshipKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.inverseForRelationshipKey(_:String)*/
/*Foundation.(file).NSObject.inverseForRelationshipKey(_:String)*/
/*!!!DUPLICATE NAME*/
inverseForRelationshipKey(relationshipKey, $info?) {
throw 'unsupported method Foundation.(file).NSObject.inverseForRelationshipKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.classDescription()*/
/*Foundation.(file).NSObject.classDescription()*/
classDescription($info?) {
throw 'unsupported method Foundation.(file).NSObject.classDescription() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.attributeKeys()*/
/*Foundation.(file).NSObject.attributeKeys()*/
attributeKeys($info?) {
throw 'unsupported method Foundation.(file).NSObject.attributeKeys() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.toOneRelationshipKeys()*/
/*Foundation.(file).NSObject.toOneRelationshipKeys()*/
toOneRelationshipKeys($info?) {
throw 'unsupported method Foundation.(file).NSObject.toOneRelationshipKeys() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.toManyRelationshipKeys()*/
/*Foundation.(file).NSObject.toManyRelationshipKeys()*/
toManyRelationshipKeys($info?) {
throw 'unsupported method Foundation.(file).NSObject.toManyRelationshipKeys() in ' + this.constructor.name
}

classForPortCoder
static /*Foundation.(file).NSObject.replacementObject(for:NSPortCoder)*/
/*Foundation.(file).NSObject.replacementObject(for:NSPortCoder)*/
replacementObjectFor(coder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSPortCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObject(for:NSPortCoder)*/
/*Foundation.(file).NSObject.replacementObject(for:NSPortCoder)*/
replacementObjectFor(coder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSPortCoder) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.replacementObjectForPortCoder(_:NSPortCoder)*/
/*Foundation.(file).NSObject.replacementObjectForPortCoder(_:NSPortCoder)*/
replacementObjectForPortCoder(coder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForPortCoder(_:NSPortCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObjectForPortCoder(_:NSPortCoder)*/
/*Foundation.(file).NSObject.replacementObjectForPortCoder(_:NSPortCoder)*/
replacementObjectForPortCoder(coder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForPortCoder(_:NSPortCoder) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.classForPortCoder()*/
/*Foundation.(file).NSObject.classForPortCoder()*/
classForPortCoder($info?) {
throw 'unsupported method Foundation.(file).NSObject.classForPortCoder() in ' + this.constructor.name
}

classForArchiver
static /*Foundation.(file).NSObject.replacementObject(for:NSArchiver)*/
/*Foundation.(file).NSObject.replacementObject(for:NSArchiver)*/
/*!!!DUPLICATE NAME*/
replacementObjectFor(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSArchiver) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObject(for:NSArchiver)*/
/*Foundation.(file).NSObject.replacementObject(for:NSArchiver)*/
/*!!!DUPLICATE NAME*/
replacementObjectFor(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSArchiver) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.replacementObjectForArchiver(_:NSArchiver)*/
/*Foundation.(file).NSObject.replacementObjectForArchiver(_:NSArchiver)*/
replacementObjectForArchiver(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForArchiver(_:NSArchiver) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObjectForArchiver(_:NSArchiver)*/
/*Foundation.(file).NSObject.replacementObjectForArchiver(_:NSArchiver)*/
replacementObjectForArchiver(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForArchiver(_:NSArchiver) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.classForArchiver()*/
/*Foundation.(file).NSObject.classForArchiver()*/
classForArchiver($info?) {
throw 'unsupported method Foundation.(file).NSObject.classForArchiver() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
performSelectorOnMainThreadWithWaitUntilDoneModes(aSelector, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
performSelectorOnMainThreadWithWaitUntilDoneModes(aSelector, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
performSelectorOnMainThreadWithObjectWaitUntilDoneModes(aSelector, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
performSelectorOnMainThreadWithObjectWaitUntilDoneModes(aSelector, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool)*/
performSelectorOnMainThreadWithWaitUntilDone(aSelector, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool)*/
performSelectorOnMainThreadWithWaitUntilDone(aSelector, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(onMainThread:Selector,with:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool)*/
performSelectorOnMainThreadWithObjectWaitUntilDone(aSelector, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool)*/
performSelectorOnMainThreadWithObjectWaitUntilDone(aSelector, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelectorOnMainThread(_:Selector,withObject:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
performOnWithWaitUntilDoneModes(aSelector, thr, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool,modes:[String]?)*/
performOnWithWaitUntilDoneModes(aSelector, thr, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
performSelectorOnThreadWithObjectWaitUntilDoneModes(aSelector, thr, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
/*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool,modes:[String]?)*/
performSelectorOnThreadWithObjectWaitUntilDoneModes(aSelector, thr, arg, wait, array, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool,modes:[String]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool)*/
performOnWithWaitUntilDone(aSelector, thr, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool)*/
performOnWithWaitUntilDone(aSelector, thr, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,on:Thread,with:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool)*/
performSelectorOnThreadWithObjectWaitUntilDone(aSelector, thr, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool)*/
/*Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool)*/
performSelectorOnThreadWithObjectWaitUntilDone(aSelector, thr, arg, wait, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,onThread:Thread,withObject:Any?,waitUntilDone:Bool) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelector(inBackground:Selector,with:Any?)*/
/*Foundation.(file).NSObject.performSelector(inBackground:Selector,with:Any?)*/
performSelectorInBackgroundWith(aSelector, arg, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(inBackground:Selector,with:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelector(inBackground:Selector,with:Any?)*/
/*Foundation.(file).NSObject.performSelector(inBackground:Selector,with:Any?)*/
performSelectorInBackgroundWith(aSelector, arg, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(inBackground:Selector,with:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelectorInBackground(_:Selector,withObject:Any?)*/
/*Foundation.(file).NSObject.performSelectorInBackground(_:Selector,withObject:Any?)*/
performSelectorInBackgroundWithObject(aSelector, arg, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelectorInBackground(_:Selector,withObject:Any?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelectorInBackground(_:Selector,withObject:Any?)*/
/*Foundation.(file).NSObject.performSelectorInBackground(_:Selector,withObject:Any?)*/
performSelectorInBackgroundWithObject(aSelector, arg, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelectorInBackground(_:Selector,withObject:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.classForKeyedUnarchiver()*/
/*Foundation.(file).NSObject.classForKeyedUnarchiver()*/
classForKeyedUnarchiver($info?) {
throw 'unsupported method Foundation.(file).NSObject.classForKeyedUnarchiver() in ' + this.constructor.name
}

classForKeyedArchiver
static /*Foundation.(file).NSObject.replacementObject(for:NSKeyedArchiver)*/
/*Foundation.(file).NSObject.replacementObject(for:NSKeyedArchiver)*/
/*!!!DUPLICATE NAME*/
replacementObjectFor(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSKeyedArchiver) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObject(for:NSKeyedArchiver)*/
/*Foundation.(file).NSObject.replacementObject(for:NSKeyedArchiver)*/
/*!!!DUPLICATE NAME*/
replacementObjectFor(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSKeyedArchiver) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.replacementObjectForKeyedArchiver(_:NSKeyedArchiver)*/
/*Foundation.(file).NSObject.replacementObjectForKeyedArchiver(_:NSKeyedArchiver)*/
replacementObjectForKeyedArchiver(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForKeyedArchiver(_:NSKeyedArchiver) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObjectForKeyedArchiver(_:NSKeyedArchiver)*/
/*Foundation.(file).NSObject.replacementObjectForKeyedArchiver(_:NSKeyedArchiver)*/
replacementObjectForKeyedArchiver(archiver, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForKeyedArchiver(_:NSKeyedArchiver) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.classFallbacksForKeyedArchiver()*/
/*Foundation.(file).NSObject.classFallbacksForKeyedArchiver()*/
classFallbacksForKeyedArchiver($info?) {
throw 'unsupported method Foundation.(file).NSObject.classFallbacksForKeyedArchiver() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.classForKeyedArchiver()*/
/*Foundation.(file).NSObject.classForKeyedArchiver()*/
classForKeyedArchiver($info?) {
throw 'unsupported method Foundation.(file).NSObject.classForKeyedArchiver() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setKeys(_:[Any],triggerChangeNotificationsForDependentKey:String)*/
/*Foundation.(file).NSObject.setKeys(_:[Any],triggerChangeNotificationsForDependentKey:String)*/
setKeysTriggerChangeNotificationsForDependentKey(keys, dependentKey, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setKeys(_:[Any],triggerChangeNotificationsForDependentKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.keyPathsForValuesAffectingValue(forKey:String)*/
/*Foundation.(file).NSObject.keyPathsForValuesAffectingValue(forKey:String)*/
keyPathsForValuesAffectingValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.keyPathsForValuesAffectingValue(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.keyPathsForValuesAffectingValueForKey(_:String)*/
/*Foundation.(file).NSObject.keyPathsForValuesAffectingValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
keyPathsForValuesAffectingValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.keyPathsForValuesAffectingValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.automaticallyNotifiesObservers(forKey:String)*/
/*Foundation.(file).NSObject.automaticallyNotifiesObservers(forKey:String)*/
automaticallyNotifiesObserversForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.automaticallyNotifiesObservers(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.automaticallyNotifiesObserversForKey(_:String)*/
/*Foundation.(file).NSObject.automaticallyNotifiesObserversForKey(_:String)*/
/*!!!DUPLICATE NAME*/
automaticallyNotifiesObserversForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.automaticallyNotifiesObserversForKey(_:String) in ' + this.constructor.name
}

observationInfo
static /*Foundation.(file).NSObject.observationInfo()*/
/*Foundation.(file).NSObject.observationInfo()*/
observationInfo($info?) {
throw 'unsupported method Foundation.(file).NSObject.observationInfo() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setObservationInfo(_:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.setObservationInfo(_:UnsafeMutableRawPointer?)*/
setObservationInfo(observationInfo, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setObservationInfo(_:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.willChangeValue(forKey:String)*/
/*Foundation.(file).NSObject.willChangeValue(forKey:String)*/
willChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValue(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.willChangeValue(forKey:String)*/
/*Foundation.(file).NSObject.willChangeValue(forKey:String)*/
willChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValue(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.willChangeValueForKey(_:String)*/
/*Foundation.(file).NSObject.willChangeValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
willChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.willChangeValueForKey(_:String)*/
/*Foundation.(file).NSObject.willChangeValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
willChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.didChangeValue(forKey:String)*/
/*Foundation.(file).NSObject.didChangeValue(forKey:String)*/
didChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValue(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.didChangeValue(forKey:String)*/
/*Foundation.(file).NSObject.didChangeValue(forKey:String)*/
didChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValue(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.didChangeValueForKey(_:String)*/
/*Foundation.(file).NSObject.didChangeValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
didChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.didChangeValueForKey(_:String)*/
/*Foundation.(file).NSObject.didChangeValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
didChangeValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
willChangeValuesAtForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
willChangeValuesAtForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
willChangeValuesAtIndexesForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
willChangeValuesAtIndexesForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
didChangeValuesAtForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String)*/
didChangeValuesAtForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAt:IndexSet,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
didChangeValuesAtIndexesForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
/*Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String)*/
didChangeValuesAtIndexesForKey(changeKind, indexes, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChange(_:NSKeyValueChange,valuesAtIndexes:IndexSet,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.willChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.willChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
willChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.willChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.willChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
willChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.willChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.willChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
willChangeValueForKeyWithSetMutationUsingObjects(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.willChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.willChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
willChangeValueForKeyWithSetMutationUsingObjects(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.willChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.didChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.didChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
didChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.didChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.didChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>)*/
didChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValue(forKey:String,withSetMutation:NSKeyValueSetMutationKind,using:Set<AnyHashable>) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.didChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.didChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
didChangeValueForKeyWithSetMutationUsingObjects(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.didChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
/*Foundation.(file).NSObject.didChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>)*/
didChangeValueForKeyWithSetMutationUsingObjects(key, mutationKind, objects, $info?) {
throw 'unsupported method Foundation.(file).NSObject.didChangeValueForKey(_:String,withSetMutation:NSKeyValueSetMutationKind,usingObjects:Set<AnyHashable>) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.addObserver(_:NSObject,forKeyPath:String,options:NSKeyValueObservingOptions,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.addObserver(_:NSObject,forKeyPath:String,options:NSKeyValueObservingOptions,context:UnsafeMutableRawPointer?)*/
addObserverForKeyPathOptionsContext(observer, keyPath, options, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.addObserver(_:NSObject,forKeyPath:String,options:NSKeyValueObservingOptions,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.addObserver(_:NSObject,forKeyPath:String,options:NSKeyValueObservingOptions,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.addObserver(_:NSObject,forKeyPath:String,options:NSKeyValueObservingOptions,context:UnsafeMutableRawPointer?)*/
addObserverForKeyPathOptionsContext(observer, keyPath, options, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.addObserver(_:NSObject,forKeyPath:String,options:NSKeyValueObservingOptions,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String,context:UnsafeMutableRawPointer?)*/
removeObserverForKeyPathContext(observer, keyPath, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String,context:UnsafeMutableRawPointer?)*/
removeObserverForKeyPathContext(observer, keyPath, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String)*/
/*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String)*/
removeObserverForKeyPath(observer, keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String)*/
/*Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String)*/
removeObserverForKeyPath(observer, keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.removeObserver(_:NSObject,forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.observeValue(forKeyPath:String?,of:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.observeValue(forKeyPath:String?,of:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
observeValueForKeyPathOfChangeContext(keyPath, object, change, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.observeValue(forKeyPath:String?,of:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.observeValue(forKeyPath:String?,of:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.observeValue(forKeyPath:String?,of:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
observeValueForKeyPathOfChangeContext(keyPath, object, change, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.observeValue(forKeyPath:String?,of:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.observeValueForKeyPath(_:String?,ofObject:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.observeValueForKeyPath(_:String?,ofObject:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
observeValueForKeyPathOfObjectChangeContext(keyPath, object, change, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.observeValueForKeyPath(_:String?,ofObject:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.observeValueForKeyPath(_:String?,ofObject:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.observeValueForKeyPath(_:String?,ofObject:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?)*/
observeValueForKeyPathOfObjectChangeContext(keyPath, object, change, context, $info?) {
throw 'unsupported method Foundation.(file).NSObject.observeValueForKeyPath(_:String?,ofObject:Any?,change:[NSKeyValueChangeKey : Any]?,context:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.useStoredAccessor()*/
/*Foundation.(file).NSObject.useStoredAccessor()*/
useStoredAccessor($info?) {
throw 'unsupported method Foundation.(file).NSObject.useStoredAccessor() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.storedValue(forKey:String)*/
/*Foundation.(file).NSObject.storedValue(forKey:String)*/
storedValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.storedValue(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.storedValue(forKey:String)*/
/*Foundation.(file).NSObject.storedValue(forKey:String)*/
storedValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.storedValue(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.storedValueForKey(_:String)*/
/*Foundation.(file).NSObject.storedValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
storedValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.storedValueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.storedValueForKey(_:String)*/
/*Foundation.(file).NSObject.storedValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
storedValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.storedValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.takeStoredValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.takeStoredValue(_:Any?,forKey:String)*/
takeStoredValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeStoredValue(_:Any?,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.takeStoredValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.takeStoredValue(_:Any?,forKey:String)*/
takeStoredValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeStoredValue(_:Any?,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.takeValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.takeValue(_:Any?,forKey:String)*/
takeValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValue(_:Any?,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.takeValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.takeValue(_:Any?,forKey:String)*/
takeValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValue(_:Any?,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.takeValue(_:Any?,forKeyPath:String)*/
/*Foundation.(file).NSObject.takeValue(_:Any?,forKeyPath:String)*/
takeValueForKeyPath(value, keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValue(_:Any?,forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.takeValue(_:Any?,forKeyPath:String)*/
/*Foundation.(file).NSObject.takeValue(_:Any?,forKeyPath:String)*/
takeValueForKeyPath(value, keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValue(_:Any?,forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.handleQuery(withUnboundKey:String)*/
/*Foundation.(file).NSObject.handleQuery(withUnboundKey:String)*/
handleQueryWithUnboundKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.handleQuery(withUnboundKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.handleQuery(withUnboundKey:String)*/
/*Foundation.(file).NSObject.handleQuery(withUnboundKey:String)*/
handleQueryWithUnboundKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.handleQuery(withUnboundKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.handleQueryWithUnboundKey(_:String)*/
/*Foundation.(file).NSObject.handleQueryWithUnboundKey(_:String)*/
/*!!!DUPLICATE NAME*/
handleQueryWithUnboundKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.handleQueryWithUnboundKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.handleQueryWithUnboundKey(_:String)*/
/*Foundation.(file).NSObject.handleQueryWithUnboundKey(_:String)*/
/*!!!DUPLICATE NAME*/
handleQueryWithUnboundKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.handleQueryWithUnboundKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.handleTakeValue(_:Any?,forUnboundKey:String)*/
/*Foundation.(file).NSObject.handleTakeValue(_:Any?,forUnboundKey:String)*/
handleTakeValueForUnboundKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.handleTakeValue(_:Any?,forUnboundKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.handleTakeValue(_:Any?,forUnboundKey:String)*/
/*Foundation.(file).NSObject.handleTakeValue(_:Any?,forUnboundKey:String)*/
handleTakeValueForUnboundKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.handleTakeValue(_:Any?,forUnboundKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.unableToSetNil(forKey:String)*/
/*Foundation.(file).NSObject.unableToSetNil(forKey:String)*/
unableToSetNilForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.unableToSetNil(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.unableToSetNil(forKey:String)*/
/*Foundation.(file).NSObject.unableToSetNil(forKey:String)*/
unableToSetNilForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.unableToSetNil(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.unableToSetNilForKey(_:String)*/
/*Foundation.(file).NSObject.unableToSetNilForKey(_:String)*/
/*!!!DUPLICATE NAME*/
unableToSetNilForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.unableToSetNilForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.unableToSetNilForKey(_:String)*/
/*Foundation.(file).NSObject.unableToSetNilForKey(_:String)*/
/*!!!DUPLICATE NAME*/
unableToSetNilForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.unableToSetNilForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.values(forKeys:[Any])*/
/*Foundation.(file).NSObject.values(forKeys:[Any])*/
valuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.values(forKeys:[Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.values(forKeys:[Any])*/
/*Foundation.(file).NSObject.values(forKeys:[Any])*/
valuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.values(forKeys:[Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.valuesForKeys(_:[Any])*/
/*Foundation.(file).NSObject.valuesForKeys(_:[Any])*/
/*!!!DUPLICATE NAME*/
valuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valuesForKeys(_:[Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.valuesForKeys(_:[Any])*/
/*Foundation.(file).NSObject.valuesForKeys(_:[Any])*/
/*!!!DUPLICATE NAME*/
valuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valuesForKeys(_:[Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.takeValues(from:[AnyHashable : Any])*/
/*Foundation.(file).NSObject.takeValues(from:[AnyHashable : Any])*/
takeValuesFrom(properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValues(from:[AnyHashable : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.takeValues(from:[AnyHashable : Any])*/
/*Foundation.(file).NSObject.takeValues(from:[AnyHashable : Any])*/
takeValuesFrom(properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValues(from:[AnyHashable : Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.takeValuesFromDictionary(_:[AnyHashable : Any])*/
/*Foundation.(file).NSObject.takeValuesFromDictionary(_:[AnyHashable : Any])*/
takeValuesFromDictionary(properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValuesFromDictionary(_:[AnyHashable : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.takeValuesFromDictionary(_:[AnyHashable : Any])*/
/*Foundation.(file).NSObject.takeValuesFromDictionary(_:[AnyHashable : Any])*/
takeValuesFromDictionary(properties, $info?) {
throw 'unsupported method Foundation.(file).NSObject.takeValuesFromDictionary(_:[AnyHashable : Any]) in ' + this.constructor.name
}

static accessInstanceVariablesDirectly
static /*Foundation.(file).NSObject.value(forKey:String)*/
/*Foundation.(file).NSObject.value(forKey:String)*/
valueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.value(forKey:String)*/
/*Foundation.(file).NSObject.value(forKey:String)*/
valueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.valueForKey(_:String)*/
/*Foundation.(file).NSObject.valueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
valueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.valueForKey(_:String)*/
/*Foundation.(file).NSObject.valueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
valueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.setValue(_:Any?,forKey:String)*/
setValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValue(_:Any?,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.setValue(_:Any?,forKey:String)*/
/*Foundation.(file).NSObject.setValue(_:Any?,forKey:String)*/
setValueForKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValue(_:Any?,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKey:String)*/
/*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKey:String)*/
validateValueForKey(ioValue, inKey, $info?) {
throw 'unsupported method Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKey:String)*/
/*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKey:String)*/
validateValueForKey(ioValue, inKey, $info?) {
throw 'unsupported method Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableArrayValue(forKey:String)*/
/*Foundation.(file).NSObject.mutableArrayValue(forKey:String)*/
mutableArrayValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValue(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableArrayValue(forKey:String)*/
/*Foundation.(file).NSObject.mutableArrayValue(forKey:String)*/
mutableArrayValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValue(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableArrayValueForKey(_:String)*/
/*Foundation.(file).NSObject.mutableArrayValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
mutableArrayValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableArrayValueForKey(_:String)*/
/*Foundation.(file).NSObject.mutableArrayValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
mutableArrayValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableOrderedSetValue(forKey:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValue(forKey:String)*/
mutableOrderedSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValue(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableOrderedSetValue(forKey:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValue(forKey:String)*/
mutableOrderedSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValue(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableOrderedSetValueForKey(_:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
mutableOrderedSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableOrderedSetValueForKey(_:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
mutableOrderedSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableSetValue(forKey:String)*/
/*Foundation.(file).NSObject.mutableSetValue(forKey:String)*/
mutableSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValue(forKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableSetValue(forKey:String)*/
/*Foundation.(file).NSObject.mutableSetValue(forKey:String)*/
mutableSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValue(forKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableSetValueForKey(_:String)*/
/*Foundation.(file).NSObject.mutableSetValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
mutableSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableSetValueForKey(_:String)*/
/*Foundation.(file).NSObject.mutableSetValueForKey(_:String)*/
/*!!!DUPLICATE NAME*/
mutableSetValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.value(forKeyPath:String)*/
/*Foundation.(file).NSObject.value(forKeyPath:String)*/
valueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.value(forKeyPath:String)*/
/*Foundation.(file).NSObject.value(forKeyPath:String)*/
valueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.valueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.valueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
valueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueForKeyPath(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.valueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.valueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
valueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueForKeyPath(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setValue(_:Any?,forKeyPath:String)*/
/*Foundation.(file).NSObject.setValue(_:Any?,forKeyPath:String)*/
setValueForKeyPath(value, keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValue(_:Any?,forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.setValue(_:Any?,forKeyPath:String)*/
/*Foundation.(file).NSObject.setValue(_:Any?,forKeyPath:String)*/
setValueForKeyPath(value, keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValue(_:Any?,forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKeyPath:String)*/
/*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKeyPath:String)*/
validateValueForKeyPath(ioValue, inKeyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKeyPath:String)*/
/*Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKeyPath:String)*/
validateValueForKeyPath(ioValue, inKeyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.validateValue(_:AutoreleasingUnsafeMutablePointer<AnyObject?>,forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableArrayValue(forKeyPath:String)*/
/*Foundation.(file).NSObject.mutableArrayValue(forKeyPath:String)*/
mutableArrayValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValue(forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableArrayValue(forKeyPath:String)*/
/*Foundation.(file).NSObject.mutableArrayValue(forKeyPath:String)*/
mutableArrayValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValue(forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableArrayValueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.mutableArrayValueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
mutableArrayValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValueForKeyPath(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableArrayValueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.mutableArrayValueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
mutableArrayValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableArrayValueForKeyPath(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableOrderedSetValue(forKeyPath:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValue(forKeyPath:String)*/
mutableOrderedSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValue(forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableOrderedSetValue(forKeyPath:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValue(forKeyPath:String)*/
mutableOrderedSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValue(forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableOrderedSetValueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
mutableOrderedSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValueForKeyPath(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableOrderedSetValueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.mutableOrderedSetValueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
mutableOrderedSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableOrderedSetValueForKeyPath(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableSetValue(forKeyPath:String)*/
/*Foundation.(file).NSObject.mutableSetValue(forKeyPath:String)*/
mutableSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValue(forKeyPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableSetValue(forKeyPath:String)*/
/*Foundation.(file).NSObject.mutableSetValue(forKeyPath:String)*/
mutableSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValue(forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.mutableSetValueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.mutableSetValueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
mutableSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValueForKeyPath(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.mutableSetValueForKeyPath(_:String)*/
/*Foundation.(file).NSObject.mutableSetValueForKeyPath(_:String)*/
/*!!!DUPLICATE NAME*/
mutableSetValueForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSObject.mutableSetValueForKeyPath(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.value(forUndefinedKey:String)*/
/*Foundation.(file).NSObject.value(forUndefinedKey:String)*/
valueForUndefinedKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(forUndefinedKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.value(forUndefinedKey:String)*/
/*Foundation.(file).NSObject.value(forUndefinedKey:String)*/
valueForUndefinedKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.value(forUndefinedKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.valueForUndefinedKey(_:String)*/
/*Foundation.(file).NSObject.valueForUndefinedKey(_:String)*/
/*!!!DUPLICATE NAME*/
valueForUndefinedKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueForUndefinedKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.valueForUndefinedKey(_:String)*/
/*Foundation.(file).NSObject.valueForUndefinedKey(_:String)*/
/*!!!DUPLICATE NAME*/
valueForUndefinedKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.valueForUndefinedKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setValue(_:Any?,forUndefinedKey:String)*/
/*Foundation.(file).NSObject.setValue(_:Any?,forUndefinedKey:String)*/
setValueForUndefinedKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValue(_:Any?,forUndefinedKey:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.setValue(_:Any?,forUndefinedKey:String)*/
/*Foundation.(file).NSObject.setValue(_:Any?,forUndefinedKey:String)*/
setValueForUndefinedKey(value, key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValue(_:Any?,forUndefinedKey:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setNilValueForKey(_:String)*/
/*Foundation.(file).NSObject.setNilValueForKey(_:String)*/
setNilValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setNilValueForKey(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.setNilValueForKey(_:String)*/
/*Foundation.(file).NSObject.setNilValueForKey(_:String)*/
setNilValueForKey(key, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setNilValueForKey(_:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.dictionaryWithValues(forKeys:[String])*/
/*Foundation.(file).NSObject.dictionaryWithValues(forKeys:[String])*/
dictionaryWithValuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.dictionaryWithValues(forKeys:[String]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.dictionaryWithValues(forKeys:[String])*/
/*Foundation.(file).NSObject.dictionaryWithValues(forKeys:[String])*/
dictionaryWithValuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.dictionaryWithValues(forKeys:[String]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.dictionaryWithValuesForKeys(_:[String])*/
/*Foundation.(file).NSObject.dictionaryWithValuesForKeys(_:[String])*/
/*!!!DUPLICATE NAME*/
dictionaryWithValuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.dictionaryWithValuesForKeys(_:[String]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.dictionaryWithValuesForKeys(_:[String])*/
/*Foundation.(file).NSObject.dictionaryWithValuesForKeys(_:[String])*/
/*!!!DUPLICATE NAME*/
dictionaryWithValuesForKeys(keys, $info?) {
throw 'unsupported method Foundation.(file).NSObject.dictionaryWithValuesForKeys(_:[String]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setValuesForKeys(_:[String : Any])*/
/*Foundation.(file).NSObject.setValuesForKeys(_:[String : Any])*/
setValuesForKeys(keyedValues, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValuesForKeys(_:[String : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.setValuesForKeys(_:[String : Any])*/
/*Foundation.(file).NSObject.setValuesForKeys(_:[String : Any])*/
setValuesForKeys(keyedValues, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValuesForKeys(_:[String : Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setValuesForKeysWithDictionary(_:[String : Any])*/
/*Foundation.(file).NSObject.setValuesForKeysWithDictionary(_:[String : Any])*/
setValuesForKeysWithDictionary(keyedValues, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValuesForKeysWithDictionary(_:[String : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.setValuesForKeysWithDictionary(_:[String : Any])*/
/*Foundation.(file).NSObject.setValuesForKeysWithDictionary(_:[String : Any])*/
setValuesForKeysWithDictionary(keyedValues, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setValuesForKeysWithDictionary(_:[String : Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.fileManager(_:FileManager,shouldProceedAfterError:[AnyHashable : Any])*/
/*Foundation.(file).NSObject.fileManager(_:FileManager,shouldProceedAfterError:[AnyHashable : Any])*/
fileManagerShouldProceedAfterError(fm, errorInfo, $info?) {
throw 'unsupported method Foundation.(file).NSObject.fileManager(_:FileManager,shouldProceedAfterError:[AnyHashable : Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.fileManager(_:FileManager,shouldProceedAfterError:[AnyHashable : Any])*/
/*Foundation.(file).NSObject.fileManager(_:FileManager,shouldProceedAfterError:[AnyHashable : Any])*/
fileManagerShouldProceedAfterError(fm, errorInfo, $info?) {
throw 'unsupported method Foundation.(file).NSObject.fileManager(_:FileManager,shouldProceedAfterError:[AnyHashable : Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.fileManager(_:FileManager,willProcessPath:String)*/
/*Foundation.(file).NSObject.fileManager(_:FileManager,willProcessPath:String)*/
fileManagerWillProcessPath(fm, path, $info?) {
throw 'unsupported method Foundation.(file).NSObject.fileManager(_:FileManager,willProcessPath:String) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.fileManager(_:FileManager,willProcessPath:String)*/
/*Foundation.(file).NSObject.fileManager(_:FileManager,willProcessPath:String)*/
fileManagerWillProcessPath(fm, path, $info?) {
throw 'unsupported method Foundation.(file).NSObject.fileManager(_:FileManager,willProcessPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
/*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
performWithAfterDelayInModes(aSelector, anArgument, delay, modes, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
/*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
performWithAfterDelayInModes(aSelector, anArgument, delay, modes, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
/*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
performSelectorWithObjectAfterDelayInModes(aSelector, anArgument, delay, modes, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode]) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
/*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode])*/
performSelectorWithObjectAfterDelayInModes(aSelector, anArgument, delay, modes, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval,inModes:[RunLoop.Mode]) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval)*/
/*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval)*/
performWithAfterDelay(aSelector, anArgument, delay, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval)*/
/*Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval)*/
performWithAfterDelay(aSelector, anArgument, delay, $info?) {
throw 'unsupported method Foundation.(file).NSObject.perform(_:Selector,with:Any?,afterDelay:TimeInterval) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval)*/
/*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval)*/
performSelectorWithObjectAfterDelay(aSelector, anArgument, delay, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval)*/
/*Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval)*/
performSelectorWithObjectAfterDelay(aSelector, anArgument, delay, $info?) {
throw 'unsupported method Foundation.(file).NSObject.performSelector(_:Selector,withObject:Any?,afterDelay:TimeInterval) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.cancelPreviousPerformRequests(withTarget:Any,selector:Selector,object:Any?)*/
/*Foundation.(file).NSObject.cancelPreviousPerformRequests(withTarget:Any,selector:Selector,object:Any?)*/
cancelPreviousPerformRequestsWithTargetSelectorObject(aTarget, aSelector, anArgument, $info?) {
throw 'unsupported method Foundation.(file).NSObject.cancelPreviousPerformRequests(withTarget:Any,selector:Selector,object:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.cancelPreviousPerformRequestsWithTarget(_:Any,selector:Selector,object:Any?)*/
/*Foundation.(file).NSObject.cancelPreviousPerformRequestsWithTarget(_:Any,selector:Selector,object:Any?)*/
/*!!!DUPLICATE NAME*/
cancelPreviousPerformRequestsWithTargetSelectorObject(aTarget, aSelector, anArgument, $info?) {
throw 'unsupported method Foundation.(file).NSObject.cancelPreviousPerformRequestsWithTarget(_:Any,selector:Selector,object:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.cancelPreviousPerformRequests(withTarget:Any)*/
/*Foundation.(file).NSObject.cancelPreviousPerformRequests(withTarget:Any)*/
cancelPreviousPerformRequestsWithTarget(aTarget, $info?) {
throw 'unsupported method Foundation.(file).NSObject.cancelPreviousPerformRequests(withTarget:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.cancelPreviousPerformRequestsWithTarget(_:Any)*/
/*Foundation.(file).NSObject.cancelPreviousPerformRequestsWithTarget(_:Any)*/
/*!!!DUPLICATE NAME*/
cancelPreviousPerformRequestsWithTarget(aTarget, $info?) {
throw 'unsupported method Foundation.(file).NSObject.cancelPreviousPerformRequestsWithTarget(_:Any) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo(error, recoveryOptionIndex, delegate, didRecoverSelector, contextInfo, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo(error, recoveryOptionIndex, delegate, didRecoverSelector, contextInfo, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
/*!!!DUPLICATE NAME*/
attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo(error, recoveryOptionIndex, delegate, didRecoverSelector, contextInfo, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
/*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?)*/
/*!!!DUPLICATE NAME*/
attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo(error, recoveryOptionIndex, delegate, didRecoverSelector, contextInfo, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int,delegate:Any?,didRecoverSelector:Selector?,contextInfo:UnsafeMutableRawPointer?) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int)*/
/*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int)*/
attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int)*/
/*Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int)*/
attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecovery(fromError:Error,optionIndex:Int) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int)*/
/*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int)*/
/*!!!DUPLICATE NAME*/
attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int)*/
/*Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int)*/
/*!!!DUPLICATE NAME*/
attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex, $info?) {
throw 'unsupported method Foundation.(file).NSObject.attemptRecoveryFromError(_:Error,optionIndex:Int) in ' + this.constructor.name
}

autoContentAccessingProxy
static /*Foundation.(file).NSObject.autoContentAccessingProxy()*/
/*Foundation.(file).NSObject.autoContentAccessingProxy()*/
autoContentAccessingProxy($info?) {
throw 'unsupported method Foundation.(file).NSObject.autoContentAccessingProxy() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.pose(as:AnyClass)*/
/*Foundation.(file).NSObject.pose(as:AnyClass)*/
poseAs(aClass, $info?) {
throw 'unsupported method Foundation.(file).NSObject.pose(as:AnyClass) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.poseAsClass(_:AnyClass)*/
/*Foundation.(file).NSObject.poseAsClass(_:AnyClass)*/
poseAsClass(aClass, $info?) {
throw 'unsupported method Foundation.(file).NSObject.poseAsClass(_:AnyClass) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.version()*/
/*Foundation.(file).NSObject.version()*/
version($info?) {
throw 'unsupported method Foundation.(file).NSObject.version() in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.setVersion(_:Int)*/
/*Foundation.(file).NSObject.setVersion(_:Int)*/
setVersion(aVersion, $info?) {
throw 'unsupported method Foundation.(file).NSObject.setVersion(_:Int) in ' + this.constructor.name
}

classForCoder
static /*Foundation.(file).NSObject.replacementObject(for:NSCoder)*/
/*Foundation.(file).NSObject.replacementObject(for:NSCoder)*/
/*!!!DUPLICATE NAME*/
replacementObjectFor(aCoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObject(for:NSCoder)*/
/*Foundation.(file).NSObject.replacementObject(for:NSCoder)*/
/*!!!DUPLICATE NAME*/
replacementObjectFor(aCoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObject(for:NSCoder) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.replacementObjectForCoder(_:NSCoder)*/
/*Foundation.(file).NSObject.replacementObjectForCoder(_:NSCoder)*/
replacementObjectForCoder(aCoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForCoder(_:NSCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.replacementObjectForCoder(_:NSCoder)*/
/*Foundation.(file).NSObject.replacementObjectForCoder(_:NSCoder)*/
replacementObjectForCoder(aCoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.replacementObjectForCoder(_:NSCoder) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.awakeAfter(using:NSCoder)*/
/*Foundation.(file).NSObject.awakeAfter(using:NSCoder)*/
awakeAfterUsing(aDecoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.awakeAfter(using:NSCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.awakeAfter(using:NSCoder)*/
/*Foundation.(file).NSObject.awakeAfter(using:NSCoder)*/
awakeAfterUsing(aDecoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.awakeAfter(using:NSCoder) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.awakeAfterUsingCoder(_:NSCoder)*/
/*Foundation.(file).NSObject.awakeAfterUsingCoder(_:NSCoder)*/
awakeAfterUsingCoder(aDecoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.awakeAfterUsingCoder(_:NSCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSObject.awakeAfterUsingCoder(_:NSCoder)*/
/*Foundation.(file).NSObject.awakeAfterUsingCoder(_:NSCoder)*/
awakeAfterUsingCoder(aDecoder, $info?) {
throw 'unsupported method Foundation.(file).NSObject.awakeAfterUsingCoder(_:NSCoder) in ' + this.constructor.name
}
static /*Foundation.(file).NSObject.classForCoder()*/
/*Foundation.(file).NSObject.classForCoder()*/
classForCoder($info?) {
throw 'unsupported method Foundation.(file).NSObject.classForCoder() in ' + this.constructor.name
}
static /*CoreImage.(file).NSObject.provideImageData(_:UnsafeMutableRawPointer,bytesPerRow:Int,origin:Int,_:Int,size:Int,_:Int,userInfo:Any?)*/
/*CoreImage.(file).NSObject.provideImageData(_:UnsafeMutableRawPointer,bytesPerRow:Int,origin:Int,_:Int,size:Int,_:Int,userInfo:Any?)*/
provideImageData(data, rowbytes, x, y, width, height, info, $info?) {
throw 'unsupported method CoreImage.(file).NSObject.provideImageData(_:UnsafeMutableRawPointer,bytesPerRow:Int,origin:Int,_:Int,size:Int,_:Int,userInfo:Any?) in ' + this.constructor.name
}
/*CoreImage.(file).NSObject.provideImageData(_:UnsafeMutableRawPointer,bytesPerRow:Int,origin:Int,_:Int,size:Int,_:Int,userInfo:Any?)*/
/*CoreImage.(file).NSObject.provideImageData(_:UnsafeMutableRawPointer,bytesPerRow:Int,origin:Int,_:Int,size:Int,_:Int,userInfo:Any?)*/
provideImageData(data, rowbytes, x, y, width, height, info, $info?) {
throw 'unsupported method CoreImage.(file).NSObject.provideImageData(_:UnsafeMutableRawPointer,bytesPerRow:Int,origin:Int,_:Int,size:Int,_:Int,userInfo:Any?) in ' + this.constructor.name
}
init$vars() {let _this = this;

}
}
if(typeof NSObjectProtocol$implementation != 'undefined') _mixin(NSObject, NSObjectProtocol$implementation, false)
if(typeof Equatable$implementation != 'undefined') _mixin(NSObject, Equatable$implementation, false)
if(typeof Hashable$implementation != 'undefined') _mixin(NSObject, Hashable$implementation, false)
if(typeof CVarArg$implementation != 'undefined') _mixin(NSObject, CVarArg$implementation, false)
if(typeof CustomStringConvertible$implementation != 'undefined') _mixin(NSObject, CustomStringConvertible$implementation, false)
if(typeof CustomDebugStringConvertible$implementation != 'undefined') _mixin(NSObject, CustomDebugStringConvertible$implementation, false)
if(typeof _KeyValueCodingAndObserving$implementation != 'undefined') _mixin(NSObject, _KeyValueCodingAndObserving$implementation, false)






function /*Darwin.(file).arc4random()*/
/*Darwin.(file).arc4random()*/
arc4random($info?) {
return arc4random_uniform(Math.pow(2, 32), {})
}


function /*Darwin.(file).arc4random_uniform(_:UInt32)*/
/*Darwin.(file).arc4random_uniform(_:UInt32)*/
arc4random_uniform(__upper_bound, $info?) {
return Math.floor(Math.random() * __upper_bound)
}


function /*Darwin.(file).ceil(_:T)*/
/*Darwin.(file).ceil(_:T)*/
/*!!!DUPLICATE NAME*/
ceil<T>(x, $info?) {
return Math.ceil(x)
}


function /*Darwin.(file).floor(_:T)*/
/*Darwin.(file).floor(_:T)*/
/*!!!DUPLICATE NAME*/
floor<T>(x, $info?) {
return Math.floor(x)
}


function /*Darwin.(file).pow(_:Float80,_:Float80)*/
/*Darwin.(file).pow(_:Float80,_:Float80)*/
/*!!!DUPLICATE NAME*/
pow(x, y, $info?) {
return Math.pow(x, y)
}


function /*Darwin.(file).sqrt(_:T)*/
/*Darwin.(file).sqrt(_:T)*/
/*!!!DUPLICATE NAME*/
sqrt<T>(x, $info?) {
return Math.sqrt(x)
}


class NSException extends NSObject implements NSCopying, NSCoding{

/*Foundation.(file).NSException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
/*Foundation.(file).NSException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
initNameNSExceptionNameReasonOptionalUserInfoOptional(_name, reason, userInfo, $info?) {
throw 'unsupported method Foundation.(file).NSException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSException.exceptionWithName(_:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
/*Foundation.(file).NSException.exceptionWithName(_:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
exceptionWithNameReasonUserInfo(_name, reason, userInfo, $info?) {
throw 'unsupported method Foundation.(file).NSException.exceptionWithName(_:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?) in ' + this.constructor.name
}
/*Foundation.(file).NSException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
/*Foundation.(file).NSException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
initNameNSExceptionNameReasonOptionalUserInfoOptional(aName, aReason, aUserInfo, $info?) {
throw 'unsupported method Foundation.(file).NSException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?) in ' + this.constructor.name
}

_name

reason

userInfo

callStackReturnAddresses

callStackSymbols
/*Foundation.(file).NSException.raise()*/
/*Foundation.(file).NSException.raise()*/
raise($info?) {
throw 'unsupported method Foundation.(file).NSException.raise() in ' + this.constructor.name
}
/*Foundation.(file).NSException.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*Foundation.(file).NSException.copy(with:NSZone?)*/
/*Foundation.(file).NSException.copy(with:NSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Foundation.(file).NSException.copy(with:NSZone?) in ' + this.constructor.name
}
/*Foundation.(file).NSException.encode(with:NSCoder)*/
/*Foundation.(file).NSException.encode(with:NSCoder)*/
encodeWith(aCoder, $info?) {
throw 'unsupported method Foundation.(file).NSException.encode(with:NSCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSException.init(coder:NSCoder)*/
/*Foundation.(file).NSException.init(coder:NSCoder)*/
initCoderNSCoder(aDecoder, $info?) {
throw 'unsupported method Foundation.(file).NSException.init(coder:NSCoder) in ' + this.constructor.name
}
static readonly initCoderNSCoder$failable = true
static /*Foundation.(file).NSException.raise(_:NSExceptionName,format:String,arguments:CVaListPointer)*/
/*Foundation.(file).NSException.raise(_:NSExceptionName,format:String,arguments:CVaListPointer)*/
raiseFormatArguments(_name, format, argList, $info?) {
throw 'unsupported method Foundation.(file).NSException.raise(_:NSExceptionName,format:String,arguments:CVaListPointer) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof NSCopying$implementation != 'undefined') _mixin(NSException, NSCopying$implementation, false)
if(typeof NSCoding$implementation != 'undefined') _mixin(NSException, NSCoding$implementation, false)




class NSExpression extends NSObject implements NSSecureCoding, NSCopying{

/*Foundation.(file).NSExpression.init(format:String,argumentArray:[Any])*/
/*Foundation.(file).NSExpression.init(format:String,argumentArray:[Any])*/
initFormatStringArgumentArrayArray(expressionFormat, _arguments, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(format:String,argumentArray:[Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionWithFormat(_:String,argumentArray:[Any])*/
/*Foundation.(file).NSExpression.expressionWithFormat(_:String,argumentArray:[Any])*/
expressionWithFormatArgumentArray(expressionFormat, _arguments, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionWithFormat(_:String,argumentArray:[Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(format:String,arguments:CVaListPointer)*/
/*Foundation.(file).NSExpression.init(format:String,arguments:CVaListPointer)*/
initFormatStringArgumentsCVaListPointer(expressionFormat, argList, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(format:String,arguments:CVaListPointer) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionWithFormat(_:String,arguments:CVaListPointer)*/
/*Foundation.(file).NSExpression.expressionWithFormat(_:String,arguments:CVaListPointer)*/
expressionWithFormatArguments(expressionFormat, argList, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionWithFormat(_:String,arguments:CVaListPointer) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forConstantValue:Any?)*/
/*Foundation.(file).NSExpression.init(forConstantValue:Any?)*/
initForConstantValueOptional(obj, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forConstantValue:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForConstantValue(_:Any?)*/
/*Foundation.(file).NSExpression.expressionForConstantValue(_:Any?)*/
expressionForConstantValue(obj, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForConstantValue(_:Any?) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForEvaluatedObject()*/
/*Foundation.(file).NSExpression.expressionForEvaluatedObject()*/
expressionForEvaluatedObject($info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForEvaluatedObject() in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forVariable:String)*/
/*Foundation.(file).NSExpression.init(forVariable:String)*/
initForVariableString(string, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forVariable:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForVariable(_:String)*/
/*Foundation.(file).NSExpression.expressionForVariable(_:String)*/
expressionForVariable(string, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForVariable(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forKeyPath:String)*/
/*Foundation.(file).NSExpression.init(forKeyPath:String)*/
initForKeyPathString(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forKeyPath:String) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForKeyPath(_:String)*/
/*Foundation.(file).NSExpression.expressionForKeyPath(_:String)*/
expressionForKeyPath(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForKeyPath(_:String) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forFunction:String,arguments:[Any])*/
/*Foundation.(file).NSExpression.init(forFunction:String,arguments:[Any])*/
initForFunctionStringArgumentsArray(_name, parameters, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forFunction:String,arguments:[Any]) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForFunction(_:String,arguments:[Any])*/
/*Foundation.(file).NSExpression.expressionForFunction(_:String,arguments:[Any])*/
expressionForFunctionArguments(_name, parameters, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForFunction(_:String,arguments:[Any]) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forAggregate:[NSExpression])*/
/*Foundation.(file).NSExpression.init(forAggregate:[NSExpression])*/
initForAggregateArray(subexpressions, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forAggregate:[NSExpression]) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForAggregate(_:[NSExpression])*/
/*Foundation.(file).NSExpression.expressionForAggregate(_:[NSExpression])*/
expressionForAggregate(subexpressions, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForAggregate(_:[NSExpression]) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forUnionSet:NSExpression,with:NSExpression)*/
/*Foundation.(file).NSExpression.init(forUnionSet:NSExpression,with:NSExpression)*/
initForUnionSetNSExpressionWithNSExpression(left, right, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forUnionSet:NSExpression,with:NSExpression) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForUnionSet(_:NSExpression,with:NSExpression)*/
/*Foundation.(file).NSExpression.expressionForUnionSet(_:NSExpression,with:NSExpression)*/
expressionForUnionSetWith(left, right, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForUnionSet(_:NSExpression,with:NSExpression) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forIntersectSet:NSExpression,with:NSExpression)*/
/*Foundation.(file).NSExpression.init(forIntersectSet:NSExpression,with:NSExpression)*/
initForIntersectSetNSExpressionWithNSExpression(left, right, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forIntersectSet:NSExpression,with:NSExpression) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForIntersectSet(_:NSExpression,with:NSExpression)*/
/*Foundation.(file).NSExpression.expressionForIntersectSet(_:NSExpression,with:NSExpression)*/
expressionForIntersectSetWith(left, right, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForIntersectSet(_:NSExpression,with:NSExpression) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forMinusSet:NSExpression,with:NSExpression)*/
/*Foundation.(file).NSExpression.init(forMinusSet:NSExpression,with:NSExpression)*/
initForMinusSetNSExpressionWithNSExpression(left, right, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forMinusSet:NSExpression,with:NSExpression) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForMinusSet(_:NSExpression,with:NSExpression)*/
/*Foundation.(file).NSExpression.expressionForMinusSet(_:NSExpression,with:NSExpression)*/
expressionForMinusSetWith(left, right, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForMinusSet(_:NSExpression,with:NSExpression) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forSubquery:NSExpression,usingIteratorVariable:String,predicate:NSPredicate)*/
/*Foundation.(file).NSExpression.init(forSubquery:NSExpression,usingIteratorVariable:String,predicate:NSPredicate)*/
initForSubqueryNSExpressionUsingIteratorVariableStringPredicateNSPredicate(expression, variable, predicate, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forSubquery:NSExpression,usingIteratorVariable:String,predicate:NSPredicate) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForSubquery(_:NSExpression,usingIteratorVariable:String,predicate:NSPredicate)*/
/*Foundation.(file).NSExpression.expressionForSubquery(_:NSExpression,usingIteratorVariable:String,predicate:NSPredicate)*/
expressionForSubqueryUsingIteratorVariablePredicate(expression, variable, predicate, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForSubquery(_:NSExpression,usingIteratorVariable:String,predicate:NSPredicate) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forFunction:NSExpression,selectorName:String,arguments:[Any]?)*/
/*Foundation.(file).NSExpression.init(forFunction:NSExpression,selectorName:String,arguments:[Any]?)*/
initForFunctionNSExpressionSelectorNameStringArgumentsOptional(target, _name, parameters, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forFunction:NSExpression,selectorName:String,arguments:[Any]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForFunction(_:NSExpression,selectorName:String,arguments:[Any]?)*/
/*Foundation.(file).NSExpression.expressionForFunction(_:NSExpression,selectorName:String,arguments:[Any]?)*/
expressionForFunctionSelectorNameArguments(target, _name, parameters, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForFunction(_:NSExpression,selectorName:String,arguments:[Any]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForAnyKey()*/
/*Foundation.(file).NSExpression.expressionForAnyKey()*/
expressionForAnyKey($info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForAnyKey() in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(block:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?)*/
/*Foundation.(file).NSExpression.init(block:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?)*/
initBlockfunction_typeArgumentsOptional(block, _arguments, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(block:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forBlock:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?)*/
/*Foundation.(file).NSExpression.init(forBlock:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?)*/
initForBlockfunction_typeArgumentsOptional(block, _arguments, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forBlock:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForBlock(_:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?)*/
/*Foundation.(file).NSExpression.expressionForBlock(_:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?)*/
expressionForBlockArguments(block, _arguments, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForBlock(_:(Any?, [NSExpression], NSMutableDictionary?) -> Any,arguments:[NSExpression]?) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forConditional:NSPredicate,trueExpression:NSExpression,falseExpression:NSExpression)*/
/*Foundation.(file).NSExpression.init(forConditional:NSPredicate,trueExpression:NSExpression,falseExpression:NSExpression)*/
initForConditionalNSPredicateTrueExpressionNSExpressionFalseExpressionNSExpression(predicate, trueExpression, falseExpression, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forConditional:NSPredicate,trueExpression:NSExpression,falseExpression:NSExpression) in ' + this.constructor.name
}
static /*Foundation.(file).NSExpression.expressionForConditional(_:NSPredicate,trueExpression:NSExpression,falseExpression:NSExpression)*/
/*Foundation.(file).NSExpression.expressionForConditional(_:NSPredicate,trueExpression:NSExpression,falseExpression:NSExpression)*/
expressionForConditionalTrueExpressionFalseExpression(predicate, trueExpression, falseExpression, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionForConditional(_:NSPredicate,trueExpression:NSExpression,falseExpression:NSExpression) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(expressionType:NSExpression.ExpressionType)*/
/*Foundation.(file).NSExpression.init(expressionType:NSExpression.ExpressionType)*/
initExpressionTypeNSExpressionExpressionType(type, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(expressionType:NSExpression.ExpressionType) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(coder:NSCoder)*/
/*Foundation.(file).NSExpression.init(coder:NSCoder)*/
initCoderNSCoder(coder, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(coder:NSCoder) in ' + this.constructor.name
}
static readonly initCoderNSCoder$failable = true

expressionType

constantValue

keyPath

_function

variable

operand

_arguments

collection

predicate

left

leftExpression

right

rightExpression

_true

trueExpression

_false

falseExpression

expressionBlock
/*Foundation.(file).NSExpression.expressionValue(with:Any?,context:NSMutableDictionary?)*/
/*Foundation.(file).NSExpression.expressionValue(with:Any?,context:NSMutableDictionary?)*/
expressionValueWithContext(object, context, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionValue(with:Any?,context:NSMutableDictionary?) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.expressionValueWithObject(_:Any?,context:NSMutableDictionary?)*/
/*Foundation.(file).NSExpression.expressionValueWithObject(_:Any?,context:NSMutableDictionary?)*/
expressionValueWithObjectContext(object, context, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.expressionValueWithObject(_:Any?,context:NSMutableDictionary?) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.allowEvaluation()*/
/*Foundation.(file).NSExpression.allowEvaluation()*/
allowEvaluation($info?) {
throw 'unsupported method Foundation.(file).NSExpression.allowEvaluation() in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

static supportsSecureCoding
/*Foundation.(file).NSExpression.encode(with:NSCoder)*/
/*Foundation.(file).NSExpression.encode(with:NSCoder)*/
encodeWith(aCoder, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.encode(with:NSCoder) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.copy(with:NSZone?)*/
/*Foundation.(file).NSExpression.copy(with:NSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.copy(with:NSZone?) in ' + this.constructor.name
}
static ExpressionType = class{
/*Foundation.(file).NSExpression.ExpressionType.init(rawValue:UInt)*/
/*Foundation.(file).NSExpression.ExpressionType.init(rawValue:UInt)*/
initRawValueUInt(rawValue, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.ExpressionType.init(rawValue:UInt) in ' + this.constructor.name
}
static readonly initRawValueUInt$failable = true



/*Foundation.(file).NSExpression.ExpressionType.rawValue*/
rawValue$get() {
throw 'unsupported variable Foundation.(file).NSExpression.ExpressionType.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get constantValue() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 0, ...Array.from(arguments)})}

static NSConstantValueExpressionType


static get evaluatedObject() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 1, ...Array.from(arguments)})}

static NSEvaluatedObjectExpressionType


static get variable() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 2, ...Array.from(arguments)})}

static NSVariableExpressionType


static get keyPath() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 3, ...Array.from(arguments)})}

static NSKeyPathExpressionType


static get _function() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 4, ...Array.from(arguments)})}

static NSFunctionExpressionType


static get unionSet() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 5, ...Array.from(arguments)})}

static NSUnionSetExpressionType


static get intersectSet() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 6, ...Array.from(arguments)})}

static NSIntersectSetExpressionType


static get minusSet() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 7, ...Array.from(arguments)})}

static NSMinusSetExpressionType


static get subquery() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 13, ...Array.from(arguments)})}

static NSSubqueryExpressionType


static get aggregate() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 14, ...Array.from(arguments)})}

static NSAggregateExpressionType


static get anyKey() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 15, ...Array.from(arguments)})}

static NSAnyKeyExpressionType


static get block() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 19, ...Array.from(arguments)})}

static NSBlockExpressionType


static get conditional() {return Object.assign(new NSExpression.ExpressionType(), {rawValue: 20, ...Array.from(arguments)})}

static NSConditionalExpressionType

init$vars() {let _this = this;

}
}
/*Foundation.(file).NSExpression.init(format:String,_:[CVarArg])*/
/*Foundation.(file).NSExpression.init(format:String,_:[CVarArg])*/
initFormatStringArray(expressionFormat, args, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(format:String,_:[CVarArg]) in ' + this.constructor.name
}
/*Foundation.(file).NSExpression.init(forKeyPath:KeyPath<Root, Value>)*/
/*Foundation.(file).NSExpression.init(forKeyPath:KeyPath<Root, Value>)*/
initForKeyPathKeyPath<Root, Value>(keyPath, $info?) {
throw 'unsupported method Foundation.(file).NSExpression.init(forKeyPath:KeyPath<Root, Value>) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
_mixin(NSExpression.ExpressionType, _DefaultEnumImplementation, false)
if(typeof NSSecureCoding$implementation != 'undefined') _mixin(NSExpression, NSSecureCoding$implementation, false)
if(typeof NSCopying$implementation != 'undefined') _mixin(NSExpression, NSCopying$implementation, false)








class Operation extends NSObject{

/*Foundation.(file).Operation.start()*/
/*Foundation.(file).Operation.start()*/
start($info?) {
throw 'unsupported method Foundation.(file).Operation.start() in ' + this.constructor.name
}
/*Foundation.(file).Operation.main()*/
/*Foundation.(file).Operation.main()*/
main($info?) {
throw 'unsupported method Foundation.(file).Operation.main() in ' + this.constructor.name
}

isCancelled

cancelled
/*Foundation.(file).Operation.cancel()*/
/*Foundation.(file).Operation.cancel()*/
cancel($info?) {
throw 'unsupported method Foundation.(file).Operation.cancel() in ' + this.constructor.name
}

isExecuting

executing

isFinished

finished

isConcurrent

concurrent

isAsynchronous

asynchronous

isReady

ready
/*Foundation.(file).Operation.addDependency(_:Operation)*/
/*Foundation.(file).Operation.addDependency(_:Operation)*/
addDependency(op, $info?) {
throw 'unsupported method Foundation.(file).Operation.addDependency(_:Operation) in ' + this.constructor.name
}
/*Foundation.(file).Operation.removeDependency(_:Operation)*/
/*Foundation.(file).Operation.removeDependency(_:Operation)*/
removeDependency(op, $info?) {
throw 'unsupported method Foundation.(file).Operation.removeDependency(_:Operation) in ' + this.constructor.name
}

dependencies

queuePriority

completionBlock
/*Foundation.(file).Operation.waitUntilFinished()*/
/*Foundation.(file).Operation.waitUntilFinished()*/
waitUntilFinished($info?) {
throw 'unsupported method Foundation.(file).Operation.waitUntilFinished() in ' + this.constructor.name
}

threadPriority

qualityOfService

_name
/*Foundation.(file).Operation.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
static QueuePriority = class{
/*Foundation.(file).Operation.QueuePriority.init(rawValue:Int)*/
/*Foundation.(file).Operation.QueuePriority.init(rawValue:Int)*/
initRawValueInt(rawValue, $info?) {
throw 'unsupported method Foundation.(file).Operation.QueuePriority.init(rawValue:Int) in ' + this.constructor.name
}
static readonly initRawValueInt$failable = true



/*Foundation.(file).Operation.QueuePriority.rawValue*/
rawValue$get() {
throw 'unsupported variable Foundation.(file).Operation.QueuePriority.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get veryLow() {return Object.assign(new Operation.QueuePriority(), {rawValue: -8, ...Array.from(arguments)})}

static VeryLow


static get low() {return Object.assign(new Operation.QueuePriority(), {rawValue: -4, ...Array.from(arguments)})}

static Low


static get normal() {return Object.assign(new Operation.QueuePriority(), {rawValue: 0, ...Array.from(arguments)})}

static Normal


static get high() {return Object.assign(new Operation.QueuePriority(), {rawValue: 4, ...Array.from(arguments)})}

static High


static get veryHigh() {return Object.assign(new Operation.QueuePriority(), {rawValue: 8, ...Array.from(arguments)})}

static VeryHigh

init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
_mixin(Operation.QueuePriority, _DefaultEnumImplementation, false)





const XCTPerformanceMetric_WallClockTime


function /*XCTest.(file).XCTSelfTestMain()*/
/*XCTest.(file).XCTSelfTestMain()*/
XCTSelfTestMain($info?) {
throw 'unsupported method XCTest.(file).XCTSelfTestMain() in ' + this.constructor.name
}



let XCT_UI_TESTING_AVAILABLE



const XCTestErrorDomain



const XCTestObserverClassKey



const XCTestScopeAll



const XCTestScopeKey



const XCTestScopeNone



const XCTestScopeSelf



const XCTestToolKey



const XCTestedUnitPath



const XCUIElementAttributeNameChildren



const XCUIElementAttributeNameElementType



const XCUIElementAttributeNameEnabled



const XCUIElementAttributeNameFrame



const XCUIElementAttributeNameHasFocus



const XCUIElementAttributeNameHorizontalSizeClass



const XCUIElementAttributeNameIdentifier



const XCUIElementAttributeNameLabel



const XCUIElementAttributeNamePlaceholderValue



const XCUIElementAttributeNameSelected



const XCUIElementAttributeNameTitle



const XCUIElementAttributeNameValue



const XCUIElementAttributeNameVerticalSizeClass



const XCUIIdentifierCloseWindow



const XCUIIdentifierFullScreenWindow



const XCUIIdentifierMinimizeWindow



const XCUIIdentifierZoomWindow



const XCUIKeyboardKeyCapsLock



const XCUIKeyboardKeyClear



const XCUIKeyboardKeyCommand



const XCUIKeyboardKeyControl



const XCUIKeyboardKeyDelete



const XCUIKeyboardKeyDownArrow



const XCUIKeyboardKeyEnd



const XCUIKeyboardKeyEnter



const XCUIKeyboardKeyEscape



const XCUIKeyboardKeyF1



const XCUIKeyboardKeyF10



const XCUIKeyboardKeyF11



const XCUIKeyboardKeyF12



const XCUIKeyboardKeyF13



const XCUIKeyboardKeyF14



const XCUIKeyboardKeyF15



const XCUIKeyboardKeyF16



const XCUIKeyboardKeyF17



const XCUIKeyboardKeyF18



const XCUIKeyboardKeyF19



const XCUIKeyboardKeyF2



const XCUIKeyboardKeyF3



const XCUIKeyboardKeyF4



const XCUIKeyboardKeyF5



const XCUIKeyboardKeyF6



const XCUIKeyboardKeyF7



const XCUIKeyboardKeyF8



const XCUIKeyboardKeyF9



const XCUIKeyboardKeyForwardDelete



const XCUIKeyboardKeyHelp



const XCUIKeyboardKeyHome



const XCUIKeyboardKeyLeftArrow



const XCUIKeyboardKeyOption



const XCUIKeyboardKeyPageDown



const XCUIKeyboardKeyPageUp



const XCUIKeyboardKeyReturn



const XCUIKeyboardKeyRightArrow



const XCUIKeyboardKeyRightCommand



const XCUIKeyboardKeyRightControl



const XCUIKeyboardKeyRightOption



const XCUIKeyboardKeyRightShift



const XCUIKeyboardKeySecondaryFn



const XCUIKeyboardKeyShift



const XCUIKeyboardKeySpace



const XCUIKeyboardKeyTab



const XCUIKeyboardKeyUpArrow























function /*XCTest.(file).XCTFail(_:String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTFail(_:String,file:StaticString,line:UInt)*/
XCTFailFileLine(message, file, line, $info?) {
assertionFailureFileLine(() => message, null, null)
}


function /*XCTest.(file).XCTAssertNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertNilFileLine(expression, message, file, line, $info?) {
preconditionFileLine(() => Optional.wrappedEqualsOptionalNilComparisonType(expression( {}), _injectIntoOptional(null)), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertNotNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertNotNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertNotNilFileLine(expression, message, file, line, $info?) {
preconditionFileLine(() => Optional.wrappedNotEqualsOptionalNilComparisonType(expression( {}), _injectIntoOptional(null)), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssert(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssert(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertFileLine(expression, message, file, line, $info?) {
preconditionFileLine(() => expression( {}), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertTrue(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertTrue(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertTrueFileLine(expression, message, file, line, $info?) {
preconditionFileLine(() => Bool.$equal(expression( {}), true), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertFalse(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertFalse(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertFalseFileLine(expression, message, file, line, $info?) {
preconditionFileLine(() => Bool.$not(expression( {})), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertEqualFileLine<T>(expression1, expression2, message, file, line, $info?) {
preconditionFileLine(() => (_.arg0 = expression1( {})).constructor.$equal(_.arg0, expression2( {})), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertNotEqualFileLine<T>(expression1, expression2, message, file, line, $info?) {
preconditionFileLine(() => (_.arg0 = expression1( {})).constructor.$notEqual(_.arg0, expression2( {})), () => message( {}), null, null)
}











function /*XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertEqualAccuracyFileLine<T>(expression1, expression2, accuracy, message, file, line, $info?) {
throw 'unsupported method XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt) in ' + this.constructor.name
}


function /*XCTest.(file).XCTAssertEqualWithAccuracy(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertEqualWithAccuracy(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertEqualWithAccuracyAccuracyFileLine<T>(expression1, expression2, accuracy, message, file, line, $info?) {
throw 'unsupported method XCTest.(file).XCTAssertEqualWithAccuracy(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt) in ' + this.constructor.name
}











function /*XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertNotEqualAccuracyFileLine<T>(expression1, expression2, accuracy, message, file, line, $info?) {
throw 'unsupported method XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,accuracy:T,_:() -> String,file:StaticString,line:UInt) in ' + this.constructor.name
}


function /*XCTest.(file).XCTAssertNotEqualWithAccuracy(_:() throws -> T,_:() throws -> T,_:T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertNotEqualWithAccuracy(_:() throws -> T,_:() throws -> T,_:T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertNotEqualWithAccuracyFileLine<T>(expression1, expression2, accuracy, message, file, line, $info?) {
throw 'unsupported method XCTest.(file).XCTAssertNotEqualWithAccuracy(_:() throws -> T,_:() throws -> T,_:T,_:() -> String,file:StaticString,line:UInt) in ' + this.constructor.name
}


function /*XCTest.(file).XCTAssertGreaterThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertGreaterThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertGreaterThanFileLine<T>(expression1, expression2, message, file, line, $info?) {
preconditionFileLine(() => (_.arg0 = expression1( {})).constructor.$greaterThan(_.arg0, expression2( {})), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertGreaterThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertGreaterThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertGreaterThanOrEqualFileLine<T>(expression1, expression2, message, file, line, $info?) {
preconditionFileLine(() => (_.arg0 = expression1( {})).constructor.$greaterThanOrEqual(_.arg0, expression2( {})), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertLessThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertLessThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertLessThanFileLine<T>(expression1, expression2, message, file, line, $info?) {
preconditionFileLine(() => (_.arg0 = expression1( {})).constructor.$lessThan(_.arg0, expression2( {})), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertLessThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertLessThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertLessThanOrEqualFileLine<T>(expression1, expression2, message, file, line, $info?) {
preconditionFileLine(() => (_.arg0 = expression1( {})).constructor.$lessThanOrEqual(_.arg0, expression2( {})), () => message( {}), null, null)
}


function /*XCTest.(file).XCTAssertThrowsError(_:() throws -> T,_:() -> String,file:StaticString,line:UInt,_:(Error) -> Void)*/
/*XCTest.(file).XCTAssertThrowsError(_:() throws -> T,_:() -> String,file:StaticString,line:UInt,_:(Error) -> Void)*/
XCTAssertThrowsErrorFileLine<T>(expression, message, file, line, errorHandler, $info?) {
throw 'unsupported method XCTest.(file).XCTAssertThrowsError(_:() throws -> T,_:() -> String,file:StaticString,line:UInt,_:(Error) -> Void) in ' + this.constructor.name
}


function /*XCTest.(file).XCTAssertNoThrow(_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
/*XCTest.(file).XCTAssertNoThrow(_:() throws -> T,_:() -> String,file:StaticString,line:UInt)*/
XCTAssertNoThrowFileLine<T>(expression, message, file, line, $info?) {
throw 'unsupported method XCTest.(file).XCTAssertNoThrow(_:() throws -> T,_:() -> String,file:StaticString,line:UInt) in ' + this.constructor.name
}


interface XCTActivity extends NSObjectProtocol{

_name
/*XCTest.(file).XCTActivity.add(_:XCTAttachment)*/
/*XCTest.(file).XCTActivity.add(_:XCTAttachment)*/
add(attachment, $info?)
/*XCTest.(file).XCTActivity.addAttachment(_:XCTAttachment)*/
/*XCTest.(file).XCTActivity.addAttachment(_:XCTAttachment)*/
addAttachment(attachment, $info?)
}
class XCTActivity$implementation{
}
if(typeof NSObjectProtocol$implementation != 'undefined') _mixin(XCTActivity$implementation, NSObjectProtocol$implementation, false)


class XCTAttachment extends NSObject implements NSSecureCoding{


/*XCTest.(file).XCTAttachment.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTAttachment.init(uniformTypeIdentifier:String?,name:String?,payload:Data?,userInfo:[AnyHashable : Any]?)*/
/*XCTest.(file).XCTAttachment.init(uniformTypeIdentifier:String?,name:String?,payload:Data?,userInfo:[AnyHashable : Any]?)*/
initUniformTypeIdentifierOptionalNameOptionalPayloadOptionalUserInfoOptional(identifier, _name, payload, userInfo, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(uniformTypeIdentifier:String?,name:String?,payload:Data?,userInfo:[AnyHashable : Any]?) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithUniformTypeIdentifier(_:String?,name:String?,payload:Data?,userInfo:[AnyHashable : Any]?)*/
/*XCTest.(file).XCTAttachment.attachmentWithUniformTypeIdentifier(_:String?,name:String?,payload:Data?,userInfo:[AnyHashable : Any]?)*/
attachmentWithUniformTypeIdentifierNamePayloadUserInfo(identifier, _name, payload, userInfo, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithUniformTypeIdentifier(_:String?,name:String?,payload:Data?,userInfo:[AnyHashable : Any]?) in ' + this.constructor.name
}

uniformTypeIdentifier

_name

userInfo

lifetime

static supportsSecureCoding
/*XCTest.(file).XCTAttachment.encode(with:NSCoder)*/
/*XCTest.(file).XCTAttachment.encode(with:NSCoder)*/
encodeWith(aCoder, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.encode(with:NSCoder) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(coder:NSCoder)*/
/*XCTest.(file).XCTAttachment.init(coder:NSCoder)*/
initCoderNSCoder(aDecoder, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(coder:NSCoder) in ' + this.constructor.name
}
static readonly initCoderNSCoder$failable = true
static ImageQuality = class{
/*XCTest.(file).XCTAttachment.ImageQuality.init(rawValue:Int)*/
/*XCTest.(file).XCTAttachment.ImageQuality.init(rawValue:Int)*/
initRawValueInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.ImageQuality.init(rawValue:Int) in ' + this.constructor.name
}
static readonly initRawValueInt$failable = true



/*XCTest.(file).XCTAttachment.ImageQuality.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCTAttachment.ImageQuality.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get original() {return Object.assign(new XCTAttachment.ImageQuality(), {rawValue: 0, ...Array.from(arguments)})}

static Original


static get medium() {return Object.assign(new XCTAttachment.ImageQuality(), {rawValue: 1, ...Array.from(arguments)})}

static Medium


static get low() {return Object.assign(new XCTAttachment.ImageQuality(), {rawValue: 2, ...Array.from(arguments)})}

static Low

init$vars() {let _this = this;

}
}
static Lifetime = class{
/*XCTest.(file).XCTAttachment.Lifetime.init(rawValue:Int)*/
/*XCTest.(file).XCTAttachment.Lifetime.init(rawValue:Int)*/
initRawValueInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.Lifetime.init(rawValue:Int) in ' + this.constructor.name
}
static readonly initRawValueInt$failable = true



/*XCTest.(file).XCTAttachment.Lifetime.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCTAttachment.Lifetime.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get keepAlways() {return Object.assign(new XCTAttachment.Lifetime(), {rawValue: 0, ...Array.from(arguments)})}

static KeepAlways


static get deleteOnSuccess() {return Object.assign(new XCTAttachment.Lifetime(), {rawValue: 1, ...Array.from(arguments)})}

static DeleteOnSuccess

init$vars() {let _this = this;

}
}
/*XCTest.(file).XCTAttachment.init(data:Data)*/
/*XCTest.(file).XCTAttachment.init(data:Data)*/
initDataData(payload, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(data:Data) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithData(_:Data)*/
/*XCTest.(file).XCTAttachment.attachmentWithData(_:Data)*/
attachmentWithData(payload, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithData(_:Data) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(data:Data,uniformTypeIdentifier:String)*/
/*XCTest.(file).XCTAttachment.init(data:Data,uniformTypeIdentifier:String)*/
initDataDataUniformTypeIdentifierString(payload, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(data:Data,uniformTypeIdentifier:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithData(_:Data,uniformTypeIdentifier:String)*/
/*XCTest.(file).XCTAttachment.attachmentWithData(_:Data,uniformTypeIdentifier:String)*/
attachmentWithDataUniformTypeIdentifier(payload, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithData(_:Data,uniformTypeIdentifier:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(string:String)*/
/*XCTest.(file).XCTAttachment.init(string:String)*/
initStringString(string, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(string:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithString(_:String)*/
/*XCTest.(file).XCTAttachment.attachmentWithString(_:String)*/
attachmentWithString(string, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithString(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(archivableObject:NSSecureCoding)*/
/*XCTest.(file).XCTAttachment.init(archivableObject:NSSecureCoding)*/
initArchivableObjectNSSecureCoding(object, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(archivableObject:NSSecureCoding) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithArchivableObject(_:NSSecureCoding)*/
/*XCTest.(file).XCTAttachment.attachmentWithArchivableObject(_:NSSecureCoding)*/
attachmentWithArchivableObject(object, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithArchivableObject(_:NSSecureCoding) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(archivableObject:NSSecureCoding,uniformTypeIdentifier:String)*/
/*XCTest.(file).XCTAttachment.init(archivableObject:NSSecureCoding,uniformTypeIdentifier:String)*/
initArchivableObjectNSSecureCodingUniformTypeIdentifierString(object, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(archivableObject:NSSecureCoding,uniformTypeIdentifier:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithArchivableObject(_:NSSecureCoding,uniformTypeIdentifier:String)*/
/*XCTest.(file).XCTAttachment.attachmentWithArchivableObject(_:NSSecureCoding,uniformTypeIdentifier:String)*/
attachmentWithArchivableObjectUniformTypeIdentifier(object, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithArchivableObject(_:NSSecureCoding,uniformTypeIdentifier:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(plistObject:Any)*/
/*XCTest.(file).XCTAttachment.init(plistObject:Any)*/
initPlistObjectprotocol_composition_type(object, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(plistObject:Any) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithPlistObject(_:Any)*/
/*XCTest.(file).XCTAttachment.attachmentWithPlistObject(_:Any)*/
attachmentWithPlistObject(object, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithPlistObject(_:Any) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(contentsOfFile:URL)*/
/*XCTest.(file).XCTAttachment.init(contentsOfFile:URL)*/
initContentsOfFileURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(contentsOfFile:URL) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(contentsOfFileAtURL:URL)*/
/*XCTest.(file).XCTAttachment.init(contentsOfFileAtURL:URL)*/
initContentsOfFileAtURLURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(contentsOfFileAtURL:URL) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithContentsOfFileAtURL(_:URL)*/
/*XCTest.(file).XCTAttachment.attachmentWithContentsOfFileAtURL(_:URL)*/
attachmentWithContentsOfFileAtURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithContentsOfFileAtURL(_:URL) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(contentsOfFile:URL,uniformTypeIdentifier:String)*/
/*XCTest.(file).XCTAttachment.init(contentsOfFile:URL,uniformTypeIdentifier:String)*/
initContentsOfFileURLUniformTypeIdentifierString(url, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(contentsOfFile:URL,uniformTypeIdentifier:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(contentsOfFileAtURL:URL,uniformTypeIdentifier:String)*/
/*XCTest.(file).XCTAttachment.init(contentsOfFileAtURL:URL,uniformTypeIdentifier:String)*/
initContentsOfFileAtURLURLUniformTypeIdentifierString(url, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(contentsOfFileAtURL:URL,uniformTypeIdentifier:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithContentsOfFileAtURL(_:URL,uniformTypeIdentifier:String)*/
/*XCTest.(file).XCTAttachment.attachmentWithContentsOfFileAtURL(_:URL,uniformTypeIdentifier:String)*/
attachmentWithContentsOfFileAtURLUniformTypeIdentifier(url, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithContentsOfFileAtURL(_:URL,uniformTypeIdentifier:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(compressedContentsOfDirectory:URL)*/
/*XCTest.(file).XCTAttachment.init(compressedContentsOfDirectory:URL)*/
initCompressedContentsOfDirectoryURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(compressedContentsOfDirectory:URL) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(compressedContentsOfDirectoryAtURL:URL)*/
/*XCTest.(file).XCTAttachment.init(compressedContentsOfDirectoryAtURL:URL)*/
initCompressedContentsOfDirectoryAtURLURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(compressedContentsOfDirectoryAtURL:URL) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithCompressedContentsOfDirectoryAtURL(_:URL)*/
/*XCTest.(file).XCTAttachment.attachmentWithCompressedContentsOfDirectoryAtURL(_:URL)*/
attachmentWithCompressedContentsOfDirectoryAtURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithCompressedContentsOfDirectoryAtURL(_:URL) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(image:NSImage)*/
/*XCTest.(file).XCTAttachment.init(image:NSImage)*/
initImageNSImage(_image, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(image:NSImage) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithImage(_:NSImage)*/
/*XCTest.(file).XCTAttachment.attachmentWithImage(_:NSImage)*/
attachmentWithImage(_image, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithImage(_:NSImage) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(image:NSImage,quality:XCTAttachment.ImageQuality)*/
/*XCTest.(file).XCTAttachment.init(image:NSImage,quality:XCTAttachment.ImageQuality)*/
initImageNSImageQualityXCTAttachmentImageQuality(_image, quality, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(image:NSImage,quality:XCTAttachment.ImageQuality) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithImage(_:NSImage,quality:XCTAttachment.ImageQuality)*/
/*XCTest.(file).XCTAttachment.attachmentWithImage(_:NSImage,quality:XCTAttachment.ImageQuality)*/
attachmentWithImageQuality(_image, quality, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithImage(_:NSImage,quality:XCTAttachment.ImageQuality) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(screenshot:XCUIScreenshot)*/
/*XCTest.(file).XCTAttachment.init(screenshot:XCUIScreenshot)*/
initScreenshotXCUIScreenshot(screenshot, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(screenshot:XCUIScreenshot) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithScreenshot(_:XCUIScreenshot)*/
/*XCTest.(file).XCTAttachment.attachmentWithScreenshot(_:XCUIScreenshot)*/
attachmentWithScreenshot(screenshot, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithScreenshot(_:XCUIScreenshot) in ' + this.constructor.name
}
/*XCTest.(file).XCTAttachment.init(screenshot:XCUIScreenshot,quality:XCTAttachment.ImageQuality)*/
/*XCTest.(file).XCTAttachment.init(screenshot:XCUIScreenshot,quality:XCTAttachment.ImageQuality)*/
initScreenshotXCUIScreenshotQualityXCTAttachmentImageQuality(screenshot, quality, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.init(screenshot:XCUIScreenshot,quality:XCTAttachment.ImageQuality) in ' + this.constructor.name
}
static /*XCTest.(file).XCTAttachment.attachmentWithScreenshot(_:XCUIScreenshot,quality:XCTAttachment.ImageQuality)*/
/*XCTest.(file).XCTAttachment.attachmentWithScreenshot(_:XCUIScreenshot,quality:XCTAttachment.ImageQuality)*/
attachmentWithScreenshotQuality(screenshot, quality, $info?) {
throw 'unsupported method XCTest.(file).XCTAttachment.attachmentWithScreenshot(_:XCUIScreenshot,quality:XCTAttachment.ImageQuality) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
_mixin(XCTAttachment.ImageQuality, _DefaultEnumImplementation, false)
_mixin(XCTAttachment.Lifetime, _DefaultEnumImplementation, false)
if(typeof NSSecureCoding$implementation != 'undefined') _mixin(XCTAttachment, NSSecureCoding$implementation, false)






class XCTContext extends NSObject{

/*XCTest.(file).XCTContext.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}


static /*XCTest.(file).XCTContext.runActivity(named:String,block:(XCTActivity) throws -> Result)*/
/*XCTest.(file).XCTContext.runActivity(named:String,block:(XCTActivity) throws -> Result)*/
runActivityNamedBlock<Result>(_name, block, $info?) {
throw 'unsupported method XCTest.(file).XCTContext.runActivity(named:String,block:(XCTActivity) throws -> Result) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}




class XCTPerformanceMetric{
static readonly $struct = true
/*XCTest.(file).XCTPerformanceMetric.init(_:String)*/
/*XCTest.(file).XCTPerformanceMetric.init(_:String)*/
initString(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCTPerformanceMetric.init(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTPerformanceMetric.init(rawValue:String)*/
/*XCTest.(file).XCTPerformanceMetric.init(rawValue:String)*/
initRawValueString(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCTPerformanceMetric.init(rawValue:String) in ' + this.constructor.name
}



/*XCTest.(file).XCTPerformanceMetric.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCTPerformanceMetric.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };






static readonly wallClockTime

static readonly XCTPerformanceMetric_WallClockTime
init$vars() {let _this = this;

}
}




class XCTWaiter extends NSObject{

/*XCTest.(file).XCTWaiter.init(delegate:XCTWaiterDelegate?)*/
/*XCTest.(file).XCTWaiter.init(delegate:XCTWaiterDelegate?)*/
initDelegateOptional(delegate, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.init(delegate:XCTWaiterDelegate?) in ' + this.constructor.name
}

delegate

fulfilledExpectations
/*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval)*/
/*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval)*/
waitForTimeout(expectations, seconds, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval)*/
/*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval)*/
waitForExpectationsTimeout(expectations, seconds, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
/*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
waitForTimeoutEnforceOrder(expectations, seconds, enforceOrderOfFulfillment, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
/*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
waitForExpectationsTimeoutEnforceOrder(expectations, seconds, enforceOrderOfFulfillment, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool) in ' + this.constructor.name
}
static /*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval)*/
/*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval)*/
waitForTimeout(expectations, seconds, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval) in ' + this.constructor.name
}
static /*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval)*/
/*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval)*/
waitForExpectationsTimeout(expectations, seconds, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval) in ' + this.constructor.name
}
static /*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
/*XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
waitForTimeoutEnforceOrder(expectations, seconds, enforceOrderOfFulfillment, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool) in ' + this.constructor.name
}
static /*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
/*XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
waitForExpectationsTimeoutEnforceOrder(expectations, seconds, enforceOrderOfFulfillment, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTWaiter.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
static Result = class{
/*XCTest.(file).XCTWaiter.Result.init(rawValue:Int)*/
/*XCTest.(file).XCTWaiter.Result.init(rawValue:Int)*/
initRawValueInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCTWaiter.Result.init(rawValue:Int) in ' + this.constructor.name
}
static readonly initRawValueInt$failable = true



/*XCTest.(file).XCTWaiter.Result.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCTWaiter.Result.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get completed() {return Object.assign(new XCTWaiter.Result(), {rawValue: 1, ...Array.from(arguments)})}

static Completed


static get timedOut() {return Object.assign(new XCTWaiter.Result(), {rawValue: 2, ...Array.from(arguments)})}

static TimedOut


static get incorrectOrder() {return Object.assign(new XCTWaiter.Result(), {rawValue: 3, ...Array.from(arguments)})}

static IncorrectOrder


static get invertedFulfillment() {return Object.assign(new XCTWaiter.Result(), {rawValue: 4, ...Array.from(arguments)})}

static InvertedFulfillment


static get interrupted() {return Object.assign(new XCTWaiter.Result(), {rawValue: 5, ...Array.from(arguments)})}

static Interrupted

init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
_mixin(XCTWaiter.Result, _DefaultEnumImplementation, false)




interface XCTWaiterDelegate extends NSObjectProtocol{
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,didTimeoutWithUnfulfilledExpectations:[XCTestExpectation])*/
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,didTimeoutWithUnfulfilledExpectations:[XCTestExpectation])*/
waiterDidTimeoutWithUnfulfilledExpectations(waiter, unfulfilledExpectations, $info?)
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,fulfillmentDidViolateOrderingConstraintsFor:XCTestExpectation,requiredExpectation:XCTestExpectation)*/
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,fulfillmentDidViolateOrderingConstraintsFor:XCTestExpectation,requiredExpectation:XCTestExpectation)*/
waiterFulfillmentDidViolateOrderingConstraintsForRequiredExpectation(waiter, expectation, requiredExpectation, $info?)
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,fulfillmentDidViolateOrderingConstraintsForExpectation:XCTestExpectation,requiredExpectation:XCTestExpectation)*/
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,fulfillmentDidViolateOrderingConstraintsForExpectation:XCTestExpectation,requiredExpectation:XCTestExpectation)*/
waiterFulfillmentDidViolateOrderingConstraintsForExpectationRequiredExpectation(waiter, expectation, requiredExpectation, $info?)
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,didFulfillInvertedExpectation:XCTestExpectation)*/
/*XCTest.(file).XCTWaiterDelegate.waiter(_:XCTWaiter,didFulfillInvertedExpectation:XCTestExpectation)*/
waiterDidFulfillInvertedExpectation(waiter, expectation, $info?)
/*XCTest.(file).XCTWaiterDelegate.nestedWaiter(_:XCTWaiter,wasInterruptedByTimedOutWaiter:XCTWaiter)*/
/*XCTest.(file).XCTWaiterDelegate.nestedWaiter(_:XCTWaiter,wasInterruptedByTimedOutWaiter:XCTWaiter)*/
nestedWaiterWasInterruptedByTimedOutWaiter(waiter, outerWaiter, $info?)
}
class XCTWaiterDelegate$implementation{
}
if(typeof NSObjectProtocol$implementation != 'undefined') _mixin(XCTWaiterDelegate$implementation, NSObjectProtocol$implementation, false)


class XCTest extends NSObject{


testCaseCount

_name

testRunClass

testRun
/*XCTest.(file).XCTest.perform(_:XCTestRun)*/
/*XCTest.(file).XCTest.perform(_:XCTestRun)*/
perform(run, $info?) {
throw 'unsupported method XCTest.(file).XCTest.perform(_:XCTestRun) in ' + this.constructor.name
}
/*XCTest.(file).XCTest.performTest(_:XCTestRun)*/
/*XCTest.(file).XCTest.performTest(_:XCTestRun)*/
performTest(run, $info?) {
throw 'unsupported method XCTest.(file).XCTest.performTest(_:XCTestRun) in ' + this.constructor.name
}
/*XCTest.(file).XCTest.run()*/
/*XCTest.(file).XCTest.run()*/
run($info?) {
throw 'unsupported method XCTest.(file).XCTest.run() in ' + this.constructor.name
}
/*XCTest.(file).XCTest.runTest()*/
/*XCTest.(file).XCTest.runTest()*/
runTest($info?) {
throw 'unsupported method XCTest.(file).XCTest.runTest() in ' + this.constructor.name
}
/*XCTest.(file).XCTest.setUp()*/
/*XCTest.(file).XCTest.setUp()*/
setUp($info?) {

}
/*XCTest.(file).XCTest.tearDown()*/
/*XCTest.(file).XCTest.tearDown()*/
tearDown($info?) {

}
/*XCTest.(file).XCTest.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCTestCase extends XCTest implements XCTActivity, XCTWaiterDelegate{

/*XCTest.(file).XCTestCase.init(invocation:NSInvocation?)*/
/*XCTest.(file).XCTestCase.init(invocation:NSInvocation?)*/
initInvocationOptional(invocation, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.init(invocation:NSInvocation?) in ' + this.constructor.name
}
static /*XCTest.(file).XCTestCase.testCaseWithInvocation(_:NSInvocation?)*/
/*XCTest.(file).XCTestCase.testCaseWithInvocation(_:NSInvocation?)*/
testCaseWithInvocation(invocation, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.testCaseWithInvocation(_:NSInvocation?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.init(invocation:NSInvocation?)*/
/*XCTest.(file).XCTestCase.init(invocation:NSInvocation?)*/
initInvocationOptional(invocation, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.init(invocation:NSInvocation?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.init(selector:Selector)*/
/*XCTest.(file).XCTestCase.init(selector:Selector)*/
initSelectorSelector(selector, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.init(selector:Selector) in ' + this.constructor.name
}
static readonly initSelectorSelector$failable = true
static /*XCTest.(file).XCTestCase.testCaseWithSelector(_:Selector)*/
/*XCTest.(file).XCTestCase.testCaseWithSelector(_:Selector)*/
testCaseWithSelector(selector, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.testCaseWithSelector(_:Selector) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.init(selector:Selector)*/
/*XCTest.(file).XCTestCase.init(selector:Selector)*/
initSelectorSelector(selector, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.init(selector:Selector) in ' + this.constructor.name
}

invocation
/*XCTest.(file).XCTestCase.invokeTest()*/
/*XCTest.(file).XCTestCase.invokeTest()*/
invokeTest($info?) {
throw 'unsupported method XCTest.(file).XCTestCase.invokeTest() in ' + this.constructor.name
}

continueAfterFailure
/*XCTest.(file).XCTestCase.recordFailure(withDescription:String,inFile:String,atLine:Int,expected:Bool)*/
/*XCTest.(file).XCTestCase.recordFailure(withDescription:String,inFile:String,atLine:Int,expected:Bool)*/
recordFailureWithDescriptionInFileAtLineExpected(description, filePath, lineNumber, expected, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.recordFailure(withDescription:String,inFile:String,atLine:Int,expected:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.recordFailureWithDescription(_:String,inFile:String,atLine:Int,expected:Bool)*/
/*XCTest.(file).XCTestCase.recordFailureWithDescription(_:String,inFile:String,atLine:Int,expected:Bool)*/
/*!!!DUPLICATE NAME*/
recordFailureWithDescriptionInFileAtLineExpected(description, filePath, lineNumber, expected, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.recordFailureWithDescription(_:String,inFile:String,atLine:Int,expected:Bool) in ' + this.constructor.name
}

static testInvocations
/*XCTest.(file).XCTestCase.addTeardownBlock(_:() -> Void)*/
/*XCTest.(file).XCTestCase.addTeardownBlock(_:() -> Void)*/
addTeardownBlock(block, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.addTeardownBlock(_:() -> Void) in ' + this.constructor.name
}

static defaultPerformanceMetrics
/*XCTest.(file).XCTestCase.measure(_:() -> Void)*/
/*XCTest.(file).XCTestCase.measure(_:() -> Void)*/
measure(block, $info?) {

}
/*XCTest.(file).XCTestCase.measureBlock(_:() -> Void)*/
/*XCTest.(file).XCTestCase.measureBlock(_:() -> Void)*/
measureBlock(block, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.measureBlock(_:() -> Void) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.measureMetrics(_:[XCTPerformanceMetric],automaticallyStartMeasuring:Bool,for:() -> Void)*/
/*XCTest.(file).XCTestCase.measureMetrics(_:[XCTPerformanceMetric],automaticallyStartMeasuring:Bool,for:() -> Void)*/
measureMetricsAutomaticallyStartMeasuringFor(metrics, automaticallyStartMeasuring, block, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.measureMetrics(_:[XCTPerformanceMetric],automaticallyStartMeasuring:Bool,for:() -> Void) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.measureMetrics(_:[XCTPerformanceMetric],automaticallyStartMeasuring:Bool,forBlock:() -> Void)*/
/*XCTest.(file).XCTestCase.measureMetrics(_:[XCTPerformanceMetric],automaticallyStartMeasuring:Bool,forBlock:() -> Void)*/
measureMetricsAutomaticallyStartMeasuringForBlock(metrics, automaticallyStartMeasuring, block, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.measureMetrics(_:[XCTPerformanceMetric],automaticallyStartMeasuring:Bool,forBlock:() -> Void) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.startMeasuring()*/
/*XCTest.(file).XCTestCase.startMeasuring()*/
startMeasuring($info?) {
throw 'unsupported method XCTest.(file).XCTestCase.startMeasuring() in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.stopMeasuring()*/
/*XCTest.(file).XCTestCase.stopMeasuring()*/
stopMeasuring($info?) {
throw 'unsupported method XCTest.(file).XCTestCase.stopMeasuring() in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.addUIInterruptionMonitor(withDescription:String,handler:(XCUIElement) -> Bool)*/
/*XCTest.(file).XCTestCase.addUIInterruptionMonitor(withDescription:String,handler:(XCUIElement) -> Bool)*/
addUIInterruptionMonitorWithDescriptionHandler(handlerDescription, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.addUIInterruptionMonitor(withDescription:String,handler:(XCUIElement) -> Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.addUIInterruptionMonitorWithDescription(_:String,handler:(XCUIElement) -> Bool)*/
/*XCTest.(file).XCTestCase.addUIInterruptionMonitorWithDescription(_:String,handler:(XCUIElement) -> Bool)*/
/*!!!DUPLICATE NAME*/
addUIInterruptionMonitorWithDescriptionHandler(handlerDescription, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.addUIInterruptionMonitorWithDescription(_:String,handler:(XCUIElement) -> Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.removeUIInterruptionMonitor(_:NSObjectProtocol)*/
/*XCTest.(file).XCTestCase.removeUIInterruptionMonitor(_:NSObjectProtocol)*/
removeUIInterruptionMonitor(monitor, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.removeUIInterruptionMonitor(_:NSObjectProtocol) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {
var proto = Object.getPrototypeOf(this)
var protoKeys = Object.keys(proto)
for(const testFunction of protoKeys) {
if(!testFunction.startsWith('test') || testFunction.endsWith('$get') || testFunction.endsWith('$set') || typeof Object.getOwnPropertyDescriptor(proto, testFunction).value !== 'function' || this[testFunction].length !== 1) continue
this.init$vars()
if(this.setUp) this.setUp()
this[testFunction]()
if(this.tearDown) this.tearDown()
}
}

static defaultTestSuite
static /*XCTest.(file).XCTestCase.setUp()*/
/*XCTest.(file).XCTestCase.setUp()*/
setUp($info?) {
throw 'unsupported method XCTest.(file).XCTestCase.setUp() in ' + this.constructor.name
}
static /*XCTest.(file).XCTestCase.tearDown()*/
/*XCTest.(file).XCTestCase.tearDown()*/
tearDown($info?) {
throw 'unsupported method XCTest.(file).XCTestCase.tearDown() in ' + this.constructor.name
}

_name
/*XCTest.(file).XCTestCase.add(_:XCTAttachment)*/
/*XCTest.(file).XCTestCase.add(_:XCTAttachment)*/
add(attachment, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.add(_:XCTAttachment) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectation(description:String)*/
/*XCTest.(file).XCTestCase.expectation(description:String)*/
expectationDescription(description, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectation(description:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectationWithDescription(_:String)*/
/*XCTest.(file).XCTestCase.expectationWithDescription(_:String)*/
expectationWithDescription(description, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectationWithDescription(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.waitForExpectations(timeout:TimeInterval,handler:XCWaitCompletionHandler?)*/
/*XCTest.(file).XCTestCase.waitForExpectations(timeout:TimeInterval,handler:XCWaitCompletionHandler?)*/
waitForExpectationsTimeoutHandler(timeout, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.waitForExpectations(timeout:TimeInterval,handler:XCWaitCompletionHandler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.waitForExpectationsWithTimeout(_:TimeInterval,handler:XCWaitCompletionHandler?)*/
/*XCTest.(file).XCTestCase.waitForExpectationsWithTimeout(_:TimeInterval,handler:XCWaitCompletionHandler?)*/
waitForExpectationsWithTimeoutHandler(timeout, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.waitForExpectationsWithTimeout(_:TimeInterval,handler:XCWaitCompletionHandler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.wait(for:[XCTestExpectation],timeout:TimeInterval)*/
/*XCTest.(file).XCTestCase.wait(for:[XCTestExpectation],timeout:TimeInterval)*/
waitForTimeout(expectations, seconds, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.wait(for:[XCTestExpectation],timeout:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval)*/
/*XCTest.(file).XCTestCase.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval)*/
waitForExpectationsTimeout(expectations, seconds, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
/*XCTest.(file).XCTestCase.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
waitForTimeoutEnforceOrder(expectations, seconds, enforceOrderOfFulfillment, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.wait(for:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
/*XCTest.(file).XCTestCase.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool)*/
waitForExpectationsTimeoutEnforceOrder(expectations, seconds, enforceOrderOfFulfillment, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.waitForExpectations(_:[XCTestExpectation],timeout:TimeInterval,enforceOrder:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.keyValueObservingExpectation(for:Any,keyPath:String,expectedValue:Any?)*/
/*XCTest.(file).XCTestCase.keyValueObservingExpectation(for:Any,keyPath:String,expectedValue:Any?)*/
keyValueObservingExpectationForKeyPathExpectedValue(objectToObserve, keyPath, expectedValue, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.keyValueObservingExpectation(for:Any,keyPath:String,expectedValue:Any?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.keyValueObservingExpectationForObject(_:Any,keyPath:String,expectedValue:Any?)*/
/*XCTest.(file).XCTestCase.keyValueObservingExpectationForObject(_:Any,keyPath:String,expectedValue:Any?)*/
keyValueObservingExpectationForObjectKeyPathExpectedValue(objectToObserve, keyPath, expectedValue, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.keyValueObservingExpectationForObject(_:Any,keyPath:String,expectedValue:Any?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.keyValueObservingExpectation(for:Any,keyPath:String,handler:XCTKVOExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.keyValueObservingExpectation(for:Any,keyPath:String,handler:XCTKVOExpectation.Handler?)*/
keyValueObservingExpectationForKeyPathHandler(objectToObserve, keyPath, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.keyValueObservingExpectation(for:Any,keyPath:String,handler:XCTKVOExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.keyValueObservingExpectationForObject(_:Any,keyPath:String,handler:XCTKVOExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.keyValueObservingExpectationForObject(_:Any,keyPath:String,handler:XCTKVOExpectation.Handler?)*/
keyValueObservingExpectationForObjectKeyPathHandler(objectToObserve, keyPath, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.keyValueObservingExpectationForObject(_:Any,keyPath:String,handler:XCTKVOExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectation(forNotification:NSNotification.Name,object:Any?,handler:XCTNSNotificationExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.expectation(forNotification:NSNotification.Name,object:Any?,handler:XCTNSNotificationExpectation.Handler?)*/
expectationForNotificationObjectHandler(notificationName, objectToObserve, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectation(forNotification:NSNotification.Name,object:Any?,handler:XCTNSNotificationExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectationForNotification(_:NSNotification.Name,object:Any?,handler:XCTNSNotificationExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.expectationForNotification(_:NSNotification.Name,object:Any?,handler:XCTNSNotificationExpectation.Handler?)*/
/*!!!DUPLICATE NAME*/
expectationForNotificationObjectHandler(notificationName, objectToObserve, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectationForNotification(_:NSNotification.Name,object:Any?,handler:XCTNSNotificationExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectation(forNotification:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter,handler:XCTNSNotificationExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.expectation(forNotification:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter,handler:XCTNSNotificationExpectation.Handler?)*/
expectationForNotificationObjectNotificationCenterHandler(notificationName, objectToObserve, notificationCenter, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectation(forNotification:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter,handler:XCTNSNotificationExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectationForNotification(_:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter,handler:XCTNSNotificationExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.expectationForNotification(_:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter,handler:XCTNSNotificationExpectation.Handler?)*/
/*!!!DUPLICATE NAME*/
expectationForNotificationObjectNotificationCenterHandler(notificationName, objectToObserve, notificationCenter, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectationForNotification(_:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter,handler:XCTNSNotificationExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectation(for:NSPredicate,evaluatedWith:Any?,handler:XCTNSPredicateExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.expectation(for:NSPredicate,evaluatedWith:Any?,handler:XCTNSPredicateExpectation.Handler?)*/
expectationForEvaluatedWithHandler(predicate, object, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectation(for:NSPredicate,evaluatedWith:Any?,handler:XCTNSPredicateExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.expectationForPredicate(_:NSPredicate,evaluatedWithObject:Any?,handler:XCTNSPredicateExpectation.Handler?)*/
/*XCTest.(file).XCTestCase.expectationForPredicate(_:NSPredicate,evaluatedWithObject:Any?,handler:XCTNSPredicateExpectation.Handler?)*/
expectationForPredicateEvaluatedWithObjectHandler(predicate, object, handler, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.expectationForPredicate(_:NSPredicate,evaluatedWithObject:Any?,handler:XCTNSPredicateExpectation.Handler?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.waiter(_:XCTWaiter,didTimeoutWithUnfulfilledExpectations:[XCTestExpectation])*/
/*XCTest.(file).XCTestCase.waiter(_:XCTWaiter,didTimeoutWithUnfulfilledExpectations:[XCTestExpectation])*/
waiterDidTimeoutWithUnfulfilledExpectations(waiter, unfulfilledExpectations, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.waiter(_:XCTWaiter,didTimeoutWithUnfulfilledExpectations:[XCTestExpectation]) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.waiter(_:XCTWaiter,fulfillmentDidViolateOrderingConstraintsFor:XCTestExpectation,requiredExpectation:XCTestExpectation)*/
/*XCTest.(file).XCTestCase.waiter(_:XCTWaiter,fulfillmentDidViolateOrderingConstraintsFor:XCTestExpectation,requiredExpectation:XCTestExpectation)*/
waiterFulfillmentDidViolateOrderingConstraintsForRequiredExpectation(waiter, expectation, requiredExpectation, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.waiter(_:XCTWaiter,fulfillmentDidViolateOrderingConstraintsFor:XCTestExpectation,requiredExpectation:XCTestExpectation) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.waiter(_:XCTWaiter,didFulfillInvertedExpectation:XCTestExpectation)*/
/*XCTest.(file).XCTestCase.waiter(_:XCTWaiter,didFulfillInvertedExpectation:XCTestExpectation)*/
waiterDidFulfillInvertedExpectation(waiter, expectation, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.waiter(_:XCTWaiter,didFulfillInvertedExpectation:XCTestExpectation) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCase.nestedWaiter(_:XCTWaiter,wasInterruptedByTimedOutWaiter:XCTWaiter)*/
/*XCTest.(file).XCTestCase.nestedWaiter(_:XCTWaiter,wasInterruptedByTimedOutWaiter:XCTWaiter)*/
nestedWaiterWasInterruptedByTimedOutWaiter(waiter, outerWaiter, $info?) {
throw 'unsupported method XCTest.(file).XCTestCase.nestedWaiter(_:XCTWaiter,wasInterruptedByTimedOutWaiter:XCTWaiter) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof XCTActivity$implementation != 'undefined') _mixin(XCTestCase, XCTActivity$implementation, false)
if(typeof XCTWaiterDelegate$implementation != 'undefined') _mixin(XCTestCase, XCTWaiterDelegate$implementation, false)








class XCTestError{
static readonly $struct = true


/*XCTest.(file).XCTestError.init(_nsError:NSError)*/
/*XCTest.(file).XCTestError.init(_nsError:NSError)*/
init_nsErrorNSError(_nsError, $info?) {
throw 'unsupported method XCTest.(file).XCTestError.init(_nsError:NSError) in ' + this.constructor.name
}

static errorDomain

static Code = class{
/*XCTest.(file).XCTestError.Code.init(rawValue:Int)*/
/*XCTest.(file).XCTestError.Code.init(rawValue:Int)*/
initRawValueInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCTestError.Code.init(rawValue:Int) in ' + this.constructor.name
}
static readonly initRawValueInt$failable = true



/*XCTest.(file).XCTestError.Code.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCTestError.Code.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };




static get timeoutWhileWaiting() {return Object.assign(new XCTestError.Code(), {rawValue: 0, ...Array.from(arguments)})}

static TimeoutWhileWaiting


static get failureWhileWaiting() {return Object.assign(new XCTestError.Code(), {rawValue: 1, ...Array.from(arguments)})}

static FailureWhileWaiting

init$vars() {let _this = this;

}
}

static timeoutWhileWaiting


static failureWhileWaiting

init$vars() {let _this = this;

}
}
_mixin(XCTestError.Code, _DefaultEnumImplementation, false)


class XCTestExpectation extends NSObject{

/*XCTest.(file).XCTestExpectation.init(description:String)*/
/*XCTest.(file).XCTestExpectation.init(description:String)*/
initDescriptionString(expectationDescription, $info?) {
throw 'unsupported method XCTest.(file).XCTestExpectation.init(description:String) in ' + this.constructor.name
}

expectationDescription

isInverted

inverted

expectedFulfillmentCount

assertForOverFulfill
/*XCTest.(file).XCTestExpectation.fulfill()*/
/*XCTest.(file).XCTestExpectation.fulfill()*/
fulfill($info?) {
throw 'unsupported method XCTest.(file).XCTestExpectation.fulfill() in ' + this.constructor.name
}
/*XCTest.(file).XCTestExpectation.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


interface XCTestObservation extends NSObjectProtocol{
/*XCTest.(file).XCTestObservation.testBundleWillStart(_:Bundle)*/
/*XCTest.(file).XCTestObservation.testBundleWillStart(_:Bundle)*/
testBundleWillStart(testBundle, $info?)
/*XCTest.(file).XCTestObservation.testBundleDidFinish(_:Bundle)*/
/*XCTest.(file).XCTestObservation.testBundleDidFinish(_:Bundle)*/
testBundleDidFinish(testBundle, $info?)
/*XCTest.(file).XCTestObservation.testSuiteWillStart(_:XCTestSuite)*/
/*XCTest.(file).XCTestObservation.testSuiteWillStart(_:XCTestSuite)*/
testSuiteWillStart(testSuite, $info?)
/*XCTest.(file).XCTestObservation.testSuite(_:XCTestSuite,didFailWithDescription:String,inFile:String?,atLine:Int)*/
/*XCTest.(file).XCTestObservation.testSuite(_:XCTestSuite,didFailWithDescription:String,inFile:String?,atLine:Int)*/
testSuiteDidFailWithDescriptionInFileAtLine(testSuite, description, filePath, lineNumber, $info?)
/*XCTest.(file).XCTestObservation.testSuiteDidFinish(_:XCTestSuite)*/
/*XCTest.(file).XCTestObservation.testSuiteDidFinish(_:XCTestSuite)*/
testSuiteDidFinish(testSuite, $info?)
/*XCTest.(file).XCTestObservation.testCaseWillStart(_:XCTestCase)*/
/*XCTest.(file).XCTestObservation.testCaseWillStart(_:XCTestCase)*/
testCaseWillStart(testCase, $info?)
/*XCTest.(file).XCTestObservation.testCase(_:XCTestCase,didFailWithDescription:String,inFile:String?,atLine:Int)*/
/*XCTest.(file).XCTestObservation.testCase(_:XCTestCase,didFailWithDescription:String,inFile:String?,atLine:Int)*/
testCaseDidFailWithDescriptionInFileAtLine(testCase, description, filePath, lineNumber, $info?)
/*XCTest.(file).XCTestObservation.testCaseDidFinish(_:XCTestCase)*/
/*XCTest.(file).XCTestObservation.testCaseDidFinish(_:XCTestCase)*/
testCaseDidFinish(testCase, $info?)
}
class XCTestObservation$implementation{
}
if(typeof NSObjectProtocol$implementation != 'undefined') _mixin(XCTestObservation$implementation, NSObjectProtocol$implementation, false)


class XCTestObservationCenter extends NSObject{


static shared

static sharedTestObservationCenter
/*XCTest.(file).XCTestObservationCenter.addTestObserver(_:XCTestObservation)*/
/*XCTest.(file).XCTestObservationCenter.addTestObserver(_:XCTestObservation)*/
addTestObserver(testObserver, $info?) {
throw 'unsupported method XCTest.(file).XCTestObservationCenter.addTestObserver(_:XCTestObservation) in ' + this.constructor.name
}
/*XCTest.(file).XCTestObservationCenter.removeTestObserver(_:XCTestObservation)*/
/*XCTest.(file).XCTestObservationCenter.removeTestObserver(_:XCTestObservation)*/
removeTestObserver(testObserver, $info?) {
throw 'unsupported method XCTest.(file).XCTestObservationCenter.removeTestObserver(_:XCTestObservation) in ' + this.constructor.name
}
/*XCTest.(file).XCTestObservationCenter.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCTestObserver extends NSObject{

/*XCTest.(file).XCTestObserver.startObserving()*/
/*XCTest.(file).XCTestObserver.startObserving()*/
startObserving($info?) {
throw 'unsupported method XCTest.(file).XCTestObserver.startObserving() in ' + this.constructor.name
}
/*XCTest.(file).XCTestObserver.stopObserving()*/
/*XCTest.(file).XCTestObserver.stopObserving()*/
stopObserving($info?) {
throw 'unsupported method XCTest.(file).XCTestObserver.stopObserving() in ' + this.constructor.name
}
/*XCTest.(file).XCTestObserver.testSuiteDidStart(_:XCTestRun?)*/
/*XCTest.(file).XCTestObserver.testSuiteDidStart(_:XCTestRun?)*/
testSuiteDidStart(testRun, $info?) {
throw 'unsupported method XCTest.(file).XCTestObserver.testSuiteDidStart(_:XCTestRun?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestObserver.testSuiteDidStop(_:XCTestRun?)*/
/*XCTest.(file).XCTestObserver.testSuiteDidStop(_:XCTestRun?)*/
testSuiteDidStop(testRun, $info?) {
throw 'unsupported method XCTest.(file).XCTestObserver.testSuiteDidStop(_:XCTestRun?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestObserver.testCaseDidStart(_:XCTestRun?)*/
/*XCTest.(file).XCTestObserver.testCaseDidStart(_:XCTestRun?)*/
testCaseDidStart(testRun, $info?) {
throw 'unsupported method XCTest.(file).XCTestObserver.testCaseDidStart(_:XCTestRun?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestObserver.testCaseDidStop(_:XCTestRun?)*/
/*XCTest.(file).XCTestObserver.testCaseDidStop(_:XCTestRun?)*/
testCaseDidStop(testRun, $info?) {
throw 'unsupported method XCTest.(file).XCTestObserver.testCaseDidStop(_:XCTestRun?) in ' + this.constructor.name
}
/*XCTest.(file).XCTestObserver.testCaseDidFail(_:XCTestRun?,withDescription:String?,inFile:String?,atLine:Int)*/
/*XCTest.(file).XCTestObserver.testCaseDidFail(_:XCTestRun?,withDescription:String?,inFile:String?,atLine:Int)*/
testCaseDidFailWithDescriptionInFileAtLine(testRun, description, filePath, lineNumber, $info?) {
throw 'unsupported method XCTest.(file).XCTestObserver.testCaseDidFail(_:XCTestRun?,withDescription:String?,inFile:String?,atLine:Int) in ' + this.constructor.name
}
/*XCTest.(file).XCTestObserver.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCTestProbe extends NSObject{

static /*XCTest.(file).XCTestProbe.isTesting()*/
/*XCTest.(file).XCTestProbe.isTesting()*/
isTesting($info?) {
throw 'unsupported method XCTest.(file).XCTestProbe.isTesting() in ' + this.constructor.name
}
/*XCTest.(file).XCTestProbe.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCTestRun extends NSObject{


/*XCTest.(file).XCTestRun.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTestRun.init(test:XCTest)*/
/*XCTest.(file).XCTestRun.init(test:XCTest)*/
initTestXCTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestRun.init(test:XCTest) in ' + this.constructor.name
}
static /*XCTest.(file).XCTestRun.testRunWithTest(_:XCTest)*/
/*XCTest.(file).XCTestRun.testRunWithTest(_:XCTest)*/
testRunWithTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestRun.testRunWithTest(_:XCTest) in ' + this.constructor.name
}
/*XCTest.(file).XCTestRun.init(test:XCTest)*/
/*XCTest.(file).XCTestRun.init(test:XCTest)*/
initTestXCTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestRun.init(test:XCTest) in ' + this.constructor.name
}

test
/*XCTest.(file).XCTestRun.start()*/
/*XCTest.(file).XCTestRun.start()*/
start($info?) {
throw 'unsupported method XCTest.(file).XCTestRun.start() in ' + this.constructor.name
}
/*XCTest.(file).XCTestRun.stop()*/
/*XCTest.(file).XCTestRun.stop()*/
stop($info?) {
throw 'unsupported method XCTest.(file).XCTestRun.stop() in ' + this.constructor.name
}

startDate

stopDate

totalDuration

testDuration

testCaseCount

executionCount

failureCount

unexpectedExceptionCount

totalFailureCount

hasSucceeded
/*XCTest.(file).XCTestRun.recordFailure(withDescription:String,inFile:String?,atLine:Int,expected:Bool)*/
/*XCTest.(file).XCTestRun.recordFailure(withDescription:String,inFile:String?,atLine:Int,expected:Bool)*/
recordFailureWithDescriptionInFileAtLineExpected(description, filePath, lineNumber, expected, $info?) {
throw 'unsupported method XCTest.(file).XCTestRun.recordFailure(withDescription:String,inFile:String?,atLine:Int,expected:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestRun.recordFailureWithDescription(_:String,inFile:String?,atLine:Int,expected:Bool)*/
/*XCTest.(file).XCTestRun.recordFailureWithDescription(_:String,inFile:String?,atLine:Int,expected:Bool)*/
/*!!!DUPLICATE NAME*/
recordFailureWithDescriptionInFileAtLineExpected(description, filePath, lineNumber, expected, $info?) {
throw 'unsupported method XCTest.(file).XCTestRun.recordFailureWithDescription(_:String,inFile:String?,atLine:Int,expected:Bool) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCTestSuite extends XCTest{


static _default

static defaultTestSuite
/*XCTest.(file).XCTestSuite.init(forBundlePath:String)*/
/*XCTest.(file).XCTestSuite.init(forBundlePath:String)*/
initForBundlePathString(bundlePath, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.init(forBundlePath:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCTestSuite.testSuiteForBundlePath(_:String)*/
/*XCTest.(file).XCTestSuite.testSuiteForBundlePath(_:String)*/
testSuiteForBundlePath(bundlePath, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.testSuiteForBundlePath(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTestSuite.init(forTestCaseWithName:String)*/
/*XCTest.(file).XCTestSuite.init(forTestCaseWithName:String)*/
initForTestCaseWithNameString(_name, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.init(forTestCaseWithName:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCTestSuite.testSuiteForTestCaseWithName(_:String)*/
/*XCTest.(file).XCTestSuite.testSuiteForTestCaseWithName(_:String)*/
testSuiteForTestCaseWithName(_name, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.testSuiteForTestCaseWithName(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTestSuite.init(forTestCaseClass:AnyClass)*/
/*XCTest.(file).XCTestSuite.init(forTestCaseClass:AnyClass)*/
initForTestCaseClassAnyClass(testCaseClass, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.init(forTestCaseClass:AnyClass) in ' + this.constructor.name
}
static /*XCTest.(file).XCTestSuite.testSuiteForTestCaseClass(_:AnyClass)*/
/*XCTest.(file).XCTestSuite.testSuiteForTestCaseClass(_:AnyClass)*/
testSuiteForTestCaseClass(testCaseClass, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.testSuiteForTestCaseClass(_:AnyClass) in ' + this.constructor.name
}
/*XCTest.(file).XCTestSuite.init(name:String)*/
/*XCTest.(file).XCTestSuite.init(name:String)*/
initNameString(_name, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.init(name:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCTestSuite.testSuiteWithName(_:String)*/
/*XCTest.(file).XCTestSuite.testSuiteWithName(_:String)*/
testSuiteWithName(_name, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.testSuiteWithName(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTestSuite.init(name:String)*/
/*XCTest.(file).XCTestSuite.init(name:String)*/
initNameString(_name, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.init(name:String) in ' + this.constructor.name
}

/*XCTest.(file).XCTestSuite.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTestSuite.addTest(_:XCTest)*/
/*XCTest.(file).XCTestSuite.addTest(_:XCTest)*/
addTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuite.addTest(_:XCTest) in ' + this.constructor.name
}

tests
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCTestSuiteRun extends XCTestRun{


testRuns
/*XCTest.(file).XCTestSuiteRun.addTestRun(_:XCTestRun)*/
/*XCTest.(file).XCTestSuiteRun.addTestRun(_:XCTestRun)*/
addTestRun(testRun, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuiteRun.addTestRun(_:XCTestRun) in ' + this.constructor.name
}
/*XCTest.(file).XCTestSuiteRun.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTestSuiteRun.init(test:XCTest)*/
/*XCTest.(file).XCTestSuiteRun.init(test:XCTest)*/
initTestXCTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuiteRun.init(test:XCTest) in ' + this.constructor.name
}
/*XCTest.(file).XCTestSuiteRun.init(test:XCTest)*/
/*XCTest.(file).XCTestRun.init(test:XCTest)*/
/*!!!DUPLICATE NAME*/
initTestXCTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestSuiteRun.init(test:XCTest) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCUICoordinate extends NSObject implements NSCopying{


/*XCTest.(file).XCUICoordinate.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

referencedElement

screenPoint
/*XCTest.(file).XCUICoordinate.withOffset(_:CGVector)*/
/*XCTest.(file).XCUICoordinate.withOffset(_:CGVector)*/
withOffset(offsetVector, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.withOffset(_:CGVector) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.coordinateWithOffset(_:CGVector)*/
/*XCTest.(file).XCUICoordinate.coordinateWithOffset(_:CGVector)*/
coordinateWithOffset(offsetVector, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.coordinateWithOffset(_:CGVector) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.copy(with:NSZone?)*/
/*XCTest.(file).XCUICoordinate.copy(with:NSZone?)*/
copyWith(zone, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.copy(with:NSZone?) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.hover()*/
/*XCTest.(file).XCUICoordinate.hover()*/
hover($info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.hover() in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.click()*/
/*XCTest.(file).XCUICoordinate.click()*/
click($info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.click() in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.doubleClick()*/
/*XCTest.(file).XCUICoordinate.doubleClick()*/
doubleClick($info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.doubleClick() in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.rightClick()*/
/*XCTest.(file).XCUICoordinate.rightClick()*/
rightClick($info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.rightClick() in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.click(forDuration:TimeInterval,thenDragTo:XCUICoordinate)*/
/*XCTest.(file).XCUICoordinate.click(forDuration:TimeInterval,thenDragTo:XCUICoordinate)*/
clickForDurationThenDragTo(duration, otherCoordinate, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.click(forDuration:TimeInterval,thenDragTo:XCUICoordinate) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.clickForDuration(_:TimeInterval,thenDragToCoordinate:XCUICoordinate)*/
/*XCTest.(file).XCUICoordinate.clickForDuration(_:TimeInterval,thenDragToCoordinate:XCUICoordinate)*/
clickForDurationThenDragToCoordinate(duration, otherCoordinate, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.clickForDuration(_:TimeInterval,thenDragToCoordinate:XCUICoordinate) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.scroll(byDeltaX:CGFloat,deltaY:CGFloat)*/
/*XCTest.(file).XCUICoordinate.scroll(byDeltaX:CGFloat,deltaY:CGFloat)*/
scrollByDeltaXDeltaY(deltaX, deltaY, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.scroll(byDeltaX:CGFloat,deltaY:CGFloat) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.scrollByDeltaX(_:CGFloat,deltaY:CGFloat)*/
/*XCTest.(file).XCUICoordinate.scrollByDeltaX(_:CGFloat,deltaY:CGFloat)*/
/*!!!DUPLICATE NAME*/
scrollByDeltaXDeltaY(deltaX, deltaY, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.scrollByDeltaX(_:CGFloat,deltaY:CGFloat) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.tap()*/
/*XCTest.(file).XCUICoordinate.tap()*/
tap($info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.tap() in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.doubleTap()*/
/*XCTest.(file).XCUICoordinate.doubleTap()*/
doubleTap($info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.doubleTap() in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.press(forDuration:TimeInterval)*/
/*XCTest.(file).XCUICoordinate.press(forDuration:TimeInterval)*/
pressForDuration(duration, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.press(forDuration:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.pressForDuration(_:TimeInterval)*/
/*XCTest.(file).XCUICoordinate.pressForDuration(_:TimeInterval)*/
/*!!!DUPLICATE NAME*/
pressForDuration(duration, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.pressForDuration(_:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.press(forDuration:TimeInterval,thenDragTo:XCUICoordinate)*/
/*XCTest.(file).XCUICoordinate.press(forDuration:TimeInterval,thenDragTo:XCUICoordinate)*/
pressForDurationThenDragTo(duration, otherCoordinate, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.press(forDuration:TimeInterval,thenDragTo:XCUICoordinate) in ' + this.constructor.name
}
/*XCTest.(file).XCUICoordinate.pressForDuration(_:TimeInterval,thenDragToCoordinate:XCUICoordinate)*/
/*XCTest.(file).XCUICoordinate.pressForDuration(_:TimeInterval,thenDragToCoordinate:XCUICoordinate)*/
pressForDurationThenDragToCoordinate(duration, otherCoordinate, $info?) {
throw 'unsupported method XCTest.(file).XCUICoordinate.pressForDuration(_:TimeInterval,thenDragToCoordinate:XCUICoordinate) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof NSCopying$implementation != 'undefined') _mixin(XCUICoordinate, NSCopying$implementation, false)






interface XCUIElementAttributes{

identifier

_frame

value

title

label

elementType

isEnabled

enabled

horizontalSizeClass

verticalSizeClass

placeholderValue

isSelected

selected
}
class XCUIElementAttributes$implementation{
}


interface XCUIElementSnapshot extends XCUIElementAttributes{

children

dictionaryRepresentation
}
class XCUIElementSnapshot$implementation{
}
if(typeof XCUIElementAttributes$implementation != 'undefined') _mixin(XCUIElementSnapshot$implementation, XCUIElementAttributes$implementation, false)


interface XCUIElementSnapshotProviding extends NSObjectProtocol{
/*XCTest.(file).XCUIElementSnapshotProviding.snapshot()*/
/*XCTest.(file).XCUIElementSnapshotProviding.snapshot()*/
snapshot($info?)
}
class XCUIElementSnapshotProviding$implementation{
}
if(typeof NSObjectProtocol$implementation != 'undefined') _mixin(XCUIElementSnapshotProviding$implementation, NSObjectProtocol$implementation, false)


interface XCUIElementTypeQueryProvider{

touchBars

groups

windows

sheets

drawers

alerts

dialogs

buttons

radioButtons

radioGroups

checkBoxes

disclosureTriangles

popUpButtons

comboBoxes

menuButtons

toolbarButtons

popovers

keyboards

keys

navigationBars

tabBars

tabGroups

toolbars

statusBars

tables

tableRows

tableColumns

outlines

outlineRows

disclosedChildRows

browsers

collectionViews

sliders

pageIndicators

progressIndicators

activityIndicators

segmentedControls

pickers

pickerWheels

switches

toggles

links

_images

icons

searchFields

scrollViews

scrollBars

staticTexts

textFields

secureTextFields

datePickers

textViews

menus

menuItems

menuBars

menuBarItems

maps

webViews

steppers

incrementArrows

decrementArrows

tabs

timelines

ratingIndicators

valueIndicators

splitGroups

splitters

relevanceIndicators

colorWells

helpTags

mattes

dockItems

rulers

rulerMarkers

grids

levelIndicators

cells

layoutAreas

layoutItems

handles

otherElements

statusItems

firstMatch
}
class XCUIElementTypeQueryProvider$implementation{
}


class XCUIKeyboardKey{
static readonly $struct = true
/*XCTest.(file).XCUIKeyboardKey.init(_:String)*/
/*XCTest.(file).XCUIKeyboardKey.init(_:String)*/
initString(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIKeyboardKey.init(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCUIKeyboardKey.init(rawValue:String)*/
/*XCTest.(file).XCUIKeyboardKey.init(rawValue:String)*/
initRawValueString(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIKeyboardKey.init(rawValue:String) in ' + this.constructor.name
}



/*XCTest.(file).XCUIKeyboardKey.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCUIKeyboardKey.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };






static readonly _delete

static readonly XCUIKeyboardKeyDelete

static readonly _return

static readonly XCUIKeyboardKeyReturn

static readonly enter

static readonly XCUIKeyboardKeyEnter

static readonly tab

static readonly XCUIKeyboardKeyTab

static readonly space

static readonly XCUIKeyboardKeySpace

static readonly _escape

static readonly XCUIKeyboardKeyEscape

static readonly upArrow

static readonly XCUIKeyboardKeyUpArrow

static readonly downArrow

static readonly XCUIKeyboardKeyDownArrow

static readonly leftArrow

static readonly XCUIKeyboardKeyLeftArrow

static readonly rightArrow

static readonly XCUIKeyboardKeyRightArrow

static readonly F1

static readonly XCUIKeyboardKeyF1

static readonly F2

static readonly XCUIKeyboardKeyF2

static readonly F3

static readonly XCUIKeyboardKeyF3

static readonly F4

static readonly XCUIKeyboardKeyF4

static readonly F5

static readonly XCUIKeyboardKeyF5

static readonly F6

static readonly XCUIKeyboardKeyF6

static readonly F7

static readonly XCUIKeyboardKeyF7

static readonly F8

static readonly XCUIKeyboardKeyF8

static readonly F9

static readonly XCUIKeyboardKeyF9

static readonly F10

static readonly XCUIKeyboardKeyF10

static readonly F11

static readonly XCUIKeyboardKeyF11

static readonly F12

static readonly XCUIKeyboardKeyF12

static readonly F13

static readonly XCUIKeyboardKeyF13

static readonly F14

static readonly XCUIKeyboardKeyF14

static readonly F15

static readonly XCUIKeyboardKeyF15

static readonly F16

static readonly XCUIKeyboardKeyF16

static readonly F17

static readonly XCUIKeyboardKeyF17

static readonly F18

static readonly XCUIKeyboardKeyF18

static readonly F19

static readonly XCUIKeyboardKeyF19

static readonly forwardDelete

static readonly XCUIKeyboardKeyForwardDelete

static readonly home

static readonly XCUIKeyboardKeyHome

static readonly end

static readonly XCUIKeyboardKeyEnd

static readonly pageUp

static readonly XCUIKeyboardKeyPageUp

static readonly pageDown

static readonly XCUIKeyboardKeyPageDown

static readonly clear

static readonly XCUIKeyboardKeyClear

static readonly help

static readonly XCUIKeyboardKeyHelp

static readonly capsLock

static readonly XCUIKeyboardKeyCapsLock

static readonly shift

static readonly XCUIKeyboardKeyShift

static readonly control

static readonly XCUIKeyboardKeyControl

static readonly _option

static readonly XCUIKeyboardKeyOption

static readonly command

static readonly XCUIKeyboardKeyCommand

static readonly rightShift

static readonly XCUIKeyboardKeyRightShift

static readonly rightControl

static readonly XCUIKeyboardKeyRightControl

static readonly rightOption

static readonly XCUIKeyboardKeyRightOption

static readonly rightCommand

static readonly XCUIKeyboardKeyRightCommand

static readonly secondaryFn

static readonly XCUIKeyboardKeySecondaryFn
init$vars() {let _this = this;

}
}




class XCUIRemoteButton{
/*XCTest.(file).XCUIRemoteButton.init(rawValue:UInt)*/
/*XCTest.(file).XCUIRemoteButton.init(rawValue:UInt)*/
initRawValueUInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIRemoteButton.init(rawValue:UInt) in ' + this.constructor.name
}
static readonly initRawValueUInt$failable = true



/*XCTest.(file).XCUIRemoteButton.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCUIRemoteButton.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get up() {return Object.assign(new XCUIRemoteButton(), {rawValue: 0, ...Array.from(arguments)})}

static Up


static get down() {return Object.assign(new XCUIRemoteButton(), {rawValue: 1, ...Array.from(arguments)})}

static Down


static get left() {return Object.assign(new XCUIRemoteButton(), {rawValue: 2, ...Array.from(arguments)})}

static Left


static get right() {return Object.assign(new XCUIRemoteButton(), {rawValue: 3, ...Array.from(arguments)})}

static Right


static get _select() {return Object.assign(new XCUIRemoteButton(), {rawValue: 4, ...Array.from(arguments)})}

static Select


static get menu() {return Object.assign(new XCUIRemoteButton(), {rawValue: 5, ...Array.from(arguments)})}

static Menu


static get playPause() {return Object.assign(new XCUIRemoteButton(), {rawValue: 6, ...Array.from(arguments)})}

static PlayPause


static get home() {return Object.assign(new XCUIRemoteButton(), {rawValue: 7, ...Array.from(arguments)})}

static Home

init$vars() {let _this = this;

}
}
_mixin(XCUIRemoteButton, _DefaultEnumImplementation, false)


class XCUIScreenshot extends NSObject{


/*XCTest.(file).XCUIScreenshot.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

_image

pngRepresentation

PNGRepresentation
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


interface XCUIScreenshotProviding extends NSObjectProtocol{
/*XCTest.(file).XCUIScreenshotProviding.screenshot()*/
/*XCTest.(file).XCUIScreenshotProviding.screenshot()*/
screenshot($info?)
}
class XCUIScreenshotProviding$implementation{
}
if(typeof NSObjectProtocol$implementation != 'undefined') _mixin(XCUIScreenshotProviding$implementation, NSObjectProtocol$implementation, false)


class _XCTAssertionType{
/*XCTest.(file)._XCTAssertionType.init(rawValue:UInt)*/
/*XCTest.(file)._XCTAssertionType.init(rawValue:UInt)*/
initRawValueUInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file)._XCTAssertionType.init(rawValue:UInt) in ' + this.constructor.name
}
static readonly initRawValueUInt$failable = true



/*XCTest.(file)._XCTAssertionType.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file)._XCTAssertionType.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get fail() {return Object.assign(new _XCTAssertionType(), {rawValue: 0, ...Array.from(arguments)})}

static Fail


static get nil() {return Object.assign(new _XCTAssertionType(), {rawValue: 1, ...Array.from(arguments)})}

static Nil


static get notNil() {return Object.assign(new _XCTAssertionType(), {rawValue: 2, ...Array.from(arguments)})}

static NotNil


static get equalObjects() {return Object.assign(new _XCTAssertionType(), {rawValue: 3, ...Array.from(arguments)})}

static EqualObjects


static get notEqualObjects() {return Object.assign(new _XCTAssertionType(), {rawValue: 4, ...Array.from(arguments)})}

static NotEqualObjects


static get equal() {return Object.assign(new _XCTAssertionType(), {rawValue: 5, ...Array.from(arguments)})}

static Equal


static get notEqual() {return Object.assign(new _XCTAssertionType(), {rawValue: 6, ...Array.from(arguments)})}

static NotEqual


static get equalWithAccuracy() {return Object.assign(new _XCTAssertionType(), {rawValue: 7, ...Array.from(arguments)})}

static EqualWithAccuracy


static get notEqualWithAccuracy() {return Object.assign(new _XCTAssertionType(), {rawValue: 8, ...Array.from(arguments)})}

static NotEqualWithAccuracy


static get greaterThan() {return Object.assign(new _XCTAssertionType(), {rawValue: 9, ...Array.from(arguments)})}

static GreaterThan


static get greaterThanOrEqual() {return Object.assign(new _XCTAssertionType(), {rawValue: 10, ...Array.from(arguments)})}

static GreaterThanOrEqual


static get lessThan() {return Object.assign(new _XCTAssertionType(), {rawValue: 11, ...Array.from(arguments)})}

static LessThan


static get lessThanOrEqual() {return Object.assign(new _XCTAssertionType(), {rawValue: 12, ...Array.from(arguments)})}

static LessThanOrEqual


static get _true() {return Object.assign(new _XCTAssertionType(), {rawValue: 13, ...Array.from(arguments)})}

static True


static get _false() {return Object.assign(new _XCTAssertionType(), {rawValue: 14, ...Array.from(arguments)})}

static False


static get _throws() {return Object.assign(new _XCTAssertionType(), {rawValue: 15, ...Array.from(arguments)})}

static Throws


static get throwsSpecific() {return Object.assign(new _XCTAssertionType(), {rawValue: 16, ...Array.from(arguments)})}

static ThrowsSpecific


static get throwsSpecificNamed() {return Object.assign(new _XCTAssertionType(), {rawValue: 17, ...Array.from(arguments)})}

static ThrowsSpecificNamed


static get noThrow() {return Object.assign(new _XCTAssertionType(), {rawValue: 18, ...Array.from(arguments)})}

static NoThrow


static get noThrowSpecific() {return Object.assign(new _XCTAssertionType(), {rawValue: 19, ...Array.from(arguments)})}

static NoThrowSpecific


static get noThrowSpecificNamed() {return Object.assign(new _XCTAssertionType(), {rawValue: 20, ...Array.from(arguments)})}

static NoThrowSpecificNamed

init$vars() {let _this = this;

}
}
_mixin(_XCTAssertionType, _DefaultEnumImplementation, false)


class _XCTestCaseInterruptionException extends NSException{

/*XCTest.(file)._XCTestCaseInterruptionException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
/*Foundation.(file).NSException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?)*/
initNameNSExceptionNameReasonOptionalUserInfoOptional(aName, aReason, aUserInfo, $info?) {
throw 'unsupported method XCTest.(file)._XCTestCaseInterruptionException.init(name:NSExceptionName,reason:String?,userInfo:[AnyHashable : Any]?) in ' + this.constructor.name
}
/*XCTest.(file)._XCTestCaseInterruptionException.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file)._XCTestCaseInterruptionException.init(coder:NSCoder)*/
/*Foundation.(file).NSException.init(coder:NSCoder)*/
initCoderNSCoder(aDecoder, $info?) {
throw 'unsupported method XCTest.(file)._XCTestCaseInterruptionException.init(coder:NSCoder) in ' + this.constructor.name
}
static readonly initCoderNSCoder$failable = true
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class _XCTThrowableBlockResult{

static get success() {return Object.assign(new _XCTThrowableBlockResult(), {rawValue: "success", ...Array.from(arguments)})}

static failedWithError() {return Object.assign(new _XCTThrowableBlockResult(), {rawValue: "failedWithError", ...Array.from(arguments)})}

static failedWithException() {return Object.assign(new _XCTThrowableBlockResult(), {rawValue: "failedWithException", ...Array.from(arguments)})}

static get failedWithUnknownException() {return Object.assign(new _XCTThrowableBlockResult(), {rawValue: "failedWithUnknownException", ...Array.from(arguments)})}
init$vars() {let _this = this;

}
}
_mixin(_XCTThrowableBlockResult, _DefaultEnumImplementation, false)


class XCTDarwinNotificationExpectation extends XCTestExpectation{


/*XCTest.(file).XCTDarwinNotificationExpectation.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTDarwinNotificationExpectation.init(description:String)*/
/*XCTest.(file).XCTestExpectation.init(description:String)*/
initDescriptionString(expectationDescription, $info?) {
throw 'unsupported method XCTest.(file).XCTDarwinNotificationExpectation.init(description:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTDarwinNotificationExpectation.init(notificationName:String)*/
/*XCTest.(file).XCTDarwinNotificationExpectation.init(notificationName:String)*/
initNotificationNameString(notificationName, $info?) {
throw 'unsupported method XCTest.(file).XCTDarwinNotificationExpectation.init(notificationName:String) in ' + this.constructor.name
}

notificationName

handler

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}




class XCTKVOExpectation extends XCTestExpectation{


/*XCTest.(file).XCTKVOExpectation.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTKVOExpectation.init(description:String)*/
/*XCTest.(file).XCTestExpectation.init(description:String)*/
initDescriptionString(expectationDescription, $info?) {
throw 'unsupported method XCTest.(file).XCTKVOExpectation.init(description:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any,expectedValue:Any?,options:NSKeyValueObservingOptions)*/
/*XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any,expectedValue:Any?,options:NSKeyValueObservingOptions)*/
initKeyPathStringObjectprotocol_composition_typeExpectedValueOptionalOptionsNSKeyValueObservingOptions(keyPath, object, expectedValue, options, $info?) {
throw 'unsupported method XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any,expectedValue:Any?,options:NSKeyValueObservingOptions) in ' + this.constructor.name
}
/*XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any,expectedValue:Any?)*/
/*XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any,expectedValue:Any?)*/
initKeyPathStringObjectprotocol_composition_typeExpectedValueOptional(keyPath, object, expectedValue, $info?) {
throw 'unsupported method XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any,expectedValue:Any?) in ' + this.constructor.name
}
/*XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any)*/
/*XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any)*/
initKeyPathStringObjectprotocol_composition_type(keyPath, object, $info?) {
throw 'unsupported method XCTest.(file).XCTKVOExpectation.init(keyPath:String,object:Any) in ' + this.constructor.name
}

keyPath

observedObject

expectedValue

options

handler

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}




class XCTNSNotificationExpectation extends XCTestExpectation{


/*XCTest.(file).XCTNSNotificationExpectation.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTNSNotificationExpectation.init(description:String)*/
/*XCTest.(file).XCTestExpectation.init(description:String)*/
initDescriptionString(expectationDescription, $info?) {
throw 'unsupported method XCTest.(file).XCTNSNotificationExpectation.init(description:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter)*/
/*XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter)*/
initNameNSNotificationNameObjectOptionalNotificationCenterNotificationCenter(notificationName, object, notificationCenter, $info?) {
throw 'unsupported method XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name,object:Any?,notificationCenter:NotificationCenter) in ' + this.constructor.name
}
/*XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name,object:Any?)*/
/*XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name,object:Any?)*/
initNameNSNotificationNameObjectOptional(notificationName, object, $info?) {
throw 'unsupported method XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name,object:Any?) in ' + this.constructor.name
}
/*XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name)*/
/*XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name)*/
initNameNSNotificationName(notificationName, $info?) {
throw 'unsupported method XCTest.(file).XCTNSNotificationExpectation.init(name:NSNotification.Name) in ' + this.constructor.name
}

notificationName

observedObject

notificationCenter

handler

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}




class XCTNSPredicateExpectation extends XCTestExpectation{


/*XCTest.(file).XCTNSPredicateExpectation.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTNSPredicateExpectation.init(description:String)*/
/*XCTest.(file).XCTestExpectation.init(description:String)*/
initDescriptionString(expectationDescription, $info?) {
throw 'unsupported method XCTest.(file).XCTNSPredicateExpectation.init(description:String) in ' + this.constructor.name
}
/*XCTest.(file).XCTNSPredicateExpectation.init(predicate:NSPredicate,object:Any?)*/
/*XCTest.(file).XCTNSPredicateExpectation.init(predicate:NSPredicate,object:Any?)*/
initPredicateNSPredicateObjectOptional(predicate, object, $info?) {
throw 'unsupported method XCTest.(file).XCTNSPredicateExpectation.init(predicate:NSPredicate,object:Any?) in ' + this.constructor.name
}

predicate

object

handler

expectedFulfillmentCount

init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}




class XCTestCaseRun extends XCTestRun{

/*XCTest.(file).XCTestCaseRun.recordFailure(inTest:XCTestCase,withDescription:String,inFile:String,atLine:Int,expected:Bool)*/
/*XCTest.(file).XCTestCaseRun.recordFailure(inTest:XCTestCase,withDescription:String,inFile:String,atLine:Int,expected:Bool)*/
recordFailureInTestWithDescriptionInFileAtLineExpected(testCase, description, filePath, lineNumber, expected, $info?) {
throw 'unsupported method XCTest.(file).XCTestCaseRun.recordFailure(inTest:XCTestCase,withDescription:String,inFile:String,atLine:Int,expected:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCaseRun.recordFailureInTest(_:XCTestCase,withDescription:String,inFile:String,atLine:Int,expected:Bool)*/
/*XCTest.(file).XCTestCaseRun.recordFailureInTest(_:XCTestCase,withDescription:String,inFile:String,atLine:Int,expected:Bool)*/
/*!!!DUPLICATE NAME*/
recordFailureInTestWithDescriptionInFileAtLineExpected(testCase, description, filePath, lineNumber, expected, $info?) {
throw 'unsupported method XCTest.(file).XCTestCaseRun.recordFailureInTest(_:XCTestCase,withDescription:String,inFile:String,atLine:Int,expected:Bool) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCaseRun.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
/*XCTest.(file).XCTestCaseRun.init(test:XCTest)*/
/*XCTest.(file).XCTestCaseRun.init(test:XCTest)*/
initTestXCTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestCaseRun.init(test:XCTest) in ' + this.constructor.name
}
/*XCTest.(file).XCTestCaseRun.init(test:XCTest)*/
/*XCTest.(file).XCTestRun.init(test:XCTest)*/
/*!!!DUPLICATE NAME*/
initTestXCTest(test, $info?) {
throw 'unsupported method XCTest.(file).XCTestCaseRun.init(test:XCTest) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCTestLog extends XCTestObserver{


logFileHandle
/*XCTest.(file).XCTestLog.testLog(withFormat:String?,arguments:CVaListPointer)*/
/*XCTest.(file).XCTestLog.testLog(withFormat:String?,arguments:CVaListPointer)*/
testLogWithFormatArguments(format, _arguments, $info?) {
throw 'unsupported method XCTest.(file).XCTestLog.testLog(withFormat:String?,arguments:CVaListPointer) in ' + this.constructor.name
}
/*XCTest.(file).XCTestLog.testLogWithFormat(_:String?,arguments:CVaListPointer)*/
/*XCTest.(file).XCTestLog.testLogWithFormat(_:String?,arguments:CVaListPointer)*/
/*!!!DUPLICATE NAME*/
testLogWithFormatArguments(format, _arguments, $info?) {
throw 'unsupported method XCTest.(file).XCTestLog.testLogWithFormat(_:String?,arguments:CVaListPointer) in ' + this.constructor.name
}
/*XCTest.(file).XCTestLog.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}


class XCUIElement extends NSObject implements XCUIElementAttributes, XCUIElementTypeQueryProvider, XCUIScreenshotProviding, XCUIElementSnapshotProviding{


/*XCTest.(file).XCUIElement.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

exists
/*XCTest.(file).XCUIElement.waitForExistence(timeout:TimeInterval)*/
/*XCTest.(file).XCUIElement.waitForExistence(timeout:TimeInterval)*/
waitForExistenceTimeout(timeout, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.waitForExistence(timeout:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.waitForExistenceWithTimeout(_:TimeInterval)*/
/*XCTest.(file).XCUIElement.waitForExistenceWithTimeout(_:TimeInterval)*/
waitForExistenceWithTimeout(timeout, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.waitForExistenceWithTimeout(_:TimeInterval) in ' + this.constructor.name
}

isHittable

hittable
/*XCTest.(file).XCUIElement.descendants(matching:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElement.descendants(matching:XCUIElement.ElementType)*/
descendantsMatching(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.descendants(matching:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.descendantsMatchingType(_:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElement.descendantsMatchingType(_:XCUIElement.ElementType)*/
descendantsMatchingType(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.descendantsMatchingType(_:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.children(matching:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElement.children(matching:XCUIElement.ElementType)*/
childrenMatching(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.children(matching:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.childrenMatchingType(_:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElement.childrenMatchingType(_:XCUIElement.ElementType)*/
childrenMatchingType(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.childrenMatchingType(_:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.coordinate(withNormalizedOffset:CGVector)*/
/*XCTest.(file).XCUIElement.coordinate(withNormalizedOffset:CGVector)*/
coordinateWithNormalizedOffset(normalizedOffset, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.coordinate(withNormalizedOffset:CGVector) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.coordinateWithNormalizedOffset(_:CGVector)*/
/*XCTest.(file).XCUIElement.coordinateWithNormalizedOffset(_:CGVector)*/
/*!!!DUPLICATE NAME*/
coordinateWithNormalizedOffset(normalizedOffset, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.coordinateWithNormalizedOffset(_:CGVector) in ' + this.constructor.name
}

debugDescription

identifier

_frame

value

title

label

elementType

isEnabled

horizontalSizeClass

verticalSizeClass

placeholderValue

isSelected

touchBars

groups

windows

sheets

drawers

alerts

dialogs

buttons

radioButtons

radioGroups

checkBoxes

disclosureTriangles

popUpButtons

comboBoxes

menuButtons

toolbarButtons

popovers

keyboards

keys

navigationBars

tabBars

tabGroups

toolbars

statusBars

tables

tableRows

tableColumns

outlines

outlineRows

disclosedChildRows

browsers

collectionViews

sliders

pageIndicators

progressIndicators

activityIndicators

segmentedControls

pickers

pickerWheels

switches

toggles

links

_images

icons

searchFields

scrollViews

scrollBars

staticTexts

textFields

secureTextFields

datePickers

textViews

menus

menuItems

menuBars

menuBarItems

maps

webViews

steppers

incrementArrows

decrementArrows

tabs

timelines

ratingIndicators

valueIndicators

splitGroups

splitters

relevanceIndicators

colorWells

helpTags

mattes

dockItems

rulers

rulerMarkers

grids

levelIndicators

cells

layoutAreas

layoutItems

handles

otherElements

statusItems

firstMatch
static ElementType = class{
/*XCTest.(file).XCUIElement.ElementType.init(rawValue:UInt)*/
/*XCTest.(file).XCUIElement.ElementType.init(rawValue:UInt)*/
initRawValueUInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.ElementType.init(rawValue:UInt) in ' + this.constructor.name
}
static readonly initRawValueUInt$failable = true



/*XCTest.(file).XCUIElement.ElementType.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCUIElement.ElementType.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get any() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 0, ...Array.from(arguments)})}

static Any


static get other() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 1, ...Array.from(arguments)})}

static Other


static get application() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 2, ...Array.from(arguments)})}

static Application


static get group() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 3, ...Array.from(arguments)})}

static Group


static get window() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 4, ...Array.from(arguments)})}

static Window


static get sheet() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 5, ...Array.from(arguments)})}

static Sheet


static get drawer() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 6, ...Array.from(arguments)})}

static Drawer


static get alert() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 7, ...Array.from(arguments)})}

static Alert


static get dialog() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 8, ...Array.from(arguments)})}

static Dialog


static get _button() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 9, ...Array.from(arguments)})}

static Button


static get radioButton() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 10, ...Array.from(arguments)})}

static RadioButton


static get radioGroup() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 11, ...Array.from(arguments)})}

static RadioGroup


static get checkBox() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 12, ...Array.from(arguments)})}

static CheckBox


static get disclosureTriangle() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 13, ...Array.from(arguments)})}

static DisclosureTriangle


static get popUpButton() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 14, ...Array.from(arguments)})}

static PopUpButton


static get comboBox() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 15, ...Array.from(arguments)})}

static ComboBox


static get menuButton() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 16, ...Array.from(arguments)})}

static MenuButton


static get toolbarButton() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 17, ...Array.from(arguments)})}

static ToolbarButton


static get popover() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 18, ...Array.from(arguments)})}

static Popover


static get keyboard() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 19, ...Array.from(arguments)})}

static Keyboard


static get key() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 20, ...Array.from(arguments)})}

static Key


static get navigationBar() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 21, ...Array.from(arguments)})}

static NavigationBar


static get tabBar() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 22, ...Array.from(arguments)})}

static TabBar


static get tabGroup() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 23, ...Array.from(arguments)})}

static TabGroup


static get toolbar() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 24, ...Array.from(arguments)})}

static Toolbar


static get statusBar() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 25, ...Array.from(arguments)})}

static StatusBar


static get table() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 26, ...Array.from(arguments)})}

static Table


static get tableRow() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 27, ...Array.from(arguments)})}

static TableRow


static get tableColumn() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 28, ...Array.from(arguments)})}

static TableColumn


static get outline() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 29, ...Array.from(arguments)})}

static Outline


static get outlineRow() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 30, ...Array.from(arguments)})}

static OutlineRow


static get browser() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 31, ...Array.from(arguments)})}

static Browser


static get collectionView() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 32, ...Array.from(arguments)})}

static CollectionView


static get slider() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 33, ...Array.from(arguments)})}

static Slider


static get pageIndicator() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 34, ...Array.from(arguments)})}

static PageIndicator


static get progressIndicator() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 35, ...Array.from(arguments)})}

static ProgressIndicator


static get activityIndicator() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 36, ...Array.from(arguments)})}

static ActivityIndicator


static get segmentedControl() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 37, ...Array.from(arguments)})}

static SegmentedControl


static get picker() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 38, ...Array.from(arguments)})}

static Picker


static get pickerWheel() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 39, ...Array.from(arguments)})}

static PickerWheel


static get _switch() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 40, ...Array.from(arguments)})}

static Switch


static get toggle() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 41, ...Array.from(arguments)})}

static Toggle


static get _link() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 42, ...Array.from(arguments)})}

static Link


static get _image() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 43, ...Array.from(arguments)})}

static Image


static get icon() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 44, ...Array.from(arguments)})}

static Icon


static get searchField() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 45, ...Array.from(arguments)})}

static SearchField


static get scrollView() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 46, ...Array.from(arguments)})}

static ScrollView


static get scrollBar() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 47, ...Array.from(arguments)})}

static ScrollBar


static get staticText() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 48, ...Array.from(arguments)})}

static StaticText


static get textField() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 49, ...Array.from(arguments)})}

static TextField


static get secureTextField() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 50, ...Array.from(arguments)})}

static SecureTextField


static get datePicker() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 51, ...Array.from(arguments)})}

static DatePicker


static get textView() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 52, ...Array.from(arguments)})}

static TextView


static get menu() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 53, ...Array.from(arguments)})}

static Menu


static get menuItem() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 54, ...Array.from(arguments)})}

static MenuItem


static get menuBar() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 55, ...Array.from(arguments)})}

static MenuBar


static get menuBarItem() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 56, ...Array.from(arguments)})}

static MenuBarItem


static get map() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 57, ...Array.from(arguments)})}

static Map


static get webView() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 58, ...Array.from(arguments)})}

static WebView


static get incrementArrow() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 59, ...Array.from(arguments)})}

static IncrementArrow


static get decrementArrow() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 60, ...Array.from(arguments)})}

static DecrementArrow


static get timeline() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 61, ...Array.from(arguments)})}

static Timeline


static get ratingIndicator() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 62, ...Array.from(arguments)})}

static RatingIndicator


static get valueIndicator() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 63, ...Array.from(arguments)})}

static ValueIndicator


static get splitGroup() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 64, ...Array.from(arguments)})}

static SplitGroup


static get splitter() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 65, ...Array.from(arguments)})}

static Splitter


static get relevanceIndicator() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 66, ...Array.from(arguments)})}

static RelevanceIndicator


static get colorWell() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 67, ...Array.from(arguments)})}

static ColorWell


static get helpTag() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 68, ...Array.from(arguments)})}

static HelpTag


static get matte() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 69, ...Array.from(arguments)})}

static Matte


static get dockItem() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 70, ...Array.from(arguments)})}

static DockItem


static get ruler() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 71, ...Array.from(arguments)})}

static Ruler


static get rulerMarker() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 72, ...Array.from(arguments)})}

static RulerMarker


static get grid() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 73, ...Array.from(arguments)})}

static Grid


static get levelIndicator() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 74, ...Array.from(arguments)})}

static LevelIndicator


static get cell() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 75, ...Array.from(arguments)})}

static Cell


static get layoutArea() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 76, ...Array.from(arguments)})}

static LayoutArea


static get layoutItem() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 77, ...Array.from(arguments)})}

static LayoutItem


static get handle() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 78, ...Array.from(arguments)})}

static Handle


static get stepper() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 79, ...Array.from(arguments)})}

static Stepper


static get tab() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 80, ...Array.from(arguments)})}

static Tab


static get touchBar() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 81, ...Array.from(arguments)})}

static TouchBar


static get statusItem() {return Object.assign(new XCUIElement.ElementType(), {rawValue: 82, ...Array.from(arguments)})}

static StatusItem

init$vars() {let _this = this;

}
}
static SizeClass = class{
/*XCTest.(file).XCUIElement.SizeClass.init(rawValue:Int)*/
/*XCTest.(file).XCUIElement.SizeClass.init(rawValue:Int)*/
initRawValueInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.SizeClass.init(rawValue:Int) in ' + this.constructor.name
}
static readonly initRawValueInt$failable = true



/*XCTest.(file).XCUIElement.SizeClass.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCUIElement.SizeClass.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get unspecified() {return Object.assign(new XCUIElement.SizeClass(), {rawValue: 0, ...Array.from(arguments)})}

static Unspecified

init$vars() {let _this = this;

}
}
static AttributeName = class{
static readonly $struct = true
/*XCTest.(file).XCUIElement.AttributeName.init(rawValue:String)*/
/*XCTest.(file).XCUIElement.AttributeName.init(rawValue:String)*/
initRawValueString(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.AttributeName.init(rawValue:String) in ' + this.constructor.name
}



/*XCTest.(file).XCUIElement.AttributeName.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCUIElement.AttributeName.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };






static readonly children

static readonly elementType

static readonly identifier

static readonly value

static readonly placeholderValue

static readonly title

static readonly label

static readonly _frame

static readonly enabled

static readonly selected

static readonly hasFocus

static readonly horizontalSizeClass

static readonly verticalSizeClass
init$vars() {let _this = this;

}
}
static KeyModifierFlags = class{
static readonly $struct = true
/*XCTest.(file).XCUIElement.KeyModifierFlags.init(rawValue:UInt)*/
/*XCTest.(file).XCUIElement.KeyModifierFlags.init(rawValue:UInt)*/
initRawValueUInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.KeyModifierFlags.init(rawValue:UInt) in ' + this.constructor.name
}

/*XCTest.(file).XCUIElement.KeyModifierFlags.rawValue*/
readonly rawValue$get() {
throw 'unsupported variable XCTest.(file).XCUIElement.KeyModifierFlags.rawValue in ' + this.constructor.name
}
readonly get rawValue() { return this.rawValue$get() };







static none


static None


static capsLock


static CapsLock


static shift


static Shift


static control


static Control


static _option


static Option


static command


static Command


static alphaShift


static AlphaShift


static alternate


static Alternate

init$vars() {let _this = this;

}
}
/*XCTest.(file).XCUIElement.screenshot()*/
/*XCTest.(file).XCUIElement.screenshot()*/
screenshot($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.screenshot() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.typeText(_:String)*/
/*XCTest.(file).XCUIElement.typeText(_:String)*/
typeText(text, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.typeText(_:String) in ' + this.constructor.name
}
static /*XCTest.(file).XCUIElement.perform(withKeyModifiers:XCUIElement.KeyModifierFlags,block:() -> Void)*/
/*XCTest.(file).XCUIElement.perform(withKeyModifiers:XCUIElement.KeyModifierFlags,block:() -> Void)*/
performWithKeyModifiersBlock(flags, block, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.perform(withKeyModifiers:XCUIElement.KeyModifierFlags,block:() -> Void) in ' + this.constructor.name
}
static /*XCTest.(file).XCUIElement.performWithKeyModifiers(_:XCUIElement.KeyModifierFlags,block:() -> Void)*/
/*XCTest.(file).XCUIElement.performWithKeyModifiers(_:XCUIElement.KeyModifierFlags,block:() -> Void)*/
/*!!!DUPLICATE NAME*/
performWithKeyModifiersBlock(flags, block, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.performWithKeyModifiers(_:XCUIElement.KeyModifierFlags,block:() -> Void) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.typeKey(_:String,modifierFlags:XCUIElement.KeyModifierFlags)*/
/*XCTest.(file).XCUIElement.typeKey(_:String,modifierFlags:XCUIElement.KeyModifierFlags)*/
typeKeyModifierFlags(key, flags, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.typeKey(_:String,modifierFlags:XCUIElement.KeyModifierFlags) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.hover()*/
/*XCTest.(file).XCUIElement.hover()*/
hover($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.hover() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.click()*/
/*XCTest.(file).XCUIElement.click()*/
click($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.click() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.doubleClick()*/
/*XCTest.(file).XCUIElement.doubleClick()*/
doubleClick($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.doubleClick() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.rightClick()*/
/*XCTest.(file).XCUIElement.rightClick()*/
rightClick($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.rightClick() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.click(forDuration:TimeInterval,thenDragTo:XCUIElement)*/
/*XCTest.(file).XCUIElement.click(forDuration:TimeInterval,thenDragTo:XCUIElement)*/
clickForDurationThenDragTo(duration, otherElement, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.click(forDuration:TimeInterval,thenDragTo:XCUIElement) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.clickForDuration(_:TimeInterval,thenDragToElement:XCUIElement)*/
/*XCTest.(file).XCUIElement.clickForDuration(_:TimeInterval,thenDragToElement:XCUIElement)*/
clickForDurationThenDragToElement(duration, otherElement, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.clickForDuration(_:TimeInterval,thenDragToElement:XCUIElement) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.scroll(byDeltaX:CGFloat,deltaY:CGFloat)*/
/*XCTest.(file).XCUIElement.scroll(byDeltaX:CGFloat,deltaY:CGFloat)*/
scrollByDeltaXDeltaY(deltaX, deltaY, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.scroll(byDeltaX:CGFloat,deltaY:CGFloat) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.scrollByDeltaX(_:CGFloat,deltaY:CGFloat)*/
/*XCTest.(file).XCUIElement.scrollByDeltaX(_:CGFloat,deltaY:CGFloat)*/
/*!!!DUPLICATE NAME*/
scrollByDeltaXDeltaY(deltaX, deltaY, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.scrollByDeltaX(_:CGFloat,deltaY:CGFloat) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.tap()*/
/*XCTest.(file).XCUIElement.tap()*/
tap($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.tap() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.doubleTap()*/
/*XCTest.(file).XCUIElement.doubleTap()*/
doubleTap($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.doubleTap() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.press(forDuration:TimeInterval)*/
/*XCTest.(file).XCUIElement.press(forDuration:TimeInterval)*/
pressForDuration(duration, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.press(forDuration:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.pressForDuration(_:TimeInterval)*/
/*XCTest.(file).XCUIElement.pressForDuration(_:TimeInterval)*/
/*!!!DUPLICATE NAME*/
pressForDuration(duration, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.pressForDuration(_:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.press(forDuration:TimeInterval,thenDragTo:XCUIElement)*/
/*XCTest.(file).XCUIElement.press(forDuration:TimeInterval,thenDragTo:XCUIElement)*/
pressForDurationThenDragTo(duration, otherElement, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.press(forDuration:TimeInterval,thenDragTo:XCUIElement) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.pressForDuration(_:TimeInterval,thenDragToElement:XCUIElement)*/
/*XCTest.(file).XCUIElement.pressForDuration(_:TimeInterval,thenDragToElement:XCUIElement)*/
pressForDurationThenDragToElement(duration, otherElement, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.pressForDuration(_:TimeInterval,thenDragToElement:XCUIElement) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.adjust(toNormalizedSliderPosition:CGFloat)*/
/*XCTest.(file).XCUIElement.adjust(toNormalizedSliderPosition:CGFloat)*/
adjustToNormalizedSliderPosition(normalizedSliderPosition, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.adjust(toNormalizedSliderPosition:CGFloat) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.adjustToNormalizedSliderPosition(_:CGFloat)*/
/*XCTest.(file).XCUIElement.adjustToNormalizedSliderPosition(_:CGFloat)*/
/*!!!DUPLICATE NAME*/
adjustToNormalizedSliderPosition(normalizedSliderPosition, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.adjustToNormalizedSliderPosition(_:CGFloat) in ' + this.constructor.name
}

normalizedSliderPosition
/*XCTest.(file).XCUIElement.snapshot()*/
/*XCTest.(file).XCUIElement.snapshot()*/
snapshot($info?) {
throw 'unsupported method XCTest.(file).XCUIElement.snapshot() in ' + this.constructor.name
}
/*XCTest.(file).XCUIElement.typeKey(_:XCUIKeyboardKey,modifierFlags:XCUIElement.KeyModifierFlags)*/
/*XCTest.(file).XCUIElement.typeKey(_:XCUIKeyboardKey,modifierFlags:XCUIElement.KeyModifierFlags)*/
/*!!!DUPLICATE NAME*/
typeKeyModifierFlags(key, modifierFlags, $info?) {
throw 'unsupported method XCTest.(file).XCUIElement.typeKey(_:XCUIKeyboardKey,modifierFlags:XCUIElement.KeyModifierFlags) in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
_mixin(XCUIElement.ElementType, _DefaultEnumImplementation, false)
_mixin(XCUIElement.SizeClass, _DefaultEnumImplementation, false)
if(typeof XCUIElementAttributes$implementation != 'undefined') _mixin(XCUIElement, XCUIElementAttributes$implementation, false)
if(typeof XCUIElementTypeQueryProvider$implementation != 'undefined') _mixin(XCUIElement, XCUIElementTypeQueryProvider$implementation, false)
if(typeof XCUIScreenshotProviding$implementation != 'undefined') _mixin(XCUIElement, XCUIScreenshotProviding$implementation, false)
if(typeof XCUIElementSnapshotProviding$implementation != 'undefined') _mixin(XCUIElement, XCUIElementSnapshotProviding$implementation, false)


















class XCUIElementQuery extends NSObject implements XCUIElementTypeQueryProvider{


/*XCTest.(file).XCUIElementQuery.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

_element

count
/*XCTest.(file).XCUIElementQuery.element(at:Int)*/
/*XCTest.(file).XCUIElementQuery.element(at:Int)*/
elementAt(index, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.element(at:Int) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.elementAtIndex(_:Int)*/
/*XCTest.(file).XCUIElementQuery.elementAtIndex(_:Int)*/
elementAtIndex(index, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.elementAtIndex(_:Int) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.element(boundBy:Int)*/
/*XCTest.(file).XCUIElementQuery.element(boundBy:Int)*/
elementBoundBy(index, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.element(boundBy:Int) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.elementBoundByIndex(_:Int)*/
/*XCTest.(file).XCUIElementQuery.elementBoundByIndex(_:Int)*/
elementBoundByIndex(index, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.elementBoundByIndex(_:Int) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.element(matching:NSPredicate)*/
/*XCTest.(file).XCUIElementQuery.element(matching:NSPredicate)*/
elementMatching(predicate, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.element(matching:NSPredicate) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.elementMatchingPredicate(_:NSPredicate)*/
/*XCTest.(file).XCUIElementQuery.elementMatchingPredicate(_:NSPredicate)*/
elementMatchingPredicate(predicate, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.elementMatchingPredicate(_:NSPredicate) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.element(matching:XCUIElement.ElementType,identifier:String?)*/
/*XCTest.(file).XCUIElementQuery.element(matching:XCUIElement.ElementType,identifier:String?)*/
elementMatchingIdentifier(elementType, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.element(matching:XCUIElement.ElementType,identifier:String?) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.elementMatchingType(_:XCUIElement.ElementType,identifier:String?)*/
/*XCTest.(file).XCUIElementQuery.elementMatchingType(_:XCUIElement.ElementType,identifier:String?)*/
elementMatchingTypeIdentifier(elementType, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.elementMatchingType(_:XCUIElement.ElementType,identifier:String?) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.subscript(_:String)*/
/*XCTest.(file).XCUIElementQuery.subscript(_:String)*/
subscript$get(key, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.subscript(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.objectForKeyedSubscript(_:String)*/
/*XCTest.(file).XCUIElementQuery.objectForKeyedSubscript(_:String)*/
objectForKeyedSubscript(key, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.objectForKeyedSubscript(_:String) in ' + this.constructor.name
}

allElementsBoundByAccessibilityElement

allElementsBoundByIndex
/*XCTest.(file).XCUIElementQuery.descendants(matching:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElementQuery.descendants(matching:XCUIElement.ElementType)*/
descendantsMatching(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.descendants(matching:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.descendantsMatchingType(_:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElementQuery.descendantsMatchingType(_:XCUIElement.ElementType)*/
descendantsMatchingType(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.descendantsMatchingType(_:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.children(matching:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElementQuery.children(matching:XCUIElement.ElementType)*/
childrenMatching(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.children(matching:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.childrenMatchingType(_:XCUIElement.ElementType)*/
/*XCTest.(file).XCUIElementQuery.childrenMatchingType(_:XCUIElement.ElementType)*/
childrenMatchingType(type, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.childrenMatchingType(_:XCUIElement.ElementType) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.matching(_:NSPredicate)*/
/*XCTest.(file).XCUIElementQuery.matching(_:NSPredicate)*/
matching(predicate, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.matching(_:NSPredicate) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.matchingPredicate(_:NSPredicate)*/
/*XCTest.(file).XCUIElementQuery.matchingPredicate(_:NSPredicate)*/
matchingPredicate(predicate, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.matchingPredicate(_:NSPredicate) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.matching(_:XCUIElement.ElementType,identifier:String?)*/
/*XCTest.(file).XCUIElementQuery.matching(_:XCUIElement.ElementType,identifier:String?)*/
matchingIdentifier(elementType, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.matching(_:XCUIElement.ElementType,identifier:String?) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.matchingType(_:XCUIElement.ElementType,identifier:String?)*/
/*XCTest.(file).XCUIElementQuery.matchingType(_:XCUIElement.ElementType,identifier:String?)*/
matchingTypeIdentifier(elementType, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.matchingType(_:XCUIElement.ElementType,identifier:String?) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.matching(identifier:String)*/
/*XCTest.(file).XCUIElementQuery.matching(identifier:String)*/
/*!!!DUPLICATE NAME*/
matchingIdentifier(identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.matching(identifier:String) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.matchingIdentifier(_:String)*/
/*XCTest.(file).XCUIElementQuery.matchingIdentifier(_:String)*/
/*!!!DUPLICATE NAME*/
matchingIdentifier(identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.matchingIdentifier(_:String) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.containing(_:NSPredicate)*/
/*XCTest.(file).XCUIElementQuery.containing(_:NSPredicate)*/
containing(predicate, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.containing(_:NSPredicate) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.containingPredicate(_:NSPredicate)*/
/*XCTest.(file).XCUIElementQuery.containingPredicate(_:NSPredicate)*/
containingPredicate(predicate, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.containingPredicate(_:NSPredicate) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.containing(_:XCUIElement.ElementType,identifier:String?)*/
/*XCTest.(file).XCUIElementQuery.containing(_:XCUIElement.ElementType,identifier:String?)*/
containingIdentifier(elementType, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.containing(_:XCUIElement.ElementType,identifier:String?) in ' + this.constructor.name
}
/*XCTest.(file).XCUIElementQuery.containingType(_:XCUIElement.ElementType,identifier:String?)*/
/*XCTest.(file).XCUIElementQuery.containingType(_:XCUIElement.ElementType,identifier:String?)*/
containingTypeIdentifier(elementType, identifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIElementQuery.containingType(_:XCUIElement.ElementType,identifier:String?) in ' + this.constructor.name
}

debugDescription

touchBars

groups

windows

sheets

drawers

alerts

dialogs

buttons

radioButtons

radioGroups

checkBoxes

disclosureTriangles

popUpButtons

comboBoxes

menuButtons

toolbarButtons

popovers

keyboards

keys

navigationBars

tabBars

tabGroups

toolbars

statusBars

tables

tableRows

tableColumns

outlines

outlineRows

disclosedChildRows

browsers

collectionViews

sliders

pageIndicators

progressIndicators

activityIndicators

segmentedControls

pickers

pickerWheels

switches

toggles

links

_images

icons

searchFields

scrollViews

scrollBars

staticTexts

textFields

secureTextFields

datePickers

textViews

menus

menuItems

menuBars

menuBarItems

maps

webViews

steppers

incrementArrows

decrementArrows

tabs

timelines

ratingIndicators

valueIndicators

splitGroups

splitters

relevanceIndicators

colorWells

helpTags

mattes

dockItems

rulers

rulerMarkers

grids

levelIndicators

cells

layoutAreas

layoutItems

handles

otherElements

statusItems

firstMatch
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof XCUIElementTypeQueryProvider$implementation != 'undefined') _mixin(XCUIElementQuery, XCUIElementTypeQueryProvider$implementation, false)


class XCUIScreen extends NSObject implements XCUIScreenshotProviding{


/*XCTest.(file).XCUIScreen.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

static main

static mainScreen

static screens
/*XCTest.(file).XCUIScreen.screenshot()*/
/*XCTest.(file).XCUIScreen.screenshot()*/
screenshot($info?) {
throw 'unsupported method XCTest.(file).XCUIScreen.screenshot() in ' + this.constructor.name
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
if(typeof XCUIScreenshotProviding$implementation != 'undefined') _mixin(XCUIScreen, XCUIScreenshotProviding$implementation, false)


class XCUIApplication extends XCUIElement{

/*XCTest.(file).XCUIApplication.init()*/
/*ObjectiveC.(file).NSObject.init()*/
init($info?) {

}

/*XCTest.(file).XCUIApplication.init(bundleIdentifier:String)*/
/*XCTest.(file).XCUIApplication.init(bundleIdentifier:String)*/
initBundleIdentifierString(bundleIdentifier, $info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.init(bundleIdentifier:String) in ' + this.constructor.name
}
/*XCTest.(file).XCUIApplication.init(url:URL)*/
/*XCTest.(file).XCUIApplication.init(url:URL)*/
initUrlURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.init(url:URL) in ' + this.constructor.name
}
/*XCTest.(file).XCUIApplication.init(URL:URL)*/
/*XCTest.(file).XCUIApplication.init(URL:URL)*/
initURLURL(url, $info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.init(URL:URL) in ' + this.constructor.name
}
/*XCTest.(file).XCUIApplication.launch()*/
/*XCTest.(file).XCUIApplication.launch()*/
launch($info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.launch() in ' + this.constructor.name
}
/*XCTest.(file).XCUIApplication.activate()*/
/*XCTest.(file).XCUIApplication.activate()*/
activate($info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.activate() in ' + this.constructor.name
}
/*XCTest.(file).XCUIApplication.terminate()*/
/*XCTest.(file).XCUIApplication.terminate()*/
terminate($info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.terminate() in ' + this.constructor.name
}

launchArguments

launchEnvironment

state
/*XCTest.(file).XCUIApplication.wait(for:XCUIApplication.State,timeout:TimeInterval)*/
/*XCTest.(file).XCUIApplication.wait(for:XCUIApplication.State,timeout:TimeInterval)*/
waitForTimeout(state, timeout, $info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.wait(for:XCUIApplication.State,timeout:TimeInterval) in ' + this.constructor.name
}
/*XCTest.(file).XCUIApplication.waitForState(_:XCUIApplication.State,timeout:TimeInterval)*/
/*XCTest.(file).XCUIApplication.waitForState(_:XCUIApplication.State,timeout:TimeInterval)*/
waitForStateTimeout(state, timeout, $info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.waitForState(_:XCUIApplication.State,timeout:TimeInterval) in ' + this.constructor.name
}
static State = class{
/*XCTest.(file).XCUIApplication.State.init(rawValue:UInt)*/
/*XCTest.(file).XCUIApplication.State.init(rawValue:UInt)*/
initRawValueUInt(rawValue, $info?) {
throw 'unsupported method XCTest.(file).XCUIApplication.State.init(rawValue:UInt) in ' + this.constructor.name
}
static readonly initRawValueUInt$failable = true



/*XCTest.(file).XCUIApplication.State.rawValue*/
rawValue$get() {
throw 'unsupported variable XCTest.(file).XCUIApplication.State.rawValue in ' + this.constructor.name
}
get rawValue() { return this.rawValue$get() };



static get unknown() {return Object.assign(new XCUIApplication.State(), {rawValue: 0, ...Array.from(arguments)})}

static Unknown


static get notRunning() {return Object.assign(new XCUIApplication.State(), {rawValue: 1, ...Array.from(arguments)})}

static NotRunning


static get runningBackground() {return Object.assign(new XCUIApplication.State(), {rawValue: 3, ...Array.from(arguments)})}

static RunningBackground


static get runningForeground() {return Object.assign(new XCUIApplication.State(), {rawValue: 4, ...Array.from(arguments)})}

static RunningForeground

init$vars() {let _this = this;

}
}
init$vars() {let _this = this;

if(super.init$vars)super.init$vars()
}
}
_mixin(XCUIApplication.State, _DefaultEnumImplementation, false)




const XCKeyValueObservingExpectationHandler = XCTKVOExpectation.Handler


const XCNotificationExpectationHandler = XCTNSNotificationExpectation.Handler


const XCPredicateExpectationHandler = XCTNSPredicateExpectation.Handler


const XCTAttachmentLifetime = XCTAttachment.Lifetime


const XCTDarwinNotificationExpectationHandler = XCTDarwinNotificationExpectation.Handler


const XCTImageQuality = XCTAttachment.ImageQuality


const XCTWaiterResult = XCTWaiter.Result


const XCUIApplicationState = XCUIApplication.State


const XCUIElementAttributeName = XCUIElement.AttributeName


const XCUIElementType = XCUIElement.ElementType


const XCUIKeyModifierFlags = XCUIElement.KeyModifierFlags


const XCUIUserInterfaceSizeClass = XCUIElement.SizeClass


const XCWaitCompletionHandler = '?function_type'

